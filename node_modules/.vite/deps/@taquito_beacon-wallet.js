import {
  For,
  IEvents,
  JsonRpcProvider,
  RELAY_JSONRPC,
  addEventListener,
  className,
  concat,
  createComponent,
  createEffect,
  createMemo,
  createRenderEffect,
  createSignal,
  delegateEvents,
  detect,
  encodeIss,
  esm_default,
  esm_exports,
  formatJsonRpcError,
  formatJsonRpcRequest,
  formatJsonRpcResult,
  fromString,
  generateKeyPair,
  getBigIntRpcId,
  init_esm,
  insert,
  isJsonRpcError,
  isJsonRpcRequest,
  isJsonRpcResponse,
  isJsonRpcResult,
  isServer,
  onCleanup,
  onMount,
  payloadId,
  render,
  require_axios,
  require_blake2b,
  require_browser,
  require_bs58check,
  require_bytes,
  require_chacha20poly1305,
  require_cjs,
  require_cjs2,
  require_cjs3,
  require_cjs4,
  require_cjs5,
  require_crypto,
  require_decode_uri_component,
  require_ed25519,
  require_events,
  require_filter_obj,
  require_hkdf,
  require_inherits_browser,
  require_lodash,
  require_nacl,
  require_qrcode,
  require_random,
  require_sha256,
  require_split_on_first,
  require_strict_uri_encode,
  require_utf8,
  require_x25519,
  require_x25519_session,
  safeJsonParse,
  safeJsonStringify,
  setAttribute,
  signJWT,
  style,
  template,
  toString
} from "./chunk-URBVMREY.js";
import {
  require_buffer
} from "./chunk-QX5IKVBM.js";
import {
  __commonJS,
  __toESM
} from "./chunk-W7S2ME4R.js";

// node_modules/@taquito/beacon-wallet/node_modules/query-string/index.js
var require_query_string = __commonJS({
  "node_modules/@taquito/beacon-wallet/node_modules/query-string/index.js"(exports) {
    "use strict";
    var strictUriEncode = require_strict_uri_encode();
    var decodeComponent = require_decode_uri_component();
    var splitOnFirst = require_split_on_first();
    var filterObject = require_filter_obj();
    var isNullOrUndefined = (value) => value === null || value === void 0;
    var encodeFragmentIdentifier = Symbol("encodeFragmentIdentifier");
    function encoderForArrayFormat(options) {
      switch (options.arrayFormat) {
        case "index":
          return (key) => (result, value) => {
            const index = result.length;
            if (value === void 0 || options.skipNull && value === null || options.skipEmptyString && value === "") {
              return result;
            }
            if (value === null) {
              return [...result, [encode9(key, options), "[", index, "]"].join("")];
            }
            return [
              ...result,
              [encode9(key, options), "[", encode9(index, options), "]=", encode9(value, options)].join("")
            ];
          };
        case "bracket":
          return (key) => (result, value) => {
            if (value === void 0 || options.skipNull && value === null || options.skipEmptyString && value === "") {
              return result;
            }
            if (value === null) {
              return [...result, [encode9(key, options), "[]"].join("")];
            }
            return [...result, [encode9(key, options), "[]=", encode9(value, options)].join("")];
          };
        case "colon-list-separator":
          return (key) => (result, value) => {
            if (value === void 0 || options.skipNull && value === null || options.skipEmptyString && value === "") {
              return result;
            }
            if (value === null) {
              return [...result, [encode9(key, options), ":list="].join("")];
            }
            return [...result, [encode9(key, options), ":list=", encode9(value, options)].join("")];
          };
        case "comma":
        case "separator":
        case "bracket-separator": {
          const keyValueSep = options.arrayFormat === "bracket-separator" ? "[]=" : "=";
          return (key) => (result, value) => {
            if (value === void 0 || options.skipNull && value === null || options.skipEmptyString && value === "") {
              return result;
            }
            value = value === null ? "" : value;
            if (result.length === 0) {
              return [[encode9(key, options), keyValueSep, encode9(value, options)].join("")];
            }
            return [[result, encode9(value, options)].join(options.arrayFormatSeparator)];
          };
        }
        default:
          return (key) => (result, value) => {
            if (value === void 0 || options.skipNull && value === null || options.skipEmptyString && value === "") {
              return result;
            }
            if (value === null) {
              return [...result, encode9(key, options)];
            }
            return [...result, [encode9(key, options), "=", encode9(value, options)].join("")];
          };
      }
    }
    function parserForArrayFormat(options) {
      let result;
      switch (options.arrayFormat) {
        case "index":
          return (key, value, accumulator) => {
            result = /\[(\d*)\]$/.exec(key);
            key = key.replace(/\[\d*\]$/, "");
            if (!result) {
              accumulator[key] = value;
              return;
            }
            if (accumulator[key] === void 0) {
              accumulator[key] = {};
            }
            accumulator[key][result[1]] = value;
          };
        case "bracket":
          return (key, value, accumulator) => {
            result = /(\[\])$/.exec(key);
            key = key.replace(/\[\]$/, "");
            if (!result) {
              accumulator[key] = value;
              return;
            }
            if (accumulator[key] === void 0) {
              accumulator[key] = [value];
              return;
            }
            accumulator[key] = [].concat(accumulator[key], value);
          };
        case "colon-list-separator":
          return (key, value, accumulator) => {
            result = /(:list)$/.exec(key);
            key = key.replace(/:list$/, "");
            if (!result) {
              accumulator[key] = value;
              return;
            }
            if (accumulator[key] === void 0) {
              accumulator[key] = [value];
              return;
            }
            accumulator[key] = [].concat(accumulator[key], value);
          };
        case "comma":
        case "separator":
          return (key, value, accumulator) => {
            const isArray4 = typeof value === "string" && value.includes(options.arrayFormatSeparator);
            const isEncodedArray = typeof value === "string" && !isArray4 && decode3(value, options).includes(options.arrayFormatSeparator);
            value = isEncodedArray ? decode3(value, options) : value;
            const newValue = isArray4 || isEncodedArray ? value.split(options.arrayFormatSeparator).map((item) => decode3(item, options)) : value === null ? value : decode3(value, options);
            accumulator[key] = newValue;
          };
        case "bracket-separator":
          return (key, value, accumulator) => {
            const isArray4 = /(\[\])$/.test(key);
            key = key.replace(/\[\]$/, "");
            if (!isArray4) {
              accumulator[key] = value ? decode3(value, options) : value;
              return;
            }
            const arrayValue = value === null ? [] : value.split(options.arrayFormatSeparator).map((item) => decode3(item, options));
            if (accumulator[key] === void 0) {
              accumulator[key] = arrayValue;
              return;
            }
            accumulator[key] = [].concat(accumulator[key], arrayValue);
          };
        default:
          return (key, value, accumulator) => {
            if (accumulator[key] === void 0) {
              accumulator[key] = value;
              return;
            }
            accumulator[key] = [].concat(accumulator[key], value);
          };
      }
    }
    function validateArrayFormatSeparator(value) {
      if (typeof value !== "string" || value.length !== 1) {
        throw new TypeError("arrayFormatSeparator must be single character string");
      }
    }
    function encode9(value, options) {
      if (options.encode) {
        return options.strict ? strictUriEncode(value) : encodeURIComponent(value);
      }
      return value;
    }
    function decode3(value, options) {
      if (options.decode) {
        return decodeComponent(value);
      }
      return value;
    }
    function keysSorter(input) {
      if (Array.isArray(input)) {
        return input.sort();
      }
      if (typeof input === "object") {
        return keysSorter(Object.keys(input)).sort((a2, b3) => Number(a2) - Number(b3)).map((key) => input[key]);
      }
      return input;
    }
    function removeHash(input) {
      const hashStart = input.indexOf("#");
      if (hashStart !== -1) {
        input = input.slice(0, hashStart);
      }
      return input;
    }
    function getHash(url) {
      let hash6 = "";
      const hashStart = url.indexOf("#");
      if (hashStart !== -1) {
        hash6 = url.slice(hashStart);
      }
      return hash6;
    }
    function extract(input) {
      input = removeHash(input);
      const queryStart = input.indexOf("?");
      if (queryStart === -1) {
        return "";
      }
      return input.slice(queryStart + 1);
    }
    function parseValue(value, options) {
      if (options.parseNumbers && !Number.isNaN(Number(value)) && (typeof value === "string" && value.trim() !== "")) {
        value = Number(value);
      } else if (options.parseBooleans && value !== null && (value.toLowerCase() === "true" || value.toLowerCase() === "false")) {
        value = value.toLowerCase() === "true";
      }
      return value;
    }
    function parse2(query, options) {
      options = Object.assign({
        decode: true,
        sort: true,
        arrayFormat: "none",
        arrayFormatSeparator: ",",
        parseNumbers: false,
        parseBooleans: false
      }, options);
      validateArrayFormatSeparator(options.arrayFormatSeparator);
      const formatter = parserForArrayFormat(options);
      const ret = /* @__PURE__ */ Object.create(null);
      if (typeof query !== "string") {
        return ret;
      }
      query = query.trim().replace(/^[?#&]/, "");
      if (!query) {
        return ret;
      }
      for (const param of query.split("&")) {
        if (param === "") {
          continue;
        }
        let [key, value] = splitOnFirst(options.decode ? param.replace(/\+/g, " ") : param, "=");
        value = value === void 0 ? null : ["comma", "separator", "bracket-separator"].includes(options.arrayFormat) ? value : decode3(value, options);
        formatter(decode3(key, options), value, ret);
      }
      for (const key of Object.keys(ret)) {
        const value = ret[key];
        if (typeof value === "object" && value !== null) {
          for (const k2 of Object.keys(value)) {
            value[k2] = parseValue(value[k2], options);
          }
        } else {
          ret[key] = parseValue(value, options);
        }
      }
      if (options.sort === false) {
        return ret;
      }
      return (options.sort === true ? Object.keys(ret).sort() : Object.keys(ret).sort(options.sort)).reduce((result, key) => {
        const value = ret[key];
        if (Boolean(value) && typeof value === "object" && !Array.isArray(value)) {
          result[key] = keysSorter(value);
        } else {
          result[key] = value;
        }
        return result;
      }, /* @__PURE__ */ Object.create(null));
    }
    exports.extract = extract;
    exports.parse = parse2;
    exports.stringify = (object, options) => {
      if (!object) {
        return "";
      }
      options = Object.assign({
        encode: true,
        strict: true,
        arrayFormat: "none",
        arrayFormatSeparator: ","
      }, options);
      validateArrayFormatSeparator(options.arrayFormatSeparator);
      const shouldFilter = (key) => options.skipNull && isNullOrUndefined(object[key]) || options.skipEmptyString && object[key] === "";
      const formatter = encoderForArrayFormat(options);
      const objectCopy = {};
      for (const key of Object.keys(object)) {
        if (!shouldFilter(key)) {
          objectCopy[key] = object[key];
        }
      }
      const keys2 = Object.keys(objectCopy);
      if (options.sort !== false) {
        keys2.sort(options.sort);
      }
      return keys2.map((key) => {
        const value = object[key];
        if (value === void 0) {
          return "";
        }
        if (value === null) {
          return encode9(key, options);
        }
        if (Array.isArray(value)) {
          if (value.length === 0 && options.arrayFormat === "bracket-separator") {
            return encode9(key, options) + "[]";
          }
          return value.reduce(formatter(key), []).join("&");
        }
        return encode9(key, options) + "=" + encode9(value, options);
      }).filter((x3) => x3.length > 0).join("&");
    };
    exports.parseUrl = (url, options) => {
      options = Object.assign({
        decode: true
      }, options);
      const [url_, hash6] = splitOnFirst(url, "#");
      return Object.assign(
        {
          url: url_.split("?")[0] || "",
          query: parse2(extract(url), options)
        },
        options && options.parseFragmentIdentifier && hash6 ? { fragmentIdentifier: decode3(hash6, options) } : {}
      );
    };
    exports.stringifyUrl = (object, options) => {
      options = Object.assign({
        encode: true,
        strict: true,
        [encodeFragmentIdentifier]: true
      }, options);
      const url = removeHash(object.url).split("?")[0] || "";
      const queryFromUrl = exports.extract(object.url);
      const parsedQueryFromUrl = exports.parse(queryFromUrl, { sort: false });
      const query = Object.assign(parsedQueryFromUrl, object.query);
      let queryString = exports.stringify(query, options);
      if (queryString) {
        queryString = `?${queryString}`;
      }
      let hash6 = getHash(object.url);
      if (object.fragmentIdentifier) {
        hash6 = `#${options[encodeFragmentIdentifier] ? encode9(object.fragmentIdentifier, options) : object.fragmentIdentifier}`;
      }
      return `${url}${queryString}${hash6}`;
    };
    exports.pick = (input, filter2, options) => {
      options = Object.assign({
        parseFragmentIdentifier: true,
        [encodeFragmentIdentifier]: false
      }, options);
      const { url, query, fragmentIdentifier } = exports.parseUrl(input, options);
      return exports.stringifyUrl({
        url,
        query: filterObject(query, filter2),
        fragmentIdentifier
      }, options);
    };
    exports.exclude = (input, filter2, options) => {
      const exclusionFilter = Array.isArray(filter2) ? (key) => !filter2.includes(key) : (key, value) => !filter2(key, value);
      return exports.pick(input, exclusionFilter, options);
    };
  }
});

// node_modules/typedarray-to-buffer/index.js
var require_typedarray_to_buffer = __commonJS({
  "node_modules/typedarray-to-buffer/index.js"(exports, module) {
    module.exports = function typedarrayToBuffer(arr) {
      return ArrayBuffer.isView(arr) ? Buffer.from(arr.buffer, arr.byteOffset, arr.byteLength) : Buffer.from(arr);
    };
  }
});

// node_modules/@taquito/http-utils/node_modules/axios/lib/helpers/bind.js
var require_bind = __commonJS({
  "node_modules/@taquito/http-utils/node_modules/axios/lib/helpers/bind.js"(exports, module) {
    "use strict";
    module.exports = function bind2(fn2, thisArg) {
      return function wrap() {
        var args = new Array(arguments.length);
        for (var i2 = 0; i2 < args.length; i2++) {
          args[i2] = arguments[i2];
        }
        return fn2.apply(thisArg, args);
      };
    };
  }
});

// node_modules/@taquito/http-utils/node_modules/axios/lib/utils.js
var require_utils = __commonJS({
  "node_modules/@taquito/http-utils/node_modules/axios/lib/utils.js"(exports, module) {
    "use strict";
    var bind2 = require_bind();
    var toString2 = Object.prototype.toString;
    function isArray4(val) {
      return Array.isArray(val);
    }
    function isUndefined2(val) {
      return typeof val === "undefined";
    }
    function isBuffer(val) {
      return val !== null && !isUndefined2(val) && val.constructor !== null && !isUndefined2(val.constructor) && typeof val.constructor.isBuffer === "function" && val.constructor.isBuffer(val);
    }
    function isArrayBuffer(val) {
      return toString2.call(val) === "[object ArrayBuffer]";
    }
    function isFormData2(val) {
      return toString2.call(val) === "[object FormData]";
    }
    function isArrayBufferView(val) {
      var result;
      if (typeof ArrayBuffer !== "undefined" && ArrayBuffer.isView) {
        result = ArrayBuffer.isView(val);
      } else {
        result = val && val.buffer && isArrayBuffer(val.buffer);
      }
      return result;
    }
    function isString2(val) {
      return typeof val === "string";
    }
    function isNumber(val) {
      return typeof val === "number";
    }
    function isObject(val) {
      return val !== null && typeof val === "object";
    }
    function isPlainObject(val) {
      if (toString2.call(val) !== "[object Object]") {
        return false;
      }
      var prototype = Object.getPrototypeOf(val);
      return prototype === null || prototype === Object.prototype;
    }
    function isDate(val) {
      return toString2.call(val) === "[object Date]";
    }
    function isFile(val) {
      return toString2.call(val) === "[object File]";
    }
    function isBlob(val) {
      return toString2.call(val) === "[object Blob]";
    }
    function isFunction3(val) {
      return toString2.call(val) === "[object Function]";
    }
    function isStream(val) {
      return isObject(val) && isFunction3(val.pipe);
    }
    function isURLSearchParams(val) {
      return toString2.call(val) === "[object URLSearchParams]";
    }
    function trim(str) {
      return str.trim ? str.trim() : str.replace(/^\s+|\s+$/g, "");
    }
    function isStandardBrowserEnv2() {
      if (typeof navigator !== "undefined" && (navigator.product === "ReactNative" || navigator.product === "NativeScript" || navigator.product === "NS")) {
        return false;
      }
      return typeof window !== "undefined" && typeof document !== "undefined";
    }
    function forEach(obj, fn2) {
      if (obj === null || typeof obj === "undefined") {
        return;
      }
      if (typeof obj !== "object") {
        obj = [obj];
      }
      if (isArray4(obj)) {
        for (var i2 = 0, l = obj.length; i2 < l; i2++) {
          fn2.call(null, obj[i2], i2, obj);
        }
      } else {
        for (var key in obj) {
          if (Object.prototype.hasOwnProperty.call(obj, key)) {
            fn2.call(null, obj[key], key, obj);
          }
        }
      }
    }
    function merge3() {
      var result = {};
      function assignValue(val, key) {
        if (isPlainObject(result[key]) && isPlainObject(val)) {
          result[key] = merge3(result[key], val);
        } else if (isPlainObject(val)) {
          result[key] = merge3({}, val);
        } else if (isArray4(val)) {
          result[key] = val.slice();
        } else {
          result[key] = val;
        }
      }
      for (var i2 = 0, l = arguments.length; i2 < l; i2++) {
        forEach(arguments[i2], assignValue);
      }
      return result;
    }
    function extend(a2, b3, thisArg) {
      forEach(b3, function assignValue(val, key) {
        if (thisArg && typeof val === "function") {
          a2[key] = bind2(val, thisArg);
        } else {
          a2[key] = val;
        }
      });
      return a2;
    }
    function stripBOM(content) {
      if (content.charCodeAt(0) === 65279) {
        content = content.slice(1);
      }
      return content;
    }
    module.exports = {
      isArray: isArray4,
      isArrayBuffer,
      isBuffer,
      isFormData: isFormData2,
      isArrayBufferView,
      isString: isString2,
      isNumber,
      isObject,
      isPlainObject,
      isUndefined: isUndefined2,
      isDate,
      isFile,
      isBlob,
      isFunction: isFunction3,
      isStream,
      isURLSearchParams,
      isStandardBrowserEnv: isStandardBrowserEnv2,
      forEach,
      merge: merge3,
      extend,
      trim,
      stripBOM
    };
  }
});

// node_modules/@taquito/http-utils/node_modules/axios/lib/helpers/buildURL.js
var require_buildURL = __commonJS({
  "node_modules/@taquito/http-utils/node_modules/axios/lib/helpers/buildURL.js"(exports, module) {
    "use strict";
    var utils = require_utils();
    function encode9(val) {
      return encodeURIComponent(val).replace(/%3A/gi, ":").replace(/%24/g, "$").replace(/%2C/gi, ",").replace(/%20/g, "+").replace(/%5B/gi, "[").replace(/%5D/gi, "]");
    }
    module.exports = function buildURL2(url, params, paramsSerializer) {
      if (!params) {
        return url;
      }
      var serializedParams;
      if (paramsSerializer) {
        serializedParams = paramsSerializer(params);
      } else if (utils.isURLSearchParams(params)) {
        serializedParams = params.toString();
      } else {
        var parts = [];
        utils.forEach(params, function serialize(val, key) {
          if (val === null || typeof val === "undefined") {
            return;
          }
          if (utils.isArray(val)) {
            key = key + "[]";
          } else {
            val = [val];
          }
          utils.forEach(val, function parseValue(v) {
            if (utils.isDate(v)) {
              v = v.toISOString();
            } else if (utils.isObject(v)) {
              v = JSON.stringify(v);
            }
            parts.push(encode9(key) + "=" + encode9(v));
          });
        });
        serializedParams = parts.join("&");
      }
      if (serializedParams) {
        var hashmarkIndex = url.indexOf("#");
        if (hashmarkIndex !== -1) {
          url = url.slice(0, hashmarkIndex);
        }
        url += (url.indexOf("?") === -1 ? "?" : "&") + serializedParams;
      }
      return url;
    };
  }
});

// node_modules/@taquito/http-utils/node_modules/axios/lib/core/InterceptorManager.js
var require_InterceptorManager = __commonJS({
  "node_modules/@taquito/http-utils/node_modules/axios/lib/core/InterceptorManager.js"(exports, module) {
    "use strict";
    var utils = require_utils();
    function InterceptorManager() {
      this.handlers = [];
    }
    InterceptorManager.prototype.use = function use(fulfilled, rejected, options) {
      this.handlers.push({
        fulfilled,
        rejected,
        synchronous: options ? options.synchronous : false,
        runWhen: options ? options.runWhen : null
      });
      return this.handlers.length - 1;
    };
    InterceptorManager.prototype.eject = function eject(id) {
      if (this.handlers[id]) {
        this.handlers[id] = null;
      }
    };
    InterceptorManager.prototype.forEach = function forEach(fn2) {
      utils.forEach(this.handlers, function forEachHandler(h3) {
        if (h3 !== null) {
          fn2(h3);
        }
      });
    };
    module.exports = InterceptorManager;
  }
});

// node_modules/@taquito/http-utils/node_modules/axios/lib/helpers/normalizeHeaderName.js
var require_normalizeHeaderName = __commonJS({
  "node_modules/@taquito/http-utils/node_modules/axios/lib/helpers/normalizeHeaderName.js"(exports, module) {
    "use strict";
    var utils = require_utils();
    module.exports = function normalizeHeaderName(headers, normalizedName) {
      utils.forEach(headers, function processHeader(value, name) {
        if (name !== normalizedName && name.toUpperCase() === normalizedName.toUpperCase()) {
          headers[normalizedName] = value;
          delete headers[name];
        }
      });
    };
  }
});

// node_modules/@taquito/http-utils/node_modules/axios/lib/core/enhanceError.js
var require_enhanceError = __commonJS({
  "node_modules/@taquito/http-utils/node_modules/axios/lib/core/enhanceError.js"(exports, module) {
    "use strict";
    module.exports = function enhanceError(error, config2, code, request, response) {
      error.config = config2;
      if (code) {
        error.code = code;
      }
      error.request = request;
      error.response = response;
      error.isAxiosError = true;
      error.toJSON = function toJSON() {
        return {
          // Standard
          message: this.message,
          name: this.name,
          // Microsoft
          description: this.description,
          number: this.number,
          // Mozilla
          fileName: this.fileName,
          lineNumber: this.lineNumber,
          columnNumber: this.columnNumber,
          stack: this.stack,
          // Axios
          config: this.config,
          code: this.code,
          status: this.response && this.response.status ? this.response.status : null
        };
      };
      return error;
    };
  }
});

// node_modules/@taquito/http-utils/node_modules/axios/lib/core/createError.js
var require_createError = __commonJS({
  "node_modules/@taquito/http-utils/node_modules/axios/lib/core/createError.js"(exports, module) {
    "use strict";
    var enhanceError = require_enhanceError();
    module.exports = function createError(message, config2, code, request, response) {
      var error = new Error(message);
      return enhanceError(error, config2, code, request, response);
    };
  }
});

// node_modules/@taquito/http-utils/node_modules/axios/lib/core/settle.js
var require_settle = __commonJS({
  "node_modules/@taquito/http-utils/node_modules/axios/lib/core/settle.js"(exports, module) {
    "use strict";
    var createError = require_createError();
    module.exports = function settle2(resolve, reject, response) {
      var validateStatus = response.config.validateStatus;
      if (!response.status || !validateStatus || validateStatus(response.status)) {
        resolve(response);
      } else {
        reject(createError(
          "Request failed with status code " + response.status,
          response.config,
          null,
          response.request,
          response
        ));
      }
    };
  }
});

// node_modules/@taquito/http-utils/node_modules/axios/lib/helpers/cookies.js
var require_cookies = __commonJS({
  "node_modules/@taquito/http-utils/node_modules/axios/lib/helpers/cookies.js"(exports, module) {
    "use strict";
    var utils = require_utils();
    module.exports = utils.isStandardBrowserEnv() ? (
      // Standard browser envs support document.cookie
      function standardBrowserEnv() {
        return {
          write: function write(name, value, expires, path, domain, secure) {
            var cookie = [];
            cookie.push(name + "=" + encodeURIComponent(value));
            if (utils.isNumber(expires)) {
              cookie.push("expires=" + new Date(expires).toGMTString());
            }
            if (utils.isString(path)) {
              cookie.push("path=" + path);
            }
            if (utils.isString(domain)) {
              cookie.push("domain=" + domain);
            }
            if (secure === true) {
              cookie.push("secure");
            }
            document.cookie = cookie.join("; ");
          },
          read: function read(name) {
            var match = document.cookie.match(new RegExp("(^|;\\s*)(" + name + ")=([^;]*)"));
            return match ? decodeURIComponent(match[3]) : null;
          },
          remove: function remove(name) {
            this.write(name, "", Date.now() - 864e5);
          }
        };
      }()
    ) : (
      // Non standard browser env (web workers, react-native) lack needed support.
      function nonStandardBrowserEnv() {
        return {
          write: function write() {
          },
          read: function read() {
            return null;
          },
          remove: function remove() {
          }
        };
      }()
    );
  }
});

// node_modules/@taquito/http-utils/node_modules/axios/lib/helpers/isAbsoluteURL.js
var require_isAbsoluteURL = __commonJS({
  "node_modules/@taquito/http-utils/node_modules/axios/lib/helpers/isAbsoluteURL.js"(exports, module) {
    "use strict";
    module.exports = function isAbsoluteURL(url) {
      return /^([a-z][a-z\d+\-.]*:)?\/\//i.test(url);
    };
  }
});

// node_modules/@taquito/http-utils/node_modules/axios/lib/helpers/combineURLs.js
var require_combineURLs = __commonJS({
  "node_modules/@taquito/http-utils/node_modules/axios/lib/helpers/combineURLs.js"(exports, module) {
    "use strict";
    module.exports = function combineURLs(baseURL, relativeURL) {
      return relativeURL ? baseURL.replace(/\/+$/, "") + "/" + relativeURL.replace(/^\/+/, "") : baseURL;
    };
  }
});

// node_modules/@taquito/http-utils/node_modules/axios/lib/core/buildFullPath.js
var require_buildFullPath = __commonJS({
  "node_modules/@taquito/http-utils/node_modules/axios/lib/core/buildFullPath.js"(exports, module) {
    "use strict";
    var isAbsoluteURL = require_isAbsoluteURL();
    var combineURLs = require_combineURLs();
    module.exports = function buildFullPath2(baseURL, requestedURL) {
      if (baseURL && !isAbsoluteURL(requestedURL)) {
        return combineURLs(baseURL, requestedURL);
      }
      return requestedURL;
    };
  }
});

// node_modules/@taquito/http-utils/node_modules/axios/lib/helpers/parseHeaders.js
var require_parseHeaders = __commonJS({
  "node_modules/@taquito/http-utils/node_modules/axios/lib/helpers/parseHeaders.js"(exports, module) {
    "use strict";
    var utils = require_utils();
    var ignoreDuplicateOf = [
      "age",
      "authorization",
      "content-length",
      "content-type",
      "etag",
      "expires",
      "from",
      "host",
      "if-modified-since",
      "if-unmodified-since",
      "last-modified",
      "location",
      "max-forwards",
      "proxy-authorization",
      "referer",
      "retry-after",
      "user-agent"
    ];
    module.exports = function parseHeaders(headers) {
      var parsed = {};
      var key;
      var val;
      var i2;
      if (!headers) {
        return parsed;
      }
      utils.forEach(headers.split("\n"), function parser(line) {
        i2 = line.indexOf(":");
        key = utils.trim(line.substr(0, i2)).toLowerCase();
        val = utils.trim(line.substr(i2 + 1));
        if (key) {
          if (parsed[key] && ignoreDuplicateOf.indexOf(key) >= 0) {
            return;
          }
          if (key === "set-cookie") {
            parsed[key] = (parsed[key] ? parsed[key] : []).concat([val]);
          } else {
            parsed[key] = parsed[key] ? parsed[key] + ", " + val : val;
          }
        }
      });
      return parsed;
    };
  }
});

// node_modules/@taquito/http-utils/node_modules/axios/lib/helpers/isURLSameOrigin.js
var require_isURLSameOrigin = __commonJS({
  "node_modules/@taquito/http-utils/node_modules/axios/lib/helpers/isURLSameOrigin.js"(exports, module) {
    "use strict";
    var utils = require_utils();
    module.exports = utils.isStandardBrowserEnv() ? (
      // Standard browser envs have full support of the APIs needed to test
      // whether the request URL is of the same origin as current location.
      function standardBrowserEnv() {
        var msie = /(msie|trident)/i.test(navigator.userAgent);
        var urlParsingNode = document.createElement("a");
        var originURL;
        function resolveURL(url) {
          var href = url;
          if (msie) {
            urlParsingNode.setAttribute("href", href);
            href = urlParsingNode.href;
          }
          urlParsingNode.setAttribute("href", href);
          return {
            href: urlParsingNode.href,
            protocol: urlParsingNode.protocol ? urlParsingNode.protocol.replace(/:$/, "") : "",
            host: urlParsingNode.host,
            search: urlParsingNode.search ? urlParsingNode.search.replace(/^\?/, "") : "",
            hash: urlParsingNode.hash ? urlParsingNode.hash.replace(/^#/, "") : "",
            hostname: urlParsingNode.hostname,
            port: urlParsingNode.port,
            pathname: urlParsingNode.pathname.charAt(0) === "/" ? urlParsingNode.pathname : "/" + urlParsingNode.pathname
          };
        }
        originURL = resolveURL(window.location.href);
        return function isURLSameOrigin(requestURL) {
          var parsed = utils.isString(requestURL) ? resolveURL(requestURL) : requestURL;
          return parsed.protocol === originURL.protocol && parsed.host === originURL.host;
        };
      }()
    ) : (
      // Non standard browser envs (web workers, react-native) lack needed support.
      function nonStandardBrowserEnv() {
        return function isURLSameOrigin() {
          return true;
        };
      }()
    );
  }
});

// node_modules/@taquito/http-utils/node_modules/axios/lib/cancel/Cancel.js
var require_Cancel = __commonJS({
  "node_modules/@taquito/http-utils/node_modules/axios/lib/cancel/Cancel.js"(exports, module) {
    "use strict";
    function Cancel(message) {
      this.message = message;
    }
    Cancel.prototype.toString = function toString2() {
      return "Cancel" + (this.message ? ": " + this.message : "");
    };
    Cancel.prototype.__CANCEL__ = true;
    module.exports = Cancel;
  }
});

// node_modules/@taquito/http-utils/node_modules/axios/lib/adapters/xhr.js
var require_xhr = __commonJS({
  "node_modules/@taquito/http-utils/node_modules/axios/lib/adapters/xhr.js"(exports, module) {
    "use strict";
    var utils = require_utils();
    var settle2 = require_settle();
    var cookies = require_cookies();
    var buildURL2 = require_buildURL();
    var buildFullPath2 = require_buildFullPath();
    var parseHeaders = require_parseHeaders();
    var isURLSameOrigin = require_isURLSameOrigin();
    var createError = require_createError();
    var defaults = require_defaults();
    var Cancel = require_Cancel();
    module.exports = function xhrAdapter(config2) {
      return new Promise(function dispatchXhrRequest(resolve, reject) {
        var requestData = config2.data;
        var requestHeaders = config2.headers;
        var responseType = config2.responseType;
        var onCanceled;
        function done() {
          if (config2.cancelToken) {
            config2.cancelToken.unsubscribe(onCanceled);
          }
          if (config2.signal) {
            config2.signal.removeEventListener("abort", onCanceled);
          }
        }
        if (utils.isFormData(requestData)) {
          delete requestHeaders["Content-Type"];
        }
        var request = new XMLHttpRequest();
        if (config2.auth) {
          var username = config2.auth.username || "";
          var password = config2.auth.password ? unescape(encodeURIComponent(config2.auth.password)) : "";
          requestHeaders.Authorization = "Basic " + btoa(username + ":" + password);
        }
        var fullPath = buildFullPath2(config2.baseURL, config2.url);
        request.open(config2.method.toUpperCase(), buildURL2(fullPath, config2.params, config2.paramsSerializer), true);
        request.timeout = config2.timeout;
        function onloadend() {
          if (!request) {
            return;
          }
          var responseHeaders = "getAllResponseHeaders" in request ? parseHeaders(request.getAllResponseHeaders()) : null;
          var responseData = !responseType || responseType === "text" || responseType === "json" ? request.responseText : request.response;
          var response = {
            data: responseData,
            status: request.status,
            statusText: request.statusText,
            headers: responseHeaders,
            config: config2,
            request
          };
          settle2(function _resolve(value) {
            resolve(value);
            done();
          }, function _reject(err) {
            reject(err);
            done();
          }, response);
          request = null;
        }
        if ("onloadend" in request) {
          request.onloadend = onloadend;
        } else {
          request.onreadystatechange = function handleLoad() {
            if (!request || request.readyState !== 4) {
              return;
            }
            if (request.status === 0 && !(request.responseURL && request.responseURL.indexOf("file:") === 0)) {
              return;
            }
            setTimeout(onloadend);
          };
        }
        request.onabort = function handleAbort() {
          if (!request) {
            return;
          }
          reject(createError("Request aborted", config2, "ECONNABORTED", request));
          request = null;
        };
        request.onerror = function handleError() {
          reject(createError("Network Error", config2, null, request));
          request = null;
        };
        request.ontimeout = function handleTimeout() {
          var timeoutErrorMessage = config2.timeout ? "timeout of " + config2.timeout + "ms exceeded" : "timeout exceeded";
          var transitional = config2.transitional || defaults.transitional;
          if (config2.timeoutErrorMessage) {
            timeoutErrorMessage = config2.timeoutErrorMessage;
          }
          reject(createError(
            timeoutErrorMessage,
            config2,
            transitional.clarifyTimeoutError ? "ETIMEDOUT" : "ECONNABORTED",
            request
          ));
          request = null;
        };
        if (utils.isStandardBrowserEnv()) {
          var xsrfValue = (config2.withCredentials || isURLSameOrigin(fullPath)) && config2.xsrfCookieName ? cookies.read(config2.xsrfCookieName) : void 0;
          if (xsrfValue) {
            requestHeaders[config2.xsrfHeaderName] = xsrfValue;
          }
        }
        if ("setRequestHeader" in request) {
          utils.forEach(requestHeaders, function setRequestHeader(val, key) {
            if (typeof requestData === "undefined" && key.toLowerCase() === "content-type") {
              delete requestHeaders[key];
            } else {
              request.setRequestHeader(key, val);
            }
          });
        }
        if (!utils.isUndefined(config2.withCredentials)) {
          request.withCredentials = !!config2.withCredentials;
        }
        if (responseType && responseType !== "json") {
          request.responseType = config2.responseType;
        }
        if (typeof config2.onDownloadProgress === "function") {
          request.addEventListener("progress", config2.onDownloadProgress);
        }
        if (typeof config2.onUploadProgress === "function" && request.upload) {
          request.upload.addEventListener("progress", config2.onUploadProgress);
        }
        if (config2.cancelToken || config2.signal) {
          onCanceled = function(cancel) {
            if (!request) {
              return;
            }
            reject(!cancel || cancel && cancel.type ? new Cancel("canceled") : cancel);
            request.abort();
            request = null;
          };
          config2.cancelToken && config2.cancelToken.subscribe(onCanceled);
          if (config2.signal) {
            config2.signal.aborted ? onCanceled() : config2.signal.addEventListener("abort", onCanceled);
          }
        }
        if (!requestData) {
          requestData = null;
        }
        request.send(requestData);
      });
    };
  }
});

// node_modules/@taquito/http-utils/node_modules/axios/lib/defaults.js
var require_defaults = __commonJS({
  "node_modules/@taquito/http-utils/node_modules/axios/lib/defaults.js"(exports, module) {
    "use strict";
    var utils = require_utils();
    var normalizeHeaderName = require_normalizeHeaderName();
    var enhanceError = require_enhanceError();
    var DEFAULT_CONTENT_TYPE = {
      "Content-Type": "application/x-www-form-urlencoded"
    };
    function setContentTypeIfUnset(headers, value) {
      if (!utils.isUndefined(headers) && utils.isUndefined(headers["Content-Type"])) {
        headers["Content-Type"] = value;
      }
    }
    function getDefaultAdapter() {
      var adapter;
      if (typeof XMLHttpRequest !== "undefined") {
        adapter = require_xhr();
      } else if (typeof process !== "undefined" && Object.prototype.toString.call(process) === "[object process]") {
        adapter = require_xhr();
      }
      return adapter;
    }
    function stringifySafely(rawValue, parser, encoder) {
      if (utils.isString(rawValue)) {
        try {
          (parser || JSON.parse)(rawValue);
          return utils.trim(rawValue);
        } catch (e) {
          if (e.name !== "SyntaxError") {
            throw e;
          }
        }
      }
      return (encoder || JSON.stringify)(rawValue);
    }
    var defaults = {
      transitional: {
        silentJSONParsing: true,
        forcedJSONParsing: true,
        clarifyTimeoutError: false
      },
      adapter: getDefaultAdapter(),
      transformRequest: [function transformRequest(data, headers) {
        normalizeHeaderName(headers, "Accept");
        normalizeHeaderName(headers, "Content-Type");
        if (utils.isFormData(data) || utils.isArrayBuffer(data) || utils.isBuffer(data) || utils.isStream(data) || utils.isFile(data) || utils.isBlob(data)) {
          return data;
        }
        if (utils.isArrayBufferView(data)) {
          return data.buffer;
        }
        if (utils.isURLSearchParams(data)) {
          setContentTypeIfUnset(headers, "application/x-www-form-urlencoded;charset=utf-8");
          return data.toString();
        }
        if (utils.isObject(data) || headers && headers["Content-Type"] === "application/json") {
          setContentTypeIfUnset(headers, "application/json");
          return stringifySafely(data);
        }
        return data;
      }],
      transformResponse: [function transformResponse(data) {
        var transitional = this.transitional || defaults.transitional;
        var silentJSONParsing = transitional && transitional.silentJSONParsing;
        var forcedJSONParsing = transitional && transitional.forcedJSONParsing;
        var strictJSONParsing = !silentJSONParsing && this.responseType === "json";
        if (strictJSONParsing || forcedJSONParsing && utils.isString(data) && data.length) {
          try {
            return JSON.parse(data);
          } catch (e) {
            if (strictJSONParsing) {
              if (e.name === "SyntaxError") {
                throw enhanceError(e, this, "E_JSON_PARSE");
              }
              throw e;
            }
          }
        }
        return data;
      }],
      /**
       * A timeout in milliseconds to abort a request. If set to 0 (default) a
       * timeout is not created.
       */
      timeout: 0,
      xsrfCookieName: "XSRF-TOKEN",
      xsrfHeaderName: "X-XSRF-TOKEN",
      maxContentLength: -1,
      maxBodyLength: -1,
      validateStatus: function validateStatus(status) {
        return status >= 200 && status < 300;
      },
      headers: {
        common: {
          "Accept": "application/json, text/plain, */*"
        }
      }
    };
    utils.forEach(["delete", "get", "head"], function forEachMethodNoData(method) {
      defaults.headers[method] = {};
    });
    utils.forEach(["post", "put", "patch"], function forEachMethodWithData(method) {
      defaults.headers[method] = utils.merge(DEFAULT_CONTENT_TYPE);
    });
    module.exports = defaults;
  }
});

// node_modules/@taquito/http-utils/node_modules/axios/lib/core/transformData.js
var require_transformData = __commonJS({
  "node_modules/@taquito/http-utils/node_modules/axios/lib/core/transformData.js"(exports, module) {
    "use strict";
    var utils = require_utils();
    var defaults = require_defaults();
    module.exports = function transformData(data, headers, fns) {
      var context2 = this || defaults;
      utils.forEach(fns, function transform(fn2) {
        data = fn2.call(context2, data, headers);
      });
      return data;
    };
  }
});

// node_modules/@taquito/http-utils/node_modules/axios/lib/cancel/isCancel.js
var require_isCancel = __commonJS({
  "node_modules/@taquito/http-utils/node_modules/axios/lib/cancel/isCancel.js"(exports, module) {
    "use strict";
    module.exports = function isCancel(value) {
      return !!(value && value.__CANCEL__);
    };
  }
});

// node_modules/@taquito/http-utils/node_modules/axios/lib/core/dispatchRequest.js
var require_dispatchRequest = __commonJS({
  "node_modules/@taquito/http-utils/node_modules/axios/lib/core/dispatchRequest.js"(exports, module) {
    "use strict";
    var utils = require_utils();
    var transformData = require_transformData();
    var isCancel = require_isCancel();
    var defaults = require_defaults();
    var Cancel = require_Cancel();
    function throwIfCancellationRequested(config2) {
      if (config2.cancelToken) {
        config2.cancelToken.throwIfRequested();
      }
      if (config2.signal && config2.signal.aborted) {
        throw new Cancel("canceled");
      }
    }
    module.exports = function dispatchRequest(config2) {
      throwIfCancellationRequested(config2);
      config2.headers = config2.headers || {};
      config2.data = transformData.call(
        config2,
        config2.data,
        config2.headers,
        config2.transformRequest
      );
      config2.headers = utils.merge(
        config2.headers.common || {},
        config2.headers[config2.method] || {},
        config2.headers
      );
      utils.forEach(
        ["delete", "get", "head", "post", "put", "patch", "common"],
        function cleanHeaderConfig(method) {
          delete config2.headers[method];
        }
      );
      var adapter = config2.adapter || defaults.adapter;
      return adapter(config2).then(function onAdapterResolution(response) {
        throwIfCancellationRequested(config2);
        response.data = transformData.call(
          config2,
          response.data,
          response.headers,
          config2.transformResponse
        );
        return response;
      }, function onAdapterRejection(reason) {
        if (!isCancel(reason)) {
          throwIfCancellationRequested(config2);
          if (reason && reason.response) {
            reason.response.data = transformData.call(
              config2,
              reason.response.data,
              reason.response.headers,
              config2.transformResponse
            );
          }
        }
        return Promise.reject(reason);
      });
    };
  }
});

// node_modules/@taquito/http-utils/node_modules/axios/lib/core/mergeConfig.js
var require_mergeConfig = __commonJS({
  "node_modules/@taquito/http-utils/node_modules/axios/lib/core/mergeConfig.js"(exports, module) {
    "use strict";
    var utils = require_utils();
    module.exports = function mergeConfig(config1, config2) {
      config2 = config2 || {};
      var config3 = {};
      function getMergedValue(target, source) {
        if (utils.isPlainObject(target) && utils.isPlainObject(source)) {
          return utils.merge(target, source);
        } else if (utils.isPlainObject(source)) {
          return utils.merge({}, source);
        } else if (utils.isArray(source)) {
          return source.slice();
        }
        return source;
      }
      function mergeDeepProperties(prop) {
        if (!utils.isUndefined(config2[prop])) {
          return getMergedValue(config1[prop], config2[prop]);
        } else if (!utils.isUndefined(config1[prop])) {
          return getMergedValue(void 0, config1[prop]);
        }
      }
      function valueFromConfig2(prop) {
        if (!utils.isUndefined(config2[prop])) {
          return getMergedValue(void 0, config2[prop]);
        }
      }
      function defaultToConfig2(prop) {
        if (!utils.isUndefined(config2[prop])) {
          return getMergedValue(void 0, config2[prop]);
        } else if (!utils.isUndefined(config1[prop])) {
          return getMergedValue(void 0, config1[prop]);
        }
      }
      function mergeDirectKeys(prop) {
        if (prop in config2) {
          return getMergedValue(config1[prop], config2[prop]);
        } else if (prop in config1) {
          return getMergedValue(void 0, config1[prop]);
        }
      }
      var mergeMap2 = {
        "url": valueFromConfig2,
        "method": valueFromConfig2,
        "data": valueFromConfig2,
        "baseURL": defaultToConfig2,
        "transformRequest": defaultToConfig2,
        "transformResponse": defaultToConfig2,
        "paramsSerializer": defaultToConfig2,
        "timeout": defaultToConfig2,
        "timeoutMessage": defaultToConfig2,
        "withCredentials": defaultToConfig2,
        "adapter": defaultToConfig2,
        "responseType": defaultToConfig2,
        "xsrfCookieName": defaultToConfig2,
        "xsrfHeaderName": defaultToConfig2,
        "onUploadProgress": defaultToConfig2,
        "onDownloadProgress": defaultToConfig2,
        "decompress": defaultToConfig2,
        "maxContentLength": defaultToConfig2,
        "maxBodyLength": defaultToConfig2,
        "transport": defaultToConfig2,
        "httpAgent": defaultToConfig2,
        "httpsAgent": defaultToConfig2,
        "cancelToken": defaultToConfig2,
        "socketPath": defaultToConfig2,
        "responseEncoding": defaultToConfig2,
        "validateStatus": mergeDirectKeys
      };
      utils.forEach(Object.keys(config1).concat(Object.keys(config2)), function computeConfigValue(prop) {
        var merge3 = mergeMap2[prop] || mergeDeepProperties;
        var configValue = merge3(prop);
        utils.isUndefined(configValue) && merge3 !== mergeDirectKeys || (config3[prop] = configValue);
      });
      return config3;
    };
  }
});

// node_modules/@taquito/http-utils/node_modules/axios/lib/env/data.js
var require_data = __commonJS({
  "node_modules/@taquito/http-utils/node_modules/axios/lib/env/data.js"(exports, module) {
    module.exports = {
      "version": "0.26.0"
    };
  }
});

// node_modules/@taquito/http-utils/node_modules/axios/lib/helpers/validator.js
var require_validator = __commonJS({
  "node_modules/@taquito/http-utils/node_modules/axios/lib/helpers/validator.js"(exports, module) {
    "use strict";
    var VERSION2 = require_data().version;
    var validators = {};
    ["object", "boolean", "number", "function", "string", "symbol"].forEach(function(type, i2) {
      validators[type] = function validator(thing) {
        return typeof thing === type || "a" + (i2 < 1 ? "n " : " ") + type;
      };
    });
    var deprecatedWarnings = {};
    validators.transitional = function transitional(validator, version, message) {
      function formatMessage(opt, desc) {
        return "[Axios v" + VERSION2 + "] Transitional option '" + opt + "'" + desc + (message ? ". " + message : "");
      }
      return function(value, opt, opts) {
        if (validator === false) {
          throw new Error(formatMessage(opt, " has been removed" + (version ? " in " + version : "")));
        }
        if (version && !deprecatedWarnings[opt]) {
          deprecatedWarnings[opt] = true;
          console.warn(
            formatMessage(
              opt,
              " has been deprecated since v" + version + " and will be removed in the near future"
            )
          );
        }
        return validator ? validator(value, opt, opts) : true;
      };
    };
    function assertOptions(options, schema, allowUnknown) {
      if (typeof options !== "object") {
        throw new TypeError("options must be an object");
      }
      var keys2 = Object.keys(options);
      var i2 = keys2.length;
      while (i2-- > 0) {
        var opt = keys2[i2];
        var validator = schema[opt];
        if (validator) {
          var value = options[opt];
          var result = value === void 0 || validator(value, opt, options);
          if (result !== true) {
            throw new TypeError("option " + opt + " must be " + result);
          }
          continue;
        }
        if (allowUnknown !== true) {
          throw Error("Unknown option " + opt);
        }
      }
    }
    module.exports = {
      assertOptions,
      validators
    };
  }
});

// node_modules/@taquito/http-utils/node_modules/axios/lib/core/Axios.js
var require_Axios = __commonJS({
  "node_modules/@taquito/http-utils/node_modules/axios/lib/core/Axios.js"(exports, module) {
    "use strict";
    var utils = require_utils();
    var buildURL2 = require_buildURL();
    var InterceptorManager = require_InterceptorManager();
    var dispatchRequest = require_dispatchRequest();
    var mergeConfig = require_mergeConfig();
    var validator = require_validator();
    var validators = validator.validators;
    function Axios(instanceConfig) {
      this.defaults = instanceConfig;
      this.interceptors = {
        request: new InterceptorManager(),
        response: new InterceptorManager()
      };
    }
    Axios.prototype.request = function request(configOrUrl, config2) {
      if (typeof configOrUrl === "string") {
        config2 = config2 || {};
        config2.url = configOrUrl;
      } else {
        config2 = configOrUrl || {};
      }
      config2 = mergeConfig(this.defaults, config2);
      if (config2.method) {
        config2.method = config2.method.toLowerCase();
      } else if (this.defaults.method) {
        config2.method = this.defaults.method.toLowerCase();
      } else {
        config2.method = "get";
      }
      var transitional = config2.transitional;
      if (transitional !== void 0) {
        validator.assertOptions(transitional, {
          silentJSONParsing: validators.transitional(validators.boolean),
          forcedJSONParsing: validators.transitional(validators.boolean),
          clarifyTimeoutError: validators.transitional(validators.boolean)
        }, false);
      }
      var requestInterceptorChain = [];
      var synchronousRequestInterceptors = true;
      this.interceptors.request.forEach(function unshiftRequestInterceptors(interceptor) {
        if (typeof interceptor.runWhen === "function" && interceptor.runWhen(config2) === false) {
          return;
        }
        synchronousRequestInterceptors = synchronousRequestInterceptors && interceptor.synchronous;
        requestInterceptorChain.unshift(interceptor.fulfilled, interceptor.rejected);
      });
      var responseInterceptorChain = [];
      this.interceptors.response.forEach(function pushResponseInterceptors(interceptor) {
        responseInterceptorChain.push(interceptor.fulfilled, interceptor.rejected);
      });
      var promise;
      if (!synchronousRequestInterceptors) {
        var chain = [dispatchRequest, void 0];
        Array.prototype.unshift.apply(chain, requestInterceptorChain);
        chain = chain.concat(responseInterceptorChain);
        promise = Promise.resolve(config2);
        while (chain.length) {
          promise = promise.then(chain.shift(), chain.shift());
        }
        return promise;
      }
      var newConfig = config2;
      while (requestInterceptorChain.length) {
        var onFulfilled = requestInterceptorChain.shift();
        var onRejected = requestInterceptorChain.shift();
        try {
          newConfig = onFulfilled(newConfig);
        } catch (error) {
          onRejected(error);
          break;
        }
      }
      try {
        promise = dispatchRequest(newConfig);
      } catch (error) {
        return Promise.reject(error);
      }
      while (responseInterceptorChain.length) {
        promise = promise.then(responseInterceptorChain.shift(), responseInterceptorChain.shift());
      }
      return promise;
    };
    Axios.prototype.getUri = function getUri(config2) {
      config2 = mergeConfig(this.defaults, config2);
      return buildURL2(config2.url, config2.params, config2.paramsSerializer).replace(/^\?/, "");
    };
    utils.forEach(["delete", "get", "head", "options"], function forEachMethodNoData(method) {
      Axios.prototype[method] = function(url, config2) {
        return this.request(mergeConfig(config2 || {}, {
          method,
          url,
          data: (config2 || {}).data
        }));
      };
    });
    utils.forEach(["post", "put", "patch"], function forEachMethodWithData(method) {
      Axios.prototype[method] = function(url, data, config2) {
        return this.request(mergeConfig(config2 || {}, {
          method,
          url,
          data
        }));
      };
    });
    module.exports = Axios;
  }
});

// node_modules/@taquito/http-utils/node_modules/axios/lib/cancel/CancelToken.js
var require_CancelToken = __commonJS({
  "node_modules/@taquito/http-utils/node_modules/axios/lib/cancel/CancelToken.js"(exports, module) {
    "use strict";
    var Cancel = require_Cancel();
    function CancelToken(executor) {
      if (typeof executor !== "function") {
        throw new TypeError("executor must be a function.");
      }
      var resolvePromise;
      this.promise = new Promise(function promiseExecutor(resolve) {
        resolvePromise = resolve;
      });
      var token = this;
      this.promise.then(function(cancel) {
        if (!token._listeners)
          return;
        var i2;
        var l = token._listeners.length;
        for (i2 = 0; i2 < l; i2++) {
          token._listeners[i2](cancel);
        }
        token._listeners = null;
      });
      this.promise.then = function(onfulfilled) {
        var _resolve;
        var promise = new Promise(function(resolve) {
          token.subscribe(resolve);
          _resolve = resolve;
        }).then(onfulfilled);
        promise.cancel = function reject() {
          token.unsubscribe(_resolve);
        };
        return promise;
      };
      executor(function cancel(message) {
        if (token.reason) {
          return;
        }
        token.reason = new Cancel(message);
        resolvePromise(token.reason);
      });
    }
    CancelToken.prototype.throwIfRequested = function throwIfRequested() {
      if (this.reason) {
        throw this.reason;
      }
    };
    CancelToken.prototype.subscribe = function subscribe(listener) {
      if (this.reason) {
        listener(this.reason);
        return;
      }
      if (this._listeners) {
        this._listeners.push(listener);
      } else {
        this._listeners = [listener];
      }
    };
    CancelToken.prototype.unsubscribe = function unsubscribe(listener) {
      if (!this._listeners) {
        return;
      }
      var index = this._listeners.indexOf(listener);
      if (index !== -1) {
        this._listeners.splice(index, 1);
      }
    };
    CancelToken.source = function source() {
      var cancel;
      var token = new CancelToken(function executor(c2) {
        cancel = c2;
      });
      return {
        token,
        cancel
      };
    };
    module.exports = CancelToken;
  }
});

// node_modules/@taquito/http-utils/node_modules/axios/lib/helpers/spread.js
var require_spread = __commonJS({
  "node_modules/@taquito/http-utils/node_modules/axios/lib/helpers/spread.js"(exports, module) {
    "use strict";
    module.exports = function spread(callback) {
      return function wrap(arr) {
        return callback.apply(null, arr);
      };
    };
  }
});

// node_modules/@taquito/http-utils/node_modules/axios/lib/helpers/isAxiosError.js
var require_isAxiosError = __commonJS({
  "node_modules/@taquito/http-utils/node_modules/axios/lib/helpers/isAxiosError.js"(exports, module) {
    "use strict";
    var utils = require_utils();
    module.exports = function isAxiosError(payload) {
      return utils.isObject(payload) && payload.isAxiosError === true;
    };
  }
});

// node_modules/@taquito/http-utils/node_modules/axios/lib/axios.js
var require_axios2 = __commonJS({
  "node_modules/@taquito/http-utils/node_modules/axios/lib/axios.js"(exports, module) {
    "use strict";
    var utils = require_utils();
    var bind2 = require_bind();
    var Axios = require_Axios();
    var mergeConfig = require_mergeConfig();
    var defaults = require_defaults();
    function createInstance(defaultConfig) {
      var context2 = new Axios(defaultConfig);
      var instance = bind2(Axios.prototype.request, context2);
      utils.extend(instance, Axios.prototype, context2);
      utils.extend(instance, context2);
      instance.create = function create(instanceConfig) {
        return createInstance(mergeConfig(defaultConfig, instanceConfig));
      };
      return instance;
    }
    var axios5 = createInstance(defaults);
    axios5.Axios = Axios;
    axios5.Cancel = require_Cancel();
    axios5.CancelToken = require_CancelToken();
    axios5.isCancel = require_isCancel();
    axios5.VERSION = require_data().version;
    axios5.all = function all(promises) {
      return Promise.all(promises);
    };
    axios5.spread = require_spread();
    axios5.isAxiosError = require_isAxiosError();
    module.exports = axios5;
    module.exports.default = axios5;
  }
});

// node_modules/@taquito/http-utils/node_modules/axios/index.js
var require_axios3 = __commonJS({
  "node_modules/@taquito/http-utils/node_modules/axios/index.js"(exports, module) {
    module.exports = require_axios2();
  }
});

// node_modules/blakejs/util.js
var require_util = __commonJS({
  "node_modules/blakejs/util.js"(exports, module) {
    var ERROR_MSG_INPUT = "Input must be an string, Buffer or Uint8Array";
    function normalizeInput(input) {
      let ret;
      if (input instanceof Uint8Array) {
        ret = input;
      } else if (typeof input === "string") {
        const encoder = new TextEncoder();
        ret = encoder.encode(input);
      } else {
        throw new Error(ERROR_MSG_INPUT);
      }
      return ret;
    }
    function toHex2(bytes) {
      return Array.prototype.map.call(bytes, function(n2) {
        return (n2 < 16 ? "0" : "") + n2.toString(16);
      }).join("");
    }
    function uint32ToHex(val) {
      return (4294967296 + val).toString(16).substring(1);
    }
    function debugPrint(label, arr, size) {
      let msg = "\n" + label + " = ";
      for (let i2 = 0; i2 < arr.length; i2 += 2) {
        if (size === 32) {
          msg += uint32ToHex(arr[i2]).toUpperCase();
          msg += " ";
          msg += uint32ToHex(arr[i2 + 1]).toUpperCase();
        } else if (size === 64) {
          msg += uint32ToHex(arr[i2 + 1]).toUpperCase();
          msg += uint32ToHex(arr[i2]).toUpperCase();
        } else
          throw new Error("Invalid size " + size);
        if (i2 % 6 === 4) {
          msg += "\n" + new Array(label.length + 4).join(" ");
        } else if (i2 < arr.length - 2) {
          msg += " ";
        }
      }
      console.log(msg);
    }
    function testSpeed(hashFn, N3, M3) {
      let startMs = (/* @__PURE__ */ new Date()).getTime();
      const input = new Uint8Array(N3);
      for (let i2 = 0; i2 < N3; i2++) {
        input[i2] = i2 % 256;
      }
      const genMs = (/* @__PURE__ */ new Date()).getTime();
      console.log("Generated random input in " + (genMs - startMs) + "ms");
      startMs = genMs;
      for (let i2 = 0; i2 < M3; i2++) {
        const hashHex = hashFn(input);
        const hashMs = (/* @__PURE__ */ new Date()).getTime();
        const ms2 = hashMs - startMs;
        startMs = hashMs;
        console.log("Hashed in " + ms2 + "ms: " + hashHex.substring(0, 20) + "...");
        console.log(
          Math.round(N3 / (1 << 20) / (ms2 / 1e3) * 100) / 100 + " MB PER SECOND"
        );
      }
    }
    module.exports = {
      normalizeInput,
      toHex: toHex2,
      debugPrint,
      testSpeed
    };
  }
});

// node_modules/blakejs/blake2b.js
var require_blake2b2 = __commonJS({
  "node_modules/blakejs/blake2b.js"(exports, module) {
    var util = require_util();
    function ADD64AA(v2, a2, b3) {
      const o0 = v2[a2] + v2[b3];
      let o1 = v2[a2 + 1] + v2[b3 + 1];
      if (o0 >= 4294967296) {
        o1++;
      }
      v2[a2] = o0;
      v2[a2 + 1] = o1;
    }
    function ADD64AC(v2, a2, b0, b1) {
      let o0 = v2[a2] + b0;
      if (b0 < 0) {
        o0 += 4294967296;
      }
      let o1 = v2[a2 + 1] + b1;
      if (o0 >= 4294967296) {
        o1++;
      }
      v2[a2] = o0;
      v2[a2 + 1] = o1;
    }
    function B2B_GET32(arr, i2) {
      return arr[i2] ^ arr[i2 + 1] << 8 ^ arr[i2 + 2] << 16 ^ arr[i2 + 3] << 24;
    }
    function B2B_G(a2, b3, c2, d2, ix, iy) {
      const x0 = m2[ix];
      const x1 = m2[ix + 1];
      const y0 = m2[iy];
      const y1 = m2[iy + 1];
      ADD64AA(v, a2, b3);
      ADD64AC(v, a2, x0, x1);
      let xor0 = v[d2] ^ v[a2];
      let xor1 = v[d2 + 1] ^ v[a2 + 1];
      v[d2] = xor1;
      v[d2 + 1] = xor0;
      ADD64AA(v, c2, d2);
      xor0 = v[b3] ^ v[c2];
      xor1 = v[b3 + 1] ^ v[c2 + 1];
      v[b3] = xor0 >>> 24 ^ xor1 << 8;
      v[b3 + 1] = xor1 >>> 24 ^ xor0 << 8;
      ADD64AA(v, a2, b3);
      ADD64AC(v, a2, y0, y1);
      xor0 = v[d2] ^ v[a2];
      xor1 = v[d2 + 1] ^ v[a2 + 1];
      v[d2] = xor0 >>> 16 ^ xor1 << 16;
      v[d2 + 1] = xor1 >>> 16 ^ xor0 << 16;
      ADD64AA(v, c2, d2);
      xor0 = v[b3] ^ v[c2];
      xor1 = v[b3 + 1] ^ v[c2 + 1];
      v[b3] = xor1 >>> 31 ^ xor0 << 1;
      v[b3 + 1] = xor0 >>> 31 ^ xor1 << 1;
    }
    var BLAKE2B_IV32 = new Uint32Array([
      4089235720,
      1779033703,
      2227873595,
      3144134277,
      4271175723,
      1013904242,
      1595750129,
      2773480762,
      2917565137,
      1359893119,
      725511199,
      2600822924,
      4215389547,
      528734635,
      327033209,
      1541459225
    ]);
    var SIGMA8 = [
      0,
      1,
      2,
      3,
      4,
      5,
      6,
      7,
      8,
      9,
      10,
      11,
      12,
      13,
      14,
      15,
      14,
      10,
      4,
      8,
      9,
      15,
      13,
      6,
      1,
      12,
      0,
      2,
      11,
      7,
      5,
      3,
      11,
      8,
      12,
      0,
      5,
      2,
      15,
      13,
      10,
      14,
      3,
      6,
      7,
      1,
      9,
      4,
      7,
      9,
      3,
      1,
      13,
      12,
      11,
      14,
      2,
      6,
      5,
      10,
      4,
      0,
      15,
      8,
      9,
      0,
      5,
      7,
      2,
      4,
      10,
      15,
      14,
      1,
      11,
      12,
      6,
      8,
      3,
      13,
      2,
      12,
      6,
      10,
      0,
      11,
      8,
      3,
      4,
      13,
      7,
      5,
      15,
      14,
      1,
      9,
      12,
      5,
      1,
      15,
      14,
      13,
      4,
      10,
      0,
      7,
      6,
      3,
      9,
      2,
      8,
      11,
      13,
      11,
      7,
      14,
      12,
      1,
      3,
      9,
      5,
      0,
      15,
      4,
      8,
      6,
      2,
      10,
      6,
      15,
      14,
      9,
      11,
      3,
      0,
      8,
      12,
      2,
      13,
      7,
      1,
      4,
      10,
      5,
      10,
      2,
      8,
      4,
      7,
      6,
      1,
      5,
      15,
      11,
      9,
      14,
      3,
      12,
      13,
      0,
      0,
      1,
      2,
      3,
      4,
      5,
      6,
      7,
      8,
      9,
      10,
      11,
      12,
      13,
      14,
      15,
      14,
      10,
      4,
      8,
      9,
      15,
      13,
      6,
      1,
      12,
      0,
      2,
      11,
      7,
      5,
      3
    ];
    var SIGMA82 = new Uint8Array(
      SIGMA8.map(function(x3) {
        return x3 * 2;
      })
    );
    var v = new Uint32Array(32);
    var m2 = new Uint32Array(32);
    function blake2bCompress(ctx, last3) {
      let i2 = 0;
      for (i2 = 0; i2 < 16; i2++) {
        v[i2] = ctx.h[i2];
        v[i2 + 16] = BLAKE2B_IV32[i2];
      }
      v[24] = v[24] ^ ctx.t;
      v[25] = v[25] ^ ctx.t / 4294967296;
      if (last3) {
        v[28] = ~v[28];
        v[29] = ~v[29];
      }
      for (i2 = 0; i2 < 32; i2++) {
        m2[i2] = B2B_GET32(ctx.b, 4 * i2);
      }
      for (i2 = 0; i2 < 12; i2++) {
        B2B_G(0, 8, 16, 24, SIGMA82[i2 * 16 + 0], SIGMA82[i2 * 16 + 1]);
        B2B_G(2, 10, 18, 26, SIGMA82[i2 * 16 + 2], SIGMA82[i2 * 16 + 3]);
        B2B_G(4, 12, 20, 28, SIGMA82[i2 * 16 + 4], SIGMA82[i2 * 16 + 5]);
        B2B_G(6, 14, 22, 30, SIGMA82[i2 * 16 + 6], SIGMA82[i2 * 16 + 7]);
        B2B_G(0, 10, 20, 30, SIGMA82[i2 * 16 + 8], SIGMA82[i2 * 16 + 9]);
        B2B_G(2, 12, 22, 24, SIGMA82[i2 * 16 + 10], SIGMA82[i2 * 16 + 11]);
        B2B_G(4, 14, 16, 26, SIGMA82[i2 * 16 + 12], SIGMA82[i2 * 16 + 13]);
        B2B_G(6, 8, 18, 28, SIGMA82[i2 * 16 + 14], SIGMA82[i2 * 16 + 15]);
      }
      for (i2 = 0; i2 < 16; i2++) {
        ctx.h[i2] = ctx.h[i2] ^ v[i2] ^ v[i2 + 16];
      }
    }
    var parameterBlock = new Uint8Array([
      0,
      0,
      0,
      0,
      //  0: outlen, keylen, fanout, depth
      0,
      0,
      0,
      0,
      //  4: leaf length, sequential mode
      0,
      0,
      0,
      0,
      //  8: node offset
      0,
      0,
      0,
      0,
      // 12: node offset
      0,
      0,
      0,
      0,
      // 16: node depth, inner length, rfu
      0,
      0,
      0,
      0,
      // 20: rfu
      0,
      0,
      0,
      0,
      // 24: rfu
      0,
      0,
      0,
      0,
      // 28: rfu
      0,
      0,
      0,
      0,
      // 32: salt
      0,
      0,
      0,
      0,
      // 36: salt
      0,
      0,
      0,
      0,
      // 40: salt
      0,
      0,
      0,
      0,
      // 44: salt
      0,
      0,
      0,
      0,
      // 48: personal
      0,
      0,
      0,
      0,
      // 52: personal
      0,
      0,
      0,
      0,
      // 56: personal
      0,
      0,
      0,
      0
      // 60: personal
    ]);
    function blake2bInit(outlen, key, salt, personal) {
      if (outlen === 0 || outlen > 64) {
        throw new Error("Illegal output length, expected 0 < length <= 64");
      }
      if (key && key.length > 64) {
        throw new Error("Illegal key, expected Uint8Array with 0 < length <= 64");
      }
      if (salt && salt.length !== 16) {
        throw new Error("Illegal salt, expected Uint8Array with length is 16");
      }
      if (personal && personal.length !== 16) {
        throw new Error("Illegal personal, expected Uint8Array with length is 16");
      }
      const ctx = {
        b: new Uint8Array(128),
        h: new Uint32Array(16),
        t: 0,
        // input count
        c: 0,
        // pointer within buffer
        outlen
        // output length in bytes
      };
      parameterBlock.fill(0);
      parameterBlock[0] = outlen;
      if (key)
        parameterBlock[1] = key.length;
      parameterBlock[2] = 1;
      parameterBlock[3] = 1;
      if (salt)
        parameterBlock.set(salt, 32);
      if (personal)
        parameterBlock.set(personal, 48);
      for (let i2 = 0; i2 < 16; i2++) {
        ctx.h[i2] = BLAKE2B_IV32[i2] ^ B2B_GET32(parameterBlock, i2 * 4);
      }
      if (key) {
        blake2bUpdate(ctx, key);
        ctx.c = 128;
      }
      return ctx;
    }
    function blake2bUpdate(ctx, input) {
      for (let i2 = 0; i2 < input.length; i2++) {
        if (ctx.c === 128) {
          ctx.t += ctx.c;
          blake2bCompress(ctx, false);
          ctx.c = 0;
        }
        ctx.b[ctx.c++] = input[i2];
      }
    }
    function blake2bFinal(ctx) {
      ctx.t += ctx.c;
      while (ctx.c < 128) {
        ctx.b[ctx.c++] = 0;
      }
      blake2bCompress(ctx, true);
      const out = new Uint8Array(ctx.outlen);
      for (let i2 = 0; i2 < ctx.outlen; i2++) {
        out[i2] = ctx.h[i2 >> 2] >> 8 * (i2 & 3);
      }
      return out;
    }
    function blake2b(input, key, outlen, salt, personal) {
      outlen = outlen || 64;
      input = util.normalizeInput(input);
      if (salt) {
        salt = util.normalizeInput(salt);
      }
      if (personal) {
        personal = util.normalizeInput(personal);
      }
      const ctx = blake2bInit(outlen, key, salt, personal);
      blake2bUpdate(ctx, input);
      return blake2bFinal(ctx);
    }
    function blake2bHex(input, key, outlen, salt, personal) {
      const output = blake2b(input, key, outlen, salt, personal);
      return util.toHex(output);
    }
    module.exports = {
      blake2b,
      blake2bHex,
      blake2bInit,
      blake2bUpdate,
      blake2bFinal
    };
  }
});

// node_modules/blakejs/blake2s.js
var require_blake2s = __commonJS({
  "node_modules/blakejs/blake2s.js"(exports, module) {
    var util = require_util();
    function B2S_GET32(v2, i2) {
      return v2[i2] ^ v2[i2 + 1] << 8 ^ v2[i2 + 2] << 16 ^ v2[i2 + 3] << 24;
    }
    function B2S_G(a2, b3, c2, d2, x3, y3) {
      v[a2] = v[a2] + v[b3] + x3;
      v[d2] = ROTR32(v[d2] ^ v[a2], 16);
      v[c2] = v[c2] + v[d2];
      v[b3] = ROTR32(v[b3] ^ v[c2], 12);
      v[a2] = v[a2] + v[b3] + y3;
      v[d2] = ROTR32(v[d2] ^ v[a2], 8);
      v[c2] = v[c2] + v[d2];
      v[b3] = ROTR32(v[b3] ^ v[c2], 7);
    }
    function ROTR32(x3, y3) {
      return x3 >>> y3 ^ x3 << 32 - y3;
    }
    var BLAKE2S_IV = new Uint32Array([
      1779033703,
      3144134277,
      1013904242,
      2773480762,
      1359893119,
      2600822924,
      528734635,
      1541459225
    ]);
    var SIGMA = new Uint8Array([
      0,
      1,
      2,
      3,
      4,
      5,
      6,
      7,
      8,
      9,
      10,
      11,
      12,
      13,
      14,
      15,
      14,
      10,
      4,
      8,
      9,
      15,
      13,
      6,
      1,
      12,
      0,
      2,
      11,
      7,
      5,
      3,
      11,
      8,
      12,
      0,
      5,
      2,
      15,
      13,
      10,
      14,
      3,
      6,
      7,
      1,
      9,
      4,
      7,
      9,
      3,
      1,
      13,
      12,
      11,
      14,
      2,
      6,
      5,
      10,
      4,
      0,
      15,
      8,
      9,
      0,
      5,
      7,
      2,
      4,
      10,
      15,
      14,
      1,
      11,
      12,
      6,
      8,
      3,
      13,
      2,
      12,
      6,
      10,
      0,
      11,
      8,
      3,
      4,
      13,
      7,
      5,
      15,
      14,
      1,
      9,
      12,
      5,
      1,
      15,
      14,
      13,
      4,
      10,
      0,
      7,
      6,
      3,
      9,
      2,
      8,
      11,
      13,
      11,
      7,
      14,
      12,
      1,
      3,
      9,
      5,
      0,
      15,
      4,
      8,
      6,
      2,
      10,
      6,
      15,
      14,
      9,
      11,
      3,
      0,
      8,
      12,
      2,
      13,
      7,
      1,
      4,
      10,
      5,
      10,
      2,
      8,
      4,
      7,
      6,
      1,
      5,
      15,
      11,
      9,
      14,
      3,
      12,
      13,
      0
    ]);
    var v = new Uint32Array(16);
    var m2 = new Uint32Array(16);
    function blake2sCompress(ctx, last3) {
      let i2 = 0;
      for (i2 = 0; i2 < 8; i2++) {
        v[i2] = ctx.h[i2];
        v[i2 + 8] = BLAKE2S_IV[i2];
      }
      v[12] ^= ctx.t;
      v[13] ^= ctx.t / 4294967296;
      if (last3) {
        v[14] = ~v[14];
      }
      for (i2 = 0; i2 < 16; i2++) {
        m2[i2] = B2S_GET32(ctx.b, 4 * i2);
      }
      for (i2 = 0; i2 < 10; i2++) {
        B2S_G(0, 4, 8, 12, m2[SIGMA[i2 * 16 + 0]], m2[SIGMA[i2 * 16 + 1]]);
        B2S_G(1, 5, 9, 13, m2[SIGMA[i2 * 16 + 2]], m2[SIGMA[i2 * 16 + 3]]);
        B2S_G(2, 6, 10, 14, m2[SIGMA[i2 * 16 + 4]], m2[SIGMA[i2 * 16 + 5]]);
        B2S_G(3, 7, 11, 15, m2[SIGMA[i2 * 16 + 6]], m2[SIGMA[i2 * 16 + 7]]);
        B2S_G(0, 5, 10, 15, m2[SIGMA[i2 * 16 + 8]], m2[SIGMA[i2 * 16 + 9]]);
        B2S_G(1, 6, 11, 12, m2[SIGMA[i2 * 16 + 10]], m2[SIGMA[i2 * 16 + 11]]);
        B2S_G(2, 7, 8, 13, m2[SIGMA[i2 * 16 + 12]], m2[SIGMA[i2 * 16 + 13]]);
        B2S_G(3, 4, 9, 14, m2[SIGMA[i2 * 16 + 14]], m2[SIGMA[i2 * 16 + 15]]);
      }
      for (i2 = 0; i2 < 8; i2++) {
        ctx.h[i2] ^= v[i2] ^ v[i2 + 8];
      }
    }
    function blake2sInit(outlen, key) {
      if (!(outlen > 0 && outlen <= 32)) {
        throw new Error("Incorrect output length, should be in [1, 32]");
      }
      const keylen = key ? key.length : 0;
      if (key && !(keylen > 0 && keylen <= 32)) {
        throw new Error("Incorrect key length, should be in [1, 32]");
      }
      const ctx = {
        h: new Uint32Array(BLAKE2S_IV),
        // hash state
        b: new Uint8Array(64),
        // input block
        c: 0,
        // pointer within block
        t: 0,
        // input count
        outlen
        // output length in bytes
      };
      ctx.h[0] ^= 16842752 ^ keylen << 8 ^ outlen;
      if (keylen > 0) {
        blake2sUpdate(ctx, key);
        ctx.c = 64;
      }
      return ctx;
    }
    function blake2sUpdate(ctx, input) {
      for (let i2 = 0; i2 < input.length; i2++) {
        if (ctx.c === 64) {
          ctx.t += ctx.c;
          blake2sCompress(ctx, false);
          ctx.c = 0;
        }
        ctx.b[ctx.c++] = input[i2];
      }
    }
    function blake2sFinal(ctx) {
      ctx.t += ctx.c;
      while (ctx.c < 64) {
        ctx.b[ctx.c++] = 0;
      }
      blake2sCompress(ctx, true);
      const out = new Uint8Array(ctx.outlen);
      for (let i2 = 0; i2 < ctx.outlen; i2++) {
        out[i2] = ctx.h[i2 >> 2] >> 8 * (i2 & 3) & 255;
      }
      return out;
    }
    function blake2s(input, key, outlen) {
      outlen = outlen || 32;
      input = util.normalizeInput(input);
      const ctx = blake2sInit(outlen, key);
      blake2sUpdate(ctx, input);
      return blake2sFinal(ctx);
    }
    function blake2sHex(input, key, outlen) {
      const output = blake2s(input, key, outlen);
      return util.toHex(output);
    }
    module.exports = {
      blake2s,
      blake2sHex,
      blake2sInit,
      blake2sUpdate,
      blake2sFinal
    };
  }
});

// node_modules/blakejs/index.js
var require_blakejs = __commonJS({
  "node_modules/blakejs/index.js"(exports, module) {
    var b2b = require_blake2b2();
    var b2s = require_blake2s();
    module.exports = {
      blake2b: b2b.blake2b,
      blake2bHex: b2b.blake2bHex,
      blake2bInit: b2b.blake2bInit,
      blake2bUpdate: b2b.blake2bUpdate,
      blake2bFinal: b2b.blake2bFinal,
      blake2s: b2s.blake2s,
      blake2sHex: b2s.blake2sHex,
      blake2sInit: b2s.blake2sInit,
      blake2sUpdate: b2s.blake2sUpdate,
      blake2sFinal: b2s.blake2sFinal
    };
  }
});

// node_modules/elliptic/package.json
var require_package = __commonJS({
  "node_modules/elliptic/package.json"(exports, module) {
    module.exports = {
      name: "elliptic",
      version: "6.5.4",
      description: "EC cryptography",
      main: "lib/elliptic.js",
      files: [
        "lib"
      ],
      scripts: {
        lint: "eslint lib test",
        "lint:fix": "npm run lint -- --fix",
        unit: "istanbul test _mocha --reporter=spec test/index.js",
        test: "npm run lint && npm run unit",
        version: "grunt dist && git add dist/"
      },
      repository: {
        type: "git",
        url: "git@github.com:indutny/elliptic"
      },
      keywords: [
        "EC",
        "Elliptic",
        "curve",
        "Cryptography"
      ],
      author: "Fedor Indutny <fedor@indutny.com>",
      license: "MIT",
      bugs: {
        url: "https://github.com/indutny/elliptic/issues"
      },
      homepage: "https://github.com/indutny/elliptic",
      devDependencies: {
        brfs: "^2.0.2",
        coveralls: "^3.1.0",
        eslint: "^7.6.0",
        grunt: "^1.2.1",
        "grunt-browserify": "^5.3.0",
        "grunt-cli": "^1.3.2",
        "grunt-contrib-connect": "^3.0.0",
        "grunt-contrib-copy": "^1.0.0",
        "grunt-contrib-uglify": "^5.0.0",
        "grunt-mocha-istanbul": "^5.0.2",
        "grunt-saucelabs": "^9.0.1",
        istanbul: "^0.4.5",
        mocha: "^8.0.1"
      },
      dependencies: {
        "bn.js": "^4.11.9",
        brorand: "^1.1.0",
        "hash.js": "^1.0.0",
        "hmac-drbg": "^1.0.1",
        inherits: "^2.0.4",
        "minimalistic-assert": "^1.0.1",
        "minimalistic-crypto-utils": "^1.0.1"
      }
    };
  }
});

// browser-external:buffer
var require_buffer2 = __commonJS({
  "browser-external:buffer"(exports, module) {
    module.exports = Object.create(new Proxy({}, {
      get(_2, key) {
        if (key !== "__esModule" && key !== "__proto__" && key !== "constructor" && key !== "splice") {
          console.warn(`Module "buffer" has been externalized for browser compatibility. Cannot access "buffer.${key}" in client code. See http://vitejs.dev/guide/troubleshooting.html#module-externalized-for-browser-compatibility for more details.`);
        }
      }
    }));
  }
});

// node_modules/bn.js/lib/bn.js
var require_bn = __commonJS({
  "node_modules/bn.js/lib/bn.js"(exports, module) {
    (function(module2, exports2) {
      "use strict";
      function assert(val, msg) {
        if (!val)
          throw new Error(msg || "Assertion failed");
      }
      function inherits(ctor, superCtor) {
        ctor.super_ = superCtor;
        var TempCtor = function() {
        };
        TempCtor.prototype = superCtor.prototype;
        ctor.prototype = new TempCtor();
        ctor.prototype.constructor = ctor;
      }
      function BN(number, base, endian) {
        if (BN.isBN(number)) {
          return number;
        }
        this.negative = 0;
        this.words = null;
        this.length = 0;
        this.red = null;
        if (number !== null) {
          if (base === "le" || base === "be") {
            endian = base;
            base = 10;
          }
          this._init(number || 0, base || 10, endian || "be");
        }
      }
      if (typeof module2 === "object") {
        module2.exports = BN;
      } else {
        exports2.BN = BN;
      }
      BN.BN = BN;
      BN.wordSize = 26;
      var Buffer3;
      try {
        if (typeof window !== "undefined" && typeof window.Buffer !== "undefined") {
          Buffer3 = window.Buffer;
        } else {
          Buffer3 = require_buffer2().Buffer;
        }
      } catch (e) {
      }
      BN.isBN = function isBN(num) {
        if (num instanceof BN) {
          return true;
        }
        return num !== null && typeof num === "object" && num.constructor.wordSize === BN.wordSize && Array.isArray(num.words);
      };
      BN.max = function max2(left, right) {
        if (left.cmp(right) > 0)
          return left;
        return right;
      };
      BN.min = function min2(left, right) {
        if (left.cmp(right) < 0)
          return left;
        return right;
      };
      BN.prototype._init = function init(number, base, endian) {
        if (typeof number === "number") {
          return this._initNumber(number, base, endian);
        }
        if (typeof number === "object") {
          return this._initArray(number, base, endian);
        }
        if (base === "hex") {
          base = 16;
        }
        assert(base === (base | 0) && base >= 2 && base <= 36);
        number = number.toString().replace(/\s+/g, "");
        var start = 0;
        if (number[0] === "-") {
          start++;
          this.negative = 1;
        }
        if (start < number.length) {
          if (base === 16) {
            this._parseHex(number, start, endian);
          } else {
            this._parseBase(number, base, start);
            if (endian === "le") {
              this._initArray(this.toArray(), base, endian);
            }
          }
        }
      };
      BN.prototype._initNumber = function _initNumber(number, base, endian) {
        if (number < 0) {
          this.negative = 1;
          number = -number;
        }
        if (number < 67108864) {
          this.words = [number & 67108863];
          this.length = 1;
        } else if (number < 4503599627370496) {
          this.words = [
            number & 67108863,
            number / 67108864 & 67108863
          ];
          this.length = 2;
        } else {
          assert(number < 9007199254740992);
          this.words = [
            number & 67108863,
            number / 67108864 & 67108863,
            1
          ];
          this.length = 3;
        }
        if (endian !== "le")
          return;
        this._initArray(this.toArray(), base, endian);
      };
      BN.prototype._initArray = function _initArray(number, base, endian) {
        assert(typeof number.length === "number");
        if (number.length <= 0) {
          this.words = [0];
          this.length = 1;
          return this;
        }
        this.length = Math.ceil(number.length / 3);
        this.words = new Array(this.length);
        for (var i2 = 0; i2 < this.length; i2++) {
          this.words[i2] = 0;
        }
        var j2, w3;
        var off = 0;
        if (endian === "be") {
          for (i2 = number.length - 1, j2 = 0; i2 >= 0; i2 -= 3) {
            w3 = number[i2] | number[i2 - 1] << 8 | number[i2 - 2] << 16;
            this.words[j2] |= w3 << off & 67108863;
            this.words[j2 + 1] = w3 >>> 26 - off & 67108863;
            off += 24;
            if (off >= 26) {
              off -= 26;
              j2++;
            }
          }
        } else if (endian === "le") {
          for (i2 = 0, j2 = 0; i2 < number.length; i2 += 3) {
            w3 = number[i2] | number[i2 + 1] << 8 | number[i2 + 2] << 16;
            this.words[j2] |= w3 << off & 67108863;
            this.words[j2 + 1] = w3 >>> 26 - off & 67108863;
            off += 24;
            if (off >= 26) {
              off -= 26;
              j2++;
            }
          }
        }
        return this.strip();
      };
      function parseHex4Bits(string, index) {
        var c2 = string.charCodeAt(index);
        if (c2 >= 65 && c2 <= 70) {
          return c2 - 55;
        } else if (c2 >= 97 && c2 <= 102) {
          return c2 - 87;
        } else {
          return c2 - 48 & 15;
        }
      }
      function parseHexByte(string, lowerBound, index) {
        var r = parseHex4Bits(string, index);
        if (index - 1 >= lowerBound) {
          r |= parseHex4Bits(string, index - 1) << 4;
        }
        return r;
      }
      BN.prototype._parseHex = function _parseHex(number, start, endian) {
        this.length = Math.ceil((number.length - start) / 6);
        this.words = new Array(this.length);
        for (var i2 = 0; i2 < this.length; i2++) {
          this.words[i2] = 0;
        }
        var off = 0;
        var j2 = 0;
        var w3;
        if (endian === "be") {
          for (i2 = number.length - 1; i2 >= start; i2 -= 2) {
            w3 = parseHexByte(number, start, i2) << off;
            this.words[j2] |= w3 & 67108863;
            if (off >= 18) {
              off -= 18;
              j2 += 1;
              this.words[j2] |= w3 >>> 26;
            } else {
              off += 8;
            }
          }
        } else {
          var parseLength = number.length - start;
          for (i2 = parseLength % 2 === 0 ? start + 1 : start; i2 < number.length; i2 += 2) {
            w3 = parseHexByte(number, start, i2) << off;
            this.words[j2] |= w3 & 67108863;
            if (off >= 18) {
              off -= 18;
              j2 += 1;
              this.words[j2] |= w3 >>> 26;
            } else {
              off += 8;
            }
          }
        }
        this.strip();
      };
      function parseBase(str, start, end, mul) {
        var r = 0;
        var len = Math.min(str.length, end);
        for (var i2 = start; i2 < len; i2++) {
          var c2 = str.charCodeAt(i2) - 48;
          r *= mul;
          if (c2 >= 49) {
            r += c2 - 49 + 10;
          } else if (c2 >= 17) {
            r += c2 - 17 + 10;
          } else {
            r += c2;
          }
        }
        return r;
      }
      BN.prototype._parseBase = function _parseBase(number, base, start) {
        this.words = [0];
        this.length = 1;
        for (var limbLen = 0, limbPow = 1; limbPow <= 67108863; limbPow *= base) {
          limbLen++;
        }
        limbLen--;
        limbPow = limbPow / base | 0;
        var total = number.length - start;
        var mod = total % limbLen;
        var end = Math.min(total, total - mod) + start;
        var word = 0;
        for (var i2 = start; i2 < end; i2 += limbLen) {
          word = parseBase(number, i2, i2 + limbLen, base);
          this.imuln(limbPow);
          if (this.words[0] + word < 67108864) {
            this.words[0] += word;
          } else {
            this._iaddn(word);
          }
        }
        if (mod !== 0) {
          var pow = 1;
          word = parseBase(number, i2, number.length, base);
          for (i2 = 0; i2 < mod; i2++) {
            pow *= base;
          }
          this.imuln(pow);
          if (this.words[0] + word < 67108864) {
            this.words[0] += word;
          } else {
            this._iaddn(word);
          }
        }
        this.strip();
      };
      BN.prototype.copy = function copy(dest) {
        dest.words = new Array(this.length);
        for (var i2 = 0; i2 < this.length; i2++) {
          dest.words[i2] = this.words[i2];
        }
        dest.length = this.length;
        dest.negative = this.negative;
        dest.red = this.red;
      };
      BN.prototype.clone = function clone2() {
        var r = new BN(null);
        this.copy(r);
        return r;
      };
      BN.prototype._expand = function _expand(size) {
        while (this.length < size) {
          this.words[this.length++] = 0;
        }
        return this;
      };
      BN.prototype.strip = function strip() {
        while (this.length > 1 && this.words[this.length - 1] === 0) {
          this.length--;
        }
        return this._normSign();
      };
      BN.prototype._normSign = function _normSign() {
        if (this.length === 1 && this.words[0] === 0) {
          this.negative = 0;
        }
        return this;
      };
      BN.prototype.inspect = function inspect() {
        return (this.red ? "<BN-R: " : "<BN: ") + this.toString(16) + ">";
      };
      var zeros = [
        "",
        "0",
        "00",
        "000",
        "0000",
        "00000",
        "000000",
        "0000000",
        "00000000",
        "000000000",
        "0000000000",
        "00000000000",
        "000000000000",
        "0000000000000",
        "00000000000000",
        "000000000000000",
        "0000000000000000",
        "00000000000000000",
        "000000000000000000",
        "0000000000000000000",
        "00000000000000000000",
        "000000000000000000000",
        "0000000000000000000000",
        "00000000000000000000000",
        "000000000000000000000000",
        "0000000000000000000000000"
      ];
      var groupSizes = [
        0,
        0,
        25,
        16,
        12,
        11,
        10,
        9,
        8,
        8,
        7,
        7,
        7,
        7,
        6,
        6,
        6,
        6,
        6,
        6,
        6,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5
      ];
      var groupBases = [
        0,
        0,
        33554432,
        43046721,
        16777216,
        48828125,
        60466176,
        40353607,
        16777216,
        43046721,
        1e7,
        19487171,
        35831808,
        62748517,
        7529536,
        11390625,
        16777216,
        24137569,
        34012224,
        47045881,
        64e6,
        4084101,
        5153632,
        6436343,
        7962624,
        9765625,
        11881376,
        14348907,
        17210368,
        20511149,
        243e5,
        28629151,
        33554432,
        39135393,
        45435424,
        52521875,
        60466176
      ];
      BN.prototype.toString = function toString2(base, padding) {
        base = base || 10;
        padding = padding | 0 || 1;
        var out;
        if (base === 16 || base === "hex") {
          out = "";
          var off = 0;
          var carry = 0;
          for (var i2 = 0; i2 < this.length; i2++) {
            var w3 = this.words[i2];
            var word = ((w3 << off | carry) & 16777215).toString(16);
            carry = w3 >>> 24 - off & 16777215;
            if (carry !== 0 || i2 !== this.length - 1) {
              out = zeros[6 - word.length] + word + out;
            } else {
              out = word + out;
            }
            off += 2;
            if (off >= 26) {
              off -= 26;
              i2--;
            }
          }
          if (carry !== 0) {
            out = carry.toString(16) + out;
          }
          while (out.length % padding !== 0) {
            out = "0" + out;
          }
          if (this.negative !== 0) {
            out = "-" + out;
          }
          return out;
        }
        if (base === (base | 0) && base >= 2 && base <= 36) {
          var groupSize = groupSizes[base];
          var groupBase = groupBases[base];
          out = "";
          var c2 = this.clone();
          c2.negative = 0;
          while (!c2.isZero()) {
            var r = c2.modn(groupBase).toString(base);
            c2 = c2.idivn(groupBase);
            if (!c2.isZero()) {
              out = zeros[groupSize - r.length] + r + out;
            } else {
              out = r + out;
            }
          }
          if (this.isZero()) {
            out = "0" + out;
          }
          while (out.length % padding !== 0) {
            out = "0" + out;
          }
          if (this.negative !== 0) {
            out = "-" + out;
          }
          return out;
        }
        assert(false, "Base should be between 2 and 36");
      };
      BN.prototype.toNumber = function toNumber() {
        var ret = this.words[0];
        if (this.length === 2) {
          ret += this.words[1] * 67108864;
        } else if (this.length === 3 && this.words[2] === 1) {
          ret += 4503599627370496 + this.words[1] * 67108864;
        } else if (this.length > 2) {
          assert(false, "Number can only safely store up to 53 bits");
        }
        return this.negative !== 0 ? -ret : ret;
      };
      BN.prototype.toJSON = function toJSON() {
        return this.toString(16);
      };
      BN.prototype.toBuffer = function toBuffer4(endian, length) {
        assert(typeof Buffer3 !== "undefined");
        return this.toArrayLike(Buffer3, endian, length);
      };
      BN.prototype.toArray = function toArray2(endian, length) {
        return this.toArrayLike(Array, endian, length);
      };
      BN.prototype.toArrayLike = function toArrayLike(ArrayType, endian, length) {
        var byteLength = this.byteLength();
        var reqLength = length || Math.max(1, byteLength);
        assert(byteLength <= reqLength, "byte array longer than desired length");
        assert(reqLength > 0, "Requested array length <= 0");
        this.strip();
        var littleEndian = endian === "le";
        var res = new ArrayType(reqLength);
        var b3, i2;
        var q3 = this.clone();
        if (!littleEndian) {
          for (i2 = 0; i2 < reqLength - byteLength; i2++) {
            res[i2] = 0;
          }
          for (i2 = 0; !q3.isZero(); i2++) {
            b3 = q3.andln(255);
            q3.iushrn(8);
            res[reqLength - i2 - 1] = b3;
          }
        } else {
          for (i2 = 0; !q3.isZero(); i2++) {
            b3 = q3.andln(255);
            q3.iushrn(8);
            res[i2] = b3;
          }
          for (; i2 < reqLength; i2++) {
            res[i2] = 0;
          }
        }
        return res;
      };
      if (Math.clz32) {
        BN.prototype._countBits = function _countBits(w3) {
          return 32 - Math.clz32(w3);
        };
      } else {
        BN.prototype._countBits = function _countBits(w3) {
          var t = w3;
          var r = 0;
          if (t >= 4096) {
            r += 13;
            t >>>= 13;
          }
          if (t >= 64) {
            r += 7;
            t >>>= 7;
          }
          if (t >= 8) {
            r += 4;
            t >>>= 4;
          }
          if (t >= 2) {
            r += 2;
            t >>>= 2;
          }
          return r + t;
        };
      }
      BN.prototype._zeroBits = function _zeroBits(w3) {
        if (w3 === 0)
          return 26;
        var t = w3;
        var r = 0;
        if ((t & 8191) === 0) {
          r += 13;
          t >>>= 13;
        }
        if ((t & 127) === 0) {
          r += 7;
          t >>>= 7;
        }
        if ((t & 15) === 0) {
          r += 4;
          t >>>= 4;
        }
        if ((t & 3) === 0) {
          r += 2;
          t >>>= 2;
        }
        if ((t & 1) === 0) {
          r++;
        }
        return r;
      };
      BN.prototype.bitLength = function bitLength() {
        var w3 = this.words[this.length - 1];
        var hi = this._countBits(w3);
        return (this.length - 1) * 26 + hi;
      };
      function toBitArray(num) {
        var w3 = new Array(num.bitLength());
        for (var bit = 0; bit < w3.length; bit++) {
          var off = bit / 26 | 0;
          var wbit = bit % 26;
          w3[bit] = (num.words[off] & 1 << wbit) >>> wbit;
        }
        return w3;
      }
      BN.prototype.zeroBits = function zeroBits() {
        if (this.isZero())
          return 0;
        var r = 0;
        for (var i2 = 0; i2 < this.length; i2++) {
          var b3 = this._zeroBits(this.words[i2]);
          r += b3;
          if (b3 !== 26)
            break;
        }
        return r;
      };
      BN.prototype.byteLength = function byteLength() {
        return Math.ceil(this.bitLength() / 8);
      };
      BN.prototype.toTwos = function toTwos(width) {
        if (this.negative !== 0) {
          return this.abs().inotn(width).iaddn(1);
        }
        return this.clone();
      };
      BN.prototype.fromTwos = function fromTwos(width) {
        if (this.testn(width - 1)) {
          return this.notn(width).iaddn(1).ineg();
        }
        return this.clone();
      };
      BN.prototype.isNeg = function isNeg() {
        return this.negative !== 0;
      };
      BN.prototype.neg = function neg() {
        return this.clone().ineg();
      };
      BN.prototype.ineg = function ineg() {
        if (!this.isZero()) {
          this.negative ^= 1;
        }
        return this;
      };
      BN.prototype.iuor = function iuor(num) {
        while (this.length < num.length) {
          this.words[this.length++] = 0;
        }
        for (var i2 = 0; i2 < num.length; i2++) {
          this.words[i2] = this.words[i2] | num.words[i2];
        }
        return this.strip();
      };
      BN.prototype.ior = function ior(num) {
        assert((this.negative | num.negative) === 0);
        return this.iuor(num);
      };
      BN.prototype.or = function or2(num) {
        if (this.length > num.length)
          return this.clone().ior(num);
        return num.clone().ior(this);
      };
      BN.prototype.uor = function uor(num) {
        if (this.length > num.length)
          return this.clone().iuor(num);
        return num.clone().iuor(this);
      };
      BN.prototype.iuand = function iuand(num) {
        var b3;
        if (this.length > num.length) {
          b3 = num;
        } else {
          b3 = this;
        }
        for (var i2 = 0; i2 < b3.length; i2++) {
          this.words[i2] = this.words[i2] & num.words[i2];
        }
        this.length = b3.length;
        return this.strip();
      };
      BN.prototype.iand = function iand(num) {
        assert((this.negative | num.negative) === 0);
        return this.iuand(num);
      };
      BN.prototype.and = function and(num) {
        if (this.length > num.length)
          return this.clone().iand(num);
        return num.clone().iand(this);
      };
      BN.prototype.uand = function uand(num) {
        if (this.length > num.length)
          return this.clone().iuand(num);
        return num.clone().iuand(this);
      };
      BN.prototype.iuxor = function iuxor(num) {
        var a2;
        var b3;
        if (this.length > num.length) {
          a2 = this;
          b3 = num;
        } else {
          a2 = num;
          b3 = this;
        }
        for (var i2 = 0; i2 < b3.length; i2++) {
          this.words[i2] = a2.words[i2] ^ b3.words[i2];
        }
        if (this !== a2) {
          for (; i2 < a2.length; i2++) {
            this.words[i2] = a2.words[i2];
          }
        }
        this.length = a2.length;
        return this.strip();
      };
      BN.prototype.ixor = function ixor(num) {
        assert((this.negative | num.negative) === 0);
        return this.iuxor(num);
      };
      BN.prototype.xor = function xor(num) {
        if (this.length > num.length)
          return this.clone().ixor(num);
        return num.clone().ixor(this);
      };
      BN.prototype.uxor = function uxor(num) {
        if (this.length > num.length)
          return this.clone().iuxor(num);
        return num.clone().iuxor(this);
      };
      BN.prototype.inotn = function inotn(width) {
        assert(typeof width === "number" && width >= 0);
        var bytesNeeded = Math.ceil(width / 26) | 0;
        var bitsLeft = width % 26;
        this._expand(bytesNeeded);
        if (bitsLeft > 0) {
          bytesNeeded--;
        }
        for (var i2 = 0; i2 < bytesNeeded; i2++) {
          this.words[i2] = ~this.words[i2] & 67108863;
        }
        if (bitsLeft > 0) {
          this.words[i2] = ~this.words[i2] & 67108863 >> 26 - bitsLeft;
        }
        return this.strip();
      };
      BN.prototype.notn = function notn(width) {
        return this.clone().inotn(width);
      };
      BN.prototype.setn = function setn(bit, val) {
        assert(typeof bit === "number" && bit >= 0);
        var off = bit / 26 | 0;
        var wbit = bit % 26;
        this._expand(off + 1);
        if (val) {
          this.words[off] = this.words[off] | 1 << wbit;
        } else {
          this.words[off] = this.words[off] & ~(1 << wbit);
        }
        return this.strip();
      };
      BN.prototype.iadd = function iadd(num) {
        var r;
        if (this.negative !== 0 && num.negative === 0) {
          this.negative = 0;
          r = this.isub(num);
          this.negative ^= 1;
          return this._normSign();
        } else if (this.negative === 0 && num.negative !== 0) {
          num.negative = 0;
          r = this.isub(num);
          num.negative = 1;
          return r._normSign();
        }
        var a2, b3;
        if (this.length > num.length) {
          a2 = this;
          b3 = num;
        } else {
          a2 = num;
          b3 = this;
        }
        var carry = 0;
        for (var i2 = 0; i2 < b3.length; i2++) {
          r = (a2.words[i2] | 0) + (b3.words[i2] | 0) + carry;
          this.words[i2] = r & 67108863;
          carry = r >>> 26;
        }
        for (; carry !== 0 && i2 < a2.length; i2++) {
          r = (a2.words[i2] | 0) + carry;
          this.words[i2] = r & 67108863;
          carry = r >>> 26;
        }
        this.length = a2.length;
        if (carry !== 0) {
          this.words[this.length] = carry;
          this.length++;
        } else if (a2 !== this) {
          for (; i2 < a2.length; i2++) {
            this.words[i2] = a2.words[i2];
          }
        }
        return this;
      };
      BN.prototype.add = function add(num) {
        var res;
        if (num.negative !== 0 && this.negative === 0) {
          num.negative = 0;
          res = this.sub(num);
          num.negative ^= 1;
          return res;
        } else if (num.negative === 0 && this.negative !== 0) {
          this.negative = 0;
          res = num.sub(this);
          this.negative = 1;
          return res;
        }
        if (this.length > num.length)
          return this.clone().iadd(num);
        return num.clone().iadd(this);
      };
      BN.prototype.isub = function isub(num) {
        if (num.negative !== 0) {
          num.negative = 0;
          var r = this.iadd(num);
          num.negative = 1;
          return r._normSign();
        } else if (this.negative !== 0) {
          this.negative = 0;
          this.iadd(num);
          this.negative = 1;
          return this._normSign();
        }
        var cmp = this.cmp(num);
        if (cmp === 0) {
          this.negative = 0;
          this.length = 1;
          this.words[0] = 0;
          return this;
        }
        var a2, b3;
        if (cmp > 0) {
          a2 = this;
          b3 = num;
        } else {
          a2 = num;
          b3 = this;
        }
        var carry = 0;
        for (var i2 = 0; i2 < b3.length; i2++) {
          r = (a2.words[i2] | 0) - (b3.words[i2] | 0) + carry;
          carry = r >> 26;
          this.words[i2] = r & 67108863;
        }
        for (; carry !== 0 && i2 < a2.length; i2++) {
          r = (a2.words[i2] | 0) + carry;
          carry = r >> 26;
          this.words[i2] = r & 67108863;
        }
        if (carry === 0 && i2 < a2.length && a2 !== this) {
          for (; i2 < a2.length; i2++) {
            this.words[i2] = a2.words[i2];
          }
        }
        this.length = Math.max(this.length, i2);
        if (a2 !== this) {
          this.negative = 1;
        }
        return this.strip();
      };
      BN.prototype.sub = function sub(num) {
        return this.clone().isub(num);
      };
      function smallMulTo(self2, num, out) {
        out.negative = num.negative ^ self2.negative;
        var len = self2.length + num.length | 0;
        out.length = len;
        len = len - 1 | 0;
        var a2 = self2.words[0] | 0;
        var b3 = num.words[0] | 0;
        var r = a2 * b3;
        var lo = r & 67108863;
        var carry = r / 67108864 | 0;
        out.words[0] = lo;
        for (var k2 = 1; k2 < len; k2++) {
          var ncarry = carry >>> 26;
          var rword = carry & 67108863;
          var maxJ = Math.min(k2, num.length - 1);
          for (var j2 = Math.max(0, k2 - self2.length + 1); j2 <= maxJ; j2++) {
            var i2 = k2 - j2 | 0;
            a2 = self2.words[i2] | 0;
            b3 = num.words[j2] | 0;
            r = a2 * b3 + rword;
            ncarry += r / 67108864 | 0;
            rword = r & 67108863;
          }
          out.words[k2] = rword | 0;
          carry = ncarry | 0;
        }
        if (carry !== 0) {
          out.words[k2] = carry | 0;
        } else {
          out.length--;
        }
        return out.strip();
      }
      var comb10MulTo = function comb10MulTo2(self2, num, out) {
        var a2 = self2.words;
        var b3 = num.words;
        var o = out.words;
        var c2 = 0;
        var lo;
        var mid;
        var hi;
        var a0 = a2[0] | 0;
        var al0 = a0 & 8191;
        var ah0 = a0 >>> 13;
        var a1 = a2[1] | 0;
        var al1 = a1 & 8191;
        var ah1 = a1 >>> 13;
        var a22 = a2[2] | 0;
        var al2 = a22 & 8191;
        var ah2 = a22 >>> 13;
        var a3 = a2[3] | 0;
        var al3 = a3 & 8191;
        var ah3 = a3 >>> 13;
        var a4 = a2[4] | 0;
        var al4 = a4 & 8191;
        var ah4 = a4 >>> 13;
        var a5 = a2[5] | 0;
        var al5 = a5 & 8191;
        var ah5 = a5 >>> 13;
        var a6 = a2[6] | 0;
        var al6 = a6 & 8191;
        var ah6 = a6 >>> 13;
        var a7 = a2[7] | 0;
        var al7 = a7 & 8191;
        var ah7 = a7 >>> 13;
        var a8 = a2[8] | 0;
        var al8 = a8 & 8191;
        var ah8 = a8 >>> 13;
        var a9 = a2[9] | 0;
        var al9 = a9 & 8191;
        var ah9 = a9 >>> 13;
        var b0 = b3[0] | 0;
        var bl0 = b0 & 8191;
        var bh0 = b0 >>> 13;
        var b1 = b3[1] | 0;
        var bl1 = b1 & 8191;
        var bh1 = b1 >>> 13;
        var b22 = b3[2] | 0;
        var bl2 = b22 & 8191;
        var bh2 = b22 >>> 13;
        var b32 = b3[3] | 0;
        var bl3 = b32 & 8191;
        var bh3 = b32 >>> 13;
        var b4 = b3[4] | 0;
        var bl4 = b4 & 8191;
        var bh4 = b4 >>> 13;
        var b5 = b3[5] | 0;
        var bl5 = b5 & 8191;
        var bh5 = b5 >>> 13;
        var b6 = b3[6] | 0;
        var bl6 = b6 & 8191;
        var bh6 = b6 >>> 13;
        var b7 = b3[7] | 0;
        var bl7 = b7 & 8191;
        var bh7 = b7 >>> 13;
        var b8 = b3[8] | 0;
        var bl8 = b8 & 8191;
        var bh8 = b8 >>> 13;
        var b9 = b3[9] | 0;
        var bl9 = b9 & 8191;
        var bh9 = b9 >>> 13;
        out.negative = self2.negative ^ num.negative;
        out.length = 19;
        lo = Math.imul(al0, bl0);
        mid = Math.imul(al0, bh0);
        mid = mid + Math.imul(ah0, bl0) | 0;
        hi = Math.imul(ah0, bh0);
        var w0 = (c2 + lo | 0) + ((mid & 8191) << 13) | 0;
        c2 = (hi + (mid >>> 13) | 0) + (w0 >>> 26) | 0;
        w0 &= 67108863;
        lo = Math.imul(al1, bl0);
        mid = Math.imul(al1, bh0);
        mid = mid + Math.imul(ah1, bl0) | 0;
        hi = Math.imul(ah1, bh0);
        lo = lo + Math.imul(al0, bl1) | 0;
        mid = mid + Math.imul(al0, bh1) | 0;
        mid = mid + Math.imul(ah0, bl1) | 0;
        hi = hi + Math.imul(ah0, bh1) | 0;
        var w1 = (c2 + lo | 0) + ((mid & 8191) << 13) | 0;
        c2 = (hi + (mid >>> 13) | 0) + (w1 >>> 26) | 0;
        w1 &= 67108863;
        lo = Math.imul(al2, bl0);
        mid = Math.imul(al2, bh0);
        mid = mid + Math.imul(ah2, bl0) | 0;
        hi = Math.imul(ah2, bh0);
        lo = lo + Math.imul(al1, bl1) | 0;
        mid = mid + Math.imul(al1, bh1) | 0;
        mid = mid + Math.imul(ah1, bl1) | 0;
        hi = hi + Math.imul(ah1, bh1) | 0;
        lo = lo + Math.imul(al0, bl2) | 0;
        mid = mid + Math.imul(al0, bh2) | 0;
        mid = mid + Math.imul(ah0, bl2) | 0;
        hi = hi + Math.imul(ah0, bh2) | 0;
        var w22 = (c2 + lo | 0) + ((mid & 8191) << 13) | 0;
        c2 = (hi + (mid >>> 13) | 0) + (w22 >>> 26) | 0;
        w22 &= 67108863;
        lo = Math.imul(al3, bl0);
        mid = Math.imul(al3, bh0);
        mid = mid + Math.imul(ah3, bl0) | 0;
        hi = Math.imul(ah3, bh0);
        lo = lo + Math.imul(al2, bl1) | 0;
        mid = mid + Math.imul(al2, bh1) | 0;
        mid = mid + Math.imul(ah2, bl1) | 0;
        hi = hi + Math.imul(ah2, bh1) | 0;
        lo = lo + Math.imul(al1, bl2) | 0;
        mid = mid + Math.imul(al1, bh2) | 0;
        mid = mid + Math.imul(ah1, bl2) | 0;
        hi = hi + Math.imul(ah1, bh2) | 0;
        lo = lo + Math.imul(al0, bl3) | 0;
        mid = mid + Math.imul(al0, bh3) | 0;
        mid = mid + Math.imul(ah0, bl3) | 0;
        hi = hi + Math.imul(ah0, bh3) | 0;
        var w3 = (c2 + lo | 0) + ((mid & 8191) << 13) | 0;
        c2 = (hi + (mid >>> 13) | 0) + (w3 >>> 26) | 0;
        w3 &= 67108863;
        lo = Math.imul(al4, bl0);
        mid = Math.imul(al4, bh0);
        mid = mid + Math.imul(ah4, bl0) | 0;
        hi = Math.imul(ah4, bh0);
        lo = lo + Math.imul(al3, bl1) | 0;
        mid = mid + Math.imul(al3, bh1) | 0;
        mid = mid + Math.imul(ah3, bl1) | 0;
        hi = hi + Math.imul(ah3, bh1) | 0;
        lo = lo + Math.imul(al2, bl2) | 0;
        mid = mid + Math.imul(al2, bh2) | 0;
        mid = mid + Math.imul(ah2, bl2) | 0;
        hi = hi + Math.imul(ah2, bh2) | 0;
        lo = lo + Math.imul(al1, bl3) | 0;
        mid = mid + Math.imul(al1, bh3) | 0;
        mid = mid + Math.imul(ah1, bl3) | 0;
        hi = hi + Math.imul(ah1, bh3) | 0;
        lo = lo + Math.imul(al0, bl4) | 0;
        mid = mid + Math.imul(al0, bh4) | 0;
        mid = mid + Math.imul(ah0, bl4) | 0;
        hi = hi + Math.imul(ah0, bh4) | 0;
        var w4 = (c2 + lo | 0) + ((mid & 8191) << 13) | 0;
        c2 = (hi + (mid >>> 13) | 0) + (w4 >>> 26) | 0;
        w4 &= 67108863;
        lo = Math.imul(al5, bl0);
        mid = Math.imul(al5, bh0);
        mid = mid + Math.imul(ah5, bl0) | 0;
        hi = Math.imul(ah5, bh0);
        lo = lo + Math.imul(al4, bl1) | 0;
        mid = mid + Math.imul(al4, bh1) | 0;
        mid = mid + Math.imul(ah4, bl1) | 0;
        hi = hi + Math.imul(ah4, bh1) | 0;
        lo = lo + Math.imul(al3, bl2) | 0;
        mid = mid + Math.imul(al3, bh2) | 0;
        mid = mid + Math.imul(ah3, bl2) | 0;
        hi = hi + Math.imul(ah3, bh2) | 0;
        lo = lo + Math.imul(al2, bl3) | 0;
        mid = mid + Math.imul(al2, bh3) | 0;
        mid = mid + Math.imul(ah2, bl3) | 0;
        hi = hi + Math.imul(ah2, bh3) | 0;
        lo = lo + Math.imul(al1, bl4) | 0;
        mid = mid + Math.imul(al1, bh4) | 0;
        mid = mid + Math.imul(ah1, bl4) | 0;
        hi = hi + Math.imul(ah1, bh4) | 0;
        lo = lo + Math.imul(al0, bl5) | 0;
        mid = mid + Math.imul(al0, bh5) | 0;
        mid = mid + Math.imul(ah0, bl5) | 0;
        hi = hi + Math.imul(ah0, bh5) | 0;
        var w5 = (c2 + lo | 0) + ((mid & 8191) << 13) | 0;
        c2 = (hi + (mid >>> 13) | 0) + (w5 >>> 26) | 0;
        w5 &= 67108863;
        lo = Math.imul(al6, bl0);
        mid = Math.imul(al6, bh0);
        mid = mid + Math.imul(ah6, bl0) | 0;
        hi = Math.imul(ah6, bh0);
        lo = lo + Math.imul(al5, bl1) | 0;
        mid = mid + Math.imul(al5, bh1) | 0;
        mid = mid + Math.imul(ah5, bl1) | 0;
        hi = hi + Math.imul(ah5, bh1) | 0;
        lo = lo + Math.imul(al4, bl2) | 0;
        mid = mid + Math.imul(al4, bh2) | 0;
        mid = mid + Math.imul(ah4, bl2) | 0;
        hi = hi + Math.imul(ah4, bh2) | 0;
        lo = lo + Math.imul(al3, bl3) | 0;
        mid = mid + Math.imul(al3, bh3) | 0;
        mid = mid + Math.imul(ah3, bl3) | 0;
        hi = hi + Math.imul(ah3, bh3) | 0;
        lo = lo + Math.imul(al2, bl4) | 0;
        mid = mid + Math.imul(al2, bh4) | 0;
        mid = mid + Math.imul(ah2, bl4) | 0;
        hi = hi + Math.imul(ah2, bh4) | 0;
        lo = lo + Math.imul(al1, bl5) | 0;
        mid = mid + Math.imul(al1, bh5) | 0;
        mid = mid + Math.imul(ah1, bl5) | 0;
        hi = hi + Math.imul(ah1, bh5) | 0;
        lo = lo + Math.imul(al0, bl6) | 0;
        mid = mid + Math.imul(al0, bh6) | 0;
        mid = mid + Math.imul(ah0, bl6) | 0;
        hi = hi + Math.imul(ah0, bh6) | 0;
        var w6 = (c2 + lo | 0) + ((mid & 8191) << 13) | 0;
        c2 = (hi + (mid >>> 13) | 0) + (w6 >>> 26) | 0;
        w6 &= 67108863;
        lo = Math.imul(al7, bl0);
        mid = Math.imul(al7, bh0);
        mid = mid + Math.imul(ah7, bl0) | 0;
        hi = Math.imul(ah7, bh0);
        lo = lo + Math.imul(al6, bl1) | 0;
        mid = mid + Math.imul(al6, bh1) | 0;
        mid = mid + Math.imul(ah6, bl1) | 0;
        hi = hi + Math.imul(ah6, bh1) | 0;
        lo = lo + Math.imul(al5, bl2) | 0;
        mid = mid + Math.imul(al5, bh2) | 0;
        mid = mid + Math.imul(ah5, bl2) | 0;
        hi = hi + Math.imul(ah5, bh2) | 0;
        lo = lo + Math.imul(al4, bl3) | 0;
        mid = mid + Math.imul(al4, bh3) | 0;
        mid = mid + Math.imul(ah4, bl3) | 0;
        hi = hi + Math.imul(ah4, bh3) | 0;
        lo = lo + Math.imul(al3, bl4) | 0;
        mid = mid + Math.imul(al3, bh4) | 0;
        mid = mid + Math.imul(ah3, bl4) | 0;
        hi = hi + Math.imul(ah3, bh4) | 0;
        lo = lo + Math.imul(al2, bl5) | 0;
        mid = mid + Math.imul(al2, bh5) | 0;
        mid = mid + Math.imul(ah2, bl5) | 0;
        hi = hi + Math.imul(ah2, bh5) | 0;
        lo = lo + Math.imul(al1, bl6) | 0;
        mid = mid + Math.imul(al1, bh6) | 0;
        mid = mid + Math.imul(ah1, bl6) | 0;
        hi = hi + Math.imul(ah1, bh6) | 0;
        lo = lo + Math.imul(al0, bl7) | 0;
        mid = mid + Math.imul(al0, bh7) | 0;
        mid = mid + Math.imul(ah0, bl7) | 0;
        hi = hi + Math.imul(ah0, bh7) | 0;
        var w7 = (c2 + lo | 0) + ((mid & 8191) << 13) | 0;
        c2 = (hi + (mid >>> 13) | 0) + (w7 >>> 26) | 0;
        w7 &= 67108863;
        lo = Math.imul(al8, bl0);
        mid = Math.imul(al8, bh0);
        mid = mid + Math.imul(ah8, bl0) | 0;
        hi = Math.imul(ah8, bh0);
        lo = lo + Math.imul(al7, bl1) | 0;
        mid = mid + Math.imul(al7, bh1) | 0;
        mid = mid + Math.imul(ah7, bl1) | 0;
        hi = hi + Math.imul(ah7, bh1) | 0;
        lo = lo + Math.imul(al6, bl2) | 0;
        mid = mid + Math.imul(al6, bh2) | 0;
        mid = mid + Math.imul(ah6, bl2) | 0;
        hi = hi + Math.imul(ah6, bh2) | 0;
        lo = lo + Math.imul(al5, bl3) | 0;
        mid = mid + Math.imul(al5, bh3) | 0;
        mid = mid + Math.imul(ah5, bl3) | 0;
        hi = hi + Math.imul(ah5, bh3) | 0;
        lo = lo + Math.imul(al4, bl4) | 0;
        mid = mid + Math.imul(al4, bh4) | 0;
        mid = mid + Math.imul(ah4, bl4) | 0;
        hi = hi + Math.imul(ah4, bh4) | 0;
        lo = lo + Math.imul(al3, bl5) | 0;
        mid = mid + Math.imul(al3, bh5) | 0;
        mid = mid + Math.imul(ah3, bl5) | 0;
        hi = hi + Math.imul(ah3, bh5) | 0;
        lo = lo + Math.imul(al2, bl6) | 0;
        mid = mid + Math.imul(al2, bh6) | 0;
        mid = mid + Math.imul(ah2, bl6) | 0;
        hi = hi + Math.imul(ah2, bh6) | 0;
        lo = lo + Math.imul(al1, bl7) | 0;
        mid = mid + Math.imul(al1, bh7) | 0;
        mid = mid + Math.imul(ah1, bl7) | 0;
        hi = hi + Math.imul(ah1, bh7) | 0;
        lo = lo + Math.imul(al0, bl8) | 0;
        mid = mid + Math.imul(al0, bh8) | 0;
        mid = mid + Math.imul(ah0, bl8) | 0;
        hi = hi + Math.imul(ah0, bh8) | 0;
        var w8 = (c2 + lo | 0) + ((mid & 8191) << 13) | 0;
        c2 = (hi + (mid >>> 13) | 0) + (w8 >>> 26) | 0;
        w8 &= 67108863;
        lo = Math.imul(al9, bl0);
        mid = Math.imul(al9, bh0);
        mid = mid + Math.imul(ah9, bl0) | 0;
        hi = Math.imul(ah9, bh0);
        lo = lo + Math.imul(al8, bl1) | 0;
        mid = mid + Math.imul(al8, bh1) | 0;
        mid = mid + Math.imul(ah8, bl1) | 0;
        hi = hi + Math.imul(ah8, bh1) | 0;
        lo = lo + Math.imul(al7, bl2) | 0;
        mid = mid + Math.imul(al7, bh2) | 0;
        mid = mid + Math.imul(ah7, bl2) | 0;
        hi = hi + Math.imul(ah7, bh2) | 0;
        lo = lo + Math.imul(al6, bl3) | 0;
        mid = mid + Math.imul(al6, bh3) | 0;
        mid = mid + Math.imul(ah6, bl3) | 0;
        hi = hi + Math.imul(ah6, bh3) | 0;
        lo = lo + Math.imul(al5, bl4) | 0;
        mid = mid + Math.imul(al5, bh4) | 0;
        mid = mid + Math.imul(ah5, bl4) | 0;
        hi = hi + Math.imul(ah5, bh4) | 0;
        lo = lo + Math.imul(al4, bl5) | 0;
        mid = mid + Math.imul(al4, bh5) | 0;
        mid = mid + Math.imul(ah4, bl5) | 0;
        hi = hi + Math.imul(ah4, bh5) | 0;
        lo = lo + Math.imul(al3, bl6) | 0;
        mid = mid + Math.imul(al3, bh6) | 0;
        mid = mid + Math.imul(ah3, bl6) | 0;
        hi = hi + Math.imul(ah3, bh6) | 0;
        lo = lo + Math.imul(al2, bl7) | 0;
        mid = mid + Math.imul(al2, bh7) | 0;
        mid = mid + Math.imul(ah2, bl7) | 0;
        hi = hi + Math.imul(ah2, bh7) | 0;
        lo = lo + Math.imul(al1, bl8) | 0;
        mid = mid + Math.imul(al1, bh8) | 0;
        mid = mid + Math.imul(ah1, bl8) | 0;
        hi = hi + Math.imul(ah1, bh8) | 0;
        lo = lo + Math.imul(al0, bl9) | 0;
        mid = mid + Math.imul(al0, bh9) | 0;
        mid = mid + Math.imul(ah0, bl9) | 0;
        hi = hi + Math.imul(ah0, bh9) | 0;
        var w9 = (c2 + lo | 0) + ((mid & 8191) << 13) | 0;
        c2 = (hi + (mid >>> 13) | 0) + (w9 >>> 26) | 0;
        w9 &= 67108863;
        lo = Math.imul(al9, bl1);
        mid = Math.imul(al9, bh1);
        mid = mid + Math.imul(ah9, bl1) | 0;
        hi = Math.imul(ah9, bh1);
        lo = lo + Math.imul(al8, bl2) | 0;
        mid = mid + Math.imul(al8, bh2) | 0;
        mid = mid + Math.imul(ah8, bl2) | 0;
        hi = hi + Math.imul(ah8, bh2) | 0;
        lo = lo + Math.imul(al7, bl3) | 0;
        mid = mid + Math.imul(al7, bh3) | 0;
        mid = mid + Math.imul(ah7, bl3) | 0;
        hi = hi + Math.imul(ah7, bh3) | 0;
        lo = lo + Math.imul(al6, bl4) | 0;
        mid = mid + Math.imul(al6, bh4) | 0;
        mid = mid + Math.imul(ah6, bl4) | 0;
        hi = hi + Math.imul(ah6, bh4) | 0;
        lo = lo + Math.imul(al5, bl5) | 0;
        mid = mid + Math.imul(al5, bh5) | 0;
        mid = mid + Math.imul(ah5, bl5) | 0;
        hi = hi + Math.imul(ah5, bh5) | 0;
        lo = lo + Math.imul(al4, bl6) | 0;
        mid = mid + Math.imul(al4, bh6) | 0;
        mid = mid + Math.imul(ah4, bl6) | 0;
        hi = hi + Math.imul(ah4, bh6) | 0;
        lo = lo + Math.imul(al3, bl7) | 0;
        mid = mid + Math.imul(al3, bh7) | 0;
        mid = mid + Math.imul(ah3, bl7) | 0;
        hi = hi + Math.imul(ah3, bh7) | 0;
        lo = lo + Math.imul(al2, bl8) | 0;
        mid = mid + Math.imul(al2, bh8) | 0;
        mid = mid + Math.imul(ah2, bl8) | 0;
        hi = hi + Math.imul(ah2, bh8) | 0;
        lo = lo + Math.imul(al1, bl9) | 0;
        mid = mid + Math.imul(al1, bh9) | 0;
        mid = mid + Math.imul(ah1, bl9) | 0;
        hi = hi + Math.imul(ah1, bh9) | 0;
        var w10 = (c2 + lo | 0) + ((mid & 8191) << 13) | 0;
        c2 = (hi + (mid >>> 13) | 0) + (w10 >>> 26) | 0;
        w10 &= 67108863;
        lo = Math.imul(al9, bl2);
        mid = Math.imul(al9, bh2);
        mid = mid + Math.imul(ah9, bl2) | 0;
        hi = Math.imul(ah9, bh2);
        lo = lo + Math.imul(al8, bl3) | 0;
        mid = mid + Math.imul(al8, bh3) | 0;
        mid = mid + Math.imul(ah8, bl3) | 0;
        hi = hi + Math.imul(ah8, bh3) | 0;
        lo = lo + Math.imul(al7, bl4) | 0;
        mid = mid + Math.imul(al7, bh4) | 0;
        mid = mid + Math.imul(ah7, bl4) | 0;
        hi = hi + Math.imul(ah7, bh4) | 0;
        lo = lo + Math.imul(al6, bl5) | 0;
        mid = mid + Math.imul(al6, bh5) | 0;
        mid = mid + Math.imul(ah6, bl5) | 0;
        hi = hi + Math.imul(ah6, bh5) | 0;
        lo = lo + Math.imul(al5, bl6) | 0;
        mid = mid + Math.imul(al5, bh6) | 0;
        mid = mid + Math.imul(ah5, bl6) | 0;
        hi = hi + Math.imul(ah5, bh6) | 0;
        lo = lo + Math.imul(al4, bl7) | 0;
        mid = mid + Math.imul(al4, bh7) | 0;
        mid = mid + Math.imul(ah4, bl7) | 0;
        hi = hi + Math.imul(ah4, bh7) | 0;
        lo = lo + Math.imul(al3, bl8) | 0;
        mid = mid + Math.imul(al3, bh8) | 0;
        mid = mid + Math.imul(ah3, bl8) | 0;
        hi = hi + Math.imul(ah3, bh8) | 0;
        lo = lo + Math.imul(al2, bl9) | 0;
        mid = mid + Math.imul(al2, bh9) | 0;
        mid = mid + Math.imul(ah2, bl9) | 0;
        hi = hi + Math.imul(ah2, bh9) | 0;
        var w11 = (c2 + lo | 0) + ((mid & 8191) << 13) | 0;
        c2 = (hi + (mid >>> 13) | 0) + (w11 >>> 26) | 0;
        w11 &= 67108863;
        lo = Math.imul(al9, bl3);
        mid = Math.imul(al9, bh3);
        mid = mid + Math.imul(ah9, bl3) | 0;
        hi = Math.imul(ah9, bh3);
        lo = lo + Math.imul(al8, bl4) | 0;
        mid = mid + Math.imul(al8, bh4) | 0;
        mid = mid + Math.imul(ah8, bl4) | 0;
        hi = hi + Math.imul(ah8, bh4) | 0;
        lo = lo + Math.imul(al7, bl5) | 0;
        mid = mid + Math.imul(al7, bh5) | 0;
        mid = mid + Math.imul(ah7, bl5) | 0;
        hi = hi + Math.imul(ah7, bh5) | 0;
        lo = lo + Math.imul(al6, bl6) | 0;
        mid = mid + Math.imul(al6, bh6) | 0;
        mid = mid + Math.imul(ah6, bl6) | 0;
        hi = hi + Math.imul(ah6, bh6) | 0;
        lo = lo + Math.imul(al5, bl7) | 0;
        mid = mid + Math.imul(al5, bh7) | 0;
        mid = mid + Math.imul(ah5, bl7) | 0;
        hi = hi + Math.imul(ah5, bh7) | 0;
        lo = lo + Math.imul(al4, bl8) | 0;
        mid = mid + Math.imul(al4, bh8) | 0;
        mid = mid + Math.imul(ah4, bl8) | 0;
        hi = hi + Math.imul(ah4, bh8) | 0;
        lo = lo + Math.imul(al3, bl9) | 0;
        mid = mid + Math.imul(al3, bh9) | 0;
        mid = mid + Math.imul(ah3, bl9) | 0;
        hi = hi + Math.imul(ah3, bh9) | 0;
        var w12 = (c2 + lo | 0) + ((mid & 8191) << 13) | 0;
        c2 = (hi + (mid >>> 13) | 0) + (w12 >>> 26) | 0;
        w12 &= 67108863;
        lo = Math.imul(al9, bl4);
        mid = Math.imul(al9, bh4);
        mid = mid + Math.imul(ah9, bl4) | 0;
        hi = Math.imul(ah9, bh4);
        lo = lo + Math.imul(al8, bl5) | 0;
        mid = mid + Math.imul(al8, bh5) | 0;
        mid = mid + Math.imul(ah8, bl5) | 0;
        hi = hi + Math.imul(ah8, bh5) | 0;
        lo = lo + Math.imul(al7, bl6) | 0;
        mid = mid + Math.imul(al7, bh6) | 0;
        mid = mid + Math.imul(ah7, bl6) | 0;
        hi = hi + Math.imul(ah7, bh6) | 0;
        lo = lo + Math.imul(al6, bl7) | 0;
        mid = mid + Math.imul(al6, bh7) | 0;
        mid = mid + Math.imul(ah6, bl7) | 0;
        hi = hi + Math.imul(ah6, bh7) | 0;
        lo = lo + Math.imul(al5, bl8) | 0;
        mid = mid + Math.imul(al5, bh8) | 0;
        mid = mid + Math.imul(ah5, bl8) | 0;
        hi = hi + Math.imul(ah5, bh8) | 0;
        lo = lo + Math.imul(al4, bl9) | 0;
        mid = mid + Math.imul(al4, bh9) | 0;
        mid = mid + Math.imul(ah4, bl9) | 0;
        hi = hi + Math.imul(ah4, bh9) | 0;
        var w13 = (c2 + lo | 0) + ((mid & 8191) << 13) | 0;
        c2 = (hi + (mid >>> 13) | 0) + (w13 >>> 26) | 0;
        w13 &= 67108863;
        lo = Math.imul(al9, bl5);
        mid = Math.imul(al9, bh5);
        mid = mid + Math.imul(ah9, bl5) | 0;
        hi = Math.imul(ah9, bh5);
        lo = lo + Math.imul(al8, bl6) | 0;
        mid = mid + Math.imul(al8, bh6) | 0;
        mid = mid + Math.imul(ah8, bl6) | 0;
        hi = hi + Math.imul(ah8, bh6) | 0;
        lo = lo + Math.imul(al7, bl7) | 0;
        mid = mid + Math.imul(al7, bh7) | 0;
        mid = mid + Math.imul(ah7, bl7) | 0;
        hi = hi + Math.imul(ah7, bh7) | 0;
        lo = lo + Math.imul(al6, bl8) | 0;
        mid = mid + Math.imul(al6, bh8) | 0;
        mid = mid + Math.imul(ah6, bl8) | 0;
        hi = hi + Math.imul(ah6, bh8) | 0;
        lo = lo + Math.imul(al5, bl9) | 0;
        mid = mid + Math.imul(al5, bh9) | 0;
        mid = mid + Math.imul(ah5, bl9) | 0;
        hi = hi + Math.imul(ah5, bh9) | 0;
        var w14 = (c2 + lo | 0) + ((mid & 8191) << 13) | 0;
        c2 = (hi + (mid >>> 13) | 0) + (w14 >>> 26) | 0;
        w14 &= 67108863;
        lo = Math.imul(al9, bl6);
        mid = Math.imul(al9, bh6);
        mid = mid + Math.imul(ah9, bl6) | 0;
        hi = Math.imul(ah9, bh6);
        lo = lo + Math.imul(al8, bl7) | 0;
        mid = mid + Math.imul(al8, bh7) | 0;
        mid = mid + Math.imul(ah8, bl7) | 0;
        hi = hi + Math.imul(ah8, bh7) | 0;
        lo = lo + Math.imul(al7, bl8) | 0;
        mid = mid + Math.imul(al7, bh8) | 0;
        mid = mid + Math.imul(ah7, bl8) | 0;
        hi = hi + Math.imul(ah7, bh8) | 0;
        lo = lo + Math.imul(al6, bl9) | 0;
        mid = mid + Math.imul(al6, bh9) | 0;
        mid = mid + Math.imul(ah6, bl9) | 0;
        hi = hi + Math.imul(ah6, bh9) | 0;
        var w15 = (c2 + lo | 0) + ((mid & 8191) << 13) | 0;
        c2 = (hi + (mid >>> 13) | 0) + (w15 >>> 26) | 0;
        w15 &= 67108863;
        lo = Math.imul(al9, bl7);
        mid = Math.imul(al9, bh7);
        mid = mid + Math.imul(ah9, bl7) | 0;
        hi = Math.imul(ah9, bh7);
        lo = lo + Math.imul(al8, bl8) | 0;
        mid = mid + Math.imul(al8, bh8) | 0;
        mid = mid + Math.imul(ah8, bl8) | 0;
        hi = hi + Math.imul(ah8, bh8) | 0;
        lo = lo + Math.imul(al7, bl9) | 0;
        mid = mid + Math.imul(al7, bh9) | 0;
        mid = mid + Math.imul(ah7, bl9) | 0;
        hi = hi + Math.imul(ah7, bh9) | 0;
        var w16 = (c2 + lo | 0) + ((mid & 8191) << 13) | 0;
        c2 = (hi + (mid >>> 13) | 0) + (w16 >>> 26) | 0;
        w16 &= 67108863;
        lo = Math.imul(al9, bl8);
        mid = Math.imul(al9, bh8);
        mid = mid + Math.imul(ah9, bl8) | 0;
        hi = Math.imul(ah9, bh8);
        lo = lo + Math.imul(al8, bl9) | 0;
        mid = mid + Math.imul(al8, bh9) | 0;
        mid = mid + Math.imul(ah8, bl9) | 0;
        hi = hi + Math.imul(ah8, bh9) | 0;
        var w17 = (c2 + lo | 0) + ((mid & 8191) << 13) | 0;
        c2 = (hi + (mid >>> 13) | 0) + (w17 >>> 26) | 0;
        w17 &= 67108863;
        lo = Math.imul(al9, bl9);
        mid = Math.imul(al9, bh9);
        mid = mid + Math.imul(ah9, bl9) | 0;
        hi = Math.imul(ah9, bh9);
        var w18 = (c2 + lo | 0) + ((mid & 8191) << 13) | 0;
        c2 = (hi + (mid >>> 13) | 0) + (w18 >>> 26) | 0;
        w18 &= 67108863;
        o[0] = w0;
        o[1] = w1;
        o[2] = w22;
        o[3] = w3;
        o[4] = w4;
        o[5] = w5;
        o[6] = w6;
        o[7] = w7;
        o[8] = w8;
        o[9] = w9;
        o[10] = w10;
        o[11] = w11;
        o[12] = w12;
        o[13] = w13;
        o[14] = w14;
        o[15] = w15;
        o[16] = w16;
        o[17] = w17;
        o[18] = w18;
        if (c2 !== 0) {
          o[19] = c2;
          out.length++;
        }
        return out;
      };
      if (!Math.imul) {
        comb10MulTo = smallMulTo;
      }
      function bigMulTo(self2, num, out) {
        out.negative = num.negative ^ self2.negative;
        out.length = self2.length + num.length;
        var carry = 0;
        var hncarry = 0;
        for (var k2 = 0; k2 < out.length - 1; k2++) {
          var ncarry = hncarry;
          hncarry = 0;
          var rword = carry & 67108863;
          var maxJ = Math.min(k2, num.length - 1);
          for (var j2 = Math.max(0, k2 - self2.length + 1); j2 <= maxJ; j2++) {
            var i2 = k2 - j2;
            var a2 = self2.words[i2] | 0;
            var b3 = num.words[j2] | 0;
            var r = a2 * b3;
            var lo = r & 67108863;
            ncarry = ncarry + (r / 67108864 | 0) | 0;
            lo = lo + rword | 0;
            rword = lo & 67108863;
            ncarry = ncarry + (lo >>> 26) | 0;
            hncarry += ncarry >>> 26;
            ncarry &= 67108863;
          }
          out.words[k2] = rword;
          carry = ncarry;
          ncarry = hncarry;
        }
        if (carry !== 0) {
          out.words[k2] = carry;
        } else {
          out.length--;
        }
        return out.strip();
      }
      function jumboMulTo(self2, num, out) {
        var fftm = new FFTM();
        return fftm.mulp(self2, num, out);
      }
      BN.prototype.mulTo = function mulTo(num, out) {
        var res;
        var len = this.length + num.length;
        if (this.length === 10 && num.length === 10) {
          res = comb10MulTo(this, num, out);
        } else if (len < 63) {
          res = smallMulTo(this, num, out);
        } else if (len < 1024) {
          res = bigMulTo(this, num, out);
        } else {
          res = jumboMulTo(this, num, out);
        }
        return res;
      };
      function FFTM(x3, y3) {
        this.x = x3;
        this.y = y3;
      }
      FFTM.prototype.makeRBT = function makeRBT(N3) {
        var t = new Array(N3);
        var l = BN.prototype._countBits(N3) - 1;
        for (var i2 = 0; i2 < N3; i2++) {
          t[i2] = this.revBin(i2, l, N3);
        }
        return t;
      };
      FFTM.prototype.revBin = function revBin(x3, l, N3) {
        if (x3 === 0 || x3 === N3 - 1)
          return x3;
        var rb = 0;
        for (var i2 = 0; i2 < l; i2++) {
          rb |= (x3 & 1) << l - i2 - 1;
          x3 >>= 1;
        }
        return rb;
      };
      FFTM.prototype.permute = function permute(rbt, rws, iws, rtws, itws, N3) {
        for (var i2 = 0; i2 < N3; i2++) {
          rtws[i2] = rws[rbt[i2]];
          itws[i2] = iws[rbt[i2]];
        }
      };
      FFTM.prototype.transform = function transform(rws, iws, rtws, itws, N3, rbt) {
        this.permute(rbt, rws, iws, rtws, itws, N3);
        for (var s = 1; s < N3; s <<= 1) {
          var l = s << 1;
          var rtwdf = Math.cos(2 * Math.PI / l);
          var itwdf = Math.sin(2 * Math.PI / l);
          for (var p3 = 0; p3 < N3; p3 += l) {
            var rtwdf_ = rtwdf;
            var itwdf_ = itwdf;
            for (var j2 = 0; j2 < s; j2++) {
              var re2 = rtws[p3 + j2];
              var ie3 = itws[p3 + j2];
              var ro = rtws[p3 + j2 + s];
              var io = itws[p3 + j2 + s];
              var rx = rtwdf_ * ro - itwdf_ * io;
              io = rtwdf_ * io + itwdf_ * ro;
              ro = rx;
              rtws[p3 + j2] = re2 + ro;
              itws[p3 + j2] = ie3 + io;
              rtws[p3 + j2 + s] = re2 - ro;
              itws[p3 + j2 + s] = ie3 - io;
              if (j2 !== l) {
                rx = rtwdf * rtwdf_ - itwdf * itwdf_;
                itwdf_ = rtwdf * itwdf_ + itwdf * rtwdf_;
                rtwdf_ = rx;
              }
            }
          }
        }
      };
      FFTM.prototype.guessLen13b = function guessLen13b(n2, m2) {
        var N3 = Math.max(m2, n2) | 1;
        var odd = N3 & 1;
        var i2 = 0;
        for (N3 = N3 / 2 | 0; N3; N3 = N3 >>> 1) {
          i2++;
        }
        return 1 << i2 + 1 + odd;
      };
      FFTM.prototype.conjugate = function conjugate(rws, iws, N3) {
        if (N3 <= 1)
          return;
        for (var i2 = 0; i2 < N3 / 2; i2++) {
          var t = rws[i2];
          rws[i2] = rws[N3 - i2 - 1];
          rws[N3 - i2 - 1] = t;
          t = iws[i2];
          iws[i2] = -iws[N3 - i2 - 1];
          iws[N3 - i2 - 1] = -t;
        }
      };
      FFTM.prototype.normalize13b = function normalize13b(ws2, N3) {
        var carry = 0;
        for (var i2 = 0; i2 < N3 / 2; i2++) {
          var w3 = Math.round(ws2[2 * i2 + 1] / N3) * 8192 + Math.round(ws2[2 * i2] / N3) + carry;
          ws2[i2] = w3 & 67108863;
          if (w3 < 67108864) {
            carry = 0;
          } else {
            carry = w3 / 67108864 | 0;
          }
        }
        return ws2;
      };
      FFTM.prototype.convert13b = function convert13b(ws2, len, rws, N3) {
        var carry = 0;
        for (var i2 = 0; i2 < len; i2++) {
          carry = carry + (ws2[i2] | 0);
          rws[2 * i2] = carry & 8191;
          carry = carry >>> 13;
          rws[2 * i2 + 1] = carry & 8191;
          carry = carry >>> 13;
        }
        for (i2 = 2 * len; i2 < N3; ++i2) {
          rws[i2] = 0;
        }
        assert(carry === 0);
        assert((carry & ~8191) === 0);
      };
      FFTM.prototype.stub = function stub(N3) {
        var ph = new Array(N3);
        for (var i2 = 0; i2 < N3; i2++) {
          ph[i2] = 0;
        }
        return ph;
      };
      FFTM.prototype.mulp = function mulp(x3, y3, out) {
        var N3 = 2 * this.guessLen13b(x3.length, y3.length);
        var rbt = this.makeRBT(N3);
        var _2 = this.stub(N3);
        var rws = new Array(N3);
        var rwst = new Array(N3);
        var iwst = new Array(N3);
        var nrws = new Array(N3);
        var nrwst = new Array(N3);
        var niwst = new Array(N3);
        var rmws = out.words;
        rmws.length = N3;
        this.convert13b(x3.words, x3.length, rws, N3);
        this.convert13b(y3.words, y3.length, nrws, N3);
        this.transform(rws, _2, rwst, iwst, N3, rbt);
        this.transform(nrws, _2, nrwst, niwst, N3, rbt);
        for (var i2 = 0; i2 < N3; i2++) {
          var rx = rwst[i2] * nrwst[i2] - iwst[i2] * niwst[i2];
          iwst[i2] = rwst[i2] * niwst[i2] + iwst[i2] * nrwst[i2];
          rwst[i2] = rx;
        }
        this.conjugate(rwst, iwst, N3);
        this.transform(rwst, iwst, rmws, _2, N3, rbt);
        this.conjugate(rmws, _2, N3);
        this.normalize13b(rmws, N3);
        out.negative = x3.negative ^ y3.negative;
        out.length = x3.length + y3.length;
        return out.strip();
      };
      BN.prototype.mul = function mul(num) {
        var out = new BN(null);
        out.words = new Array(this.length + num.length);
        return this.mulTo(num, out);
      };
      BN.prototype.mulf = function mulf(num) {
        var out = new BN(null);
        out.words = new Array(this.length + num.length);
        return jumboMulTo(this, num, out);
      };
      BN.prototype.imul = function imul(num) {
        return this.clone().mulTo(num, this);
      };
      BN.prototype.imuln = function imuln(num) {
        assert(typeof num === "number");
        assert(num < 67108864);
        var carry = 0;
        for (var i2 = 0; i2 < this.length; i2++) {
          var w3 = (this.words[i2] | 0) * num;
          var lo = (w3 & 67108863) + (carry & 67108863);
          carry >>= 26;
          carry += w3 / 67108864 | 0;
          carry += lo >>> 26;
          this.words[i2] = lo & 67108863;
        }
        if (carry !== 0) {
          this.words[i2] = carry;
          this.length++;
        }
        return this;
      };
      BN.prototype.muln = function muln(num) {
        return this.clone().imuln(num);
      };
      BN.prototype.sqr = function sqr() {
        return this.mul(this);
      };
      BN.prototype.isqr = function isqr() {
        return this.imul(this.clone());
      };
      BN.prototype.pow = function pow(num) {
        var w3 = toBitArray(num);
        if (w3.length === 0)
          return new BN(1);
        var res = this;
        for (var i2 = 0; i2 < w3.length; i2++, res = res.sqr()) {
          if (w3[i2] !== 0)
            break;
        }
        if (++i2 < w3.length) {
          for (var q3 = res.sqr(); i2 < w3.length; i2++, q3 = q3.sqr()) {
            if (w3[i2] === 0)
              continue;
            res = res.mul(q3);
          }
        }
        return res;
      };
      BN.prototype.iushln = function iushln(bits) {
        assert(typeof bits === "number" && bits >= 0);
        var r = bits % 26;
        var s = (bits - r) / 26;
        var carryMask = 67108863 >>> 26 - r << 26 - r;
        var i2;
        if (r !== 0) {
          var carry = 0;
          for (i2 = 0; i2 < this.length; i2++) {
            var newCarry = this.words[i2] & carryMask;
            var c2 = (this.words[i2] | 0) - newCarry << r;
            this.words[i2] = c2 | carry;
            carry = newCarry >>> 26 - r;
          }
          if (carry) {
            this.words[i2] = carry;
            this.length++;
          }
        }
        if (s !== 0) {
          for (i2 = this.length - 1; i2 >= 0; i2--) {
            this.words[i2 + s] = this.words[i2];
          }
          for (i2 = 0; i2 < s; i2++) {
            this.words[i2] = 0;
          }
          this.length += s;
        }
        return this.strip();
      };
      BN.prototype.ishln = function ishln(bits) {
        assert(this.negative === 0);
        return this.iushln(bits);
      };
      BN.prototype.iushrn = function iushrn(bits, hint, extended) {
        assert(typeof bits === "number" && bits >= 0);
        var h3;
        if (hint) {
          h3 = (hint - hint % 26) / 26;
        } else {
          h3 = 0;
        }
        var r = bits % 26;
        var s = Math.min((bits - r) / 26, this.length);
        var mask = 67108863 ^ 67108863 >>> r << r;
        var maskedWords = extended;
        h3 -= s;
        h3 = Math.max(0, h3);
        if (maskedWords) {
          for (var i2 = 0; i2 < s; i2++) {
            maskedWords.words[i2] = this.words[i2];
          }
          maskedWords.length = s;
        }
        if (s === 0) {
        } else if (this.length > s) {
          this.length -= s;
          for (i2 = 0; i2 < this.length; i2++) {
            this.words[i2] = this.words[i2 + s];
          }
        } else {
          this.words[0] = 0;
          this.length = 1;
        }
        var carry = 0;
        for (i2 = this.length - 1; i2 >= 0 && (carry !== 0 || i2 >= h3); i2--) {
          var word = this.words[i2] | 0;
          this.words[i2] = carry << 26 - r | word >>> r;
          carry = word & mask;
        }
        if (maskedWords && carry !== 0) {
          maskedWords.words[maskedWords.length++] = carry;
        }
        if (this.length === 0) {
          this.words[0] = 0;
          this.length = 1;
        }
        return this.strip();
      };
      BN.prototype.ishrn = function ishrn(bits, hint, extended) {
        assert(this.negative === 0);
        return this.iushrn(bits, hint, extended);
      };
      BN.prototype.shln = function shln(bits) {
        return this.clone().ishln(bits);
      };
      BN.prototype.ushln = function ushln(bits) {
        return this.clone().iushln(bits);
      };
      BN.prototype.shrn = function shrn(bits) {
        return this.clone().ishrn(bits);
      };
      BN.prototype.ushrn = function ushrn(bits) {
        return this.clone().iushrn(bits);
      };
      BN.prototype.testn = function testn(bit) {
        assert(typeof bit === "number" && bit >= 0);
        var r = bit % 26;
        var s = (bit - r) / 26;
        var q3 = 1 << r;
        if (this.length <= s)
          return false;
        var w3 = this.words[s];
        return !!(w3 & q3);
      };
      BN.prototype.imaskn = function imaskn(bits) {
        assert(typeof bits === "number" && bits >= 0);
        var r = bits % 26;
        var s = (bits - r) / 26;
        assert(this.negative === 0, "imaskn works only with positive numbers");
        if (this.length <= s) {
          return this;
        }
        if (r !== 0) {
          s++;
        }
        this.length = Math.min(s, this.length);
        if (r !== 0) {
          var mask = 67108863 ^ 67108863 >>> r << r;
          this.words[this.length - 1] &= mask;
        }
        return this.strip();
      };
      BN.prototype.maskn = function maskn(bits) {
        return this.clone().imaskn(bits);
      };
      BN.prototype.iaddn = function iaddn(num) {
        assert(typeof num === "number");
        assert(num < 67108864);
        if (num < 0)
          return this.isubn(-num);
        if (this.negative !== 0) {
          if (this.length === 1 && (this.words[0] | 0) < num) {
            this.words[0] = num - (this.words[0] | 0);
            this.negative = 0;
            return this;
          }
          this.negative = 0;
          this.isubn(num);
          this.negative = 1;
          return this;
        }
        return this._iaddn(num);
      };
      BN.prototype._iaddn = function _iaddn(num) {
        this.words[0] += num;
        for (var i2 = 0; i2 < this.length && this.words[i2] >= 67108864; i2++) {
          this.words[i2] -= 67108864;
          if (i2 === this.length - 1) {
            this.words[i2 + 1] = 1;
          } else {
            this.words[i2 + 1]++;
          }
        }
        this.length = Math.max(this.length, i2 + 1);
        return this;
      };
      BN.prototype.isubn = function isubn(num) {
        assert(typeof num === "number");
        assert(num < 67108864);
        if (num < 0)
          return this.iaddn(-num);
        if (this.negative !== 0) {
          this.negative = 0;
          this.iaddn(num);
          this.negative = 1;
          return this;
        }
        this.words[0] -= num;
        if (this.length === 1 && this.words[0] < 0) {
          this.words[0] = -this.words[0];
          this.negative = 1;
        } else {
          for (var i2 = 0; i2 < this.length && this.words[i2] < 0; i2++) {
            this.words[i2] += 67108864;
            this.words[i2 + 1] -= 1;
          }
        }
        return this.strip();
      };
      BN.prototype.addn = function addn(num) {
        return this.clone().iaddn(num);
      };
      BN.prototype.subn = function subn(num) {
        return this.clone().isubn(num);
      };
      BN.prototype.iabs = function iabs() {
        this.negative = 0;
        return this;
      };
      BN.prototype.abs = function abs() {
        return this.clone().iabs();
      };
      BN.prototype._ishlnsubmul = function _ishlnsubmul(num, mul, shift) {
        var len = num.length + shift;
        var i2;
        this._expand(len);
        var w3;
        var carry = 0;
        for (i2 = 0; i2 < num.length; i2++) {
          w3 = (this.words[i2 + shift] | 0) + carry;
          var right = (num.words[i2] | 0) * mul;
          w3 -= right & 67108863;
          carry = (w3 >> 26) - (right / 67108864 | 0);
          this.words[i2 + shift] = w3 & 67108863;
        }
        for (; i2 < this.length - shift; i2++) {
          w3 = (this.words[i2 + shift] | 0) + carry;
          carry = w3 >> 26;
          this.words[i2 + shift] = w3 & 67108863;
        }
        if (carry === 0)
          return this.strip();
        assert(carry === -1);
        carry = 0;
        for (i2 = 0; i2 < this.length; i2++) {
          w3 = -(this.words[i2] | 0) + carry;
          carry = w3 >> 26;
          this.words[i2] = w3 & 67108863;
        }
        this.negative = 1;
        return this.strip();
      };
      BN.prototype._wordDiv = function _wordDiv(num, mode) {
        var shift = this.length - num.length;
        var a2 = this.clone();
        var b3 = num;
        var bhi = b3.words[b3.length - 1] | 0;
        var bhiBits = this._countBits(bhi);
        shift = 26 - bhiBits;
        if (shift !== 0) {
          b3 = b3.ushln(shift);
          a2.iushln(shift);
          bhi = b3.words[b3.length - 1] | 0;
        }
        var m2 = a2.length - b3.length;
        var q3;
        if (mode !== "mod") {
          q3 = new BN(null);
          q3.length = m2 + 1;
          q3.words = new Array(q3.length);
          for (var i2 = 0; i2 < q3.length; i2++) {
            q3.words[i2] = 0;
          }
        }
        var diff = a2.clone()._ishlnsubmul(b3, 1, m2);
        if (diff.negative === 0) {
          a2 = diff;
          if (q3) {
            q3.words[m2] = 1;
          }
        }
        for (var j2 = m2 - 1; j2 >= 0; j2--) {
          var qj = (a2.words[b3.length + j2] | 0) * 67108864 + (a2.words[b3.length + j2 - 1] | 0);
          qj = Math.min(qj / bhi | 0, 67108863);
          a2._ishlnsubmul(b3, qj, j2);
          while (a2.negative !== 0) {
            qj--;
            a2.negative = 0;
            a2._ishlnsubmul(b3, 1, j2);
            if (!a2.isZero()) {
              a2.negative ^= 1;
            }
          }
          if (q3) {
            q3.words[j2] = qj;
          }
        }
        if (q3) {
          q3.strip();
        }
        a2.strip();
        if (mode !== "div" && shift !== 0) {
          a2.iushrn(shift);
        }
        return {
          div: q3 || null,
          mod: a2
        };
      };
      BN.prototype.divmod = function divmod(num, mode, positive) {
        assert(!num.isZero());
        if (this.isZero()) {
          return {
            div: new BN(0),
            mod: new BN(0)
          };
        }
        var div, mod, res;
        if (this.negative !== 0 && num.negative === 0) {
          res = this.neg().divmod(num, mode);
          if (mode !== "mod") {
            div = res.div.neg();
          }
          if (mode !== "div") {
            mod = res.mod.neg();
            if (positive && mod.negative !== 0) {
              mod.iadd(num);
            }
          }
          return {
            div,
            mod
          };
        }
        if (this.negative === 0 && num.negative !== 0) {
          res = this.divmod(num.neg(), mode);
          if (mode !== "mod") {
            div = res.div.neg();
          }
          return {
            div,
            mod: res.mod
          };
        }
        if ((this.negative & num.negative) !== 0) {
          res = this.neg().divmod(num.neg(), mode);
          if (mode !== "div") {
            mod = res.mod.neg();
            if (positive && mod.negative !== 0) {
              mod.isub(num);
            }
          }
          return {
            div: res.div,
            mod
          };
        }
        if (num.length > this.length || this.cmp(num) < 0) {
          return {
            div: new BN(0),
            mod: this
          };
        }
        if (num.length === 1) {
          if (mode === "div") {
            return {
              div: this.divn(num.words[0]),
              mod: null
            };
          }
          if (mode === "mod") {
            return {
              div: null,
              mod: new BN(this.modn(num.words[0]))
            };
          }
          return {
            div: this.divn(num.words[0]),
            mod: new BN(this.modn(num.words[0]))
          };
        }
        return this._wordDiv(num, mode);
      };
      BN.prototype.div = function div(num) {
        return this.divmod(num, "div", false).div;
      };
      BN.prototype.mod = function mod(num) {
        return this.divmod(num, "mod", false).mod;
      };
      BN.prototype.umod = function umod(num) {
        return this.divmod(num, "mod", true).mod;
      };
      BN.prototype.divRound = function divRound(num) {
        var dm = this.divmod(num);
        if (dm.mod.isZero())
          return dm.div;
        var mod = dm.div.negative !== 0 ? dm.mod.isub(num) : dm.mod;
        var half = num.ushrn(1);
        var r2 = num.andln(1);
        var cmp = mod.cmp(half);
        if (cmp < 0 || r2 === 1 && cmp === 0)
          return dm.div;
        return dm.div.negative !== 0 ? dm.div.isubn(1) : dm.div.iaddn(1);
      };
      BN.prototype.modn = function modn(num) {
        assert(num <= 67108863);
        var p3 = (1 << 26) % num;
        var acc = 0;
        for (var i2 = this.length - 1; i2 >= 0; i2--) {
          acc = (p3 * acc + (this.words[i2] | 0)) % num;
        }
        return acc;
      };
      BN.prototype.idivn = function idivn(num) {
        assert(num <= 67108863);
        var carry = 0;
        for (var i2 = this.length - 1; i2 >= 0; i2--) {
          var w3 = (this.words[i2] | 0) + carry * 67108864;
          this.words[i2] = w3 / num | 0;
          carry = w3 % num;
        }
        return this.strip();
      };
      BN.prototype.divn = function divn(num) {
        return this.clone().idivn(num);
      };
      BN.prototype.egcd = function egcd(p3) {
        assert(p3.negative === 0);
        assert(!p3.isZero());
        var x3 = this;
        var y3 = p3.clone();
        if (x3.negative !== 0) {
          x3 = x3.umod(p3);
        } else {
          x3 = x3.clone();
        }
        var A2 = new BN(1);
        var B3 = new BN(0);
        var C3 = new BN(0);
        var D3 = new BN(1);
        var g4 = 0;
        while (x3.isEven() && y3.isEven()) {
          x3.iushrn(1);
          y3.iushrn(1);
          ++g4;
        }
        var yp = y3.clone();
        var xp = x3.clone();
        while (!x3.isZero()) {
          for (var i2 = 0, im = 1; (x3.words[0] & im) === 0 && i2 < 26; ++i2, im <<= 1)
            ;
          if (i2 > 0) {
            x3.iushrn(i2);
            while (i2-- > 0) {
              if (A2.isOdd() || B3.isOdd()) {
                A2.iadd(yp);
                B3.isub(xp);
              }
              A2.iushrn(1);
              B3.iushrn(1);
            }
          }
          for (var j2 = 0, jm = 1; (y3.words[0] & jm) === 0 && j2 < 26; ++j2, jm <<= 1)
            ;
          if (j2 > 0) {
            y3.iushrn(j2);
            while (j2-- > 0) {
              if (C3.isOdd() || D3.isOdd()) {
                C3.iadd(yp);
                D3.isub(xp);
              }
              C3.iushrn(1);
              D3.iushrn(1);
            }
          }
          if (x3.cmp(y3) >= 0) {
            x3.isub(y3);
            A2.isub(C3);
            B3.isub(D3);
          } else {
            y3.isub(x3);
            C3.isub(A2);
            D3.isub(B3);
          }
        }
        return {
          a: C3,
          b: D3,
          gcd: y3.iushln(g4)
        };
      };
      BN.prototype._invmp = function _invmp(p3) {
        assert(p3.negative === 0);
        assert(!p3.isZero());
        var a2 = this;
        var b3 = p3.clone();
        if (a2.negative !== 0) {
          a2 = a2.umod(p3);
        } else {
          a2 = a2.clone();
        }
        var x1 = new BN(1);
        var x22 = new BN(0);
        var delta = b3.clone();
        while (a2.cmpn(1) > 0 && b3.cmpn(1) > 0) {
          for (var i2 = 0, im = 1; (a2.words[0] & im) === 0 && i2 < 26; ++i2, im <<= 1)
            ;
          if (i2 > 0) {
            a2.iushrn(i2);
            while (i2-- > 0) {
              if (x1.isOdd()) {
                x1.iadd(delta);
              }
              x1.iushrn(1);
            }
          }
          for (var j2 = 0, jm = 1; (b3.words[0] & jm) === 0 && j2 < 26; ++j2, jm <<= 1)
            ;
          if (j2 > 0) {
            b3.iushrn(j2);
            while (j2-- > 0) {
              if (x22.isOdd()) {
                x22.iadd(delta);
              }
              x22.iushrn(1);
            }
          }
          if (a2.cmp(b3) >= 0) {
            a2.isub(b3);
            x1.isub(x22);
          } else {
            b3.isub(a2);
            x22.isub(x1);
          }
        }
        var res;
        if (a2.cmpn(1) === 0) {
          res = x1;
        } else {
          res = x22;
        }
        if (res.cmpn(0) < 0) {
          res.iadd(p3);
        }
        return res;
      };
      BN.prototype.gcd = function gcd(num) {
        if (this.isZero())
          return num.abs();
        if (num.isZero())
          return this.abs();
        var a2 = this.clone();
        var b3 = num.clone();
        a2.negative = 0;
        b3.negative = 0;
        for (var shift = 0; a2.isEven() && b3.isEven(); shift++) {
          a2.iushrn(1);
          b3.iushrn(1);
        }
        do {
          while (a2.isEven()) {
            a2.iushrn(1);
          }
          while (b3.isEven()) {
            b3.iushrn(1);
          }
          var r = a2.cmp(b3);
          if (r < 0) {
            var t = a2;
            a2 = b3;
            b3 = t;
          } else if (r === 0 || b3.cmpn(1) === 0) {
            break;
          }
          a2.isub(b3);
        } while (true);
        return b3.iushln(shift);
      };
      BN.prototype.invm = function invm(num) {
        return this.egcd(num).a.umod(num);
      };
      BN.prototype.isEven = function isEven() {
        return (this.words[0] & 1) === 0;
      };
      BN.prototype.isOdd = function isOdd2() {
        return (this.words[0] & 1) === 1;
      };
      BN.prototype.andln = function andln(num) {
        return this.words[0] & num;
      };
      BN.prototype.bincn = function bincn(bit) {
        assert(typeof bit === "number");
        var r = bit % 26;
        var s = (bit - r) / 26;
        var q3 = 1 << r;
        if (this.length <= s) {
          this._expand(s + 1);
          this.words[s] |= q3;
          return this;
        }
        var carry = q3;
        for (var i2 = s; carry !== 0 && i2 < this.length; i2++) {
          var w3 = this.words[i2] | 0;
          w3 += carry;
          carry = w3 >>> 26;
          w3 &= 67108863;
          this.words[i2] = w3;
        }
        if (carry !== 0) {
          this.words[i2] = carry;
          this.length++;
        }
        return this;
      };
      BN.prototype.isZero = function isZero() {
        return this.length === 1 && this.words[0] === 0;
      };
      BN.prototype.cmpn = function cmpn(num) {
        var negative = num < 0;
        if (this.negative !== 0 && !negative)
          return -1;
        if (this.negative === 0 && negative)
          return 1;
        this.strip();
        var res;
        if (this.length > 1) {
          res = 1;
        } else {
          if (negative) {
            num = -num;
          }
          assert(num <= 67108863, "Number is too big");
          var w3 = this.words[0] | 0;
          res = w3 === num ? 0 : w3 < num ? -1 : 1;
        }
        if (this.negative !== 0)
          return -res | 0;
        return res;
      };
      BN.prototype.cmp = function cmp(num) {
        if (this.negative !== 0 && num.negative === 0)
          return -1;
        if (this.negative === 0 && num.negative !== 0)
          return 1;
        var res = this.ucmp(num);
        if (this.negative !== 0)
          return -res | 0;
        return res;
      };
      BN.prototype.ucmp = function ucmp(num) {
        if (this.length > num.length)
          return 1;
        if (this.length < num.length)
          return -1;
        var res = 0;
        for (var i2 = this.length - 1; i2 >= 0; i2--) {
          var a2 = this.words[i2] | 0;
          var b3 = num.words[i2] | 0;
          if (a2 === b3)
            continue;
          if (a2 < b3) {
            res = -1;
          } else if (a2 > b3) {
            res = 1;
          }
          break;
        }
        return res;
      };
      BN.prototype.gtn = function gtn(num) {
        return this.cmpn(num) === 1;
      };
      BN.prototype.gt = function gt3(num) {
        return this.cmp(num) === 1;
      };
      BN.prototype.gten = function gten(num) {
        return this.cmpn(num) >= 0;
      };
      BN.prototype.gte = function gte(num) {
        return this.cmp(num) >= 0;
      };
      BN.prototype.ltn = function ltn(num) {
        return this.cmpn(num) === -1;
      };
      BN.prototype.lt = function lt3(num) {
        return this.cmp(num) === -1;
      };
      BN.prototype.lten = function lten(num) {
        return this.cmpn(num) <= 0;
      };
      BN.prototype.lte = function lte(num) {
        return this.cmp(num) <= 0;
      };
      BN.prototype.eqn = function eqn(num) {
        return this.cmpn(num) === 0;
      };
      BN.prototype.eq = function eq(num) {
        return this.cmp(num) === 0;
      };
      BN.red = function red(num) {
        return new Red(num);
      };
      BN.prototype.toRed = function toRed(ctx) {
        assert(!this.red, "Already a number in reduction context");
        assert(this.negative === 0, "red works only with positives");
        return ctx.convertTo(this)._forceRed(ctx);
      };
      BN.prototype.fromRed = function fromRed() {
        assert(this.red, "fromRed works only with numbers in reduction context");
        return this.red.convertFrom(this);
      };
      BN.prototype._forceRed = function _forceRed(ctx) {
        this.red = ctx;
        return this;
      };
      BN.prototype.forceRed = function forceRed(ctx) {
        assert(!this.red, "Already a number in reduction context");
        return this._forceRed(ctx);
      };
      BN.prototype.redAdd = function redAdd(num) {
        assert(this.red, "redAdd works only with red numbers");
        return this.red.add(this, num);
      };
      BN.prototype.redIAdd = function redIAdd(num) {
        assert(this.red, "redIAdd works only with red numbers");
        return this.red.iadd(this, num);
      };
      BN.prototype.redSub = function redSub(num) {
        assert(this.red, "redSub works only with red numbers");
        return this.red.sub(this, num);
      };
      BN.prototype.redISub = function redISub(num) {
        assert(this.red, "redISub works only with red numbers");
        return this.red.isub(this, num);
      };
      BN.prototype.redShl = function redShl(num) {
        assert(this.red, "redShl works only with red numbers");
        return this.red.shl(this, num);
      };
      BN.prototype.redMul = function redMul(num) {
        assert(this.red, "redMul works only with red numbers");
        this.red._verify2(this, num);
        return this.red.mul(this, num);
      };
      BN.prototype.redIMul = function redIMul(num) {
        assert(this.red, "redMul works only with red numbers");
        this.red._verify2(this, num);
        return this.red.imul(this, num);
      };
      BN.prototype.redSqr = function redSqr() {
        assert(this.red, "redSqr works only with red numbers");
        this.red._verify1(this);
        return this.red.sqr(this);
      };
      BN.prototype.redISqr = function redISqr() {
        assert(this.red, "redISqr works only with red numbers");
        this.red._verify1(this);
        return this.red.isqr(this);
      };
      BN.prototype.redSqrt = function redSqrt() {
        assert(this.red, "redSqrt works only with red numbers");
        this.red._verify1(this);
        return this.red.sqrt(this);
      };
      BN.prototype.redInvm = function redInvm() {
        assert(this.red, "redInvm works only with red numbers");
        this.red._verify1(this);
        return this.red.invm(this);
      };
      BN.prototype.redNeg = function redNeg() {
        assert(this.red, "redNeg works only with red numbers");
        this.red._verify1(this);
        return this.red.neg(this);
      };
      BN.prototype.redPow = function redPow(num) {
        assert(this.red && !num.red, "redPow(normalNum)");
        this.red._verify1(this);
        return this.red.pow(this, num);
      };
      var primes = {
        k256: null,
        p224: null,
        p192: null,
        p25519: null
      };
      function MPrime(name, p3) {
        this.name = name;
        this.p = new BN(p3, 16);
        this.n = this.p.bitLength();
        this.k = new BN(1).iushln(this.n).isub(this.p);
        this.tmp = this._tmp();
      }
      MPrime.prototype._tmp = function _tmp() {
        var tmp = new BN(null);
        tmp.words = new Array(Math.ceil(this.n / 13));
        return tmp;
      };
      MPrime.prototype.ireduce = function ireduce(num) {
        var r = num;
        var rlen;
        do {
          this.split(r, this.tmp);
          r = this.imulK(r);
          r = r.iadd(this.tmp);
          rlen = r.bitLength();
        } while (rlen > this.n);
        var cmp = rlen < this.n ? -1 : r.ucmp(this.p);
        if (cmp === 0) {
          r.words[0] = 0;
          r.length = 1;
        } else if (cmp > 0) {
          r.isub(this.p);
        } else {
          if (r.strip !== void 0) {
            r.strip();
          } else {
            r._strip();
          }
        }
        return r;
      };
      MPrime.prototype.split = function split(input, out) {
        input.iushrn(this.n, 0, out);
      };
      MPrime.prototype.imulK = function imulK(num) {
        return num.imul(this.k);
      };
      function K256() {
        MPrime.call(
          this,
          "k256",
          "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f"
        );
      }
      inherits(K256, MPrime);
      K256.prototype.split = function split(input, output) {
        var mask = 4194303;
        var outLen = Math.min(input.length, 9);
        for (var i2 = 0; i2 < outLen; i2++) {
          output.words[i2] = input.words[i2];
        }
        output.length = outLen;
        if (input.length <= 9) {
          input.words[0] = 0;
          input.length = 1;
          return;
        }
        var prev = input.words[9];
        output.words[output.length++] = prev & mask;
        for (i2 = 10; i2 < input.length; i2++) {
          var next = input.words[i2] | 0;
          input.words[i2 - 10] = (next & mask) << 4 | prev >>> 22;
          prev = next;
        }
        prev >>>= 22;
        input.words[i2 - 10] = prev;
        if (prev === 0 && input.length > 10) {
          input.length -= 10;
        } else {
          input.length -= 9;
        }
      };
      K256.prototype.imulK = function imulK(num) {
        num.words[num.length] = 0;
        num.words[num.length + 1] = 0;
        num.length += 2;
        var lo = 0;
        for (var i2 = 0; i2 < num.length; i2++) {
          var w3 = num.words[i2] | 0;
          lo += w3 * 977;
          num.words[i2] = lo & 67108863;
          lo = w3 * 64 + (lo / 67108864 | 0);
        }
        if (num.words[num.length - 1] === 0) {
          num.length--;
          if (num.words[num.length - 1] === 0) {
            num.length--;
          }
        }
        return num;
      };
      function P224() {
        MPrime.call(
          this,
          "p224",
          "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001"
        );
      }
      inherits(P224, MPrime);
      function P192() {
        MPrime.call(
          this,
          "p192",
          "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff"
        );
      }
      inherits(P192, MPrime);
      function P25519() {
        MPrime.call(
          this,
          "25519",
          "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed"
        );
      }
      inherits(P25519, MPrime);
      P25519.prototype.imulK = function imulK(num) {
        var carry = 0;
        for (var i2 = 0; i2 < num.length; i2++) {
          var hi = (num.words[i2] | 0) * 19 + carry;
          var lo = hi & 67108863;
          hi >>>= 26;
          num.words[i2] = lo;
          carry = hi;
        }
        if (carry !== 0) {
          num.words[num.length++] = carry;
        }
        return num;
      };
      BN._prime = function prime(name) {
        if (primes[name])
          return primes[name];
        var prime2;
        if (name === "k256") {
          prime2 = new K256();
        } else if (name === "p224") {
          prime2 = new P224();
        } else if (name === "p192") {
          prime2 = new P192();
        } else if (name === "p25519") {
          prime2 = new P25519();
        } else {
          throw new Error("Unknown prime " + name);
        }
        primes[name] = prime2;
        return prime2;
      };
      function Red(m2) {
        if (typeof m2 === "string") {
          var prime = BN._prime(m2);
          this.m = prime.p;
          this.prime = prime;
        } else {
          assert(m2.gtn(1), "modulus must be greater than 1");
          this.m = m2;
          this.prime = null;
        }
      }
      Red.prototype._verify1 = function _verify1(a2) {
        assert(a2.negative === 0, "red works only with positives");
        assert(a2.red, "red works only with red numbers");
      };
      Red.prototype._verify2 = function _verify2(a2, b3) {
        assert((a2.negative | b3.negative) === 0, "red works only with positives");
        assert(
          a2.red && a2.red === b3.red,
          "red works only with red numbers"
        );
      };
      Red.prototype.imod = function imod(a2) {
        if (this.prime)
          return this.prime.ireduce(a2)._forceRed(this);
        return a2.umod(this.m)._forceRed(this);
      };
      Red.prototype.neg = function neg(a2) {
        if (a2.isZero()) {
          return a2.clone();
        }
        return this.m.sub(a2)._forceRed(this);
      };
      Red.prototype.add = function add(a2, b3) {
        this._verify2(a2, b3);
        var res = a2.add(b3);
        if (res.cmp(this.m) >= 0) {
          res.isub(this.m);
        }
        return res._forceRed(this);
      };
      Red.prototype.iadd = function iadd(a2, b3) {
        this._verify2(a2, b3);
        var res = a2.iadd(b3);
        if (res.cmp(this.m) >= 0) {
          res.isub(this.m);
        }
        return res;
      };
      Red.prototype.sub = function sub(a2, b3) {
        this._verify2(a2, b3);
        var res = a2.sub(b3);
        if (res.cmpn(0) < 0) {
          res.iadd(this.m);
        }
        return res._forceRed(this);
      };
      Red.prototype.isub = function isub(a2, b3) {
        this._verify2(a2, b3);
        var res = a2.isub(b3);
        if (res.cmpn(0) < 0) {
          res.iadd(this.m);
        }
        return res;
      };
      Red.prototype.shl = function shl(a2, num) {
        this._verify1(a2);
        return this.imod(a2.ushln(num));
      };
      Red.prototype.imul = function imul(a2, b3) {
        this._verify2(a2, b3);
        return this.imod(a2.imul(b3));
      };
      Red.prototype.mul = function mul(a2, b3) {
        this._verify2(a2, b3);
        return this.imod(a2.mul(b3));
      };
      Red.prototype.isqr = function isqr(a2) {
        return this.imul(a2, a2.clone());
      };
      Red.prototype.sqr = function sqr(a2) {
        return this.mul(a2, a2);
      };
      Red.prototype.sqrt = function sqrt(a2) {
        if (a2.isZero())
          return a2.clone();
        var mod3 = this.m.andln(3);
        assert(mod3 % 2 === 1);
        if (mod3 === 3) {
          var pow = this.m.add(new BN(1)).iushrn(2);
          return this.pow(a2, pow);
        }
        var q3 = this.m.subn(1);
        var s = 0;
        while (!q3.isZero() && q3.andln(1) === 0) {
          s++;
          q3.iushrn(1);
        }
        assert(!q3.isZero());
        var one = new BN(1).toRed(this);
        var nOne = one.redNeg();
        var lpow = this.m.subn(1).iushrn(1);
        var z = this.m.bitLength();
        z = new BN(2 * z * z).toRed(this);
        while (this.pow(z, lpow).cmp(nOne) !== 0) {
          z.redIAdd(nOne);
        }
        var c2 = this.pow(z, q3);
        var r = this.pow(a2, q3.addn(1).iushrn(1));
        var t = this.pow(a2, q3);
        var m2 = s;
        while (t.cmp(one) !== 0) {
          var tmp = t;
          for (var i2 = 0; tmp.cmp(one) !== 0; i2++) {
            tmp = tmp.redSqr();
          }
          assert(i2 < m2);
          var b3 = this.pow(c2, new BN(1).iushln(m2 - i2 - 1));
          r = r.redMul(b3);
          c2 = b3.redSqr();
          t = t.redMul(c2);
          m2 = i2;
        }
        return r;
      };
      Red.prototype.invm = function invm(a2) {
        var inv = a2._invmp(this.m);
        if (inv.negative !== 0) {
          inv.negative = 0;
          return this.imod(inv).redNeg();
        } else {
          return this.imod(inv);
        }
      };
      Red.prototype.pow = function pow(a2, num) {
        if (num.isZero())
          return new BN(1).toRed(this);
        if (num.cmpn(1) === 0)
          return a2.clone();
        var windowSize = 4;
        var wnd = new Array(1 << windowSize);
        wnd[0] = new BN(1).toRed(this);
        wnd[1] = a2;
        for (var i2 = 2; i2 < wnd.length; i2++) {
          wnd[i2] = this.mul(wnd[i2 - 1], a2);
        }
        var res = wnd[0];
        var current = 0;
        var currentLen = 0;
        var start = num.bitLength() % 26;
        if (start === 0) {
          start = 26;
        }
        for (i2 = num.length - 1; i2 >= 0; i2--) {
          var word = num.words[i2];
          for (var j2 = start - 1; j2 >= 0; j2--) {
            var bit = word >> j2 & 1;
            if (res !== wnd[0]) {
              res = this.sqr(res);
            }
            if (bit === 0 && current === 0) {
              currentLen = 0;
              continue;
            }
            current <<= 1;
            current |= bit;
            currentLen++;
            if (currentLen !== windowSize && (i2 !== 0 || j2 !== 0))
              continue;
            res = this.mul(res, wnd[current]);
            currentLen = 0;
            current = 0;
          }
          start = 26;
        }
        return res;
      };
      Red.prototype.convertTo = function convertTo(num) {
        var r = num.umod(this.m);
        return r === num ? r.clone() : r;
      };
      Red.prototype.convertFrom = function convertFrom(num) {
        var res = num.clone();
        res.red = null;
        return res;
      };
      BN.mont = function mont(num) {
        return new Mont(num);
      };
      function Mont(m2) {
        Red.call(this, m2);
        this.shift = this.m.bitLength();
        if (this.shift % 26 !== 0) {
          this.shift += 26 - this.shift % 26;
        }
        this.r = new BN(1).iushln(this.shift);
        this.r2 = this.imod(this.r.sqr());
        this.rinv = this.r._invmp(this.m);
        this.minv = this.rinv.mul(this.r).isubn(1).div(this.m);
        this.minv = this.minv.umod(this.r);
        this.minv = this.r.sub(this.minv);
      }
      inherits(Mont, Red);
      Mont.prototype.convertTo = function convertTo(num) {
        return this.imod(num.ushln(this.shift));
      };
      Mont.prototype.convertFrom = function convertFrom(num) {
        var r = this.imod(num.mul(this.rinv));
        r.red = null;
        return r;
      };
      Mont.prototype.imul = function imul(a2, b3) {
        if (a2.isZero() || b3.isZero()) {
          a2.words[0] = 0;
          a2.length = 1;
          return a2;
        }
        var t = a2.imul(b3);
        var c2 = t.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m);
        var u2 = t.isub(c2).iushrn(this.shift);
        var res = u2;
        if (u2.cmp(this.m) >= 0) {
          res = u2.isub(this.m);
        } else if (u2.cmpn(0) < 0) {
          res = u2.iadd(this.m);
        }
        return res._forceRed(this);
      };
      Mont.prototype.mul = function mul(a2, b3) {
        if (a2.isZero() || b3.isZero())
          return new BN(0)._forceRed(this);
        var t = a2.mul(b3);
        var c2 = t.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m);
        var u2 = t.isub(c2).iushrn(this.shift);
        var res = u2;
        if (u2.cmp(this.m) >= 0) {
          res = u2.isub(this.m);
        } else if (u2.cmpn(0) < 0) {
          res = u2.iadd(this.m);
        }
        return res._forceRed(this);
      };
      Mont.prototype.invm = function invm(a2) {
        var res = this.imod(a2._invmp(this.m).mul(this.r2));
        return res._forceRed(this);
      };
    })(typeof module === "undefined" || module, exports);
  }
});

// node_modules/minimalistic-assert/index.js
var require_minimalistic_assert = __commonJS({
  "node_modules/minimalistic-assert/index.js"(exports, module) {
    module.exports = assert;
    function assert(val, msg) {
      if (!val)
        throw new Error(msg || "Assertion failed");
    }
    assert.equal = function assertEqual(l, r, msg) {
      if (l != r)
        throw new Error(msg || "Assertion failed: " + l + " != " + r);
    };
  }
});

// node_modules/minimalistic-crypto-utils/lib/utils.js
var require_utils2 = __commonJS({
  "node_modules/minimalistic-crypto-utils/lib/utils.js"(exports) {
    "use strict";
    var utils = exports;
    function toArray2(msg, enc) {
      if (Array.isArray(msg))
        return msg.slice();
      if (!msg)
        return [];
      var res = [];
      if (typeof msg !== "string") {
        for (var i2 = 0; i2 < msg.length; i2++)
          res[i2] = msg[i2] | 0;
        return res;
      }
      if (enc === "hex") {
        msg = msg.replace(/[^a-z0-9]+/ig, "");
        if (msg.length % 2 !== 0)
          msg = "0" + msg;
        for (var i2 = 0; i2 < msg.length; i2 += 2)
          res.push(parseInt(msg[i2] + msg[i2 + 1], 16));
      } else {
        for (var i2 = 0; i2 < msg.length; i2++) {
          var c2 = msg.charCodeAt(i2);
          var hi = c2 >> 8;
          var lo = c2 & 255;
          if (hi)
            res.push(hi, lo);
          else
            res.push(lo);
        }
      }
      return res;
    }
    utils.toArray = toArray2;
    function zero2(word) {
      if (word.length === 1)
        return "0" + word;
      else
        return word;
    }
    utils.zero2 = zero2;
    function toHex2(msg) {
      var res = "";
      for (var i2 = 0; i2 < msg.length; i2++)
        res += zero2(msg[i2].toString(16));
      return res;
    }
    utils.toHex = toHex2;
    utils.encode = function encode9(arr, enc) {
      if (enc === "hex")
        return toHex2(arr);
      else
        return arr;
    };
  }
});

// node_modules/elliptic/lib/elliptic/utils.js
var require_utils3 = __commonJS({
  "node_modules/elliptic/lib/elliptic/utils.js"(exports) {
    "use strict";
    var utils = exports;
    var BN = require_bn();
    var minAssert = require_minimalistic_assert();
    var minUtils = require_utils2();
    utils.assert = minAssert;
    utils.toArray = minUtils.toArray;
    utils.zero2 = minUtils.zero2;
    utils.toHex = minUtils.toHex;
    utils.encode = minUtils.encode;
    function getNAF(num, w3, bits) {
      var naf = new Array(Math.max(num.bitLength(), bits) + 1);
      naf.fill(0);
      var ws2 = 1 << w3 + 1;
      var k2 = num.clone();
      for (var i2 = 0; i2 < naf.length; i2++) {
        var z;
        var mod = k2.andln(ws2 - 1);
        if (k2.isOdd()) {
          if (mod > (ws2 >> 1) - 1)
            z = (ws2 >> 1) - mod;
          else
            z = mod;
          k2.isubn(z);
        } else {
          z = 0;
        }
        naf[i2] = z;
        k2.iushrn(1);
      }
      return naf;
    }
    utils.getNAF = getNAF;
    function getJSF(k1, k2) {
      var jsf = [
        [],
        []
      ];
      k1 = k1.clone();
      k2 = k2.clone();
      var d1 = 0;
      var d2 = 0;
      var m8;
      while (k1.cmpn(-d1) > 0 || k2.cmpn(-d2) > 0) {
        var m14 = k1.andln(3) + d1 & 3;
        var m24 = k2.andln(3) + d2 & 3;
        if (m14 === 3)
          m14 = -1;
        if (m24 === 3)
          m24 = -1;
        var u1;
        if ((m14 & 1) === 0) {
          u1 = 0;
        } else {
          m8 = k1.andln(7) + d1 & 7;
          if ((m8 === 3 || m8 === 5) && m24 === 2)
            u1 = -m14;
          else
            u1 = m14;
        }
        jsf[0].push(u1);
        var u2;
        if ((m24 & 1) === 0) {
          u2 = 0;
        } else {
          m8 = k2.andln(7) + d2 & 7;
          if ((m8 === 3 || m8 === 5) && m14 === 2)
            u2 = -m24;
          else
            u2 = m24;
        }
        jsf[1].push(u2);
        if (2 * d1 === u1 + 1)
          d1 = 1 - d1;
        if (2 * d2 === u2 + 1)
          d2 = 1 - d2;
        k1.iushrn(1);
        k2.iushrn(1);
      }
      return jsf;
    }
    utils.getJSF = getJSF;
    function cachedProperty(obj, name, computer) {
      var key = "_" + name;
      obj.prototype[name] = function cachedProperty2() {
        return this[key] !== void 0 ? this[key] : this[key] = computer.call(this);
      };
    }
    utils.cachedProperty = cachedProperty;
    function parseBytes2(bytes) {
      return typeof bytes === "string" ? utils.toArray(bytes, "hex") : bytes;
    }
    utils.parseBytes = parseBytes2;
    function intFromLE(bytes) {
      return new BN(bytes, "hex", "le");
    }
    utils.intFromLE = intFromLE;
  }
});

// node_modules/brorand/index.js
var require_brorand = __commonJS({
  "node_modules/brorand/index.js"(exports, module) {
    var r;
    module.exports = function rand(len) {
      if (!r)
        r = new Rand(null);
      return r.generate(len);
    };
    function Rand(rand) {
      this.rand = rand;
    }
    module.exports.Rand = Rand;
    Rand.prototype.generate = function generate2(len) {
      return this._rand(len);
    };
    Rand.prototype._rand = function _rand(n2) {
      if (this.rand.getBytes)
        return this.rand.getBytes(n2);
      var res = new Uint8Array(n2);
      for (var i2 = 0; i2 < res.length; i2++)
        res[i2] = this.rand.getByte();
      return res;
    };
    if (typeof self === "object") {
      if (self.crypto && self.crypto.getRandomValues) {
        Rand.prototype._rand = function _rand(n2) {
          var arr = new Uint8Array(n2);
          self.crypto.getRandomValues(arr);
          return arr;
        };
      } else if (self.msCrypto && self.msCrypto.getRandomValues) {
        Rand.prototype._rand = function _rand(n2) {
          var arr = new Uint8Array(n2);
          self.msCrypto.getRandomValues(arr);
          return arr;
        };
      } else if (typeof window === "object") {
        Rand.prototype._rand = function() {
          throw new Error("Not implemented yet");
        };
      }
    } else {
      try {
        crypto2 = require_crypto();
        if (typeof crypto2.randomBytes !== "function")
          throw new Error("Not supported");
        Rand.prototype._rand = function _rand(n2) {
          return crypto2.randomBytes(n2);
        };
      } catch (e) {
      }
    }
    var crypto2;
  }
});

// node_modules/elliptic/lib/elliptic/curve/base.js
var require_base = __commonJS({
  "node_modules/elliptic/lib/elliptic/curve/base.js"(exports, module) {
    "use strict";
    var BN = require_bn();
    var utils = require_utils3();
    var getNAF = utils.getNAF;
    var getJSF = utils.getJSF;
    var assert = utils.assert;
    function BaseCurve(type, conf) {
      this.type = type;
      this.p = new BN(conf.p, 16);
      this.red = conf.prime ? BN.red(conf.prime) : BN.mont(this.p);
      this.zero = new BN(0).toRed(this.red);
      this.one = new BN(1).toRed(this.red);
      this.two = new BN(2).toRed(this.red);
      this.n = conf.n && new BN(conf.n, 16);
      this.g = conf.g && this.pointFromJSON(conf.g, conf.gRed);
      this._wnafT1 = new Array(4);
      this._wnafT2 = new Array(4);
      this._wnafT3 = new Array(4);
      this._wnafT4 = new Array(4);
      this._bitLength = this.n ? this.n.bitLength() : 0;
      var adjustCount = this.n && this.p.div(this.n);
      if (!adjustCount || adjustCount.cmpn(100) > 0) {
        this.redN = null;
      } else {
        this._maxwellTrick = true;
        this.redN = this.n.toRed(this.red);
      }
    }
    module.exports = BaseCurve;
    BaseCurve.prototype.point = function point() {
      throw new Error("Not implemented");
    };
    BaseCurve.prototype.validate = function validate() {
      throw new Error("Not implemented");
    };
    BaseCurve.prototype._fixedNafMul = function _fixedNafMul(p3, k2) {
      assert(p3.precomputed);
      var doubles = p3._getDoubles();
      var naf = getNAF(k2, 1, this._bitLength);
      var I = (1 << doubles.step + 1) - (doubles.step % 2 === 0 ? 2 : 1);
      I /= 3;
      var repr = [];
      var j2;
      var nafW;
      for (j2 = 0; j2 < naf.length; j2 += doubles.step) {
        nafW = 0;
        for (var l = j2 + doubles.step - 1; l >= j2; l--)
          nafW = (nafW << 1) + naf[l];
        repr.push(nafW);
      }
      var a2 = this.jpoint(null, null, null);
      var b3 = this.jpoint(null, null, null);
      for (var i2 = I; i2 > 0; i2--) {
        for (j2 = 0; j2 < repr.length; j2++) {
          nafW = repr[j2];
          if (nafW === i2)
            b3 = b3.mixedAdd(doubles.points[j2]);
          else if (nafW === -i2)
            b3 = b3.mixedAdd(doubles.points[j2].neg());
        }
        a2 = a2.add(b3);
      }
      return a2.toP();
    };
    BaseCurve.prototype._wnafMul = function _wnafMul(p3, k2) {
      var w3 = 4;
      var nafPoints = p3._getNAFPoints(w3);
      w3 = nafPoints.wnd;
      var wnd = nafPoints.points;
      var naf = getNAF(k2, w3, this._bitLength);
      var acc = this.jpoint(null, null, null);
      for (var i2 = naf.length - 1; i2 >= 0; i2--) {
        for (var l = 0; i2 >= 0 && naf[i2] === 0; i2--)
          l++;
        if (i2 >= 0)
          l++;
        acc = acc.dblp(l);
        if (i2 < 0)
          break;
        var z = naf[i2];
        assert(z !== 0);
        if (p3.type === "affine") {
          if (z > 0)
            acc = acc.mixedAdd(wnd[z - 1 >> 1]);
          else
            acc = acc.mixedAdd(wnd[-z - 1 >> 1].neg());
        } else {
          if (z > 0)
            acc = acc.add(wnd[z - 1 >> 1]);
          else
            acc = acc.add(wnd[-z - 1 >> 1].neg());
        }
      }
      return p3.type === "affine" ? acc.toP() : acc;
    };
    BaseCurve.prototype._wnafMulAdd = function _wnafMulAdd(defW, points, coeffs, len, jacobianResult) {
      var wndWidth = this._wnafT1;
      var wnd = this._wnafT2;
      var naf = this._wnafT3;
      var max2 = 0;
      var i2;
      var j2;
      var p3;
      for (i2 = 0; i2 < len; i2++) {
        p3 = points[i2];
        var nafPoints = p3._getNAFPoints(defW);
        wndWidth[i2] = nafPoints.wnd;
        wnd[i2] = nafPoints.points;
      }
      for (i2 = len - 1; i2 >= 1; i2 -= 2) {
        var a2 = i2 - 1;
        var b3 = i2;
        if (wndWidth[a2] !== 1 || wndWidth[b3] !== 1) {
          naf[a2] = getNAF(coeffs[a2], wndWidth[a2], this._bitLength);
          naf[b3] = getNAF(coeffs[b3], wndWidth[b3], this._bitLength);
          max2 = Math.max(naf[a2].length, max2);
          max2 = Math.max(naf[b3].length, max2);
          continue;
        }
        var comb = [
          points[a2],
          /* 1 */
          null,
          /* 3 */
          null,
          /* 5 */
          points[b3]
          /* 7 */
        ];
        if (points[a2].y.cmp(points[b3].y) === 0) {
          comb[1] = points[a2].add(points[b3]);
          comb[2] = points[a2].toJ().mixedAdd(points[b3].neg());
        } else if (points[a2].y.cmp(points[b3].y.redNeg()) === 0) {
          comb[1] = points[a2].toJ().mixedAdd(points[b3]);
          comb[2] = points[a2].add(points[b3].neg());
        } else {
          comb[1] = points[a2].toJ().mixedAdd(points[b3]);
          comb[2] = points[a2].toJ().mixedAdd(points[b3].neg());
        }
        var index = [
          -3,
          /* -1 -1 */
          -1,
          /* -1 0 */
          -5,
          /* -1 1 */
          -7,
          /* 0 -1 */
          0,
          /* 0 0 */
          7,
          /* 0 1 */
          5,
          /* 1 -1 */
          1,
          /* 1 0 */
          3
          /* 1 1 */
        ];
        var jsf = getJSF(coeffs[a2], coeffs[b3]);
        max2 = Math.max(jsf[0].length, max2);
        naf[a2] = new Array(max2);
        naf[b3] = new Array(max2);
        for (j2 = 0; j2 < max2; j2++) {
          var ja = jsf[0][j2] | 0;
          var jb = jsf[1][j2] | 0;
          naf[a2][j2] = index[(ja + 1) * 3 + (jb + 1)];
          naf[b3][j2] = 0;
          wnd[a2] = comb;
        }
      }
      var acc = this.jpoint(null, null, null);
      var tmp = this._wnafT4;
      for (i2 = max2; i2 >= 0; i2--) {
        var k2 = 0;
        while (i2 >= 0) {
          var zero = true;
          for (j2 = 0; j2 < len; j2++) {
            tmp[j2] = naf[j2][i2] | 0;
            if (tmp[j2] !== 0)
              zero = false;
          }
          if (!zero)
            break;
          k2++;
          i2--;
        }
        if (i2 >= 0)
          k2++;
        acc = acc.dblp(k2);
        if (i2 < 0)
          break;
        for (j2 = 0; j2 < len; j2++) {
          var z = tmp[j2];
          p3;
          if (z === 0)
            continue;
          else if (z > 0)
            p3 = wnd[j2][z - 1 >> 1];
          else if (z < 0)
            p3 = wnd[j2][-z - 1 >> 1].neg();
          if (p3.type === "affine")
            acc = acc.mixedAdd(p3);
          else
            acc = acc.add(p3);
        }
      }
      for (i2 = 0; i2 < len; i2++)
        wnd[i2] = null;
      if (jacobianResult)
        return acc;
      else
        return acc.toP();
    };
    function BasePoint(curve, type) {
      this.curve = curve;
      this.type = type;
      this.precomputed = null;
    }
    BaseCurve.BasePoint = BasePoint;
    BasePoint.prototype.eq = function eq() {
      throw new Error("Not implemented");
    };
    BasePoint.prototype.validate = function validate() {
      return this.curve.validate(this);
    };
    BaseCurve.prototype.decodePoint = function decodePoint(bytes, enc) {
      bytes = utils.toArray(bytes, enc);
      var len = this.p.byteLength();
      if ((bytes[0] === 4 || bytes[0] === 6 || bytes[0] === 7) && bytes.length - 1 === 2 * len) {
        if (bytes[0] === 6)
          assert(bytes[bytes.length - 1] % 2 === 0);
        else if (bytes[0] === 7)
          assert(bytes[bytes.length - 1] % 2 === 1);
        var res = this.point(
          bytes.slice(1, 1 + len),
          bytes.slice(1 + len, 1 + 2 * len)
        );
        return res;
      } else if ((bytes[0] === 2 || bytes[0] === 3) && bytes.length - 1 === len) {
        return this.pointFromX(bytes.slice(1, 1 + len), bytes[0] === 3);
      }
      throw new Error("Unknown point format");
    };
    BasePoint.prototype.encodeCompressed = function encodeCompressed(enc) {
      return this.encode(enc, true);
    };
    BasePoint.prototype._encode = function _encode(compact) {
      var len = this.curve.p.byteLength();
      var x3 = this.getX().toArray("be", len);
      if (compact)
        return [this.getY().isEven() ? 2 : 3].concat(x3);
      return [4].concat(x3, this.getY().toArray("be", len));
    };
    BasePoint.prototype.encode = function encode9(enc, compact) {
      return utils.encode(this._encode(compact), enc);
    };
    BasePoint.prototype.precompute = function precompute(power) {
      if (this.precomputed)
        return this;
      var precomputed = {
        doubles: null,
        naf: null,
        beta: null
      };
      precomputed.naf = this._getNAFPoints(8);
      precomputed.doubles = this._getDoubles(4, power);
      precomputed.beta = this._getBeta();
      this.precomputed = precomputed;
      return this;
    };
    BasePoint.prototype._hasDoubles = function _hasDoubles(k2) {
      if (!this.precomputed)
        return false;
      var doubles = this.precomputed.doubles;
      if (!doubles)
        return false;
      return doubles.points.length >= Math.ceil((k2.bitLength() + 1) / doubles.step);
    };
    BasePoint.prototype._getDoubles = function _getDoubles(step, power) {
      if (this.precomputed && this.precomputed.doubles)
        return this.precomputed.doubles;
      var doubles = [this];
      var acc = this;
      for (var i2 = 0; i2 < power; i2 += step) {
        for (var j2 = 0; j2 < step; j2++)
          acc = acc.dbl();
        doubles.push(acc);
      }
      return {
        step,
        points: doubles
      };
    };
    BasePoint.prototype._getNAFPoints = function _getNAFPoints(wnd) {
      if (this.precomputed && this.precomputed.naf)
        return this.precomputed.naf;
      var res = [this];
      var max2 = (1 << wnd) - 1;
      var dbl = max2 === 1 ? null : this.dbl();
      for (var i2 = 1; i2 < max2; i2++)
        res[i2] = res[i2 - 1].add(dbl);
      return {
        wnd,
        points: res
      };
    };
    BasePoint.prototype._getBeta = function _getBeta() {
      return null;
    };
    BasePoint.prototype.dblp = function dblp(k2) {
      var r = this;
      for (var i2 = 0; i2 < k2; i2++)
        r = r.dbl();
      return r;
    };
  }
});

// node_modules/elliptic/lib/elliptic/curve/short.js
var require_short = __commonJS({
  "node_modules/elliptic/lib/elliptic/curve/short.js"(exports, module) {
    "use strict";
    var utils = require_utils3();
    var BN = require_bn();
    var inherits = require_inherits_browser();
    var Base = require_base();
    var assert = utils.assert;
    function ShortCurve(conf) {
      Base.call(this, "short", conf);
      this.a = new BN(conf.a, 16).toRed(this.red);
      this.b = new BN(conf.b, 16).toRed(this.red);
      this.tinv = this.two.redInvm();
      this.zeroA = this.a.fromRed().cmpn(0) === 0;
      this.threeA = this.a.fromRed().sub(this.p).cmpn(-3) === 0;
      this.endo = this._getEndomorphism(conf);
      this._endoWnafT1 = new Array(4);
      this._endoWnafT2 = new Array(4);
    }
    inherits(ShortCurve, Base);
    module.exports = ShortCurve;
    ShortCurve.prototype._getEndomorphism = function _getEndomorphism(conf) {
      if (!this.zeroA || !this.g || !this.n || this.p.modn(3) !== 1)
        return;
      var beta;
      var lambda;
      if (conf.beta) {
        beta = new BN(conf.beta, 16).toRed(this.red);
      } else {
        var betas = this._getEndoRoots(this.p);
        beta = betas[0].cmp(betas[1]) < 0 ? betas[0] : betas[1];
        beta = beta.toRed(this.red);
      }
      if (conf.lambda) {
        lambda = new BN(conf.lambda, 16);
      } else {
        var lambdas = this._getEndoRoots(this.n);
        if (this.g.mul(lambdas[0]).x.cmp(this.g.x.redMul(beta)) === 0) {
          lambda = lambdas[0];
        } else {
          lambda = lambdas[1];
          assert(this.g.mul(lambda).x.cmp(this.g.x.redMul(beta)) === 0);
        }
      }
      var basis;
      if (conf.basis) {
        basis = conf.basis.map(function(vec) {
          return {
            a: new BN(vec.a, 16),
            b: new BN(vec.b, 16)
          };
        });
      } else {
        basis = this._getEndoBasis(lambda);
      }
      return {
        beta,
        lambda,
        basis
      };
    };
    ShortCurve.prototype._getEndoRoots = function _getEndoRoots(num) {
      var red = num === this.p ? this.red : BN.mont(num);
      var tinv = new BN(2).toRed(red).redInvm();
      var ntinv = tinv.redNeg();
      var s = new BN(3).toRed(red).redNeg().redSqrt().redMul(tinv);
      var l1 = ntinv.redAdd(s).fromRed();
      var l2 = ntinv.redSub(s).fromRed();
      return [l1, l2];
    };
    ShortCurve.prototype._getEndoBasis = function _getEndoBasis(lambda) {
      var aprxSqrt = this.n.ushrn(Math.floor(this.n.bitLength() / 2));
      var u2 = lambda;
      var v = this.n.clone();
      var x1 = new BN(1);
      var y1 = new BN(0);
      var x22 = new BN(0);
      var y22 = new BN(1);
      var a0;
      var b0;
      var a1;
      var b1;
      var a2;
      var b22;
      var prevR;
      var i2 = 0;
      var r;
      var x3;
      while (u2.cmpn(0) !== 0) {
        var q3 = v.div(u2);
        r = v.sub(q3.mul(u2));
        x3 = x22.sub(q3.mul(x1));
        var y3 = y22.sub(q3.mul(y1));
        if (!a1 && r.cmp(aprxSqrt) < 0) {
          a0 = prevR.neg();
          b0 = x1;
          a1 = r.neg();
          b1 = x3;
        } else if (a1 && ++i2 === 2) {
          break;
        }
        prevR = r;
        v = u2;
        u2 = r;
        x22 = x1;
        x1 = x3;
        y22 = y1;
        y1 = y3;
      }
      a2 = r.neg();
      b22 = x3;
      var len1 = a1.sqr().add(b1.sqr());
      var len2 = a2.sqr().add(b22.sqr());
      if (len2.cmp(len1) >= 0) {
        a2 = a0;
        b22 = b0;
      }
      if (a1.negative) {
        a1 = a1.neg();
        b1 = b1.neg();
      }
      if (a2.negative) {
        a2 = a2.neg();
        b22 = b22.neg();
      }
      return [
        { a: a1, b: b1 },
        { a: a2, b: b22 }
      ];
    };
    ShortCurve.prototype._endoSplit = function _endoSplit(k2) {
      var basis = this.endo.basis;
      var v1 = basis[0];
      var v2 = basis[1];
      var c1 = v2.b.mul(k2).divRound(this.n);
      var c2 = v1.b.neg().mul(k2).divRound(this.n);
      var p1 = c1.mul(v1.a);
      var p22 = c2.mul(v2.a);
      var q1 = c1.mul(v1.b);
      var q22 = c2.mul(v2.b);
      var k1 = k2.sub(p1).sub(p22);
      var k22 = q1.add(q22).neg();
      return { k1, k2: k22 };
    };
    ShortCurve.prototype.pointFromX = function pointFromX(x3, odd) {
      x3 = new BN(x3, 16);
      if (!x3.red)
        x3 = x3.toRed(this.red);
      var y22 = x3.redSqr().redMul(x3).redIAdd(x3.redMul(this.a)).redIAdd(this.b);
      var y3 = y22.redSqrt();
      if (y3.redSqr().redSub(y22).cmp(this.zero) !== 0)
        throw new Error("invalid point");
      var isOdd2 = y3.fromRed().isOdd();
      if (odd && !isOdd2 || !odd && isOdd2)
        y3 = y3.redNeg();
      return this.point(x3, y3);
    };
    ShortCurve.prototype.validate = function validate(point) {
      if (point.inf)
        return true;
      var x3 = point.x;
      var y3 = point.y;
      var ax = this.a.redMul(x3);
      var rhs = x3.redSqr().redMul(x3).redIAdd(ax).redIAdd(this.b);
      return y3.redSqr().redISub(rhs).cmpn(0) === 0;
    };
    ShortCurve.prototype._endoWnafMulAdd = function _endoWnafMulAdd(points, coeffs, jacobianResult) {
      var npoints = this._endoWnafT1;
      var ncoeffs = this._endoWnafT2;
      for (var i2 = 0; i2 < points.length; i2++) {
        var split = this._endoSplit(coeffs[i2]);
        var p3 = points[i2];
        var beta = p3._getBeta();
        if (split.k1.negative) {
          split.k1.ineg();
          p3 = p3.neg(true);
        }
        if (split.k2.negative) {
          split.k2.ineg();
          beta = beta.neg(true);
        }
        npoints[i2 * 2] = p3;
        npoints[i2 * 2 + 1] = beta;
        ncoeffs[i2 * 2] = split.k1;
        ncoeffs[i2 * 2 + 1] = split.k2;
      }
      var res = this._wnafMulAdd(1, npoints, ncoeffs, i2 * 2, jacobianResult);
      for (var j2 = 0; j2 < i2 * 2; j2++) {
        npoints[j2] = null;
        ncoeffs[j2] = null;
      }
      return res;
    };
    function Point(curve, x3, y3, isRed) {
      Base.BasePoint.call(this, curve, "affine");
      if (x3 === null && y3 === null) {
        this.x = null;
        this.y = null;
        this.inf = true;
      } else {
        this.x = new BN(x3, 16);
        this.y = new BN(y3, 16);
        if (isRed) {
          this.x.forceRed(this.curve.red);
          this.y.forceRed(this.curve.red);
        }
        if (!this.x.red)
          this.x = this.x.toRed(this.curve.red);
        if (!this.y.red)
          this.y = this.y.toRed(this.curve.red);
        this.inf = false;
      }
    }
    inherits(Point, Base.BasePoint);
    ShortCurve.prototype.point = function point(x3, y3, isRed) {
      return new Point(this, x3, y3, isRed);
    };
    ShortCurve.prototype.pointFromJSON = function pointFromJSON(obj, red) {
      return Point.fromJSON(this, obj, red);
    };
    Point.prototype._getBeta = function _getBeta() {
      if (!this.curve.endo)
        return;
      var pre = this.precomputed;
      if (pre && pre.beta)
        return pre.beta;
      var beta = this.curve.point(this.x.redMul(this.curve.endo.beta), this.y);
      if (pre) {
        var curve = this.curve;
        var endoMul = function(p3) {
          return curve.point(p3.x.redMul(curve.endo.beta), p3.y);
        };
        pre.beta = beta;
        beta.precomputed = {
          beta: null,
          naf: pre.naf && {
            wnd: pre.naf.wnd,
            points: pre.naf.points.map(endoMul)
          },
          doubles: pre.doubles && {
            step: pre.doubles.step,
            points: pre.doubles.points.map(endoMul)
          }
        };
      }
      return beta;
    };
    Point.prototype.toJSON = function toJSON() {
      if (!this.precomputed)
        return [this.x, this.y];
      return [this.x, this.y, this.precomputed && {
        doubles: this.precomputed.doubles && {
          step: this.precomputed.doubles.step,
          points: this.precomputed.doubles.points.slice(1)
        },
        naf: this.precomputed.naf && {
          wnd: this.precomputed.naf.wnd,
          points: this.precomputed.naf.points.slice(1)
        }
      }];
    };
    Point.fromJSON = function fromJSON(curve, obj, red) {
      if (typeof obj === "string")
        obj = JSON.parse(obj);
      var res = curve.point(obj[0], obj[1], red);
      if (!obj[2])
        return res;
      function obj2point(obj2) {
        return curve.point(obj2[0], obj2[1], red);
      }
      var pre = obj[2];
      res.precomputed = {
        beta: null,
        doubles: pre.doubles && {
          step: pre.doubles.step,
          points: [res].concat(pre.doubles.points.map(obj2point))
        },
        naf: pre.naf && {
          wnd: pre.naf.wnd,
          points: [res].concat(pre.naf.points.map(obj2point))
        }
      };
      return res;
    };
    Point.prototype.inspect = function inspect() {
      if (this.isInfinity())
        return "<EC Point Infinity>";
      return "<EC Point x: " + this.x.fromRed().toString(16, 2) + " y: " + this.y.fromRed().toString(16, 2) + ">";
    };
    Point.prototype.isInfinity = function isInfinity() {
      return this.inf;
    };
    Point.prototype.add = function add(p3) {
      if (this.inf)
        return p3;
      if (p3.inf)
        return this;
      if (this.eq(p3))
        return this.dbl();
      if (this.neg().eq(p3))
        return this.curve.point(null, null);
      if (this.x.cmp(p3.x) === 0)
        return this.curve.point(null, null);
      var c2 = this.y.redSub(p3.y);
      if (c2.cmpn(0) !== 0)
        c2 = c2.redMul(this.x.redSub(p3.x).redInvm());
      var nx = c2.redSqr().redISub(this.x).redISub(p3.x);
      var ny = c2.redMul(this.x.redSub(nx)).redISub(this.y);
      return this.curve.point(nx, ny);
    };
    Point.prototype.dbl = function dbl() {
      if (this.inf)
        return this;
      var ys1 = this.y.redAdd(this.y);
      if (ys1.cmpn(0) === 0)
        return this.curve.point(null, null);
      var a2 = this.curve.a;
      var x22 = this.x.redSqr();
      var dyinv = ys1.redInvm();
      var c2 = x22.redAdd(x22).redIAdd(x22).redIAdd(a2).redMul(dyinv);
      var nx = c2.redSqr().redISub(this.x.redAdd(this.x));
      var ny = c2.redMul(this.x.redSub(nx)).redISub(this.y);
      return this.curve.point(nx, ny);
    };
    Point.prototype.getX = function getX() {
      return this.x.fromRed();
    };
    Point.prototype.getY = function getY() {
      return this.y.fromRed();
    };
    Point.prototype.mul = function mul(k2) {
      k2 = new BN(k2, 16);
      if (this.isInfinity())
        return this;
      else if (this._hasDoubles(k2))
        return this.curve._fixedNafMul(this, k2);
      else if (this.curve.endo)
        return this.curve._endoWnafMulAdd([this], [k2]);
      else
        return this.curve._wnafMul(this, k2);
    };
    Point.prototype.mulAdd = function mulAdd(k1, p22, k2) {
      var points = [this, p22];
      var coeffs = [k1, k2];
      if (this.curve.endo)
        return this.curve._endoWnafMulAdd(points, coeffs);
      else
        return this.curve._wnafMulAdd(1, points, coeffs, 2);
    };
    Point.prototype.jmulAdd = function jmulAdd(k1, p22, k2) {
      var points = [this, p22];
      var coeffs = [k1, k2];
      if (this.curve.endo)
        return this.curve._endoWnafMulAdd(points, coeffs, true);
      else
        return this.curve._wnafMulAdd(1, points, coeffs, 2, true);
    };
    Point.prototype.eq = function eq(p3) {
      return this === p3 || this.inf === p3.inf && (this.inf || this.x.cmp(p3.x) === 0 && this.y.cmp(p3.y) === 0);
    };
    Point.prototype.neg = function neg(_precompute) {
      if (this.inf)
        return this;
      var res = this.curve.point(this.x, this.y.redNeg());
      if (_precompute && this.precomputed) {
        var pre = this.precomputed;
        var negate = function(p3) {
          return p3.neg();
        };
        res.precomputed = {
          naf: pre.naf && {
            wnd: pre.naf.wnd,
            points: pre.naf.points.map(negate)
          },
          doubles: pre.doubles && {
            step: pre.doubles.step,
            points: pre.doubles.points.map(negate)
          }
        };
      }
      return res;
    };
    Point.prototype.toJ = function toJ() {
      if (this.inf)
        return this.curve.jpoint(null, null, null);
      var res = this.curve.jpoint(this.x, this.y, this.curve.one);
      return res;
    };
    function JPoint(curve, x3, y3, z) {
      Base.BasePoint.call(this, curve, "jacobian");
      if (x3 === null && y3 === null && z === null) {
        this.x = this.curve.one;
        this.y = this.curve.one;
        this.z = new BN(0);
      } else {
        this.x = new BN(x3, 16);
        this.y = new BN(y3, 16);
        this.z = new BN(z, 16);
      }
      if (!this.x.red)
        this.x = this.x.toRed(this.curve.red);
      if (!this.y.red)
        this.y = this.y.toRed(this.curve.red);
      if (!this.z.red)
        this.z = this.z.toRed(this.curve.red);
      this.zOne = this.z === this.curve.one;
    }
    inherits(JPoint, Base.BasePoint);
    ShortCurve.prototype.jpoint = function jpoint(x3, y3, z) {
      return new JPoint(this, x3, y3, z);
    };
    JPoint.prototype.toP = function toP() {
      if (this.isInfinity())
        return this.curve.point(null, null);
      var zinv = this.z.redInvm();
      var zinv2 = zinv.redSqr();
      var ax = this.x.redMul(zinv2);
      var ay = this.y.redMul(zinv2).redMul(zinv);
      return this.curve.point(ax, ay);
    };
    JPoint.prototype.neg = function neg() {
      return this.curve.jpoint(this.x, this.y.redNeg(), this.z);
    };
    JPoint.prototype.add = function add(p3) {
      if (this.isInfinity())
        return p3;
      if (p3.isInfinity())
        return this;
      var pz2 = p3.z.redSqr();
      var z2 = this.z.redSqr();
      var u1 = this.x.redMul(pz2);
      var u2 = p3.x.redMul(z2);
      var s1 = this.y.redMul(pz2.redMul(p3.z));
      var s2 = p3.y.redMul(z2.redMul(this.z));
      var h3 = u1.redSub(u2);
      var r = s1.redSub(s2);
      if (h3.cmpn(0) === 0) {
        if (r.cmpn(0) !== 0)
          return this.curve.jpoint(null, null, null);
        else
          return this.dbl();
      }
      var h22 = h3.redSqr();
      var h32 = h22.redMul(h3);
      var v = u1.redMul(h22);
      var nx = r.redSqr().redIAdd(h32).redISub(v).redISub(v);
      var ny = r.redMul(v.redISub(nx)).redISub(s1.redMul(h32));
      var nz = this.z.redMul(p3.z).redMul(h3);
      return this.curve.jpoint(nx, ny, nz);
    };
    JPoint.prototype.mixedAdd = function mixedAdd(p3) {
      if (this.isInfinity())
        return p3.toJ();
      if (p3.isInfinity())
        return this;
      var z2 = this.z.redSqr();
      var u1 = this.x;
      var u2 = p3.x.redMul(z2);
      var s1 = this.y;
      var s2 = p3.y.redMul(z2).redMul(this.z);
      var h3 = u1.redSub(u2);
      var r = s1.redSub(s2);
      if (h3.cmpn(0) === 0) {
        if (r.cmpn(0) !== 0)
          return this.curve.jpoint(null, null, null);
        else
          return this.dbl();
      }
      var h22 = h3.redSqr();
      var h32 = h22.redMul(h3);
      var v = u1.redMul(h22);
      var nx = r.redSqr().redIAdd(h32).redISub(v).redISub(v);
      var ny = r.redMul(v.redISub(nx)).redISub(s1.redMul(h32));
      var nz = this.z.redMul(h3);
      return this.curve.jpoint(nx, ny, nz);
    };
    JPoint.prototype.dblp = function dblp(pow) {
      if (pow === 0)
        return this;
      if (this.isInfinity())
        return this;
      if (!pow)
        return this.dbl();
      var i2;
      if (this.curve.zeroA || this.curve.threeA) {
        var r = this;
        for (i2 = 0; i2 < pow; i2++)
          r = r.dbl();
        return r;
      }
      var a2 = this.curve.a;
      var tinv = this.curve.tinv;
      var jx = this.x;
      var jy = this.y;
      var jz = this.z;
      var jz4 = jz.redSqr().redSqr();
      var jyd = jy.redAdd(jy);
      for (i2 = 0; i2 < pow; i2++) {
        var jx2 = jx.redSqr();
        var jyd2 = jyd.redSqr();
        var jyd4 = jyd2.redSqr();
        var c2 = jx2.redAdd(jx2).redIAdd(jx2).redIAdd(a2.redMul(jz4));
        var t1 = jx.redMul(jyd2);
        var nx = c2.redSqr().redISub(t1.redAdd(t1));
        var t2 = t1.redISub(nx);
        var dny = c2.redMul(t2);
        dny = dny.redIAdd(dny).redISub(jyd4);
        var nz = jyd.redMul(jz);
        if (i2 + 1 < pow)
          jz4 = jz4.redMul(jyd4);
        jx = nx;
        jz = nz;
        jyd = dny;
      }
      return this.curve.jpoint(jx, jyd.redMul(tinv), jz);
    };
    JPoint.prototype.dbl = function dbl() {
      if (this.isInfinity())
        return this;
      if (this.curve.zeroA)
        return this._zeroDbl();
      else if (this.curve.threeA)
        return this._threeDbl();
      else
        return this._dbl();
    };
    JPoint.prototype._zeroDbl = function _zeroDbl() {
      var nx;
      var ny;
      var nz;
      if (this.zOne) {
        var xx = this.x.redSqr();
        var yy = this.y.redSqr();
        var yyyy = yy.redSqr();
        var s = this.x.redAdd(yy).redSqr().redISub(xx).redISub(yyyy);
        s = s.redIAdd(s);
        var m2 = xx.redAdd(xx).redIAdd(xx);
        var t = m2.redSqr().redISub(s).redISub(s);
        var yyyy8 = yyyy.redIAdd(yyyy);
        yyyy8 = yyyy8.redIAdd(yyyy8);
        yyyy8 = yyyy8.redIAdd(yyyy8);
        nx = t;
        ny = m2.redMul(s.redISub(t)).redISub(yyyy8);
        nz = this.y.redAdd(this.y);
      } else {
        var a2 = this.x.redSqr();
        var b3 = this.y.redSqr();
        var c2 = b3.redSqr();
        var d2 = this.x.redAdd(b3).redSqr().redISub(a2).redISub(c2);
        d2 = d2.redIAdd(d2);
        var e = a2.redAdd(a2).redIAdd(a2);
        var f2 = e.redSqr();
        var c8 = c2.redIAdd(c2);
        c8 = c8.redIAdd(c8);
        c8 = c8.redIAdd(c8);
        nx = f2.redISub(d2).redISub(d2);
        ny = e.redMul(d2.redISub(nx)).redISub(c8);
        nz = this.y.redMul(this.z);
        nz = nz.redIAdd(nz);
      }
      return this.curve.jpoint(nx, ny, nz);
    };
    JPoint.prototype._threeDbl = function _threeDbl() {
      var nx;
      var ny;
      var nz;
      if (this.zOne) {
        var xx = this.x.redSqr();
        var yy = this.y.redSqr();
        var yyyy = yy.redSqr();
        var s = this.x.redAdd(yy).redSqr().redISub(xx).redISub(yyyy);
        s = s.redIAdd(s);
        var m2 = xx.redAdd(xx).redIAdd(xx).redIAdd(this.curve.a);
        var t = m2.redSqr().redISub(s).redISub(s);
        nx = t;
        var yyyy8 = yyyy.redIAdd(yyyy);
        yyyy8 = yyyy8.redIAdd(yyyy8);
        yyyy8 = yyyy8.redIAdd(yyyy8);
        ny = m2.redMul(s.redISub(t)).redISub(yyyy8);
        nz = this.y.redAdd(this.y);
      } else {
        var delta = this.z.redSqr();
        var gamma = this.y.redSqr();
        var beta = this.x.redMul(gamma);
        var alpha = this.x.redSub(delta).redMul(this.x.redAdd(delta));
        alpha = alpha.redAdd(alpha).redIAdd(alpha);
        var beta4 = beta.redIAdd(beta);
        beta4 = beta4.redIAdd(beta4);
        var beta8 = beta4.redAdd(beta4);
        nx = alpha.redSqr().redISub(beta8);
        nz = this.y.redAdd(this.z).redSqr().redISub(gamma).redISub(delta);
        var ggamma8 = gamma.redSqr();
        ggamma8 = ggamma8.redIAdd(ggamma8);
        ggamma8 = ggamma8.redIAdd(ggamma8);
        ggamma8 = ggamma8.redIAdd(ggamma8);
        ny = alpha.redMul(beta4.redISub(nx)).redISub(ggamma8);
      }
      return this.curve.jpoint(nx, ny, nz);
    };
    JPoint.prototype._dbl = function _dbl() {
      var a2 = this.curve.a;
      var jx = this.x;
      var jy = this.y;
      var jz = this.z;
      var jz4 = jz.redSqr().redSqr();
      var jx2 = jx.redSqr();
      var jy2 = jy.redSqr();
      var c2 = jx2.redAdd(jx2).redIAdd(jx2).redIAdd(a2.redMul(jz4));
      var jxd4 = jx.redAdd(jx);
      jxd4 = jxd4.redIAdd(jxd4);
      var t1 = jxd4.redMul(jy2);
      var nx = c2.redSqr().redISub(t1.redAdd(t1));
      var t2 = t1.redISub(nx);
      var jyd8 = jy2.redSqr();
      jyd8 = jyd8.redIAdd(jyd8);
      jyd8 = jyd8.redIAdd(jyd8);
      jyd8 = jyd8.redIAdd(jyd8);
      var ny = c2.redMul(t2).redISub(jyd8);
      var nz = jy.redAdd(jy).redMul(jz);
      return this.curve.jpoint(nx, ny, nz);
    };
    JPoint.prototype.trpl = function trpl() {
      if (!this.curve.zeroA)
        return this.dbl().add(this);
      var xx = this.x.redSqr();
      var yy = this.y.redSqr();
      var zz = this.z.redSqr();
      var yyyy = yy.redSqr();
      var m2 = xx.redAdd(xx).redIAdd(xx);
      var mm = m2.redSqr();
      var e = this.x.redAdd(yy).redSqr().redISub(xx).redISub(yyyy);
      e = e.redIAdd(e);
      e = e.redAdd(e).redIAdd(e);
      e = e.redISub(mm);
      var ee2 = e.redSqr();
      var t = yyyy.redIAdd(yyyy);
      t = t.redIAdd(t);
      t = t.redIAdd(t);
      t = t.redIAdd(t);
      var u2 = m2.redIAdd(e).redSqr().redISub(mm).redISub(ee2).redISub(t);
      var yyu4 = yy.redMul(u2);
      yyu4 = yyu4.redIAdd(yyu4);
      yyu4 = yyu4.redIAdd(yyu4);
      var nx = this.x.redMul(ee2).redISub(yyu4);
      nx = nx.redIAdd(nx);
      nx = nx.redIAdd(nx);
      var ny = this.y.redMul(u2.redMul(t.redISub(u2)).redISub(e.redMul(ee2)));
      ny = ny.redIAdd(ny);
      ny = ny.redIAdd(ny);
      ny = ny.redIAdd(ny);
      var nz = this.z.redAdd(e).redSqr().redISub(zz).redISub(ee2);
      return this.curve.jpoint(nx, ny, nz);
    };
    JPoint.prototype.mul = function mul(k2, kbase) {
      k2 = new BN(k2, kbase);
      return this.curve._wnafMul(this, k2);
    };
    JPoint.prototype.eq = function eq(p3) {
      if (p3.type === "affine")
        return this.eq(p3.toJ());
      if (this === p3)
        return true;
      var z2 = this.z.redSqr();
      var pz2 = p3.z.redSqr();
      if (this.x.redMul(pz2).redISub(p3.x.redMul(z2)).cmpn(0) !== 0)
        return false;
      var z3 = z2.redMul(this.z);
      var pz3 = pz2.redMul(p3.z);
      return this.y.redMul(pz3).redISub(p3.y.redMul(z3)).cmpn(0) === 0;
    };
    JPoint.prototype.eqXToP = function eqXToP(x3) {
      var zs2 = this.z.redSqr();
      var rx = x3.toRed(this.curve.red).redMul(zs2);
      if (this.x.cmp(rx) === 0)
        return true;
      var xc = x3.clone();
      var t = this.curve.redN.redMul(zs2);
      for (; ; ) {
        xc.iadd(this.curve.n);
        if (xc.cmp(this.curve.p) >= 0)
          return false;
        rx.redIAdd(t);
        if (this.x.cmp(rx) === 0)
          return true;
      }
    };
    JPoint.prototype.inspect = function inspect() {
      if (this.isInfinity())
        return "<EC JPoint Infinity>";
      return "<EC JPoint x: " + this.x.toString(16, 2) + " y: " + this.y.toString(16, 2) + " z: " + this.z.toString(16, 2) + ">";
    };
    JPoint.prototype.isInfinity = function isInfinity() {
      return this.z.cmpn(0) === 0;
    };
  }
});

// node_modules/elliptic/lib/elliptic/curve/mont.js
var require_mont = __commonJS({
  "node_modules/elliptic/lib/elliptic/curve/mont.js"(exports, module) {
    "use strict";
    var BN = require_bn();
    var inherits = require_inherits_browser();
    var Base = require_base();
    var utils = require_utils3();
    function MontCurve(conf) {
      Base.call(this, "mont", conf);
      this.a = new BN(conf.a, 16).toRed(this.red);
      this.b = new BN(conf.b, 16).toRed(this.red);
      this.i4 = new BN(4).toRed(this.red).redInvm();
      this.two = new BN(2).toRed(this.red);
      this.a24 = this.i4.redMul(this.a.redAdd(this.two));
    }
    inherits(MontCurve, Base);
    module.exports = MontCurve;
    MontCurve.prototype.validate = function validate(point) {
      var x3 = point.normalize().x;
      var x22 = x3.redSqr();
      var rhs = x22.redMul(x3).redAdd(x22.redMul(this.a)).redAdd(x3);
      var y3 = rhs.redSqrt();
      return y3.redSqr().cmp(rhs) === 0;
    };
    function Point(curve, x3, z) {
      Base.BasePoint.call(this, curve, "projective");
      if (x3 === null && z === null) {
        this.x = this.curve.one;
        this.z = this.curve.zero;
      } else {
        this.x = new BN(x3, 16);
        this.z = new BN(z, 16);
        if (!this.x.red)
          this.x = this.x.toRed(this.curve.red);
        if (!this.z.red)
          this.z = this.z.toRed(this.curve.red);
      }
    }
    inherits(Point, Base.BasePoint);
    MontCurve.prototype.decodePoint = function decodePoint(bytes, enc) {
      return this.point(utils.toArray(bytes, enc), 1);
    };
    MontCurve.prototype.point = function point(x3, z) {
      return new Point(this, x3, z);
    };
    MontCurve.prototype.pointFromJSON = function pointFromJSON(obj) {
      return Point.fromJSON(this, obj);
    };
    Point.prototype.precompute = function precompute() {
    };
    Point.prototype._encode = function _encode() {
      return this.getX().toArray("be", this.curve.p.byteLength());
    };
    Point.fromJSON = function fromJSON(curve, obj) {
      return new Point(curve, obj[0], obj[1] || curve.one);
    };
    Point.prototype.inspect = function inspect() {
      if (this.isInfinity())
        return "<EC Point Infinity>";
      return "<EC Point x: " + this.x.fromRed().toString(16, 2) + " z: " + this.z.fromRed().toString(16, 2) + ">";
    };
    Point.prototype.isInfinity = function isInfinity() {
      return this.z.cmpn(0) === 0;
    };
    Point.prototype.dbl = function dbl() {
      var a2 = this.x.redAdd(this.z);
      var aa = a2.redSqr();
      var b3 = this.x.redSub(this.z);
      var bb = b3.redSqr();
      var c2 = aa.redSub(bb);
      var nx = aa.redMul(bb);
      var nz = c2.redMul(bb.redAdd(this.curve.a24.redMul(c2)));
      return this.curve.point(nx, nz);
    };
    Point.prototype.add = function add() {
      throw new Error("Not supported on Montgomery curve");
    };
    Point.prototype.diffAdd = function diffAdd(p3, diff) {
      var a2 = this.x.redAdd(this.z);
      var b3 = this.x.redSub(this.z);
      var c2 = p3.x.redAdd(p3.z);
      var d2 = p3.x.redSub(p3.z);
      var da = d2.redMul(a2);
      var cb = c2.redMul(b3);
      var nx = diff.z.redMul(da.redAdd(cb).redSqr());
      var nz = diff.x.redMul(da.redISub(cb).redSqr());
      return this.curve.point(nx, nz);
    };
    Point.prototype.mul = function mul(k2) {
      var t = k2.clone();
      var a2 = this;
      var b3 = this.curve.point(null, null);
      var c2 = this;
      for (var bits = []; t.cmpn(0) !== 0; t.iushrn(1))
        bits.push(t.andln(1));
      for (var i2 = bits.length - 1; i2 >= 0; i2--) {
        if (bits[i2] === 0) {
          a2 = a2.diffAdd(b3, c2);
          b3 = b3.dbl();
        } else {
          b3 = a2.diffAdd(b3, c2);
          a2 = a2.dbl();
        }
      }
      return b3;
    };
    Point.prototype.mulAdd = function mulAdd() {
      throw new Error("Not supported on Montgomery curve");
    };
    Point.prototype.jumlAdd = function jumlAdd() {
      throw new Error("Not supported on Montgomery curve");
    };
    Point.prototype.eq = function eq(other) {
      return this.getX().cmp(other.getX()) === 0;
    };
    Point.prototype.normalize = function normalize() {
      this.x = this.x.redMul(this.z.redInvm());
      this.z = this.curve.one;
      return this;
    };
    Point.prototype.getX = function getX() {
      this.normalize();
      return this.x.fromRed();
    };
  }
});

// node_modules/elliptic/lib/elliptic/curve/edwards.js
var require_edwards = __commonJS({
  "node_modules/elliptic/lib/elliptic/curve/edwards.js"(exports, module) {
    "use strict";
    var utils = require_utils3();
    var BN = require_bn();
    var inherits = require_inherits_browser();
    var Base = require_base();
    var assert = utils.assert;
    function EdwardsCurve(conf) {
      this.twisted = (conf.a | 0) !== 1;
      this.mOneA = this.twisted && (conf.a | 0) === -1;
      this.extended = this.mOneA;
      Base.call(this, "edwards", conf);
      this.a = new BN(conf.a, 16).umod(this.red.m);
      this.a = this.a.toRed(this.red);
      this.c = new BN(conf.c, 16).toRed(this.red);
      this.c2 = this.c.redSqr();
      this.d = new BN(conf.d, 16).toRed(this.red);
      this.dd = this.d.redAdd(this.d);
      assert(!this.twisted || this.c.fromRed().cmpn(1) === 0);
      this.oneC = (conf.c | 0) === 1;
    }
    inherits(EdwardsCurve, Base);
    module.exports = EdwardsCurve;
    EdwardsCurve.prototype._mulA = function _mulA(num) {
      if (this.mOneA)
        return num.redNeg();
      else
        return this.a.redMul(num);
    };
    EdwardsCurve.prototype._mulC = function _mulC(num) {
      if (this.oneC)
        return num;
      else
        return this.c.redMul(num);
    };
    EdwardsCurve.prototype.jpoint = function jpoint(x3, y3, z, t) {
      return this.point(x3, y3, z, t);
    };
    EdwardsCurve.prototype.pointFromX = function pointFromX(x3, odd) {
      x3 = new BN(x3, 16);
      if (!x3.red)
        x3 = x3.toRed(this.red);
      var x22 = x3.redSqr();
      var rhs = this.c2.redSub(this.a.redMul(x22));
      var lhs = this.one.redSub(this.c2.redMul(this.d).redMul(x22));
      var y22 = rhs.redMul(lhs.redInvm());
      var y3 = y22.redSqrt();
      if (y3.redSqr().redSub(y22).cmp(this.zero) !== 0)
        throw new Error("invalid point");
      var isOdd2 = y3.fromRed().isOdd();
      if (odd && !isOdd2 || !odd && isOdd2)
        y3 = y3.redNeg();
      return this.point(x3, y3);
    };
    EdwardsCurve.prototype.pointFromY = function pointFromY(y3, odd) {
      y3 = new BN(y3, 16);
      if (!y3.red)
        y3 = y3.toRed(this.red);
      var y22 = y3.redSqr();
      var lhs = y22.redSub(this.c2);
      var rhs = y22.redMul(this.d).redMul(this.c2).redSub(this.a);
      var x22 = lhs.redMul(rhs.redInvm());
      if (x22.cmp(this.zero) === 0) {
        if (odd)
          throw new Error("invalid point");
        else
          return this.point(this.zero, y3);
      }
      var x3 = x22.redSqrt();
      if (x3.redSqr().redSub(x22).cmp(this.zero) !== 0)
        throw new Error("invalid point");
      if (x3.fromRed().isOdd() !== odd)
        x3 = x3.redNeg();
      return this.point(x3, y3);
    };
    EdwardsCurve.prototype.validate = function validate(point) {
      if (point.isInfinity())
        return true;
      point.normalize();
      var x22 = point.x.redSqr();
      var y22 = point.y.redSqr();
      var lhs = x22.redMul(this.a).redAdd(y22);
      var rhs = this.c2.redMul(this.one.redAdd(this.d.redMul(x22).redMul(y22)));
      return lhs.cmp(rhs) === 0;
    };
    function Point(curve, x3, y3, z, t) {
      Base.BasePoint.call(this, curve, "projective");
      if (x3 === null && y3 === null && z === null) {
        this.x = this.curve.zero;
        this.y = this.curve.one;
        this.z = this.curve.one;
        this.t = this.curve.zero;
        this.zOne = true;
      } else {
        this.x = new BN(x3, 16);
        this.y = new BN(y3, 16);
        this.z = z ? new BN(z, 16) : this.curve.one;
        this.t = t && new BN(t, 16);
        if (!this.x.red)
          this.x = this.x.toRed(this.curve.red);
        if (!this.y.red)
          this.y = this.y.toRed(this.curve.red);
        if (!this.z.red)
          this.z = this.z.toRed(this.curve.red);
        if (this.t && !this.t.red)
          this.t = this.t.toRed(this.curve.red);
        this.zOne = this.z === this.curve.one;
        if (this.curve.extended && !this.t) {
          this.t = this.x.redMul(this.y);
          if (!this.zOne)
            this.t = this.t.redMul(this.z.redInvm());
        }
      }
    }
    inherits(Point, Base.BasePoint);
    EdwardsCurve.prototype.pointFromJSON = function pointFromJSON(obj) {
      return Point.fromJSON(this, obj);
    };
    EdwardsCurve.prototype.point = function point(x3, y3, z, t) {
      return new Point(this, x3, y3, z, t);
    };
    Point.fromJSON = function fromJSON(curve, obj) {
      return new Point(curve, obj[0], obj[1], obj[2]);
    };
    Point.prototype.inspect = function inspect() {
      if (this.isInfinity())
        return "<EC Point Infinity>";
      return "<EC Point x: " + this.x.fromRed().toString(16, 2) + " y: " + this.y.fromRed().toString(16, 2) + " z: " + this.z.fromRed().toString(16, 2) + ">";
    };
    Point.prototype.isInfinity = function isInfinity() {
      return this.x.cmpn(0) === 0 && (this.y.cmp(this.z) === 0 || this.zOne && this.y.cmp(this.curve.c) === 0);
    };
    Point.prototype._extDbl = function _extDbl() {
      var a2 = this.x.redSqr();
      var b3 = this.y.redSqr();
      var c2 = this.z.redSqr();
      c2 = c2.redIAdd(c2);
      var d2 = this.curve._mulA(a2);
      var e = this.x.redAdd(this.y).redSqr().redISub(a2).redISub(b3);
      var g4 = d2.redAdd(b3);
      var f2 = g4.redSub(c2);
      var h3 = d2.redSub(b3);
      var nx = e.redMul(f2);
      var ny = g4.redMul(h3);
      var nt3 = e.redMul(h3);
      var nz = f2.redMul(g4);
      return this.curve.point(nx, ny, nz, nt3);
    };
    Point.prototype._projDbl = function _projDbl() {
      var b3 = this.x.redAdd(this.y).redSqr();
      var c2 = this.x.redSqr();
      var d2 = this.y.redSqr();
      var nx;
      var ny;
      var nz;
      var e;
      var h3;
      var j2;
      if (this.curve.twisted) {
        e = this.curve._mulA(c2);
        var f2 = e.redAdd(d2);
        if (this.zOne) {
          nx = b3.redSub(c2).redSub(d2).redMul(f2.redSub(this.curve.two));
          ny = f2.redMul(e.redSub(d2));
          nz = f2.redSqr().redSub(f2).redSub(f2);
        } else {
          h3 = this.z.redSqr();
          j2 = f2.redSub(h3).redISub(h3);
          nx = b3.redSub(c2).redISub(d2).redMul(j2);
          ny = f2.redMul(e.redSub(d2));
          nz = f2.redMul(j2);
        }
      } else {
        e = c2.redAdd(d2);
        h3 = this.curve._mulC(this.z).redSqr();
        j2 = e.redSub(h3).redSub(h3);
        nx = this.curve._mulC(b3.redISub(e)).redMul(j2);
        ny = this.curve._mulC(e).redMul(c2.redISub(d2));
        nz = e.redMul(j2);
      }
      return this.curve.point(nx, ny, nz);
    };
    Point.prototype.dbl = function dbl() {
      if (this.isInfinity())
        return this;
      if (this.curve.extended)
        return this._extDbl();
      else
        return this._projDbl();
    };
    Point.prototype._extAdd = function _extAdd(p3) {
      var a2 = this.y.redSub(this.x).redMul(p3.y.redSub(p3.x));
      var b3 = this.y.redAdd(this.x).redMul(p3.y.redAdd(p3.x));
      var c2 = this.t.redMul(this.curve.dd).redMul(p3.t);
      var d2 = this.z.redMul(p3.z.redAdd(p3.z));
      var e = b3.redSub(a2);
      var f2 = d2.redSub(c2);
      var g4 = d2.redAdd(c2);
      var h3 = b3.redAdd(a2);
      var nx = e.redMul(f2);
      var ny = g4.redMul(h3);
      var nt3 = e.redMul(h3);
      var nz = f2.redMul(g4);
      return this.curve.point(nx, ny, nz, nt3);
    };
    Point.prototype._projAdd = function _projAdd(p3) {
      var a2 = this.z.redMul(p3.z);
      var b3 = a2.redSqr();
      var c2 = this.x.redMul(p3.x);
      var d2 = this.y.redMul(p3.y);
      var e = this.curve.d.redMul(c2).redMul(d2);
      var f2 = b3.redSub(e);
      var g4 = b3.redAdd(e);
      var tmp = this.x.redAdd(this.y).redMul(p3.x.redAdd(p3.y)).redISub(c2).redISub(d2);
      var nx = a2.redMul(f2).redMul(tmp);
      var ny;
      var nz;
      if (this.curve.twisted) {
        ny = a2.redMul(g4).redMul(d2.redSub(this.curve._mulA(c2)));
        nz = f2.redMul(g4);
      } else {
        ny = a2.redMul(g4).redMul(d2.redSub(c2));
        nz = this.curve._mulC(f2).redMul(g4);
      }
      return this.curve.point(nx, ny, nz);
    };
    Point.prototype.add = function add(p3) {
      if (this.isInfinity())
        return p3;
      if (p3.isInfinity())
        return this;
      if (this.curve.extended)
        return this._extAdd(p3);
      else
        return this._projAdd(p3);
    };
    Point.prototype.mul = function mul(k2) {
      if (this._hasDoubles(k2))
        return this.curve._fixedNafMul(this, k2);
      else
        return this.curve._wnafMul(this, k2);
    };
    Point.prototype.mulAdd = function mulAdd(k1, p3, k2) {
      return this.curve._wnafMulAdd(1, [this, p3], [k1, k2], 2, false);
    };
    Point.prototype.jmulAdd = function jmulAdd(k1, p3, k2) {
      return this.curve._wnafMulAdd(1, [this, p3], [k1, k2], 2, true);
    };
    Point.prototype.normalize = function normalize() {
      if (this.zOne)
        return this;
      var zi2 = this.z.redInvm();
      this.x = this.x.redMul(zi2);
      this.y = this.y.redMul(zi2);
      if (this.t)
        this.t = this.t.redMul(zi2);
      this.z = this.curve.one;
      this.zOne = true;
      return this;
    };
    Point.prototype.neg = function neg() {
      return this.curve.point(
        this.x.redNeg(),
        this.y,
        this.z,
        this.t && this.t.redNeg()
      );
    };
    Point.prototype.getX = function getX() {
      this.normalize();
      return this.x.fromRed();
    };
    Point.prototype.getY = function getY() {
      this.normalize();
      return this.y.fromRed();
    };
    Point.prototype.eq = function eq(other) {
      return this === other || this.getX().cmp(other.getX()) === 0 && this.getY().cmp(other.getY()) === 0;
    };
    Point.prototype.eqXToP = function eqXToP(x3) {
      var rx = x3.toRed(this.curve.red).redMul(this.z);
      if (this.x.cmp(rx) === 0)
        return true;
      var xc = x3.clone();
      var t = this.curve.redN.redMul(this.z);
      for (; ; ) {
        xc.iadd(this.curve.n);
        if (xc.cmp(this.curve.p) >= 0)
          return false;
        rx.redIAdd(t);
        if (this.x.cmp(rx) === 0)
          return true;
      }
    };
    Point.prototype.toP = Point.prototype.normalize;
    Point.prototype.mixedAdd = Point.prototype.add;
  }
});

// node_modules/elliptic/lib/elliptic/curve/index.js
var require_curve = __commonJS({
  "node_modules/elliptic/lib/elliptic/curve/index.js"(exports) {
    "use strict";
    var curve = exports;
    curve.base = require_base();
    curve.short = require_short();
    curve.mont = require_mont();
    curve.edwards = require_edwards();
  }
});

// node_modules/hash.js/lib/hash/utils.js
var require_utils4 = __commonJS({
  "node_modules/hash.js/lib/hash/utils.js"(exports) {
    "use strict";
    var assert = require_minimalistic_assert();
    var inherits = require_inherits_browser();
    exports.inherits = inherits;
    function isSurrogatePair(msg, i2) {
      if ((msg.charCodeAt(i2) & 64512) !== 55296) {
        return false;
      }
      if (i2 < 0 || i2 + 1 >= msg.length) {
        return false;
      }
      return (msg.charCodeAt(i2 + 1) & 64512) === 56320;
    }
    function toArray2(msg, enc) {
      if (Array.isArray(msg))
        return msg.slice();
      if (!msg)
        return [];
      var res = [];
      if (typeof msg === "string") {
        if (!enc) {
          var p3 = 0;
          for (var i2 = 0; i2 < msg.length; i2++) {
            var c2 = msg.charCodeAt(i2);
            if (c2 < 128) {
              res[p3++] = c2;
            } else if (c2 < 2048) {
              res[p3++] = c2 >> 6 | 192;
              res[p3++] = c2 & 63 | 128;
            } else if (isSurrogatePair(msg, i2)) {
              c2 = 65536 + ((c2 & 1023) << 10) + (msg.charCodeAt(++i2) & 1023);
              res[p3++] = c2 >> 18 | 240;
              res[p3++] = c2 >> 12 & 63 | 128;
              res[p3++] = c2 >> 6 & 63 | 128;
              res[p3++] = c2 & 63 | 128;
            } else {
              res[p3++] = c2 >> 12 | 224;
              res[p3++] = c2 >> 6 & 63 | 128;
              res[p3++] = c2 & 63 | 128;
            }
          }
        } else if (enc === "hex") {
          msg = msg.replace(/[^a-z0-9]+/ig, "");
          if (msg.length % 2 !== 0)
            msg = "0" + msg;
          for (i2 = 0; i2 < msg.length; i2 += 2)
            res.push(parseInt(msg[i2] + msg[i2 + 1], 16));
        }
      } else {
        for (i2 = 0; i2 < msg.length; i2++)
          res[i2] = msg[i2] | 0;
      }
      return res;
    }
    exports.toArray = toArray2;
    function toHex2(msg) {
      var res = "";
      for (var i2 = 0; i2 < msg.length; i2++)
        res += zero2(msg[i2].toString(16));
      return res;
    }
    exports.toHex = toHex2;
    function htonl(w3) {
      var res = w3 >>> 24 | w3 >>> 8 & 65280 | w3 << 8 & 16711680 | (w3 & 255) << 24;
      return res >>> 0;
    }
    exports.htonl = htonl;
    function toHex32(msg, endian) {
      var res = "";
      for (var i2 = 0; i2 < msg.length; i2++) {
        var w3 = msg[i2];
        if (endian === "little")
          w3 = htonl(w3);
        res += zero8(w3.toString(16));
      }
      return res;
    }
    exports.toHex32 = toHex32;
    function zero2(word) {
      if (word.length === 1)
        return "0" + word;
      else
        return word;
    }
    exports.zero2 = zero2;
    function zero8(word) {
      if (word.length === 7)
        return "0" + word;
      else if (word.length === 6)
        return "00" + word;
      else if (word.length === 5)
        return "000" + word;
      else if (word.length === 4)
        return "0000" + word;
      else if (word.length === 3)
        return "00000" + word;
      else if (word.length === 2)
        return "000000" + word;
      else if (word.length === 1)
        return "0000000" + word;
      else
        return word;
    }
    exports.zero8 = zero8;
    function join32(msg, start, end, endian) {
      var len = end - start;
      assert(len % 4 === 0);
      var res = new Array(len / 4);
      for (var i2 = 0, k2 = start; i2 < res.length; i2++, k2 += 4) {
        var w3;
        if (endian === "big")
          w3 = msg[k2] << 24 | msg[k2 + 1] << 16 | msg[k2 + 2] << 8 | msg[k2 + 3];
        else
          w3 = msg[k2 + 3] << 24 | msg[k2 + 2] << 16 | msg[k2 + 1] << 8 | msg[k2];
        res[i2] = w3 >>> 0;
      }
      return res;
    }
    exports.join32 = join32;
    function split32(msg, endian) {
      var res = new Array(msg.length * 4);
      for (var i2 = 0, k2 = 0; i2 < msg.length; i2++, k2 += 4) {
        var m2 = msg[i2];
        if (endian === "big") {
          res[k2] = m2 >>> 24;
          res[k2 + 1] = m2 >>> 16 & 255;
          res[k2 + 2] = m2 >>> 8 & 255;
          res[k2 + 3] = m2 & 255;
        } else {
          res[k2 + 3] = m2 >>> 24;
          res[k2 + 2] = m2 >>> 16 & 255;
          res[k2 + 1] = m2 >>> 8 & 255;
          res[k2] = m2 & 255;
        }
      }
      return res;
    }
    exports.split32 = split32;
    function rotr32(w3, b3) {
      return w3 >>> b3 | w3 << 32 - b3;
    }
    exports.rotr32 = rotr32;
    function rotl32(w3, b3) {
      return w3 << b3 | w3 >>> 32 - b3;
    }
    exports.rotl32 = rotl32;
    function sum32(a2, b3) {
      return a2 + b3 >>> 0;
    }
    exports.sum32 = sum32;
    function sum32_3(a2, b3, c2) {
      return a2 + b3 + c2 >>> 0;
    }
    exports.sum32_3 = sum32_3;
    function sum32_4(a2, b3, c2, d2) {
      return a2 + b3 + c2 + d2 >>> 0;
    }
    exports.sum32_4 = sum32_4;
    function sum32_5(a2, b3, c2, d2, e) {
      return a2 + b3 + c2 + d2 + e >>> 0;
    }
    exports.sum32_5 = sum32_5;
    function sum64(buf, pos, ah, al) {
      var bh = buf[pos];
      var bl = buf[pos + 1];
      var lo = al + bl >>> 0;
      var hi = (lo < al ? 1 : 0) + ah + bh;
      buf[pos] = hi >>> 0;
      buf[pos + 1] = lo;
    }
    exports.sum64 = sum64;
    function sum64_hi(ah, al, bh, bl) {
      var lo = al + bl >>> 0;
      var hi = (lo < al ? 1 : 0) + ah + bh;
      return hi >>> 0;
    }
    exports.sum64_hi = sum64_hi;
    function sum64_lo(ah, al, bh, bl) {
      var lo = al + bl;
      return lo >>> 0;
    }
    exports.sum64_lo = sum64_lo;
    function sum64_4_hi(ah, al, bh, bl, ch, cl, dh, dl) {
      var carry = 0;
      var lo = al;
      lo = lo + bl >>> 0;
      carry += lo < al ? 1 : 0;
      lo = lo + cl >>> 0;
      carry += lo < cl ? 1 : 0;
      lo = lo + dl >>> 0;
      carry += lo < dl ? 1 : 0;
      var hi = ah + bh + ch + dh + carry;
      return hi >>> 0;
    }
    exports.sum64_4_hi = sum64_4_hi;
    function sum64_4_lo(ah, al, bh, bl, ch, cl, dh, dl) {
      var lo = al + bl + cl + dl;
      return lo >>> 0;
    }
    exports.sum64_4_lo = sum64_4_lo;
    function sum64_5_hi(ah, al, bh, bl, ch, cl, dh, dl, eh, el) {
      var carry = 0;
      var lo = al;
      lo = lo + bl >>> 0;
      carry += lo < al ? 1 : 0;
      lo = lo + cl >>> 0;
      carry += lo < cl ? 1 : 0;
      lo = lo + dl >>> 0;
      carry += lo < dl ? 1 : 0;
      lo = lo + el >>> 0;
      carry += lo < el ? 1 : 0;
      var hi = ah + bh + ch + dh + eh + carry;
      return hi >>> 0;
    }
    exports.sum64_5_hi = sum64_5_hi;
    function sum64_5_lo(ah, al, bh, bl, ch, cl, dh, dl, eh, el) {
      var lo = al + bl + cl + dl + el;
      return lo >>> 0;
    }
    exports.sum64_5_lo = sum64_5_lo;
    function rotr64_hi(ah, al, num) {
      var r = al << 32 - num | ah >>> num;
      return r >>> 0;
    }
    exports.rotr64_hi = rotr64_hi;
    function rotr64_lo(ah, al, num) {
      var r = ah << 32 - num | al >>> num;
      return r >>> 0;
    }
    exports.rotr64_lo = rotr64_lo;
    function shr64_hi(ah, al, num) {
      return ah >>> num;
    }
    exports.shr64_hi = shr64_hi;
    function shr64_lo(ah, al, num) {
      var r = ah << 32 - num | al >>> num;
      return r >>> 0;
    }
    exports.shr64_lo = shr64_lo;
  }
});

// node_modules/hash.js/lib/hash/common.js
var require_common = __commonJS({
  "node_modules/hash.js/lib/hash/common.js"(exports) {
    "use strict";
    var utils = require_utils4();
    var assert = require_minimalistic_assert();
    function BlockHash() {
      this.pending = null;
      this.pendingTotal = 0;
      this.blockSize = this.constructor.blockSize;
      this.outSize = this.constructor.outSize;
      this.hmacStrength = this.constructor.hmacStrength;
      this.padLength = this.constructor.padLength / 8;
      this.endian = "big";
      this._delta8 = this.blockSize / 8;
      this._delta32 = this.blockSize / 32;
    }
    exports.BlockHash = BlockHash;
    BlockHash.prototype.update = function update(msg, enc) {
      msg = utils.toArray(msg, enc);
      if (!this.pending)
        this.pending = msg;
      else
        this.pending = this.pending.concat(msg);
      this.pendingTotal += msg.length;
      if (this.pending.length >= this._delta8) {
        msg = this.pending;
        var r = msg.length % this._delta8;
        this.pending = msg.slice(msg.length - r, msg.length);
        if (this.pending.length === 0)
          this.pending = null;
        msg = utils.join32(msg, 0, msg.length - r, this.endian);
        for (var i2 = 0; i2 < msg.length; i2 += this._delta32)
          this._update(msg, i2, i2 + this._delta32);
      }
      return this;
    };
    BlockHash.prototype.digest = function digest(enc) {
      this.update(this._pad());
      assert(this.pending === null);
      return this._digest(enc);
    };
    BlockHash.prototype._pad = function pad2() {
      var len = this.pendingTotal;
      var bytes = this._delta8;
      var k2 = bytes - (len + this.padLength) % bytes;
      var res = new Array(k2 + this.padLength);
      res[0] = 128;
      for (var i2 = 1; i2 < k2; i2++)
        res[i2] = 0;
      len <<= 3;
      if (this.endian === "big") {
        for (var t = 8; t < this.padLength; t++)
          res[i2++] = 0;
        res[i2++] = 0;
        res[i2++] = 0;
        res[i2++] = 0;
        res[i2++] = 0;
        res[i2++] = len >>> 24 & 255;
        res[i2++] = len >>> 16 & 255;
        res[i2++] = len >>> 8 & 255;
        res[i2++] = len & 255;
      } else {
        res[i2++] = len & 255;
        res[i2++] = len >>> 8 & 255;
        res[i2++] = len >>> 16 & 255;
        res[i2++] = len >>> 24 & 255;
        res[i2++] = 0;
        res[i2++] = 0;
        res[i2++] = 0;
        res[i2++] = 0;
        for (t = 8; t < this.padLength; t++)
          res[i2++] = 0;
      }
      return res;
    };
  }
});

// node_modules/hash.js/lib/hash/sha/common.js
var require_common2 = __commonJS({
  "node_modules/hash.js/lib/hash/sha/common.js"(exports) {
    "use strict";
    var utils = require_utils4();
    var rotr32 = utils.rotr32;
    function ft_1(s, x3, y3, z) {
      if (s === 0)
        return ch32(x3, y3, z);
      if (s === 1 || s === 3)
        return p32(x3, y3, z);
      if (s === 2)
        return maj32(x3, y3, z);
    }
    exports.ft_1 = ft_1;
    function ch32(x3, y3, z) {
      return x3 & y3 ^ ~x3 & z;
    }
    exports.ch32 = ch32;
    function maj32(x3, y3, z) {
      return x3 & y3 ^ x3 & z ^ y3 & z;
    }
    exports.maj32 = maj32;
    function p32(x3, y3, z) {
      return x3 ^ y3 ^ z;
    }
    exports.p32 = p32;
    function s0_256(x3) {
      return rotr32(x3, 2) ^ rotr32(x3, 13) ^ rotr32(x3, 22);
    }
    exports.s0_256 = s0_256;
    function s1_256(x3) {
      return rotr32(x3, 6) ^ rotr32(x3, 11) ^ rotr32(x3, 25);
    }
    exports.s1_256 = s1_256;
    function g0_256(x3) {
      return rotr32(x3, 7) ^ rotr32(x3, 18) ^ x3 >>> 3;
    }
    exports.g0_256 = g0_256;
    function g1_256(x3) {
      return rotr32(x3, 17) ^ rotr32(x3, 19) ^ x3 >>> 10;
    }
    exports.g1_256 = g1_256;
  }
});

// node_modules/hash.js/lib/hash/sha/1.js
var require__ = __commonJS({
  "node_modules/hash.js/lib/hash/sha/1.js"(exports, module) {
    "use strict";
    var utils = require_utils4();
    var common = require_common();
    var shaCommon = require_common2();
    var rotl32 = utils.rotl32;
    var sum32 = utils.sum32;
    var sum32_5 = utils.sum32_5;
    var ft_1 = shaCommon.ft_1;
    var BlockHash = common.BlockHash;
    var sha1_K = [
      1518500249,
      1859775393,
      2400959708,
      3395469782
    ];
    function SHA1() {
      if (!(this instanceof SHA1))
        return new SHA1();
      BlockHash.call(this);
      this.h = [
        1732584193,
        4023233417,
        2562383102,
        271733878,
        3285377520
      ];
      this.W = new Array(80);
    }
    utils.inherits(SHA1, BlockHash);
    module.exports = SHA1;
    SHA1.blockSize = 512;
    SHA1.outSize = 160;
    SHA1.hmacStrength = 80;
    SHA1.padLength = 64;
    SHA1.prototype._update = function _update(msg, start) {
      var W3 = this.W;
      for (var i2 = 0; i2 < 16; i2++)
        W3[i2] = msg[start + i2];
      for (; i2 < W3.length; i2++)
        W3[i2] = rotl32(W3[i2 - 3] ^ W3[i2 - 8] ^ W3[i2 - 14] ^ W3[i2 - 16], 1);
      var a2 = this.h[0];
      var b3 = this.h[1];
      var c2 = this.h[2];
      var d2 = this.h[3];
      var e = this.h[4];
      for (i2 = 0; i2 < W3.length; i2++) {
        var s = ~~(i2 / 20);
        var t = sum32_5(rotl32(a2, 5), ft_1(s, b3, c2, d2), e, W3[i2], sha1_K[s]);
        e = d2;
        d2 = c2;
        c2 = rotl32(b3, 30);
        b3 = a2;
        a2 = t;
      }
      this.h[0] = sum32(this.h[0], a2);
      this.h[1] = sum32(this.h[1], b3);
      this.h[2] = sum32(this.h[2], c2);
      this.h[3] = sum32(this.h[3], d2);
      this.h[4] = sum32(this.h[4], e);
    };
    SHA1.prototype._digest = function digest(enc) {
      if (enc === "hex")
        return utils.toHex32(this.h, "big");
      else
        return utils.split32(this.h, "big");
    };
  }
});

// node_modules/hash.js/lib/hash/sha/256.js
var require__2 = __commonJS({
  "node_modules/hash.js/lib/hash/sha/256.js"(exports, module) {
    "use strict";
    var utils = require_utils4();
    var common = require_common();
    var shaCommon = require_common2();
    var assert = require_minimalistic_assert();
    var sum32 = utils.sum32;
    var sum32_4 = utils.sum32_4;
    var sum32_5 = utils.sum32_5;
    var ch32 = shaCommon.ch32;
    var maj32 = shaCommon.maj32;
    var s0_256 = shaCommon.s0_256;
    var s1_256 = shaCommon.s1_256;
    var g0_256 = shaCommon.g0_256;
    var g1_256 = shaCommon.g1_256;
    var BlockHash = common.BlockHash;
    var sha256_K = [
      1116352408,
      1899447441,
      3049323471,
      3921009573,
      961987163,
      1508970993,
      2453635748,
      2870763221,
      3624381080,
      310598401,
      607225278,
      1426881987,
      1925078388,
      2162078206,
      2614888103,
      3248222580,
      3835390401,
      4022224774,
      264347078,
      604807628,
      770255983,
      1249150122,
      1555081692,
      1996064986,
      2554220882,
      2821834349,
      2952996808,
      3210313671,
      3336571891,
      3584528711,
      113926993,
      338241895,
      666307205,
      773529912,
      1294757372,
      1396182291,
      1695183700,
      1986661051,
      2177026350,
      2456956037,
      2730485921,
      2820302411,
      3259730800,
      3345764771,
      3516065817,
      3600352804,
      4094571909,
      275423344,
      430227734,
      506948616,
      659060556,
      883997877,
      958139571,
      1322822218,
      1537002063,
      1747873779,
      1955562222,
      2024104815,
      2227730452,
      2361852424,
      2428436474,
      2756734187,
      3204031479,
      3329325298
    ];
    function SHA256() {
      if (!(this instanceof SHA256))
        return new SHA256();
      BlockHash.call(this);
      this.h = [
        1779033703,
        3144134277,
        1013904242,
        2773480762,
        1359893119,
        2600822924,
        528734635,
        1541459225
      ];
      this.k = sha256_K;
      this.W = new Array(64);
    }
    utils.inherits(SHA256, BlockHash);
    module.exports = SHA256;
    SHA256.blockSize = 512;
    SHA256.outSize = 256;
    SHA256.hmacStrength = 192;
    SHA256.padLength = 64;
    SHA256.prototype._update = function _update(msg, start) {
      var W3 = this.W;
      for (var i2 = 0; i2 < 16; i2++)
        W3[i2] = msg[start + i2];
      for (; i2 < W3.length; i2++)
        W3[i2] = sum32_4(g1_256(W3[i2 - 2]), W3[i2 - 7], g0_256(W3[i2 - 15]), W3[i2 - 16]);
      var a2 = this.h[0];
      var b3 = this.h[1];
      var c2 = this.h[2];
      var d2 = this.h[3];
      var e = this.h[4];
      var f2 = this.h[5];
      var g4 = this.h[6];
      var h3 = this.h[7];
      assert(this.k.length === W3.length);
      for (i2 = 0; i2 < W3.length; i2++) {
        var T1 = sum32_5(h3, s1_256(e), ch32(e, f2, g4), this.k[i2], W3[i2]);
        var T2 = sum32(s0_256(a2), maj32(a2, b3, c2));
        h3 = g4;
        g4 = f2;
        f2 = e;
        e = sum32(d2, T1);
        d2 = c2;
        c2 = b3;
        b3 = a2;
        a2 = sum32(T1, T2);
      }
      this.h[0] = sum32(this.h[0], a2);
      this.h[1] = sum32(this.h[1], b3);
      this.h[2] = sum32(this.h[2], c2);
      this.h[3] = sum32(this.h[3], d2);
      this.h[4] = sum32(this.h[4], e);
      this.h[5] = sum32(this.h[5], f2);
      this.h[6] = sum32(this.h[6], g4);
      this.h[7] = sum32(this.h[7], h3);
    };
    SHA256.prototype._digest = function digest(enc) {
      if (enc === "hex")
        return utils.toHex32(this.h, "big");
      else
        return utils.split32(this.h, "big");
    };
  }
});

// node_modules/hash.js/lib/hash/sha/224.js
var require__3 = __commonJS({
  "node_modules/hash.js/lib/hash/sha/224.js"(exports, module) {
    "use strict";
    var utils = require_utils4();
    var SHA256 = require__2();
    function SHA224() {
      if (!(this instanceof SHA224))
        return new SHA224();
      SHA256.call(this);
      this.h = [
        3238371032,
        914150663,
        812702999,
        4144912697,
        4290775857,
        1750603025,
        1694076839,
        3204075428
      ];
    }
    utils.inherits(SHA224, SHA256);
    module.exports = SHA224;
    SHA224.blockSize = 512;
    SHA224.outSize = 224;
    SHA224.hmacStrength = 192;
    SHA224.padLength = 64;
    SHA224.prototype._digest = function digest(enc) {
      if (enc === "hex")
        return utils.toHex32(this.h.slice(0, 7), "big");
      else
        return utils.split32(this.h.slice(0, 7), "big");
    };
  }
});

// node_modules/hash.js/lib/hash/sha/512.js
var require__4 = __commonJS({
  "node_modules/hash.js/lib/hash/sha/512.js"(exports, module) {
    "use strict";
    var utils = require_utils4();
    var common = require_common();
    var assert = require_minimalistic_assert();
    var rotr64_hi = utils.rotr64_hi;
    var rotr64_lo = utils.rotr64_lo;
    var shr64_hi = utils.shr64_hi;
    var shr64_lo = utils.shr64_lo;
    var sum64 = utils.sum64;
    var sum64_hi = utils.sum64_hi;
    var sum64_lo = utils.sum64_lo;
    var sum64_4_hi = utils.sum64_4_hi;
    var sum64_4_lo = utils.sum64_4_lo;
    var sum64_5_hi = utils.sum64_5_hi;
    var sum64_5_lo = utils.sum64_5_lo;
    var BlockHash = common.BlockHash;
    var sha512_K = [
      1116352408,
      3609767458,
      1899447441,
      602891725,
      3049323471,
      3964484399,
      3921009573,
      2173295548,
      961987163,
      4081628472,
      1508970993,
      3053834265,
      2453635748,
      2937671579,
      2870763221,
      3664609560,
      3624381080,
      2734883394,
      310598401,
      1164996542,
      607225278,
      1323610764,
      1426881987,
      3590304994,
      1925078388,
      4068182383,
      2162078206,
      991336113,
      2614888103,
      633803317,
      3248222580,
      3479774868,
      3835390401,
      2666613458,
      4022224774,
      944711139,
      264347078,
      2341262773,
      604807628,
      2007800933,
      770255983,
      1495990901,
      1249150122,
      1856431235,
      1555081692,
      3175218132,
      1996064986,
      2198950837,
      2554220882,
      3999719339,
      2821834349,
      766784016,
      2952996808,
      2566594879,
      3210313671,
      3203337956,
      3336571891,
      1034457026,
      3584528711,
      2466948901,
      113926993,
      3758326383,
      338241895,
      168717936,
      666307205,
      1188179964,
      773529912,
      1546045734,
      1294757372,
      1522805485,
      1396182291,
      2643833823,
      1695183700,
      2343527390,
      1986661051,
      1014477480,
      2177026350,
      1206759142,
      2456956037,
      344077627,
      2730485921,
      1290863460,
      2820302411,
      3158454273,
      3259730800,
      3505952657,
      3345764771,
      106217008,
      3516065817,
      3606008344,
      3600352804,
      1432725776,
      4094571909,
      1467031594,
      275423344,
      851169720,
      430227734,
      3100823752,
      506948616,
      1363258195,
      659060556,
      3750685593,
      883997877,
      3785050280,
      958139571,
      3318307427,
      1322822218,
      3812723403,
      1537002063,
      2003034995,
      1747873779,
      3602036899,
      1955562222,
      1575990012,
      2024104815,
      1125592928,
      2227730452,
      2716904306,
      2361852424,
      442776044,
      2428436474,
      593698344,
      2756734187,
      3733110249,
      3204031479,
      2999351573,
      3329325298,
      3815920427,
      3391569614,
      3928383900,
      3515267271,
      566280711,
      3940187606,
      3454069534,
      4118630271,
      4000239992,
      116418474,
      1914138554,
      174292421,
      2731055270,
      289380356,
      3203993006,
      460393269,
      320620315,
      685471733,
      587496836,
      852142971,
      1086792851,
      1017036298,
      365543100,
      1126000580,
      2618297676,
      1288033470,
      3409855158,
      1501505948,
      4234509866,
      1607167915,
      987167468,
      1816402316,
      1246189591
    ];
    function SHA512() {
      if (!(this instanceof SHA512))
        return new SHA512();
      BlockHash.call(this);
      this.h = [
        1779033703,
        4089235720,
        3144134277,
        2227873595,
        1013904242,
        4271175723,
        2773480762,
        1595750129,
        1359893119,
        2917565137,
        2600822924,
        725511199,
        528734635,
        4215389547,
        1541459225,
        327033209
      ];
      this.k = sha512_K;
      this.W = new Array(160);
    }
    utils.inherits(SHA512, BlockHash);
    module.exports = SHA512;
    SHA512.blockSize = 1024;
    SHA512.outSize = 512;
    SHA512.hmacStrength = 192;
    SHA512.padLength = 128;
    SHA512.prototype._prepareBlock = function _prepareBlock(msg, start) {
      var W3 = this.W;
      for (var i2 = 0; i2 < 32; i2++)
        W3[i2] = msg[start + i2];
      for (; i2 < W3.length; i2 += 2) {
        var c0_hi = g1_512_hi(W3[i2 - 4], W3[i2 - 3]);
        var c0_lo = g1_512_lo(W3[i2 - 4], W3[i2 - 3]);
        var c1_hi = W3[i2 - 14];
        var c1_lo = W3[i2 - 13];
        var c2_hi = g0_512_hi(W3[i2 - 30], W3[i2 - 29]);
        var c2_lo = g0_512_lo(W3[i2 - 30], W3[i2 - 29]);
        var c3_hi = W3[i2 - 32];
        var c3_lo = W3[i2 - 31];
        W3[i2] = sum64_4_hi(
          c0_hi,
          c0_lo,
          c1_hi,
          c1_lo,
          c2_hi,
          c2_lo,
          c3_hi,
          c3_lo
        );
        W3[i2 + 1] = sum64_4_lo(
          c0_hi,
          c0_lo,
          c1_hi,
          c1_lo,
          c2_hi,
          c2_lo,
          c3_hi,
          c3_lo
        );
      }
    };
    SHA512.prototype._update = function _update(msg, start) {
      this._prepareBlock(msg, start);
      var W3 = this.W;
      var ah = this.h[0];
      var al = this.h[1];
      var bh = this.h[2];
      var bl = this.h[3];
      var ch = this.h[4];
      var cl = this.h[5];
      var dh = this.h[6];
      var dl = this.h[7];
      var eh = this.h[8];
      var el = this.h[9];
      var fh = this.h[10];
      var fl = this.h[11];
      var gh = this.h[12];
      var gl = this.h[13];
      var hh = this.h[14];
      var hl = this.h[15];
      assert(this.k.length === W3.length);
      for (var i2 = 0; i2 < W3.length; i2 += 2) {
        var c0_hi = hh;
        var c0_lo = hl;
        var c1_hi = s1_512_hi(eh, el);
        var c1_lo = s1_512_lo(eh, el);
        var c2_hi = ch64_hi(eh, el, fh, fl, gh, gl);
        var c2_lo = ch64_lo(eh, el, fh, fl, gh, gl);
        var c3_hi = this.k[i2];
        var c3_lo = this.k[i2 + 1];
        var c4_hi = W3[i2];
        var c4_lo = W3[i2 + 1];
        var T1_hi = sum64_5_hi(
          c0_hi,
          c0_lo,
          c1_hi,
          c1_lo,
          c2_hi,
          c2_lo,
          c3_hi,
          c3_lo,
          c4_hi,
          c4_lo
        );
        var T1_lo = sum64_5_lo(
          c0_hi,
          c0_lo,
          c1_hi,
          c1_lo,
          c2_hi,
          c2_lo,
          c3_hi,
          c3_lo,
          c4_hi,
          c4_lo
        );
        c0_hi = s0_512_hi(ah, al);
        c0_lo = s0_512_lo(ah, al);
        c1_hi = maj64_hi(ah, al, bh, bl, ch, cl);
        c1_lo = maj64_lo(ah, al, bh, bl, ch, cl);
        var T2_hi = sum64_hi(c0_hi, c0_lo, c1_hi, c1_lo);
        var T2_lo = sum64_lo(c0_hi, c0_lo, c1_hi, c1_lo);
        hh = gh;
        hl = gl;
        gh = fh;
        gl = fl;
        fh = eh;
        fl = el;
        eh = sum64_hi(dh, dl, T1_hi, T1_lo);
        el = sum64_lo(dl, dl, T1_hi, T1_lo);
        dh = ch;
        dl = cl;
        ch = bh;
        cl = bl;
        bh = ah;
        bl = al;
        ah = sum64_hi(T1_hi, T1_lo, T2_hi, T2_lo);
        al = sum64_lo(T1_hi, T1_lo, T2_hi, T2_lo);
      }
      sum64(this.h, 0, ah, al);
      sum64(this.h, 2, bh, bl);
      sum64(this.h, 4, ch, cl);
      sum64(this.h, 6, dh, dl);
      sum64(this.h, 8, eh, el);
      sum64(this.h, 10, fh, fl);
      sum64(this.h, 12, gh, gl);
      sum64(this.h, 14, hh, hl);
    };
    SHA512.prototype._digest = function digest(enc) {
      if (enc === "hex")
        return utils.toHex32(this.h, "big");
      else
        return utils.split32(this.h, "big");
    };
    function ch64_hi(xh, xl, yh, yl, zh) {
      var r = xh & yh ^ ~xh & zh;
      if (r < 0)
        r += 4294967296;
      return r;
    }
    function ch64_lo(xh, xl, yh, yl, zh, zl) {
      var r = xl & yl ^ ~xl & zl;
      if (r < 0)
        r += 4294967296;
      return r;
    }
    function maj64_hi(xh, xl, yh, yl, zh) {
      var r = xh & yh ^ xh & zh ^ yh & zh;
      if (r < 0)
        r += 4294967296;
      return r;
    }
    function maj64_lo(xh, xl, yh, yl, zh, zl) {
      var r = xl & yl ^ xl & zl ^ yl & zl;
      if (r < 0)
        r += 4294967296;
      return r;
    }
    function s0_512_hi(xh, xl) {
      var c0_hi = rotr64_hi(xh, xl, 28);
      var c1_hi = rotr64_hi(xl, xh, 2);
      var c2_hi = rotr64_hi(xl, xh, 7);
      var r = c0_hi ^ c1_hi ^ c2_hi;
      if (r < 0)
        r += 4294967296;
      return r;
    }
    function s0_512_lo(xh, xl) {
      var c0_lo = rotr64_lo(xh, xl, 28);
      var c1_lo = rotr64_lo(xl, xh, 2);
      var c2_lo = rotr64_lo(xl, xh, 7);
      var r = c0_lo ^ c1_lo ^ c2_lo;
      if (r < 0)
        r += 4294967296;
      return r;
    }
    function s1_512_hi(xh, xl) {
      var c0_hi = rotr64_hi(xh, xl, 14);
      var c1_hi = rotr64_hi(xh, xl, 18);
      var c2_hi = rotr64_hi(xl, xh, 9);
      var r = c0_hi ^ c1_hi ^ c2_hi;
      if (r < 0)
        r += 4294967296;
      return r;
    }
    function s1_512_lo(xh, xl) {
      var c0_lo = rotr64_lo(xh, xl, 14);
      var c1_lo = rotr64_lo(xh, xl, 18);
      var c2_lo = rotr64_lo(xl, xh, 9);
      var r = c0_lo ^ c1_lo ^ c2_lo;
      if (r < 0)
        r += 4294967296;
      return r;
    }
    function g0_512_hi(xh, xl) {
      var c0_hi = rotr64_hi(xh, xl, 1);
      var c1_hi = rotr64_hi(xh, xl, 8);
      var c2_hi = shr64_hi(xh, xl, 7);
      var r = c0_hi ^ c1_hi ^ c2_hi;
      if (r < 0)
        r += 4294967296;
      return r;
    }
    function g0_512_lo(xh, xl) {
      var c0_lo = rotr64_lo(xh, xl, 1);
      var c1_lo = rotr64_lo(xh, xl, 8);
      var c2_lo = shr64_lo(xh, xl, 7);
      var r = c0_lo ^ c1_lo ^ c2_lo;
      if (r < 0)
        r += 4294967296;
      return r;
    }
    function g1_512_hi(xh, xl) {
      var c0_hi = rotr64_hi(xh, xl, 19);
      var c1_hi = rotr64_hi(xl, xh, 29);
      var c2_hi = shr64_hi(xh, xl, 6);
      var r = c0_hi ^ c1_hi ^ c2_hi;
      if (r < 0)
        r += 4294967296;
      return r;
    }
    function g1_512_lo(xh, xl) {
      var c0_lo = rotr64_lo(xh, xl, 19);
      var c1_lo = rotr64_lo(xl, xh, 29);
      var c2_lo = shr64_lo(xh, xl, 6);
      var r = c0_lo ^ c1_lo ^ c2_lo;
      if (r < 0)
        r += 4294967296;
      return r;
    }
  }
});

// node_modules/hash.js/lib/hash/sha/384.js
var require__5 = __commonJS({
  "node_modules/hash.js/lib/hash/sha/384.js"(exports, module) {
    "use strict";
    var utils = require_utils4();
    var SHA512 = require__4();
    function SHA384() {
      if (!(this instanceof SHA384))
        return new SHA384();
      SHA512.call(this);
      this.h = [
        3418070365,
        3238371032,
        1654270250,
        914150663,
        2438529370,
        812702999,
        355462360,
        4144912697,
        1731405415,
        4290775857,
        2394180231,
        1750603025,
        3675008525,
        1694076839,
        1203062813,
        3204075428
      ];
    }
    utils.inherits(SHA384, SHA512);
    module.exports = SHA384;
    SHA384.blockSize = 1024;
    SHA384.outSize = 384;
    SHA384.hmacStrength = 192;
    SHA384.padLength = 128;
    SHA384.prototype._digest = function digest(enc) {
      if (enc === "hex")
        return utils.toHex32(this.h.slice(0, 12), "big");
      else
        return utils.split32(this.h.slice(0, 12), "big");
    };
  }
});

// node_modules/hash.js/lib/hash/sha.js
var require_sha = __commonJS({
  "node_modules/hash.js/lib/hash/sha.js"(exports) {
    "use strict";
    exports.sha1 = require__();
    exports.sha224 = require__3();
    exports.sha256 = require__2();
    exports.sha384 = require__5();
    exports.sha512 = require__4();
  }
});

// node_modules/hash.js/lib/hash/ripemd.js
var require_ripemd = __commonJS({
  "node_modules/hash.js/lib/hash/ripemd.js"(exports) {
    "use strict";
    var utils = require_utils4();
    var common = require_common();
    var rotl32 = utils.rotl32;
    var sum32 = utils.sum32;
    var sum32_3 = utils.sum32_3;
    var sum32_4 = utils.sum32_4;
    var BlockHash = common.BlockHash;
    function RIPEMD160() {
      if (!(this instanceof RIPEMD160))
        return new RIPEMD160();
      BlockHash.call(this);
      this.h = [1732584193, 4023233417, 2562383102, 271733878, 3285377520];
      this.endian = "little";
    }
    utils.inherits(RIPEMD160, BlockHash);
    exports.ripemd160 = RIPEMD160;
    RIPEMD160.blockSize = 512;
    RIPEMD160.outSize = 160;
    RIPEMD160.hmacStrength = 192;
    RIPEMD160.padLength = 64;
    RIPEMD160.prototype._update = function update(msg, start) {
      var A2 = this.h[0];
      var B3 = this.h[1];
      var C3 = this.h[2];
      var D3 = this.h[3];
      var E4 = this.h[4];
      var Ah = A2;
      var Bh = B3;
      var Ch = C3;
      var Dh = D3;
      var Eh = E4;
      for (var j2 = 0; j2 < 80; j2++) {
        var T = sum32(
          rotl32(
            sum32_4(A2, f2(j2, B3, C3, D3), msg[r[j2] + start], K3(j2)),
            s[j2]
          ),
          E4
        );
        A2 = E4;
        E4 = D3;
        D3 = rotl32(C3, 10);
        C3 = B3;
        B3 = T;
        T = sum32(
          rotl32(
            sum32_4(Ah, f2(79 - j2, Bh, Ch, Dh), msg[rh[j2] + start], Kh(j2)),
            sh[j2]
          ),
          Eh
        );
        Ah = Eh;
        Eh = Dh;
        Dh = rotl32(Ch, 10);
        Ch = Bh;
        Bh = T;
      }
      T = sum32_3(this.h[1], C3, Dh);
      this.h[1] = sum32_3(this.h[2], D3, Eh);
      this.h[2] = sum32_3(this.h[3], E4, Ah);
      this.h[3] = sum32_3(this.h[4], A2, Bh);
      this.h[4] = sum32_3(this.h[0], B3, Ch);
      this.h[0] = T;
    };
    RIPEMD160.prototype._digest = function digest(enc) {
      if (enc === "hex")
        return utils.toHex32(this.h, "little");
      else
        return utils.split32(this.h, "little");
    };
    function f2(j2, x3, y3, z) {
      if (j2 <= 15)
        return x3 ^ y3 ^ z;
      else if (j2 <= 31)
        return x3 & y3 | ~x3 & z;
      else if (j2 <= 47)
        return (x3 | ~y3) ^ z;
      else if (j2 <= 63)
        return x3 & z | y3 & ~z;
      else
        return x3 ^ (y3 | ~z);
    }
    function K3(j2) {
      if (j2 <= 15)
        return 0;
      else if (j2 <= 31)
        return 1518500249;
      else if (j2 <= 47)
        return 1859775393;
      else if (j2 <= 63)
        return 2400959708;
      else
        return 2840853838;
    }
    function Kh(j2) {
      if (j2 <= 15)
        return 1352829926;
      else if (j2 <= 31)
        return 1548603684;
      else if (j2 <= 47)
        return 1836072691;
      else if (j2 <= 63)
        return 2053994217;
      else
        return 0;
    }
    var r = [
      0,
      1,
      2,
      3,
      4,
      5,
      6,
      7,
      8,
      9,
      10,
      11,
      12,
      13,
      14,
      15,
      7,
      4,
      13,
      1,
      10,
      6,
      15,
      3,
      12,
      0,
      9,
      5,
      2,
      14,
      11,
      8,
      3,
      10,
      14,
      4,
      9,
      15,
      8,
      1,
      2,
      7,
      0,
      6,
      13,
      11,
      5,
      12,
      1,
      9,
      11,
      10,
      0,
      8,
      12,
      4,
      13,
      3,
      7,
      15,
      14,
      5,
      6,
      2,
      4,
      0,
      5,
      9,
      7,
      12,
      2,
      10,
      14,
      1,
      3,
      8,
      11,
      6,
      15,
      13
    ];
    var rh = [
      5,
      14,
      7,
      0,
      9,
      2,
      11,
      4,
      13,
      6,
      15,
      8,
      1,
      10,
      3,
      12,
      6,
      11,
      3,
      7,
      0,
      13,
      5,
      10,
      14,
      15,
      8,
      12,
      4,
      9,
      1,
      2,
      15,
      5,
      1,
      3,
      7,
      14,
      6,
      9,
      11,
      8,
      12,
      2,
      10,
      0,
      4,
      13,
      8,
      6,
      4,
      1,
      3,
      11,
      15,
      0,
      5,
      12,
      2,
      13,
      9,
      7,
      10,
      14,
      12,
      15,
      10,
      4,
      1,
      5,
      8,
      7,
      6,
      2,
      13,
      14,
      0,
      3,
      9,
      11
    ];
    var s = [
      11,
      14,
      15,
      12,
      5,
      8,
      7,
      9,
      11,
      13,
      14,
      15,
      6,
      7,
      9,
      8,
      7,
      6,
      8,
      13,
      11,
      9,
      7,
      15,
      7,
      12,
      15,
      9,
      11,
      7,
      13,
      12,
      11,
      13,
      6,
      7,
      14,
      9,
      13,
      15,
      14,
      8,
      13,
      6,
      5,
      12,
      7,
      5,
      11,
      12,
      14,
      15,
      14,
      15,
      9,
      8,
      9,
      14,
      5,
      6,
      8,
      6,
      5,
      12,
      9,
      15,
      5,
      11,
      6,
      8,
      13,
      12,
      5,
      12,
      13,
      14,
      11,
      8,
      5,
      6
    ];
    var sh = [
      8,
      9,
      9,
      11,
      13,
      15,
      15,
      5,
      7,
      7,
      8,
      11,
      14,
      14,
      12,
      6,
      9,
      13,
      15,
      7,
      12,
      8,
      9,
      11,
      7,
      7,
      12,
      7,
      6,
      15,
      13,
      11,
      9,
      7,
      15,
      11,
      8,
      6,
      6,
      14,
      12,
      13,
      5,
      14,
      13,
      13,
      7,
      5,
      15,
      5,
      8,
      11,
      14,
      14,
      6,
      14,
      6,
      9,
      12,
      9,
      12,
      5,
      15,
      8,
      8,
      5,
      12,
      9,
      12,
      5,
      14,
      6,
      8,
      13,
      6,
      5,
      15,
      13,
      11,
      11
    ];
  }
});

// node_modules/hash.js/lib/hash/hmac.js
var require_hmac = __commonJS({
  "node_modules/hash.js/lib/hash/hmac.js"(exports, module) {
    "use strict";
    var utils = require_utils4();
    var assert = require_minimalistic_assert();
    function Hmac(hash6, key, enc) {
      if (!(this instanceof Hmac))
        return new Hmac(hash6, key, enc);
      this.Hash = hash6;
      this.blockSize = hash6.blockSize / 8;
      this.outSize = hash6.outSize / 8;
      this.inner = null;
      this.outer = null;
      this._init(utils.toArray(key, enc));
    }
    module.exports = Hmac;
    Hmac.prototype._init = function init(key) {
      if (key.length > this.blockSize)
        key = new this.Hash().update(key).digest();
      assert(key.length <= this.blockSize);
      for (var i2 = key.length; i2 < this.blockSize; i2++)
        key.push(0);
      for (i2 = 0; i2 < key.length; i2++)
        key[i2] ^= 54;
      this.inner = new this.Hash().update(key);
      for (i2 = 0; i2 < key.length; i2++)
        key[i2] ^= 106;
      this.outer = new this.Hash().update(key);
    };
    Hmac.prototype.update = function update(msg, enc) {
      this.inner.update(msg, enc);
      return this;
    };
    Hmac.prototype.digest = function digest(enc) {
      this.outer.update(this.inner.digest());
      return this.outer.digest(enc);
    };
  }
});

// node_modules/hash.js/lib/hash.js
var require_hash = __commonJS({
  "node_modules/hash.js/lib/hash.js"(exports) {
    var hash6 = exports;
    hash6.utils = require_utils4();
    hash6.common = require_common();
    hash6.sha = require_sha();
    hash6.ripemd = require_ripemd();
    hash6.hmac = require_hmac();
    hash6.sha1 = hash6.sha.sha1;
    hash6.sha256 = hash6.sha.sha256;
    hash6.sha224 = hash6.sha.sha224;
    hash6.sha384 = hash6.sha.sha384;
    hash6.sha512 = hash6.sha.sha512;
    hash6.ripemd160 = hash6.ripemd.ripemd160;
  }
});

// node_modules/elliptic/lib/elliptic/precomputed/secp256k1.js
var require_secp256k1 = __commonJS({
  "node_modules/elliptic/lib/elliptic/precomputed/secp256k1.js"(exports, module) {
    module.exports = {
      doubles: {
        step: 4,
        points: [
          [
            "e60fce93b59e9ec53011aabc21c23e97b2a31369b87a5ae9c44ee89e2a6dec0a",
            "f7e3507399e595929db99f34f57937101296891e44d23f0be1f32cce69616821"
          ],
          [
            "8282263212c609d9ea2a6e3e172de238d8c39cabd5ac1ca10646e23fd5f51508",
            "11f8a8098557dfe45e8256e830b60ace62d613ac2f7b17bed31b6eaff6e26caf"
          ],
          [
            "175e159f728b865a72f99cc6c6fc846de0b93833fd2222ed73fce5b551e5b739",
            "d3506e0d9e3c79eba4ef97a51ff71f5eacb5955add24345c6efa6ffee9fed695"
          ],
          [
            "363d90d447b00c9c99ceac05b6262ee053441c7e55552ffe526bad8f83ff4640",
            "4e273adfc732221953b445397f3363145b9a89008199ecb62003c7f3bee9de9"
          ],
          [
            "8b4b5f165df3c2be8c6244b5b745638843e4a781a15bcd1b69f79a55dffdf80c",
            "4aad0a6f68d308b4b3fbd7813ab0da04f9e336546162ee56b3eff0c65fd4fd36"
          ],
          [
            "723cbaa6e5db996d6bf771c00bd548c7b700dbffa6c0e77bcb6115925232fcda",
            "96e867b5595cc498a921137488824d6e2660a0653779494801dc069d9eb39f5f"
          ],
          [
            "eebfa4d493bebf98ba5feec812c2d3b50947961237a919839a533eca0e7dd7fa",
            "5d9a8ca3970ef0f269ee7edaf178089d9ae4cdc3a711f712ddfd4fdae1de8999"
          ],
          [
            "100f44da696e71672791d0a09b7bde459f1215a29b3c03bfefd7835b39a48db0",
            "cdd9e13192a00b772ec8f3300c090666b7ff4a18ff5195ac0fbd5cd62bc65a09"
          ],
          [
            "e1031be262c7ed1b1dc9227a4a04c017a77f8d4464f3b3852c8acde6e534fd2d",
            "9d7061928940405e6bb6a4176597535af292dd419e1ced79a44f18f29456a00d"
          ],
          [
            "feea6cae46d55b530ac2839f143bd7ec5cf8b266a41d6af52d5e688d9094696d",
            "e57c6b6c97dce1bab06e4e12bf3ecd5c981c8957cc41442d3155debf18090088"
          ],
          [
            "da67a91d91049cdcb367be4be6ffca3cfeed657d808583de33fa978bc1ec6cb1",
            "9bacaa35481642bc41f463f7ec9780e5dec7adc508f740a17e9ea8e27a68be1d"
          ],
          [
            "53904faa0b334cdda6e000935ef22151ec08d0f7bb11069f57545ccc1a37b7c0",
            "5bc087d0bc80106d88c9eccac20d3c1c13999981e14434699dcb096b022771c8"
          ],
          [
            "8e7bcd0bd35983a7719cca7764ca906779b53a043a9b8bcaeff959f43ad86047",
            "10b7770b2a3da4b3940310420ca9514579e88e2e47fd68b3ea10047e8460372a"
          ],
          [
            "385eed34c1cdff21e6d0818689b81bde71a7f4f18397e6690a841e1599c43862",
            "283bebc3e8ea23f56701de19e9ebf4576b304eec2086dc8cc0458fe5542e5453"
          ],
          [
            "6f9d9b803ecf191637c73a4413dfa180fddf84a5947fbc9c606ed86c3fac3a7",
            "7c80c68e603059ba69b8e2a30e45c4d47ea4dd2f5c281002d86890603a842160"
          ],
          [
            "3322d401243c4e2582a2147c104d6ecbf774d163db0f5e5313b7e0e742d0e6bd",
            "56e70797e9664ef5bfb019bc4ddaf9b72805f63ea2873af624f3a2e96c28b2a0"
          ],
          [
            "85672c7d2de0b7da2bd1770d89665868741b3f9af7643397721d74d28134ab83",
            "7c481b9b5b43b2eb6374049bfa62c2e5e77f17fcc5298f44c8e3094f790313a6"
          ],
          [
            "948bf809b1988a46b06c9f1919413b10f9226c60f668832ffd959af60c82a0a",
            "53a562856dcb6646dc6b74c5d1c3418c6d4dff08c97cd2bed4cb7f88d8c8e589"
          ],
          [
            "6260ce7f461801c34f067ce0f02873a8f1b0e44dfc69752accecd819f38fd8e8",
            "bc2da82b6fa5b571a7f09049776a1ef7ecd292238051c198c1a84e95b2b4ae17"
          ],
          [
            "e5037de0afc1d8d43d8348414bbf4103043ec8f575bfdc432953cc8d2037fa2d",
            "4571534baa94d3b5f9f98d09fb990bddbd5f5b03ec481f10e0e5dc841d755bda"
          ],
          [
            "e06372b0f4a207adf5ea905e8f1771b4e7e8dbd1c6a6c5b725866a0ae4fce725",
            "7a908974bce18cfe12a27bb2ad5a488cd7484a7787104870b27034f94eee31dd"
          ],
          [
            "213c7a715cd5d45358d0bbf9dc0ce02204b10bdde2a3f58540ad6908d0559754",
            "4b6dad0b5ae462507013ad06245ba190bb4850f5f36a7eeddff2c27534b458f2"
          ],
          [
            "4e7c272a7af4b34e8dbb9352a5419a87e2838c70adc62cddf0cc3a3b08fbd53c",
            "17749c766c9d0b18e16fd09f6def681b530b9614bff7dd33e0b3941817dcaae6"
          ],
          [
            "fea74e3dbe778b1b10f238ad61686aa5c76e3db2be43057632427e2840fb27b6",
            "6e0568db9b0b13297cf674deccb6af93126b596b973f7b77701d3db7f23cb96f"
          ],
          [
            "76e64113f677cf0e10a2570d599968d31544e179b760432952c02a4417bdde39",
            "c90ddf8dee4e95cf577066d70681f0d35e2a33d2b56d2032b4b1752d1901ac01"
          ],
          [
            "c738c56b03b2abe1e8281baa743f8f9a8f7cc643df26cbee3ab150242bcbb891",
            "893fb578951ad2537f718f2eacbfbbbb82314eef7880cfe917e735d9699a84c3"
          ],
          [
            "d895626548b65b81e264c7637c972877d1d72e5f3a925014372e9f6588f6c14b",
            "febfaa38f2bc7eae728ec60818c340eb03428d632bb067e179363ed75d7d991f"
          ],
          [
            "b8da94032a957518eb0f6433571e8761ceffc73693e84edd49150a564f676e03",
            "2804dfa44805a1e4d7c99cc9762808b092cc584d95ff3b511488e4e74efdf6e7"
          ],
          [
            "e80fea14441fb33a7d8adab9475d7fab2019effb5156a792f1a11778e3c0df5d",
            "eed1de7f638e00771e89768ca3ca94472d155e80af322ea9fcb4291b6ac9ec78"
          ],
          [
            "a301697bdfcd704313ba48e51d567543f2a182031efd6915ddc07bbcc4e16070",
            "7370f91cfb67e4f5081809fa25d40f9b1735dbf7c0a11a130c0d1a041e177ea1"
          ],
          [
            "90ad85b389d6b936463f9d0512678de208cc330b11307fffab7ac63e3fb04ed4",
            "e507a3620a38261affdcbd9427222b839aefabe1582894d991d4d48cb6ef150"
          ],
          [
            "8f68b9d2f63b5f339239c1ad981f162ee88c5678723ea3351b7b444c9ec4c0da",
            "662a9f2dba063986de1d90c2b6be215dbbea2cfe95510bfdf23cbf79501fff82"
          ],
          [
            "e4f3fb0176af85d65ff99ff9198c36091f48e86503681e3e6686fd5053231e11",
            "1e63633ad0ef4f1c1661a6d0ea02b7286cc7e74ec951d1c9822c38576feb73bc"
          ],
          [
            "8c00fa9b18ebf331eb961537a45a4266c7034f2f0d4e1d0716fb6eae20eae29e",
            "efa47267fea521a1a9dc343a3736c974c2fadafa81e36c54e7d2a4c66702414b"
          ],
          [
            "e7a26ce69dd4829f3e10cec0a9e98ed3143d084f308b92c0997fddfc60cb3e41",
            "2a758e300fa7984b471b006a1aafbb18d0a6b2c0420e83e20e8a9421cf2cfd51"
          ],
          [
            "b6459e0ee3662ec8d23540c223bcbdc571cbcb967d79424f3cf29eb3de6b80ef",
            "67c876d06f3e06de1dadf16e5661db3c4b3ae6d48e35b2ff30bf0b61a71ba45"
          ],
          [
            "d68a80c8280bb840793234aa118f06231d6f1fc67e73c5a5deda0f5b496943e8",
            "db8ba9fff4b586d00c4b1f9177b0e28b5b0e7b8f7845295a294c84266b133120"
          ],
          [
            "324aed7df65c804252dc0270907a30b09612aeb973449cea4095980fc28d3d5d",
            "648a365774b61f2ff130c0c35aec1f4f19213b0c7e332843967224af96ab7c84"
          ],
          [
            "4df9c14919cde61f6d51dfdbe5fee5dceec4143ba8d1ca888e8bd373fd054c96",
            "35ec51092d8728050974c23a1d85d4b5d506cdc288490192ebac06cad10d5d"
          ],
          [
            "9c3919a84a474870faed8a9c1cc66021523489054d7f0308cbfc99c8ac1f98cd",
            "ddb84f0f4a4ddd57584f044bf260e641905326f76c64c8e6be7e5e03d4fc599d"
          ],
          [
            "6057170b1dd12fdf8de05f281d8e06bb91e1493a8b91d4cc5a21382120a959e5",
            "9a1af0b26a6a4807add9a2daf71df262465152bc3ee24c65e899be932385a2a8"
          ],
          [
            "a576df8e23a08411421439a4518da31880cef0fba7d4df12b1a6973eecb94266",
            "40a6bf20e76640b2c92b97afe58cd82c432e10a7f514d9f3ee8be11ae1b28ec8"
          ],
          [
            "7778a78c28dec3e30a05fe9629de8c38bb30d1f5cf9a3a208f763889be58ad71",
            "34626d9ab5a5b22ff7098e12f2ff580087b38411ff24ac563b513fc1fd9f43ac"
          ],
          [
            "928955ee637a84463729fd30e7afd2ed5f96274e5ad7e5cb09eda9c06d903ac",
            "c25621003d3f42a827b78a13093a95eeac3d26efa8a8d83fc5180e935bcd091f"
          ],
          [
            "85d0fef3ec6db109399064f3a0e3b2855645b4a907ad354527aae75163d82751",
            "1f03648413a38c0be29d496e582cf5663e8751e96877331582c237a24eb1f962"
          ],
          [
            "ff2b0dce97eece97c1c9b6041798b85dfdfb6d8882da20308f5404824526087e",
            "493d13fef524ba188af4c4dc54d07936c7b7ed6fb90e2ceb2c951e01f0c29907"
          ],
          [
            "827fbbe4b1e880ea9ed2b2e6301b212b57f1ee148cd6dd28780e5e2cf856e241",
            "c60f9c923c727b0b71bef2c67d1d12687ff7a63186903166d605b68baec293ec"
          ],
          [
            "eaa649f21f51bdbae7be4ae34ce6e5217a58fdce7f47f9aa7f3b58fa2120e2b3",
            "be3279ed5bbbb03ac69a80f89879aa5a01a6b965f13f7e59d47a5305ba5ad93d"
          ],
          [
            "e4a42d43c5cf169d9391df6decf42ee541b6d8f0c9a137401e23632dda34d24f",
            "4d9f92e716d1c73526fc99ccfb8ad34ce886eedfa8d8e4f13a7f7131deba9414"
          ],
          [
            "1ec80fef360cbdd954160fadab352b6b92b53576a88fea4947173b9d4300bf19",
            "aeefe93756b5340d2f3a4958a7abbf5e0146e77f6295a07b671cdc1cc107cefd"
          ],
          [
            "146a778c04670c2f91b00af4680dfa8bce3490717d58ba889ddb5928366642be",
            "b318e0ec3354028add669827f9d4b2870aaa971d2f7e5ed1d0b297483d83efd0"
          ],
          [
            "fa50c0f61d22e5f07e3acebb1aa07b128d0012209a28b9776d76a8793180eef9",
            "6b84c6922397eba9b72cd2872281a68a5e683293a57a213b38cd8d7d3f4f2811"
          ],
          [
            "da1d61d0ca721a11b1a5bf6b7d88e8421a288ab5d5bba5220e53d32b5f067ec2",
            "8157f55a7c99306c79c0766161c91e2966a73899d279b48a655fba0f1ad836f1"
          ],
          [
            "a8e282ff0c9706907215ff98e8fd416615311de0446f1e062a73b0610d064e13",
            "7f97355b8db81c09abfb7f3c5b2515888b679a3e50dd6bd6cef7c73111f4cc0c"
          ],
          [
            "174a53b9c9a285872d39e56e6913cab15d59b1fa512508c022f382de8319497c",
            "ccc9dc37abfc9c1657b4155f2c47f9e6646b3a1d8cb9854383da13ac079afa73"
          ],
          [
            "959396981943785c3d3e57edf5018cdbe039e730e4918b3d884fdff09475b7ba",
            "2e7e552888c331dd8ba0386a4b9cd6849c653f64c8709385e9b8abf87524f2fd"
          ],
          [
            "d2a63a50ae401e56d645a1153b109a8fcca0a43d561fba2dbb51340c9d82b151",
            "e82d86fb6443fcb7565aee58b2948220a70f750af484ca52d4142174dcf89405"
          ],
          [
            "64587e2335471eb890ee7896d7cfdc866bacbdbd3839317b3436f9b45617e073",
            "d99fcdd5bf6902e2ae96dd6447c299a185b90a39133aeab358299e5e9faf6589"
          ],
          [
            "8481bde0e4e4d885b3a546d3e549de042f0aa6cea250e7fd358d6c86dd45e458",
            "38ee7b8cba5404dd84a25bf39cecb2ca900a79c42b262e556d64b1b59779057e"
          ],
          [
            "13464a57a78102aa62b6979ae817f4637ffcfed3c4b1ce30bcd6303f6caf666b",
            "69be159004614580ef7e433453ccb0ca48f300a81d0942e13f495a907f6ecc27"
          ],
          [
            "bc4a9df5b713fe2e9aef430bcc1dc97a0cd9ccede2f28588cada3a0d2d83f366",
            "d3a81ca6e785c06383937adf4b798caa6e8a9fbfa547b16d758d666581f33c1"
          ],
          [
            "8c28a97bf8298bc0d23d8c749452a32e694b65e30a9472a3954ab30fe5324caa",
            "40a30463a3305193378fedf31f7cc0eb7ae784f0451cb9459e71dc73cbef9482"
          ],
          [
            "8ea9666139527a8c1dd94ce4f071fd23c8b350c5a4bb33748c4ba111faccae0",
            "620efabbc8ee2782e24e7c0cfb95c5d735b783be9cf0f8e955af34a30e62b945"
          ],
          [
            "dd3625faef5ba06074669716bbd3788d89bdde815959968092f76cc4eb9a9787",
            "7a188fa3520e30d461da2501045731ca941461982883395937f68d00c644a573"
          ],
          [
            "f710d79d9eb962297e4f6232b40e8f7feb2bc63814614d692c12de752408221e",
            "ea98e67232d3b3295d3b535532115ccac8612c721851617526ae47a9c77bfc82"
          ]
        ]
      },
      naf: {
        wnd: 7,
        points: [
          [
            "f9308a019258c31049344f85f89d5229b531c845836f99b08601f113bce036f9",
            "388f7b0f632de8140fe337e62a37f3566500a99934c2231b6cb9fd7584b8e672"
          ],
          [
            "2f8bde4d1a07209355b4a7250a5c5128e88b84bddc619ab7cba8d569b240efe4",
            "d8ac222636e5e3d6d4dba9dda6c9c426f788271bab0d6840dca87d3aa6ac62d6"
          ],
          [
            "5cbdf0646e5db4eaa398f365f2ea7a0e3d419b7e0330e39ce92bddedcac4f9bc",
            "6aebca40ba255960a3178d6d861a54dba813d0b813fde7b5a5082628087264da"
          ],
          [
            "acd484e2f0c7f65309ad178a9f559abde09796974c57e714c35f110dfc27ccbe",
            "cc338921b0a7d9fd64380971763b61e9add888a4375f8e0f05cc262ac64f9c37"
          ],
          [
            "774ae7f858a9411e5ef4246b70c65aac5649980be5c17891bbec17895da008cb",
            "d984a032eb6b5e190243dd56d7b7b365372db1e2dff9d6a8301d74c9c953c61b"
          ],
          [
            "f28773c2d975288bc7d1d205c3748651b075fbc6610e58cddeeddf8f19405aa8",
            "ab0902e8d880a89758212eb65cdaf473a1a06da521fa91f29b5cb52db03ed81"
          ],
          [
            "d7924d4f7d43ea965a465ae3095ff41131e5946f3c85f79e44adbcf8e27e080e",
            "581e2872a86c72a683842ec228cc6defea40af2bd896d3a5c504dc9ff6a26b58"
          ],
          [
            "defdea4cdb677750a420fee807eacf21eb9898ae79b9768766e4faa04a2d4a34",
            "4211ab0694635168e997b0ead2a93daeced1f4a04a95c0f6cfb199f69e56eb77"
          ],
          [
            "2b4ea0a797a443d293ef5cff444f4979f06acfebd7e86d277475656138385b6c",
            "85e89bc037945d93b343083b5a1c86131a01f60c50269763b570c854e5c09b7a"
          ],
          [
            "352bbf4a4cdd12564f93fa332ce333301d9ad40271f8107181340aef25be59d5",
            "321eb4075348f534d59c18259dda3e1f4a1b3b2e71b1039c67bd3d8bcf81998c"
          ],
          [
            "2fa2104d6b38d11b0230010559879124e42ab8dfeff5ff29dc9cdadd4ecacc3f",
            "2de1068295dd865b64569335bd5dd80181d70ecfc882648423ba76b532b7d67"
          ],
          [
            "9248279b09b4d68dab21a9b066edda83263c3d84e09572e269ca0cd7f5453714",
            "73016f7bf234aade5d1aa71bdea2b1ff3fc0de2a887912ffe54a32ce97cb3402"
          ],
          [
            "daed4f2be3a8bf278e70132fb0beb7522f570e144bf615c07e996d443dee8729",
            "a69dce4a7d6c98e8d4a1aca87ef8d7003f83c230f3afa726ab40e52290be1c55"
          ],
          [
            "c44d12c7065d812e8acf28d7cbb19f9011ecd9e9fdf281b0e6a3b5e87d22e7db",
            "2119a460ce326cdc76c45926c982fdac0e106e861edf61c5a039063f0e0e6482"
          ],
          [
            "6a245bf6dc698504c89a20cfded60853152b695336c28063b61c65cbd269e6b4",
            "e022cf42c2bd4a708b3f5126f16a24ad8b33ba48d0423b6efd5e6348100d8a82"
          ],
          [
            "1697ffa6fd9de627c077e3d2fe541084ce13300b0bec1146f95ae57f0d0bd6a5",
            "b9c398f186806f5d27561506e4557433a2cf15009e498ae7adee9d63d01b2396"
          ],
          [
            "605bdb019981718b986d0f07e834cb0d9deb8360ffb7f61df982345ef27a7479",
            "2972d2de4f8d20681a78d93ec96fe23c26bfae84fb14db43b01e1e9056b8c49"
          ],
          [
            "62d14dab4150bf497402fdc45a215e10dcb01c354959b10cfe31c7e9d87ff33d",
            "80fc06bd8cc5b01098088a1950eed0db01aa132967ab472235f5642483b25eaf"
          ],
          [
            "80c60ad0040f27dade5b4b06c408e56b2c50e9f56b9b8b425e555c2f86308b6f",
            "1c38303f1cc5c30f26e66bad7fe72f70a65eed4cbe7024eb1aa01f56430bd57a"
          ],
          [
            "7a9375ad6167ad54aa74c6348cc54d344cc5dc9487d847049d5eabb0fa03c8fb",
            "d0e3fa9eca8726909559e0d79269046bdc59ea10c70ce2b02d499ec224dc7f7"
          ],
          [
            "d528ecd9b696b54c907a9ed045447a79bb408ec39b68df504bb51f459bc3ffc9",
            "eecf41253136e5f99966f21881fd656ebc4345405c520dbc063465b521409933"
          ],
          [
            "49370a4b5f43412ea25f514e8ecdad05266115e4a7ecb1387231808f8b45963",
            "758f3f41afd6ed428b3081b0512fd62a54c3f3afbb5b6764b653052a12949c9a"
          ],
          [
            "77f230936ee88cbbd73df930d64702ef881d811e0e1498e2f1c13eb1fc345d74",
            "958ef42a7886b6400a08266e9ba1b37896c95330d97077cbbe8eb3c7671c60d6"
          ],
          [
            "f2dac991cc4ce4b9ea44887e5c7c0bce58c80074ab9d4dbaeb28531b7739f530",
            "e0dedc9b3b2f8dad4da1f32dec2531df9eb5fbeb0598e4fd1a117dba703a3c37"
          ],
          [
            "463b3d9f662621fb1b4be8fbbe2520125a216cdfc9dae3debcba4850c690d45b",
            "5ed430d78c296c3543114306dd8622d7c622e27c970a1de31cb377b01af7307e"
          ],
          [
            "f16f804244e46e2a09232d4aff3b59976b98fac14328a2d1a32496b49998f247",
            "cedabd9b82203f7e13d206fcdf4e33d92a6c53c26e5cce26d6579962c4e31df6"
          ],
          [
            "caf754272dc84563b0352b7a14311af55d245315ace27c65369e15f7151d41d1",
            "cb474660ef35f5f2a41b643fa5e460575f4fa9b7962232a5c32f908318a04476"
          ],
          [
            "2600ca4b282cb986f85d0f1709979d8b44a09c07cb86d7c124497bc86f082120",
            "4119b88753c15bd6a693b03fcddbb45d5ac6be74ab5f0ef44b0be9475a7e4b40"
          ],
          [
            "7635ca72d7e8432c338ec53cd12220bc01c48685e24f7dc8c602a7746998e435",
            "91b649609489d613d1d5e590f78e6d74ecfc061d57048bad9e76f302c5b9c61"
          ],
          [
            "754e3239f325570cdbbf4a87deee8a66b7f2b33479d468fbc1a50743bf56cc18",
            "673fb86e5bda30fb3cd0ed304ea49a023ee33d0197a695d0c5d98093c536683"
          ],
          [
            "e3e6bd1071a1e96aff57859c82d570f0330800661d1c952f9fe2694691d9b9e8",
            "59c9e0bba394e76f40c0aa58379a3cb6a5a2283993e90c4167002af4920e37f5"
          ],
          [
            "186b483d056a033826ae73d88f732985c4ccb1f32ba35f4b4cc47fdcf04aa6eb",
            "3b952d32c67cf77e2e17446e204180ab21fb8090895138b4a4a797f86e80888b"
          ],
          [
            "df9d70a6b9876ce544c98561f4be4f725442e6d2b737d9c91a8321724ce0963f",
            "55eb2dafd84d6ccd5f862b785dc39d4ab157222720ef9da217b8c45cf2ba2417"
          ],
          [
            "5edd5cc23c51e87a497ca815d5dce0f8ab52554f849ed8995de64c5f34ce7143",
            "efae9c8dbc14130661e8cec030c89ad0c13c66c0d17a2905cdc706ab7399a868"
          ],
          [
            "290798c2b6476830da12fe02287e9e777aa3fba1c355b17a722d362f84614fba",
            "e38da76dcd440621988d00bcf79af25d5b29c094db2a23146d003afd41943e7a"
          ],
          [
            "af3c423a95d9f5b3054754efa150ac39cd29552fe360257362dfdecef4053b45",
            "f98a3fd831eb2b749a93b0e6f35cfb40c8cd5aa667a15581bc2feded498fd9c6"
          ],
          [
            "766dbb24d134e745cccaa28c99bf274906bb66b26dcf98df8d2fed50d884249a",
            "744b1152eacbe5e38dcc887980da38b897584a65fa06cedd2c924f97cbac5996"
          ],
          [
            "59dbf46f8c94759ba21277c33784f41645f7b44f6c596a58ce92e666191abe3e",
            "c534ad44175fbc300f4ea6ce648309a042ce739a7919798cd85e216c4a307f6e"
          ],
          [
            "f13ada95103c4537305e691e74e9a4a8dd647e711a95e73cb62dc6018cfd87b8",
            "e13817b44ee14de663bf4bc808341f326949e21a6a75c2570778419bdaf5733d"
          ],
          [
            "7754b4fa0e8aced06d4167a2c59cca4cda1869c06ebadfb6488550015a88522c",
            "30e93e864e669d82224b967c3020b8fa8d1e4e350b6cbcc537a48b57841163a2"
          ],
          [
            "948dcadf5990e048aa3874d46abef9d701858f95de8041d2a6828c99e2262519",
            "e491a42537f6e597d5d28a3224b1bc25df9154efbd2ef1d2cbba2cae5347d57e"
          ],
          [
            "7962414450c76c1689c7b48f8202ec37fb224cf5ac0bfa1570328a8a3d7c77ab",
            "100b610ec4ffb4760d5c1fc133ef6f6b12507a051f04ac5760afa5b29db83437"
          ],
          [
            "3514087834964b54b15b160644d915485a16977225b8847bb0dd085137ec47ca",
            "ef0afbb2056205448e1652c48e8127fc6039e77c15c2378b7e7d15a0de293311"
          ],
          [
            "d3cc30ad6b483e4bc79ce2c9dd8bc54993e947eb8df787b442943d3f7b527eaf",
            "8b378a22d827278d89c5e9be8f9508ae3c2ad46290358630afb34db04eede0a4"
          ],
          [
            "1624d84780732860ce1c78fcbfefe08b2b29823db913f6493975ba0ff4847610",
            "68651cf9b6da903e0914448c6cd9d4ca896878f5282be4c8cc06e2a404078575"
          ],
          [
            "733ce80da955a8a26902c95633e62a985192474b5af207da6df7b4fd5fc61cd4",
            "f5435a2bd2badf7d485a4d8b8db9fcce3e1ef8e0201e4578c54673bc1dc5ea1d"
          ],
          [
            "15d9441254945064cf1a1c33bbd3b49f8966c5092171e699ef258dfab81c045c",
            "d56eb30b69463e7234f5137b73b84177434800bacebfc685fc37bbe9efe4070d"
          ],
          [
            "a1d0fcf2ec9de675b612136e5ce70d271c21417c9d2b8aaaac138599d0717940",
            "edd77f50bcb5a3cab2e90737309667f2641462a54070f3d519212d39c197a629"
          ],
          [
            "e22fbe15c0af8ccc5780c0735f84dbe9a790badee8245c06c7ca37331cb36980",
            "a855babad5cd60c88b430a69f53a1a7a38289154964799be43d06d77d31da06"
          ],
          [
            "311091dd9860e8e20ee13473c1155f5f69635e394704eaa74009452246cfa9b3",
            "66db656f87d1f04fffd1f04788c06830871ec5a64feee685bd80f0b1286d8374"
          ],
          [
            "34c1fd04d301be89b31c0442d3e6ac24883928b45a9340781867d4232ec2dbdf",
            "9414685e97b1b5954bd46f730174136d57f1ceeb487443dc5321857ba73abee"
          ],
          [
            "f219ea5d6b54701c1c14de5b557eb42a8d13f3abbcd08affcc2a5e6b049b8d63",
            "4cb95957e83d40b0f73af4544cccf6b1f4b08d3c07b27fb8d8c2962a400766d1"
          ],
          [
            "d7b8740f74a8fbaab1f683db8f45de26543a5490bca627087236912469a0b448",
            "fa77968128d9c92ee1010f337ad4717eff15db5ed3c049b3411e0315eaa4593b"
          ],
          [
            "32d31c222f8f6f0ef86f7c98d3a3335ead5bcd32abdd94289fe4d3091aa824bf",
            "5f3032f5892156e39ccd3d7915b9e1da2e6dac9e6f26e961118d14b8462e1661"
          ],
          [
            "7461f371914ab32671045a155d9831ea8793d77cd59592c4340f86cbc18347b5",
            "8ec0ba238b96bec0cbdddcae0aa442542eee1ff50c986ea6b39847b3cc092ff6"
          ],
          [
            "ee079adb1df1860074356a25aa38206a6d716b2c3e67453d287698bad7b2b2d6",
            "8dc2412aafe3be5c4c5f37e0ecc5f9f6a446989af04c4e25ebaac479ec1c8c1e"
          ],
          [
            "16ec93e447ec83f0467b18302ee620f7e65de331874c9dc72bfd8616ba9da6b5",
            "5e4631150e62fb40d0e8c2a7ca5804a39d58186a50e497139626778e25b0674d"
          ],
          [
            "eaa5f980c245f6f038978290afa70b6bd8855897f98b6aa485b96065d537bd99",
            "f65f5d3e292c2e0819a528391c994624d784869d7e6ea67fb18041024edc07dc"
          ],
          [
            "78c9407544ac132692ee1910a02439958ae04877151342ea96c4b6b35a49f51",
            "f3e0319169eb9b85d5404795539a5e68fa1fbd583c064d2462b675f194a3ddb4"
          ],
          [
            "494f4be219a1a77016dcd838431aea0001cdc8ae7a6fc688726578d9702857a5",
            "42242a969283a5f339ba7f075e36ba2af925ce30d767ed6e55f4b031880d562c"
          ],
          [
            "a598a8030da6d86c6bc7f2f5144ea549d28211ea58faa70ebf4c1e665c1fe9b5",
            "204b5d6f84822c307e4b4a7140737aec23fc63b65b35f86a10026dbd2d864e6b"
          ],
          [
            "c41916365abb2b5d09192f5f2dbeafec208f020f12570a184dbadc3e58595997",
            "4f14351d0087efa49d245b328984989d5caf9450f34bfc0ed16e96b58fa9913"
          ],
          [
            "841d6063a586fa475a724604da03bc5b92a2e0d2e0a36acfe4c73a5514742881",
            "73867f59c0659e81904f9a1c7543698e62562d6744c169ce7a36de01a8d6154"
          ],
          [
            "5e95bb399a6971d376026947f89bde2f282b33810928be4ded112ac4d70e20d5",
            "39f23f366809085beebfc71181313775a99c9aed7d8ba38b161384c746012865"
          ],
          [
            "36e4641a53948fd476c39f8a99fd974e5ec07564b5315d8bf99471bca0ef2f66",
            "d2424b1b1abe4eb8164227b085c9aa9456ea13493fd563e06fd51cf5694c78fc"
          ],
          [
            "336581ea7bfbbb290c191a2f507a41cf5643842170e914faeab27c2c579f726",
            "ead12168595fe1be99252129b6e56b3391f7ab1410cd1e0ef3dcdcabd2fda224"
          ],
          [
            "8ab89816dadfd6b6a1f2634fcf00ec8403781025ed6890c4849742706bd43ede",
            "6fdcef09f2f6d0a044e654aef624136f503d459c3e89845858a47a9129cdd24e"
          ],
          [
            "1e33f1a746c9c5778133344d9299fcaa20b0938e8acff2544bb40284b8c5fb94",
            "60660257dd11b3aa9c8ed618d24edff2306d320f1d03010e33a7d2057f3b3b6"
          ],
          [
            "85b7c1dcb3cec1b7ee7f30ded79dd20a0ed1f4cc18cbcfcfa410361fd8f08f31",
            "3d98a9cdd026dd43f39048f25a8847f4fcafad1895d7a633c6fed3c35e999511"
          ],
          [
            "29df9fbd8d9e46509275f4b125d6d45d7fbe9a3b878a7af872a2800661ac5f51",
            "b4c4fe99c775a606e2d8862179139ffda61dc861c019e55cd2876eb2a27d84b"
          ],
          [
            "a0b1cae06b0a847a3fea6e671aaf8adfdfe58ca2f768105c8082b2e449fce252",
            "ae434102edde0958ec4b19d917a6a28e6b72da1834aff0e650f049503a296cf2"
          ],
          [
            "4e8ceafb9b3e9a136dc7ff67e840295b499dfb3b2133e4ba113f2e4c0e121e5",
            "cf2174118c8b6d7a4b48f6d534ce5c79422c086a63460502b827ce62a326683c"
          ],
          [
            "d24a44e047e19b6f5afb81c7ca2f69080a5076689a010919f42725c2b789a33b",
            "6fb8d5591b466f8fc63db50f1c0f1c69013f996887b8244d2cdec417afea8fa3"
          ],
          [
            "ea01606a7a6c9cdd249fdfcfacb99584001edd28abbab77b5104e98e8e3b35d4",
            "322af4908c7312b0cfbfe369f7a7b3cdb7d4494bc2823700cfd652188a3ea98d"
          ],
          [
            "af8addbf2b661c8a6c6328655eb96651252007d8c5ea31be4ad196de8ce2131f",
            "6749e67c029b85f52a034eafd096836b2520818680e26ac8f3dfbcdb71749700"
          ],
          [
            "e3ae1974566ca06cc516d47e0fb165a674a3dabcfca15e722f0e3450f45889",
            "2aeabe7e4531510116217f07bf4d07300de97e4874f81f533420a72eeb0bd6a4"
          ],
          [
            "591ee355313d99721cf6993ffed1e3e301993ff3ed258802075ea8ced397e246",
            "b0ea558a113c30bea60fc4775460c7901ff0b053d25ca2bdeee98f1a4be5d196"
          ],
          [
            "11396d55fda54c49f19aa97318d8da61fa8584e47b084945077cf03255b52984",
            "998c74a8cd45ac01289d5833a7beb4744ff536b01b257be4c5767bea93ea57a4"
          ],
          [
            "3c5d2a1ba39c5a1790000738c9e0c40b8dcdfd5468754b6405540157e017aa7a",
            "b2284279995a34e2f9d4de7396fc18b80f9b8b9fdd270f6661f79ca4c81bd257"
          ],
          [
            "cc8704b8a60a0defa3a99a7299f2e9c3fbc395afb04ac078425ef8a1793cc030",
            "bdd46039feed17881d1e0862db347f8cf395b74fc4bcdc4e940b74e3ac1f1b13"
          ],
          [
            "c533e4f7ea8555aacd9777ac5cad29b97dd4defccc53ee7ea204119b2889b197",
            "6f0a256bc5efdf429a2fb6242f1a43a2d9b925bb4a4b3a26bb8e0f45eb596096"
          ],
          [
            "c14f8f2ccb27d6f109f6d08d03cc96a69ba8c34eec07bbcf566d48e33da6593",
            "c359d6923bb398f7fd4473e16fe1c28475b740dd098075e6c0e8649113dc3a38"
          ],
          [
            "a6cbc3046bc6a450bac24789fa17115a4c9739ed75f8f21ce441f72e0b90e6ef",
            "21ae7f4680e889bb130619e2c0f95a360ceb573c70603139862afd617fa9b9f"
          ],
          [
            "347d6d9a02c48927ebfb86c1359b1caf130a3c0267d11ce6344b39f99d43cc38",
            "60ea7f61a353524d1c987f6ecec92f086d565ab687870cb12689ff1e31c74448"
          ],
          [
            "da6545d2181db8d983f7dcb375ef5866d47c67b1bf31c8cf855ef7437b72656a",
            "49b96715ab6878a79e78f07ce5680c5d6673051b4935bd897fea824b77dc208a"
          ],
          [
            "c40747cc9d012cb1a13b8148309c6de7ec25d6945d657146b9d5994b8feb1111",
            "5ca560753be2a12fc6de6caf2cb489565db936156b9514e1bb5e83037e0fa2d4"
          ],
          [
            "4e42c8ec82c99798ccf3a610be870e78338c7f713348bd34c8203ef4037f3502",
            "7571d74ee5e0fb92a7a8b33a07783341a5492144cc54bcc40a94473693606437"
          ],
          [
            "3775ab7089bc6af823aba2e1af70b236d251cadb0c86743287522a1b3b0dedea",
            "be52d107bcfa09d8bcb9736a828cfa7fac8db17bf7a76a2c42ad961409018cf7"
          ],
          [
            "cee31cbf7e34ec379d94fb814d3d775ad954595d1314ba8846959e3e82f74e26",
            "8fd64a14c06b589c26b947ae2bcf6bfa0149ef0be14ed4d80f448a01c43b1c6d"
          ],
          [
            "b4f9eaea09b6917619f6ea6a4eb5464efddb58fd45b1ebefcdc1a01d08b47986",
            "39e5c9925b5a54b07433a4f18c61726f8bb131c012ca542eb24a8ac07200682a"
          ],
          [
            "d4263dfc3d2df923a0179a48966d30ce84e2515afc3dccc1b77907792ebcc60e",
            "62dfaf07a0f78feb30e30d6295853ce189e127760ad6cf7fae164e122a208d54"
          ],
          [
            "48457524820fa65a4f8d35eb6930857c0032acc0a4a2de422233eeda897612c4",
            "25a748ab367979d98733c38a1fa1c2e7dc6cc07db2d60a9ae7a76aaa49bd0f77"
          ],
          [
            "dfeeef1881101f2cb11644f3a2afdfc2045e19919152923f367a1767c11cceda",
            "ecfb7056cf1de042f9420bab396793c0c390bde74b4bbdff16a83ae09a9a7517"
          ],
          [
            "6d7ef6b17543f8373c573f44e1f389835d89bcbc6062ced36c82df83b8fae859",
            "cd450ec335438986dfefa10c57fea9bcc521a0959b2d80bbf74b190dca712d10"
          ],
          [
            "e75605d59102a5a2684500d3b991f2e3f3c88b93225547035af25af66e04541f",
            "f5c54754a8f71ee540b9b48728473e314f729ac5308b06938360990e2bfad125"
          ],
          [
            "eb98660f4c4dfaa06a2be453d5020bc99a0c2e60abe388457dd43fefb1ed620c",
            "6cb9a8876d9cb8520609af3add26cd20a0a7cd8a9411131ce85f44100099223e"
          ],
          [
            "13e87b027d8514d35939f2e6892b19922154596941888336dc3563e3b8dba942",
            "fef5a3c68059a6dec5d624114bf1e91aac2b9da568d6abeb2570d55646b8adf1"
          ],
          [
            "ee163026e9fd6fe017c38f06a5be6fc125424b371ce2708e7bf4491691e5764a",
            "1acb250f255dd61c43d94ccc670d0f58f49ae3fa15b96623e5430da0ad6c62b2"
          ],
          [
            "b268f5ef9ad51e4d78de3a750c2dc89b1e626d43505867999932e5db33af3d80",
            "5f310d4b3c99b9ebb19f77d41c1dee018cf0d34fd4191614003e945a1216e423"
          ],
          [
            "ff07f3118a9df035e9fad85eb6c7bfe42b02f01ca99ceea3bf7ffdba93c4750d",
            "438136d603e858a3a5c440c38eccbaddc1d2942114e2eddd4740d098ced1f0d8"
          ],
          [
            "8d8b9855c7c052a34146fd20ffb658bea4b9f69e0d825ebec16e8c3ce2b526a1",
            "cdb559eedc2d79f926baf44fb84ea4d44bcf50fee51d7ceb30e2e7f463036758"
          ],
          [
            "52db0b5384dfbf05bfa9d472d7ae26dfe4b851ceca91b1eba54263180da32b63",
            "c3b997d050ee5d423ebaf66a6db9f57b3180c902875679de924b69d84a7b375"
          ],
          [
            "e62f9490d3d51da6395efd24e80919cc7d0f29c3f3fa48c6fff543becbd43352",
            "6d89ad7ba4876b0b22c2ca280c682862f342c8591f1daf5170e07bfd9ccafa7d"
          ],
          [
            "7f30ea2476b399b4957509c88f77d0191afa2ff5cb7b14fd6d8e7d65aaab1193",
            "ca5ef7d4b231c94c3b15389a5f6311e9daff7bb67b103e9880ef4bff637acaec"
          ],
          [
            "5098ff1e1d9f14fb46a210fada6c903fef0fb7b4a1dd1d9ac60a0361800b7a00",
            "9731141d81fc8f8084d37c6e7542006b3ee1b40d60dfe5362a5b132fd17ddc0"
          ],
          [
            "32b78c7de9ee512a72895be6b9cbefa6e2f3c4ccce445c96b9f2c81e2778ad58",
            "ee1849f513df71e32efc3896ee28260c73bb80547ae2275ba497237794c8753c"
          ],
          [
            "e2cb74fddc8e9fbcd076eef2a7c72b0ce37d50f08269dfc074b581550547a4f7",
            "d3aa2ed71c9dd2247a62df062736eb0baddea9e36122d2be8641abcb005cc4a4"
          ],
          [
            "8438447566d4d7bedadc299496ab357426009a35f235cb141be0d99cd10ae3a8",
            "c4e1020916980a4da5d01ac5e6ad330734ef0d7906631c4f2390426b2edd791f"
          ],
          [
            "4162d488b89402039b584c6fc6c308870587d9c46f660b878ab65c82c711d67e",
            "67163e903236289f776f22c25fb8a3afc1732f2b84b4e95dbda47ae5a0852649"
          ],
          [
            "3fad3fa84caf0f34f0f89bfd2dcf54fc175d767aec3e50684f3ba4a4bf5f683d",
            "cd1bc7cb6cc407bb2f0ca647c718a730cf71872e7d0d2a53fa20efcdfe61826"
          ],
          [
            "674f2600a3007a00568c1a7ce05d0816c1fb84bf1370798f1c69532faeb1a86b",
            "299d21f9413f33b3edf43b257004580b70db57da0b182259e09eecc69e0d38a5"
          ],
          [
            "d32f4da54ade74abb81b815ad1fb3b263d82d6c692714bcff87d29bd5ee9f08f",
            "f9429e738b8e53b968e99016c059707782e14f4535359d582fc416910b3eea87"
          ],
          [
            "30e4e670435385556e593657135845d36fbb6931f72b08cb1ed954f1e3ce3ff6",
            "462f9bce619898638499350113bbc9b10a878d35da70740dc695a559eb88db7b"
          ],
          [
            "be2062003c51cc3004682904330e4dee7f3dcd10b01e580bf1971b04d4cad297",
            "62188bc49d61e5428573d48a74e1c655b1c61090905682a0d5558ed72dccb9bc"
          ],
          [
            "93144423ace3451ed29e0fb9ac2af211cb6e84a601df5993c419859fff5df04a",
            "7c10dfb164c3425f5c71a3f9d7992038f1065224f72bb9d1d902a6d13037b47c"
          ],
          [
            "b015f8044f5fcbdcf21ca26d6c34fb8197829205c7b7d2a7cb66418c157b112c",
            "ab8c1e086d04e813744a655b2df8d5f83b3cdc6faa3088c1d3aea1454e3a1d5f"
          ],
          [
            "d5e9e1da649d97d89e4868117a465a3a4f8a18de57a140d36b3f2af341a21b52",
            "4cb04437f391ed73111a13cc1d4dd0db1693465c2240480d8955e8592f27447a"
          ],
          [
            "d3ae41047dd7ca065dbf8ed77b992439983005cd72e16d6f996a5316d36966bb",
            "bd1aeb21ad22ebb22a10f0303417c6d964f8cdd7df0aca614b10dc14d125ac46"
          ],
          [
            "463e2763d885f958fc66cdd22800f0a487197d0a82e377b49f80af87c897b065",
            "bfefacdb0e5d0fd7df3a311a94de062b26b80c61fbc97508b79992671ef7ca7f"
          ],
          [
            "7985fdfd127c0567c6f53ec1bb63ec3158e597c40bfe747c83cddfc910641917",
            "603c12daf3d9862ef2b25fe1de289aed24ed291e0ec6708703a5bd567f32ed03"
          ],
          [
            "74a1ad6b5f76e39db2dd249410eac7f99e74c59cb83d2d0ed5ff1543da7703e9",
            "cc6157ef18c9c63cd6193d83631bbea0093e0968942e8c33d5737fd790e0db08"
          ],
          [
            "30682a50703375f602d416664ba19b7fc9bab42c72747463a71d0896b22f6da3",
            "553e04f6b018b4fa6c8f39e7f311d3176290d0e0f19ca73f17714d9977a22ff8"
          ],
          [
            "9e2158f0d7c0d5f26c3791efefa79597654e7a2b2464f52b1ee6c1347769ef57",
            "712fcdd1b9053f09003a3481fa7762e9ffd7c8ef35a38509e2fbf2629008373"
          ],
          [
            "176e26989a43c9cfeba4029c202538c28172e566e3c4fce7322857f3be327d66",
            "ed8cc9d04b29eb877d270b4878dc43c19aefd31f4eee09ee7b47834c1fa4b1c3"
          ],
          [
            "75d46efea3771e6e68abb89a13ad747ecf1892393dfc4f1b7004788c50374da8",
            "9852390a99507679fd0b86fd2b39a868d7efc22151346e1a3ca4726586a6bed8"
          ],
          [
            "809a20c67d64900ffb698c4c825f6d5f2310fb0451c869345b7319f645605721",
            "9e994980d9917e22b76b061927fa04143d096ccc54963e6a5ebfa5f3f8e286c1"
          ],
          [
            "1b38903a43f7f114ed4500b4eac7083fdefece1cf29c63528d563446f972c180",
            "4036edc931a60ae889353f77fd53de4a2708b26b6f5da72ad3394119daf408f9"
          ]
        ]
      }
    };
  }
});

// node_modules/elliptic/lib/elliptic/curves.js
var require_curves = __commonJS({
  "node_modules/elliptic/lib/elliptic/curves.js"(exports) {
    "use strict";
    var curves = exports;
    var hash6 = require_hash();
    var curve = require_curve();
    var utils = require_utils3();
    var assert = utils.assert;
    function PresetCurve(options) {
      if (options.type === "short")
        this.curve = new curve.short(options);
      else if (options.type === "edwards")
        this.curve = new curve.edwards(options);
      else
        this.curve = new curve.mont(options);
      this.g = this.curve.g;
      this.n = this.curve.n;
      this.hash = options.hash;
      assert(this.g.validate(), "Invalid curve");
      assert(this.g.mul(this.n).isInfinity(), "Invalid curve, G*N != O");
    }
    curves.PresetCurve = PresetCurve;
    function defineCurve(name, options) {
      Object.defineProperty(curves, name, {
        configurable: true,
        enumerable: true,
        get: function() {
          var curve2 = new PresetCurve(options);
          Object.defineProperty(curves, name, {
            configurable: true,
            enumerable: true,
            value: curve2
          });
          return curve2;
        }
      });
    }
    defineCurve("p192", {
      type: "short",
      prime: "p192",
      p: "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff",
      a: "ffffffff ffffffff ffffffff fffffffe ffffffff fffffffc",
      b: "64210519 e59c80e7 0fa7e9ab 72243049 feb8deec c146b9b1",
      n: "ffffffff ffffffff ffffffff 99def836 146bc9b1 b4d22831",
      hash: hash6.sha256,
      gRed: false,
      g: [
        "188da80e b03090f6 7cbf20eb 43a18800 f4ff0afd 82ff1012",
        "07192b95 ffc8da78 631011ed 6b24cdd5 73f977a1 1e794811"
      ]
    });
    defineCurve("p224", {
      type: "short",
      prime: "p224",
      p: "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001",
      a: "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff fffffffe",
      b: "b4050a85 0c04b3ab f5413256 5044b0b7 d7bfd8ba 270b3943 2355ffb4",
      n: "ffffffff ffffffff ffffffff ffff16a2 e0b8f03e 13dd2945 5c5c2a3d",
      hash: hash6.sha256,
      gRed: false,
      g: [
        "b70e0cbd 6bb4bf7f 321390b9 4a03c1d3 56c21122 343280d6 115c1d21",
        "bd376388 b5f723fb 4c22dfe6 cd4375a0 5a074764 44d58199 85007e34"
      ]
    });
    defineCurve("p256", {
      type: "short",
      prime: null,
      p: "ffffffff 00000001 00000000 00000000 00000000 ffffffff ffffffff ffffffff",
      a: "ffffffff 00000001 00000000 00000000 00000000 ffffffff ffffffff fffffffc",
      b: "5ac635d8 aa3a93e7 b3ebbd55 769886bc 651d06b0 cc53b0f6 3bce3c3e 27d2604b",
      n: "ffffffff 00000000 ffffffff ffffffff bce6faad a7179e84 f3b9cac2 fc632551",
      hash: hash6.sha256,
      gRed: false,
      g: [
        "6b17d1f2 e12c4247 f8bce6e5 63a440f2 77037d81 2deb33a0 f4a13945 d898c296",
        "4fe342e2 fe1a7f9b 8ee7eb4a 7c0f9e16 2bce3357 6b315ece cbb64068 37bf51f5"
      ]
    });
    defineCurve("p384", {
      type: "short",
      prime: null,
      p: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe ffffffff 00000000 00000000 ffffffff",
      a: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe ffffffff 00000000 00000000 fffffffc",
      b: "b3312fa7 e23ee7e4 988e056b e3f82d19 181d9c6e fe814112 0314088f 5013875a c656398d 8a2ed19d 2a85c8ed d3ec2aef",
      n: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff c7634d81 f4372ddf 581a0db2 48b0a77a ecec196a ccc52973",
      hash: hash6.sha384,
      gRed: false,
      g: [
        "aa87ca22 be8b0537 8eb1c71e f320ad74 6e1d3b62 8ba79b98 59f741e0 82542a38 5502f25d bf55296c 3a545e38 72760ab7",
        "3617de4a 96262c6f 5d9e98bf 9292dc29 f8f41dbd 289a147c e9da3113 b5f0b8c0 0a60b1ce 1d7e819d 7a431d7c 90ea0e5f"
      ]
    });
    defineCurve("p521", {
      type: "short",
      prime: null,
      p: "000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff",
      a: "000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffc",
      b: "00000051 953eb961 8e1c9a1f 929a21a0 b68540ee a2da725b 99b315f3 b8b48991 8ef109e1 56193951 ec7e937b 1652c0bd 3bb1bf07 3573df88 3d2c34f1 ef451fd4 6b503f00",
      n: "000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffa 51868783 bf2f966b 7fcc0148 f709a5d0 3bb5c9b8 899c47ae bb6fb71e 91386409",
      hash: hash6.sha512,
      gRed: false,
      g: [
        "000000c6 858e06b7 0404e9cd 9e3ecb66 2395b442 9c648139 053fb521 f828af60 6b4d3dba a14b5e77 efe75928 fe1dc127 a2ffa8de 3348b3c1 856a429b f97e7e31 c2e5bd66",
        "00000118 39296a78 9a3bc004 5c8a5fb4 2c7d1bd9 98f54449 579b4468 17afbd17 273e662c 97ee7299 5ef42640 c550b901 3fad0761 353c7086 a272c240 88be9476 9fd16650"
      ]
    });
    defineCurve("curve25519", {
      type: "mont",
      prime: "p25519",
      p: "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed",
      a: "76d06",
      b: "1",
      n: "1000000000000000 0000000000000000 14def9dea2f79cd6 5812631a5cf5d3ed",
      hash: hash6.sha256,
      gRed: false,
      g: [
        "9"
      ]
    });
    defineCurve("ed25519", {
      type: "edwards",
      prime: "p25519",
      p: "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed",
      a: "-1",
      c: "1",
      // -121665 * (121666^(-1)) (mod P)
      d: "52036cee2b6ffe73 8cc740797779e898 00700a4d4141d8ab 75eb4dca135978a3",
      n: "1000000000000000 0000000000000000 14def9dea2f79cd6 5812631a5cf5d3ed",
      hash: hash6.sha256,
      gRed: false,
      g: [
        "216936d3cd6e53fec0a4e231fdd6dc5c692cc7609525a7b2c9562d608f25d51a",
        // 4/5
        "6666666666666666666666666666666666666666666666666666666666666658"
      ]
    });
    var pre;
    try {
      pre = require_secp256k1();
    } catch (e) {
      pre = void 0;
    }
    defineCurve("secp256k1", {
      type: "short",
      prime: "k256",
      p: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f",
      a: "0",
      b: "7",
      n: "ffffffff ffffffff ffffffff fffffffe baaedce6 af48a03b bfd25e8c d0364141",
      h: "1",
      hash: hash6.sha256,
      // Precomputed endomorphism
      beta: "7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee",
      lambda: "5363ad4cc05c30e0a5261c028812645a122e22ea20816678df02967c1b23bd72",
      basis: [
        {
          a: "3086d221a7d46bcde86c90e49284eb15",
          b: "-e4437ed6010e88286f547fa90abfe4c3"
        },
        {
          a: "114ca50f7a8e2f3f657c1108d9d44cfd8",
          b: "3086d221a7d46bcde86c90e49284eb15"
        }
      ],
      gRed: false,
      g: [
        "79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798",
        "483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8",
        pre
      ]
    });
  }
});

// node_modules/hmac-drbg/lib/hmac-drbg.js
var require_hmac_drbg = __commonJS({
  "node_modules/hmac-drbg/lib/hmac-drbg.js"(exports, module) {
    "use strict";
    var hash6 = require_hash();
    var utils = require_utils2();
    var assert = require_minimalistic_assert();
    function HmacDRBG(options) {
      if (!(this instanceof HmacDRBG))
        return new HmacDRBG(options);
      this.hash = options.hash;
      this.predResist = !!options.predResist;
      this.outLen = this.hash.outSize;
      this.minEntropy = options.minEntropy || this.hash.hmacStrength;
      this._reseed = null;
      this.reseedInterval = null;
      this.K = null;
      this.V = null;
      var entropy = utils.toArray(options.entropy, options.entropyEnc || "hex");
      var nonce = utils.toArray(options.nonce, options.nonceEnc || "hex");
      var pers = utils.toArray(options.pers, options.persEnc || "hex");
      assert(
        entropy.length >= this.minEntropy / 8,
        "Not enough entropy. Minimum is: " + this.minEntropy + " bits"
      );
      this._init(entropy, nonce, pers);
    }
    module.exports = HmacDRBG;
    HmacDRBG.prototype._init = function init(entropy, nonce, pers) {
      var seed = entropy.concat(nonce).concat(pers);
      this.K = new Array(this.outLen / 8);
      this.V = new Array(this.outLen / 8);
      for (var i2 = 0; i2 < this.V.length; i2++) {
        this.K[i2] = 0;
        this.V[i2] = 1;
      }
      this._update(seed);
      this._reseed = 1;
      this.reseedInterval = 281474976710656;
    };
    HmacDRBG.prototype._hmac = function hmac() {
      return new hash6.hmac(this.hash, this.K);
    };
    HmacDRBG.prototype._update = function update(seed) {
      var kmac = this._hmac().update(this.V).update([0]);
      if (seed)
        kmac = kmac.update(seed);
      this.K = kmac.digest();
      this.V = this._hmac().update(this.V).digest();
      if (!seed)
        return;
      this.K = this._hmac().update(this.V).update([1]).update(seed).digest();
      this.V = this._hmac().update(this.V).digest();
    };
    HmacDRBG.prototype.reseed = function reseed(entropy, entropyEnc, add, addEnc) {
      if (typeof entropyEnc !== "string") {
        addEnc = add;
        add = entropyEnc;
        entropyEnc = null;
      }
      entropy = utils.toArray(entropy, entropyEnc);
      add = utils.toArray(add, addEnc);
      assert(
        entropy.length >= this.minEntropy / 8,
        "Not enough entropy. Minimum is: " + this.minEntropy + " bits"
      );
      this._update(entropy.concat(add || []));
      this._reseed = 1;
    };
    HmacDRBG.prototype.generate = function generate2(len, enc, add, addEnc) {
      if (this._reseed > this.reseedInterval)
        throw new Error("Reseed is required");
      if (typeof enc !== "string") {
        addEnc = add;
        add = enc;
        enc = null;
      }
      if (add) {
        add = utils.toArray(add, addEnc || "hex");
        this._update(add);
      }
      var temp = [];
      while (temp.length < len) {
        this.V = this._hmac().update(this.V).digest();
        temp = temp.concat(this.V);
      }
      var res = temp.slice(0, len);
      this._update(add);
      this._reseed++;
      return utils.encode(res, enc);
    };
  }
});

// node_modules/elliptic/lib/elliptic/ec/key.js
var require_key = __commonJS({
  "node_modules/elliptic/lib/elliptic/ec/key.js"(exports, module) {
    "use strict";
    var BN = require_bn();
    var utils = require_utils3();
    var assert = utils.assert;
    function KeyPair(ec, options) {
      this.ec = ec;
      this.priv = null;
      this.pub = null;
      if (options.priv)
        this._importPrivate(options.priv, options.privEnc);
      if (options.pub)
        this._importPublic(options.pub, options.pubEnc);
    }
    module.exports = KeyPair;
    KeyPair.fromPublic = function fromPublic(ec, pub, enc) {
      if (pub instanceof KeyPair)
        return pub;
      return new KeyPair(ec, {
        pub,
        pubEnc: enc
      });
    };
    KeyPair.fromPrivate = function fromPrivate(ec, priv, enc) {
      if (priv instanceof KeyPair)
        return priv;
      return new KeyPair(ec, {
        priv,
        privEnc: enc
      });
    };
    KeyPair.prototype.validate = function validate() {
      var pub = this.getPublic();
      if (pub.isInfinity())
        return { result: false, reason: "Invalid public key" };
      if (!pub.validate())
        return { result: false, reason: "Public key is not a point" };
      if (!pub.mul(this.ec.curve.n).isInfinity())
        return { result: false, reason: "Public key * N != O" };
      return { result: true, reason: null };
    };
    KeyPair.prototype.getPublic = function getPublic(compact, enc) {
      if (typeof compact === "string") {
        enc = compact;
        compact = null;
      }
      if (!this.pub)
        this.pub = this.ec.g.mul(this.priv);
      if (!enc)
        return this.pub;
      return this.pub.encode(enc, compact);
    };
    KeyPair.prototype.getPrivate = function getPrivate(enc) {
      if (enc === "hex")
        return this.priv.toString(16, 2);
      else
        return this.priv;
    };
    KeyPair.prototype._importPrivate = function _importPrivate(key, enc) {
      this.priv = new BN(key, enc || 16);
      this.priv = this.priv.umod(this.ec.curve.n);
    };
    KeyPair.prototype._importPublic = function _importPublic(key, enc) {
      if (key.x || key.y) {
        if (this.ec.curve.type === "mont") {
          assert(key.x, "Need x coordinate");
        } else if (this.ec.curve.type === "short" || this.ec.curve.type === "edwards") {
          assert(key.x && key.y, "Need both x and y coordinate");
        }
        this.pub = this.ec.curve.point(key.x, key.y);
        return;
      }
      this.pub = this.ec.curve.decodePoint(key, enc);
    };
    KeyPair.prototype.derive = function derive(pub) {
      if (!pub.validate()) {
        assert(pub.validate(), "public point not validated");
      }
      return pub.mul(this.priv).getX();
    };
    KeyPair.prototype.sign = function sign3(msg, enc, options) {
      return this.ec.sign(msg, this, enc, options);
    };
    KeyPair.prototype.verify = function verify2(msg, signature) {
      return this.ec.verify(msg, signature, this);
    };
    KeyPair.prototype.inspect = function inspect() {
      return "<Key priv: " + (this.priv && this.priv.toString(16, 2)) + " pub: " + (this.pub && this.pub.inspect()) + " >";
    };
  }
});

// node_modules/elliptic/lib/elliptic/ec/signature.js
var require_signature = __commonJS({
  "node_modules/elliptic/lib/elliptic/ec/signature.js"(exports, module) {
    "use strict";
    var BN = require_bn();
    var utils = require_utils3();
    var assert = utils.assert;
    function Signature(options, enc) {
      if (options instanceof Signature)
        return options;
      if (this._importDER(options, enc))
        return;
      assert(options.r && options.s, "Signature without r or s");
      this.r = new BN(options.r, 16);
      this.s = new BN(options.s, 16);
      if (options.recoveryParam === void 0)
        this.recoveryParam = null;
      else
        this.recoveryParam = options.recoveryParam;
    }
    module.exports = Signature;
    function Position() {
      this.place = 0;
    }
    function getLength(buf, p3) {
      var initial = buf[p3.place++];
      if (!(initial & 128)) {
        return initial;
      }
      var octetLen = initial & 15;
      if (octetLen === 0 || octetLen > 4) {
        return false;
      }
      var val = 0;
      for (var i2 = 0, off = p3.place; i2 < octetLen; i2++, off++) {
        val <<= 8;
        val |= buf[off];
        val >>>= 0;
      }
      if (val <= 127) {
        return false;
      }
      p3.place = off;
      return val;
    }
    function rmPadding(buf) {
      var i2 = 0;
      var len = buf.length - 1;
      while (!buf[i2] && !(buf[i2 + 1] & 128) && i2 < len) {
        i2++;
      }
      if (i2 === 0) {
        return buf;
      }
      return buf.slice(i2);
    }
    Signature.prototype._importDER = function _importDER(data, enc) {
      data = utils.toArray(data, enc);
      var p3 = new Position();
      if (data[p3.place++] !== 48) {
        return false;
      }
      var len = getLength(data, p3);
      if (len === false) {
        return false;
      }
      if (len + p3.place !== data.length) {
        return false;
      }
      if (data[p3.place++] !== 2) {
        return false;
      }
      var rlen = getLength(data, p3);
      if (rlen === false) {
        return false;
      }
      var r = data.slice(p3.place, rlen + p3.place);
      p3.place += rlen;
      if (data[p3.place++] !== 2) {
        return false;
      }
      var slen = getLength(data, p3);
      if (slen === false) {
        return false;
      }
      if (data.length !== slen + p3.place) {
        return false;
      }
      var s = data.slice(p3.place, slen + p3.place);
      if (r[0] === 0) {
        if (r[1] & 128) {
          r = r.slice(1);
        } else {
          return false;
        }
      }
      if (s[0] === 0) {
        if (s[1] & 128) {
          s = s.slice(1);
        } else {
          return false;
        }
      }
      this.r = new BN(r);
      this.s = new BN(s);
      this.recoveryParam = null;
      return true;
    };
    function constructLength(arr, len) {
      if (len < 128) {
        arr.push(len);
        return;
      }
      var octets = 1 + (Math.log(len) / Math.LN2 >>> 3);
      arr.push(octets | 128);
      while (--octets) {
        arr.push(len >>> (octets << 3) & 255);
      }
      arr.push(len);
    }
    Signature.prototype.toDER = function toDER(enc) {
      var r = this.r.toArray();
      var s = this.s.toArray();
      if (r[0] & 128)
        r = [0].concat(r);
      if (s[0] & 128)
        s = [0].concat(s);
      r = rmPadding(r);
      s = rmPadding(s);
      while (!s[0] && !(s[1] & 128)) {
        s = s.slice(1);
      }
      var arr = [2];
      constructLength(arr, r.length);
      arr = arr.concat(r);
      arr.push(2);
      constructLength(arr, s.length);
      var backHalf = arr.concat(s);
      var res = [48];
      constructLength(res, backHalf.length);
      res = res.concat(backHalf);
      return utils.encode(res, enc);
    };
  }
});

// node_modules/elliptic/lib/elliptic/ec/index.js
var require_ec = __commonJS({
  "node_modules/elliptic/lib/elliptic/ec/index.js"(exports, module) {
    "use strict";
    var BN = require_bn();
    var HmacDRBG = require_hmac_drbg();
    var utils = require_utils3();
    var curves = require_curves();
    var rand = require_brorand();
    var assert = utils.assert;
    var KeyPair = require_key();
    var Signature = require_signature();
    function EC(options) {
      if (!(this instanceof EC))
        return new EC(options);
      if (typeof options === "string") {
        assert(
          Object.prototype.hasOwnProperty.call(curves, options),
          "Unknown curve " + options
        );
        options = curves[options];
      }
      if (options instanceof curves.PresetCurve)
        options = { curve: options };
      this.curve = options.curve.curve;
      this.n = this.curve.n;
      this.nh = this.n.ushrn(1);
      this.g = this.curve.g;
      this.g = options.curve.g;
      this.g.precompute(options.curve.n.bitLength() + 1);
      this.hash = options.hash || options.curve.hash;
    }
    module.exports = EC;
    EC.prototype.keyPair = function keyPair(options) {
      return new KeyPair(this, options);
    };
    EC.prototype.keyFromPrivate = function keyFromPrivate(priv, enc) {
      return KeyPair.fromPrivate(this, priv, enc);
    };
    EC.prototype.keyFromPublic = function keyFromPublic(pub, enc) {
      return KeyPair.fromPublic(this, pub, enc);
    };
    EC.prototype.genKeyPair = function genKeyPair(options) {
      if (!options)
        options = {};
      var drbg = new HmacDRBG({
        hash: this.hash,
        pers: options.pers,
        persEnc: options.persEnc || "utf8",
        entropy: options.entropy || rand(this.hash.hmacStrength),
        entropyEnc: options.entropy && options.entropyEnc || "utf8",
        nonce: this.n.toArray()
      });
      var bytes = this.n.byteLength();
      var ns22 = this.n.sub(new BN(2));
      for (; ; ) {
        var priv = new BN(drbg.generate(bytes));
        if (priv.cmp(ns22) > 0)
          continue;
        priv.iaddn(1);
        return this.keyFromPrivate(priv);
      }
    };
    EC.prototype._truncateToN = function _truncateToN(msg, truncOnly) {
      var delta = msg.byteLength() * 8 - this.n.bitLength();
      if (delta > 0)
        msg = msg.ushrn(delta);
      if (!truncOnly && msg.cmp(this.n) >= 0)
        return msg.sub(this.n);
      else
        return msg;
    };
    EC.prototype.sign = function sign3(msg, key, enc, options) {
      if (typeof enc === "object") {
        options = enc;
        enc = null;
      }
      if (!options)
        options = {};
      key = this.keyFromPrivate(key, enc);
      msg = this._truncateToN(new BN(msg, 16));
      var bytes = this.n.byteLength();
      var bkey = key.getPrivate().toArray("be", bytes);
      var nonce = msg.toArray("be", bytes);
      var drbg = new HmacDRBG({
        hash: this.hash,
        entropy: bkey,
        nonce,
        pers: options.pers,
        persEnc: options.persEnc || "utf8"
      });
      var ns1 = this.n.sub(new BN(1));
      for (var iter = 0; ; iter++) {
        var k2 = options.k ? options.k(iter) : new BN(drbg.generate(this.n.byteLength()));
        k2 = this._truncateToN(k2, true);
        if (k2.cmpn(1) <= 0 || k2.cmp(ns1) >= 0)
          continue;
        var kp = this.g.mul(k2);
        if (kp.isInfinity())
          continue;
        var kpX = kp.getX();
        var r = kpX.umod(this.n);
        if (r.cmpn(0) === 0)
          continue;
        var s = k2.invm(this.n).mul(r.mul(key.getPrivate()).iadd(msg));
        s = s.umod(this.n);
        if (s.cmpn(0) === 0)
          continue;
        var recoveryParam = (kp.getY().isOdd() ? 1 : 0) | (kpX.cmp(r) !== 0 ? 2 : 0);
        if (options.canonical && s.cmp(this.nh) > 0) {
          s = this.n.sub(s);
          recoveryParam ^= 1;
        }
        return new Signature({ r, s, recoveryParam });
      }
    };
    EC.prototype.verify = function verify2(msg, signature, key, enc) {
      msg = this._truncateToN(new BN(msg, 16));
      key = this.keyFromPublic(key, enc);
      signature = new Signature(signature, "hex");
      var r = signature.r;
      var s = signature.s;
      if (r.cmpn(1) < 0 || r.cmp(this.n) >= 0)
        return false;
      if (s.cmpn(1) < 0 || s.cmp(this.n) >= 0)
        return false;
      var sinv = s.invm(this.n);
      var u1 = sinv.mul(msg).umod(this.n);
      var u2 = sinv.mul(r).umod(this.n);
      var p3;
      if (!this.curve._maxwellTrick) {
        p3 = this.g.mulAdd(u1, key.getPublic(), u2);
        if (p3.isInfinity())
          return false;
        return p3.getX().umod(this.n).cmp(r) === 0;
      }
      p3 = this.g.jmulAdd(u1, key.getPublic(), u2);
      if (p3.isInfinity())
        return false;
      return p3.eqXToP(r);
    };
    EC.prototype.recoverPubKey = function(msg, signature, j2, enc) {
      assert((3 & j2) === j2, "The recovery param is more than two bits");
      signature = new Signature(signature, enc);
      var n2 = this.n;
      var e = new BN(msg);
      var r = signature.r;
      var s = signature.s;
      var isYOdd = j2 & 1;
      var isSecondKey = j2 >> 1;
      if (r.cmp(this.curve.p.umod(this.curve.n)) >= 0 && isSecondKey)
        throw new Error("Unable to find sencond key candinate");
      if (isSecondKey)
        r = this.curve.pointFromX(r.add(this.curve.n), isYOdd);
      else
        r = this.curve.pointFromX(r, isYOdd);
      var rInv = signature.r.invm(n2);
      var s1 = n2.sub(e).mul(rInv).umod(n2);
      var s2 = s.mul(rInv).umod(n2);
      return this.g.mulAdd(s1, r, s2);
    };
    EC.prototype.getKeyRecoveryParam = function(e, signature, Q4, enc) {
      signature = new Signature(signature, enc);
      if (signature.recoveryParam !== null)
        return signature.recoveryParam;
      for (var i2 = 0; i2 < 4; i2++) {
        var Qprime;
        try {
          Qprime = this.recoverPubKey(e, signature, i2);
        } catch (e2) {
          continue;
        }
        if (Qprime.eq(Q4))
          return i2;
      }
      throw new Error("Unable to find valid recovery factor");
    };
  }
});

// node_modules/elliptic/lib/elliptic/eddsa/key.js
var require_key2 = __commonJS({
  "node_modules/elliptic/lib/elliptic/eddsa/key.js"(exports, module) {
    "use strict";
    var utils = require_utils3();
    var assert = utils.assert;
    var parseBytes2 = utils.parseBytes;
    var cachedProperty = utils.cachedProperty;
    function KeyPair(eddsa, params) {
      this.eddsa = eddsa;
      this._secret = parseBytes2(params.secret);
      if (eddsa.isPoint(params.pub))
        this._pub = params.pub;
      else
        this._pubBytes = parseBytes2(params.pub);
    }
    KeyPair.fromPublic = function fromPublic(eddsa, pub) {
      if (pub instanceof KeyPair)
        return pub;
      return new KeyPair(eddsa, { pub });
    };
    KeyPair.fromSecret = function fromSecret(eddsa, secret) {
      if (secret instanceof KeyPair)
        return secret;
      return new KeyPair(eddsa, { secret });
    };
    KeyPair.prototype.secret = function secret() {
      return this._secret;
    };
    cachedProperty(KeyPair, "pubBytes", function pubBytes() {
      return this.eddsa.encodePoint(this.pub());
    });
    cachedProperty(KeyPair, "pub", function pub() {
      if (this._pubBytes)
        return this.eddsa.decodePoint(this._pubBytes);
      return this.eddsa.g.mul(this.priv());
    });
    cachedProperty(KeyPair, "privBytes", function privBytes() {
      var eddsa = this.eddsa;
      var hash6 = this.hash();
      var lastIx = eddsa.encodingLength - 1;
      var a2 = hash6.slice(0, eddsa.encodingLength);
      a2[0] &= 248;
      a2[lastIx] &= 127;
      a2[lastIx] |= 64;
      return a2;
    });
    cachedProperty(KeyPair, "priv", function priv() {
      return this.eddsa.decodeInt(this.privBytes());
    });
    cachedProperty(KeyPair, "hash", function hash6() {
      return this.eddsa.hash().update(this.secret()).digest();
    });
    cachedProperty(KeyPair, "messagePrefix", function messagePrefix() {
      return this.hash().slice(this.eddsa.encodingLength);
    });
    KeyPair.prototype.sign = function sign3(message) {
      assert(this._secret, "KeyPair can only verify");
      return this.eddsa.sign(message, this);
    };
    KeyPair.prototype.verify = function verify2(message, sig) {
      return this.eddsa.verify(message, sig, this);
    };
    KeyPair.prototype.getSecret = function getSecret(enc) {
      assert(this._secret, "KeyPair is public only");
      return utils.encode(this.secret(), enc);
    };
    KeyPair.prototype.getPublic = function getPublic(enc) {
      return utils.encode(this.pubBytes(), enc);
    };
    module.exports = KeyPair;
  }
});

// node_modules/elliptic/lib/elliptic/eddsa/signature.js
var require_signature2 = __commonJS({
  "node_modules/elliptic/lib/elliptic/eddsa/signature.js"(exports, module) {
    "use strict";
    var BN = require_bn();
    var utils = require_utils3();
    var assert = utils.assert;
    var cachedProperty = utils.cachedProperty;
    var parseBytes2 = utils.parseBytes;
    function Signature(eddsa, sig) {
      this.eddsa = eddsa;
      if (typeof sig !== "object")
        sig = parseBytes2(sig);
      if (Array.isArray(sig)) {
        sig = {
          R: sig.slice(0, eddsa.encodingLength),
          S: sig.slice(eddsa.encodingLength)
        };
      }
      assert(sig.R && sig.S, "Signature without R or S");
      if (eddsa.isPoint(sig.R))
        this._R = sig.R;
      if (sig.S instanceof BN)
        this._S = sig.S;
      this._Rencoded = Array.isArray(sig.R) ? sig.R : sig.Rencoded;
      this._Sencoded = Array.isArray(sig.S) ? sig.S : sig.Sencoded;
    }
    cachedProperty(Signature, "S", function S2() {
      return this.eddsa.decodeInt(this.Sencoded());
    });
    cachedProperty(Signature, "R", function R3() {
      return this.eddsa.decodePoint(this.Rencoded());
    });
    cachedProperty(Signature, "Rencoded", function Rencoded() {
      return this.eddsa.encodePoint(this.R());
    });
    cachedProperty(Signature, "Sencoded", function Sencoded() {
      return this.eddsa.encodeInt(this.S());
    });
    Signature.prototype.toBytes = function toBytes() {
      return this.Rencoded().concat(this.Sencoded());
    };
    Signature.prototype.toHex = function toHex2() {
      return utils.encode(this.toBytes(), "hex").toUpperCase();
    };
    module.exports = Signature;
  }
});

// node_modules/elliptic/lib/elliptic/eddsa/index.js
var require_eddsa = __commonJS({
  "node_modules/elliptic/lib/elliptic/eddsa/index.js"(exports, module) {
    "use strict";
    var hash6 = require_hash();
    var curves = require_curves();
    var utils = require_utils3();
    var assert = utils.assert;
    var parseBytes2 = utils.parseBytes;
    var KeyPair = require_key2();
    var Signature = require_signature2();
    function EDDSA(curve) {
      assert(curve === "ed25519", "only tested with ed25519 so far");
      if (!(this instanceof EDDSA))
        return new EDDSA(curve);
      curve = curves[curve].curve;
      this.curve = curve;
      this.g = curve.g;
      this.g.precompute(curve.n.bitLength() + 1);
      this.pointClass = curve.point().constructor;
      this.encodingLength = Math.ceil(curve.n.bitLength() / 8);
      this.hash = hash6.sha512;
    }
    module.exports = EDDSA;
    EDDSA.prototype.sign = function sign3(message, secret) {
      message = parseBytes2(message);
      var key = this.keyFromSecret(secret);
      var r = this.hashInt(key.messagePrefix(), message);
      var R3 = this.g.mul(r);
      var Rencoded = this.encodePoint(R3);
      var s_ = this.hashInt(Rencoded, key.pubBytes(), message).mul(key.priv());
      var S2 = r.add(s_).umod(this.curve.n);
      return this.makeSignature({ R: R3, S: S2, Rencoded });
    };
    EDDSA.prototype.verify = function verify2(message, sig, pub) {
      message = parseBytes2(message);
      sig = this.makeSignature(sig);
      var key = this.keyFromPublic(pub);
      var h3 = this.hashInt(sig.Rencoded(), key.pubBytes(), message);
      var SG = this.g.mul(sig.S());
      var RplusAh = sig.R().add(key.pub().mul(h3));
      return RplusAh.eq(SG);
    };
    EDDSA.prototype.hashInt = function hashInt() {
      var hash7 = this.hash();
      for (var i2 = 0; i2 < arguments.length; i2++)
        hash7.update(arguments[i2]);
      return utils.intFromLE(hash7.digest()).umod(this.curve.n);
    };
    EDDSA.prototype.keyFromPublic = function keyFromPublic(pub) {
      return KeyPair.fromPublic(this, pub);
    };
    EDDSA.prototype.keyFromSecret = function keyFromSecret(secret) {
      return KeyPair.fromSecret(this, secret);
    };
    EDDSA.prototype.makeSignature = function makeSignature(sig) {
      if (sig instanceof Signature)
        return sig;
      return new Signature(this, sig);
    };
    EDDSA.prototype.encodePoint = function encodePoint(point) {
      var enc = point.getY().toArray("le", this.encodingLength);
      enc[this.encodingLength - 1] |= point.getX().isOdd() ? 128 : 0;
      return enc;
    };
    EDDSA.prototype.decodePoint = function decodePoint(bytes) {
      bytes = utils.parseBytes(bytes);
      var lastIx = bytes.length - 1;
      var normed = bytes.slice(0, lastIx).concat(bytes[lastIx] & ~128);
      var xIsOdd = (bytes[lastIx] & 128) !== 0;
      var y3 = utils.intFromLE(normed);
      return this.curve.pointFromY(y3, xIsOdd);
    };
    EDDSA.prototype.encodeInt = function encodeInt(num) {
      return num.toArray("le", this.encodingLength);
    };
    EDDSA.prototype.decodeInt = function decodeInt(bytes) {
      return utils.intFromLE(bytes);
    };
    EDDSA.prototype.isPoint = function isPoint(val) {
      return val instanceof this.pointClass;
    };
  }
});

// node_modules/elliptic/lib/elliptic.js
var require_elliptic = __commonJS({
  "node_modules/elliptic/lib/elliptic.js"(exports) {
    "use strict";
    var elliptic2 = exports;
    elliptic2.version = require_package().version;
    elliptic2.utils = require_utils3();
    elliptic2.rand = require_brorand();
    elliptic2.curve = require_curve();
    elliptic2.curves = require_curves();
    elliptic2.ec = require_ec();
    elliptic2.eddsa = require_eddsa();
  }
});

// node_modules/fast-json-stable-stringify/index.js
var require_fast_json_stable_stringify = __commonJS({
  "node_modules/fast-json-stable-stringify/index.js"(exports, module) {
    "use strict";
    module.exports = function(data, opts) {
      if (!opts)
        opts = {};
      if (typeof opts === "function")
        opts = { cmp: opts };
      var cycles = typeof opts.cycles === "boolean" ? opts.cycles : false;
      var cmp = opts.cmp && function(f2) {
        return function(node) {
          return function(a2, b3) {
            var aobj = { key: a2, value: node[a2] };
            var bobj = { key: b3, value: node[b3] };
            return f2(aobj, bobj);
          };
        };
      }(opts.cmp);
      var seen = [];
      return function stringify3(node) {
        if (node && node.toJSON && typeof node.toJSON === "function") {
          node = node.toJSON();
        }
        if (node === void 0)
          return;
        if (typeof node == "number")
          return isFinite(node) ? "" + node : "null";
        if (typeof node !== "object")
          return JSON.stringify(node);
        var i2, out;
        if (Array.isArray(node)) {
          out = "[";
          for (i2 = 0; i2 < node.length; i2++) {
            if (i2)
              out += ",";
            out += stringify3(node[i2]) || "null";
          }
          return out + "]";
        }
        if (node === null)
          return "null";
        if (seen.indexOf(node) !== -1) {
          if (cycles)
            return JSON.stringify("__cycle__");
          throw new TypeError("Converting circular structure to JSON");
        }
        var seenIndex = seen.push(node) - 1;
        var keys2 = Object.keys(node).sort(cmp && cmp(node));
        out = "";
        for (i2 = 0; i2 < keys2.length; i2++) {
          var key = keys2[i2];
          var value = stringify3(node[key]);
          if (!value)
            continue;
          if (out)
            out += ",";
          out += JSON.stringify(key) + ":" + value;
        }
        seen.splice(seenIndex, 1);
        return "{" + out + "}";
      }(data);
    };
  }
});

// node_modules/@taquito/beacon-wallet/node_modules/@airgap/beacon-utils/dist/esm/utils/keys.js
function keys(obj) {
  return Object.keys(obj);
}

// node_modules/@taquito/beacon-wallet/node_modules/@airgap/beacon-utils/dist/esm/utils/exposed-promise.js
var ExposedPromiseStatus;
(function(ExposedPromiseStatus2) {
  ExposedPromiseStatus2["PENDING"] = "pending";
  ExposedPromiseStatus2["RESOLVED"] = "resolved";
  ExposedPromiseStatus2["REJECTED"] = "rejected";
})(ExposedPromiseStatus || (ExposedPromiseStatus = {}));
var notInitialized = () => {
  throw new Error("ExposedPromise not initialized yet.");
};
var ExposedPromise = class _ExposedPromise {
  constructor() {
    this._resolve = notInitialized;
    this._reject = notInitialized;
    this._status = ExposedPromiseStatus.PENDING;
    this._promise = new Promise((innerResolve, innerReject) => {
      this._resolve = (value) => {
        if (this.isSettled()) {
          return;
        }
        this._promiseResult = value;
        innerResolve(value);
        this._status = ExposedPromiseStatus.RESOLVED;
        return;
      };
      this._reject = (reason) => {
        if (this.isSettled()) {
          return;
        }
        this._promiseError = reason;
        innerReject(reason);
        this._status = ExposedPromiseStatus.REJECTED;
        return;
      };
    });
  }
  get promise() {
    return this._promise;
  }
  get resolve() {
    return this._resolve;
  }
  get reject() {
    return this._reject;
  }
  get status() {
    return this._status;
  }
  get promiseResult() {
    return this._promiseResult;
  }
  get promiseError() {
    return this._promiseError;
  }
  static resolve(value) {
    const promise = new _ExposedPromise();
    promise.resolve(value);
    return promise;
  }
  static reject(reason) {
    const promise = new _ExposedPromise();
    promise.reject(reason);
    return promise;
  }
  isPending() {
    return this.status === ExposedPromiseStatus.PENDING;
  }
  isResolved() {
    return this.status === ExposedPromiseStatus.RESOLVED;
  }
  isRejected() {
    return this.status === ExposedPromiseStatus.REJECTED;
  }
  isSettled() {
    return this.isResolved() || this.isRejected();
  }
};

// node_modules/@taquito/beacon-wallet/node_modules/@airgap/beacon-utils/dist/esm/utils/crypto.js
var bs58check = __toESM(require_bs58check());
var import_nacl = __toESM(require_nacl());
var import_random = __toESM(require_random());
var import_utf8 = __toESM(require_utf8());
var import_blake2b = __toESM(require_blake2b());
var import_ed25519 = __toESM(require_ed25519());
var import_ed255192 = __toESM(require_ed25519());
var import_blake2b2 = __toESM(require_blake2b());
var import_bytes = __toESM(require_bytes());
var import_ed255193 = __toESM(require_ed25519());
var __awaiter = function(thisArg, _arguments, P2, generator) {
  function adopt(value) {
    return value instanceof P2 ? value : new P2(function(resolve) {
      resolve(value);
    });
  }
  return new (P2 || (P2 = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var secretbox_NONCEBYTES = 24;
function toHex(value) {
  return Buffer.from(value).toString("hex");
}
function getHexHash(key) {
  return __awaiter(this, void 0, void 0, function* () {
    if (typeof key === "string") {
      return toHex((0, import_blake2b.hash)((0, import_utf8.encode)(key), 32));
    }
    return toHex((0, import_blake2b.hash)(key, 32));
  });
}
function getKeypairFromSeed(seed) {
  return __awaiter(this, void 0, void 0, function* () {
    return (0, import_ed25519.generateKeyPairFromSeed)((0, import_blake2b.hash)((0, import_utf8.encode)(seed), 32));
  });
}
function encryptCryptoboxPayload(message, sharedKey2) {
  return __awaiter(this, void 0, void 0, function* () {
    const nonce = Buffer.from((0, import_random.randomBytes)(secretbox_NONCEBYTES));
    const combinedPayload = Buffer.concat([
      nonce,
      Buffer.from((0, import_nacl.secretBox)(sharedKey2, nonce, Buffer.from(message, "utf8")))
    ]);
    return toHex(combinedPayload);
  });
}
function decryptCryptoboxPayload(payload, sharedKey2) {
  return __awaiter(this, void 0, void 0, function* () {
    const nonce = payload.slice(0, secretbox_NONCEBYTES);
    const ciphertext = payload.slice(secretbox_NONCEBYTES);
    const openBox2 = (0, import_nacl.openSecretBox)(sharedKey2, nonce, ciphertext);
    if (!openBox2) {
      throw new Error("Decryption failed");
    }
    return Buffer.from(openBox2).toString("utf8");
  });
}
function sealCryptobox(payload, otherPublicKey) {
  return __awaiter(this, void 0, void 0, function* () {
    const kxOtherPublicKey = (0, import_ed255192.convertPublicKeyToX25519)(Buffer.from(otherPublicKey));
    const keypair = (0, import_nacl.generateKeyPair)();
    const state = new import_blake2b2.BLAKE2b(24);
    const nonce = state.update(keypair.publicKey, 32).update(kxOtherPublicKey, 32).digest();
    const bytesPayload = typeof payload === "string" ? (0, import_utf8.encode)(payload) : payload;
    const encryptedMessage = (0, import_nacl.box)(kxOtherPublicKey, keypair.secretKey, nonce, bytesPayload);
    return toHex((0, import_bytes.concat)(keypair.publicKey, encryptedMessage));
  });
}
function openCryptobox(encryptedPayload, publicKey, privateKey) {
  return __awaiter(this, void 0, void 0, function* () {
    const kxSelfPrivateKey = (0, import_ed255192.convertSecretKeyToX25519)(Buffer.from(privateKey));
    const kxSelfPublicKey = (0, import_ed255192.convertPublicKeyToX25519)(Buffer.from(publicKey));
    const bytesPayload = typeof encryptedPayload === "string" ? (0, import_utf8.encode)(encryptedPayload) : encryptedPayload;
    const epk = bytesPayload.slice(0, 32);
    const ciphertext = bytesPayload.slice(32);
    const state = new import_blake2b2.BLAKE2b(24);
    const nonce = state.update(epk, 32).update(kxSelfPublicKey, 32).digest();
    const decryptedMessage2 = (0, import_nacl.openBox)(epk, kxSelfPrivateKey, nonce, ciphertext);
    if (!decryptedMessage2) {
      throw new Error("Decryption failed");
    }
    return Buffer.from(decryptedMessage2).toString();
  });
}
function getAddressFromPublicKey(publicKey) {
  return __awaiter(this, void 0, void 0, function* () {
    const prefixes = {
      // tz1...
      edpk: {
        length: 54,
        prefix: Buffer.from(new Uint8Array([6, 161, 159]))
      },
      // tz2...
      sppk: {
        length: 55,
        prefix: Buffer.from(new Uint8Array([6, 161, 161]))
      },
      // tz3...
      p2pk: {
        length: 55,
        prefix: Buffer.from(new Uint8Array([6, 161, 164]))
      }
    };
    let prefix2;
    let plainPublicKey;
    if (publicKey.length === 64) {
      prefix2 = prefixes.edpk.prefix;
      plainPublicKey = publicKey;
    } else {
      const entries = Object.entries(prefixes);
      for (let index = 0; index < entries.length; index++) {
        const [key, value] = entries[index];
        if (publicKey.startsWith(key) && publicKey.length === value.length) {
          prefix2 = value.prefix;
          const decoded = bs58check.decode(publicKey);
          plainPublicKey = decoded.slice(key.length, decoded.length).toString("hex");
          break;
        }
      }
    }
    if (!prefix2 || !plainPublicKey) {
      throw new Error(`invalid publicKey: ${publicKey}`);
    }
    const payload = (0, import_blake2b.hash)(Buffer.from(plainPublicKey, "hex"), 20);
    return bs58check.encode(Buffer.concat([prefix2, Buffer.from(payload)]));
  });
}
function prefixPublicKey(publicKey) {
  return __awaiter(this, void 0, void 0, function* () {
    if (publicKey.length !== 64) {
      return publicKey;
    }
    const payload = Buffer.from(publicKey, "hex");
    return bs58check.encode(Buffer.concat([new Uint8Array([13, 15, 37, 217]), Buffer.from(payload)]));
  });
}
function recipientString(recipientHash, relayServer) {
  return `@${recipientHash}:${relayServer}`;
}
var toBuffer = (message) => __awaiter(void 0, void 0, void 0, function* () {
  if (message.length % 2 !== 0) {
    return (0, import_utf8.encode)(message);
  }
  let adjustedMessage = message;
  if (message.startsWith("0x")) {
    adjustedMessage = message.slice(2);
  }
  const buffer2 = Buffer.from(adjustedMessage, "hex");
  if (buffer2.length === adjustedMessage.length / 2) {
    return buffer2;
  }
  return (0, import_utf8.encode)(message);
});
var coinlibhash = (message, size = 32) => __awaiter(void 0, void 0, void 0, function* () {
  return (0, import_blake2b.hash)(message, size);
});
var signMessage = (message, keypair) => __awaiter(void 0, void 0, void 0, function* () {
  const bufferMessage = yield toBuffer(message);
  const edsigPrefix = new Uint8Array([9, 245, 205, 134, 18]);
  const hash6 = yield coinlibhash(bufferMessage);
  const rawSignature = (0, import_ed255193.sign)(keypair.secretKey, hash6);
  const signature = bs58check.encode(Buffer.concat([Buffer.from(edsigPrefix), Buffer.from(rawSignature)]));
  return signature;
});

// node_modules/@taquito/beacon-wallet/node_modules/@airgap/beacon-utils/dist/esm/utils/generate-uuid.js
var import_random2 = __toESM(require_random());
var __awaiter2 = function(thisArg, _arguments, P2, generator) {
  function adopt(value) {
    return value instanceof P2 ? value : new P2(function(resolve) {
      resolve(value);
    });
  }
  return new (P2 || (P2 = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
function generateGUID() {
  return __awaiter2(this, void 0, void 0, function* () {
    const buf = (0, import_random2.randomBytes)(16);
    return [buf.slice(0, 4), buf.slice(4, 6), buf.slice(6, 8), buf.slice(8, 10), buf.slice(10, 16)].map(function(subbuf) {
      return Buffer.from(subbuf).toString("hex");
    }).join("-");
  });
}

// node_modules/@taquito/beacon-wallet/node_modules/@airgap/beacon-utils/dist/esm/index.js
var secretbox_NONCEBYTES2 = 24;
var secretbox_MACBYTES = 16;

// node_modules/@taquito/beacon-wallet/node_modules/@airgap/beacon-types/dist/esm/types/beacon/BeaconMessageType.js
var BeaconMessageType;
(function(BeaconMessageType2) {
  BeaconMessageType2["BlockchainRequest"] = "blockchain_request";
  BeaconMessageType2["PermissionRequest"] = "permission_request";
  BeaconMessageType2["SignPayloadRequest"] = "sign_payload_request";
  BeaconMessageType2["OperationRequest"] = "operation_request";
  BeaconMessageType2["BroadcastRequest"] = "broadcast_request";
  BeaconMessageType2["BlockchainResponse"] = "blockchain_response";
  BeaconMessageType2["PermissionResponse"] = "permission_response";
  BeaconMessageType2["SignPayloadResponse"] = "sign_payload_response";
  BeaconMessageType2["OperationResponse"] = "operation_response";
  BeaconMessageType2["BroadcastResponse"] = "broadcast_response";
  BeaconMessageType2["Acknowledge"] = "acknowledge";
  BeaconMessageType2["Disconnect"] = "disconnect";
  BeaconMessageType2["Error"] = "error";
})(BeaconMessageType || (BeaconMessageType = {}));

// node_modules/@taquito/beacon-wallet/node_modules/@airgap/beacon-types/dist/esm/types/beacon/PermissionScope.js
var PermissionScope;
(function(PermissionScope2) {
  PermissionScope2["SIGN"] = "sign";
  PermissionScope2["OPERATION_REQUEST"] = "operation_request";
  PermissionScope2["ENCRYPT"] = "encrypt";
  PermissionScope2["NOTIFICATION"] = "notification";
  PermissionScope2["THRESHOLD"] = "threshold";
})(PermissionScope || (PermissionScope = {}));

// node_modules/@taquito/beacon-wallet/node_modules/@airgap/beacon-types/dist/esm/types/beacon/NetworkType.js
var NetworkType;
(function(NetworkType3) {
  NetworkType3["MAINNET"] = "mainnet";
  NetworkType3["GHOSTNET"] = "ghostnet";
  NetworkType3["MONDAYNET"] = "mondaynet";
  NetworkType3["DAILYNET"] = "dailynet";
  NetworkType3["DELPHINET"] = "delphinet";
  NetworkType3["EDONET"] = "edonet";
  NetworkType3["FLORENCENET"] = "florencenet";
  NetworkType3["GRANADANET"] = "granadanet";
  NetworkType3["HANGZHOUNET"] = "hangzhounet";
  NetworkType3["ITHACANET"] = "ithacanet";
  NetworkType3["JAKARTANET"] = "jakartanet";
  NetworkType3["KATHMANDUNET"] = "kathmandunet";
  NetworkType3["LIMANET"] = "limanet";
  NetworkType3["MUMBAINET"] = "mumbainet";
  NetworkType3["NAIROBINET"] = "nairobinet";
  NetworkType3["CUSTOM"] = "custom";
})(NetworkType || (NetworkType = {}));

// node_modules/@taquito/beacon-wallet/node_modules/@airgap/beacon-types/dist/esm/types/tezos/OperationTypes.js
var TezosOperationType;
(function(TezosOperationType2) {
  TezosOperationType2["ENDORSEMENT"] = "endorsement";
  TezosOperationType2["SEED_NONCE_REVELATION"] = "seed_nonce_revelation";
  TezosOperationType2["DOUBLE_ENDORSEMENT_EVIDENCE"] = "double_endorsement_evidence";
  TezosOperationType2["DOUBLE_BAKING_EVIDENCE"] = "double_baking_evidence";
  TezosOperationType2["ACTIVATE_ACCOUNT"] = "activate_account";
  TezosOperationType2["PROPOSALS"] = "proposals";
  TezosOperationType2["BALLOT"] = "ballot";
  TezosOperationType2["REVEAL"] = "reveal";
  TezosOperationType2["TRANSACTION"] = "transaction";
  TezosOperationType2["ORIGINATION"] = "origination";
  TezosOperationType2["DELEGATION"] = "delegation";
})(TezosOperationType || (TezosOperationType = {}));

// node_modules/@taquito/beacon-wallet/node_modules/@airgap/beacon-types/dist/esm/types/Origin.js
var Origin;
(function(Origin2) {
  Origin2["WEBSITE"] = "website";
  Origin2["EXTENSION"] = "extension";
  Origin2["P2P"] = "p2p";
  Origin2["WALLETCONNECT"] = "walletconnect";
})(Origin || (Origin = {}));

// node_modules/@taquito/beacon-wallet/node_modules/@airgap/beacon-types/dist/esm/types/ExtensionMessageTarget.js
var ExtensionMessageTarget;
(function(ExtensionMessageTarget2) {
  ExtensionMessageTarget2["BACKGROUND"] = "toBackground";
  ExtensionMessageTarget2["PAGE"] = "toPage";
  ExtensionMessageTarget2["EXTENSION"] = "toExtension";
})(ExtensionMessageTarget || (ExtensionMessageTarget = {}));

// node_modules/@taquito/beacon-wallet/node_modules/@airgap/beacon-types/dist/esm/types/BeaconErrorType.js
var BeaconErrorType;
(function(BeaconErrorType2) {
  BeaconErrorType2["BROADCAST_ERROR"] = "BROADCAST_ERROR";
  BeaconErrorType2["NETWORK_NOT_SUPPORTED"] = "NETWORK_NOT_SUPPORTED";
  BeaconErrorType2["NO_ADDRESS_ERROR"] = "NO_ADDRESS_ERROR";
  BeaconErrorType2["NO_PRIVATE_KEY_FOUND_ERROR"] = "NO_PRIVATE_KEY_FOUND_ERROR";
  BeaconErrorType2["NOT_GRANTED_ERROR"] = "NOT_GRANTED_ERROR";
  BeaconErrorType2["PARAMETERS_INVALID_ERROR"] = "PARAMETERS_INVALID_ERROR";
  BeaconErrorType2["TOO_MANY_OPERATIONS"] = "TOO_MANY_OPERATIONS";
  BeaconErrorType2["TRANSACTION_INVALID_ERROR"] = "TRANSACTION_INVALID_ERROR";
  BeaconErrorType2["SIGNATURE_TYPE_NOT_SUPPORTED"] = "SIGNATURE_TYPE_NOT_SUPPORTED";
  BeaconErrorType2["ABORTED_ERROR"] = "ABORTED_ERROR";
  BeaconErrorType2["UNKNOWN_ERROR"] = "UNKNOWN_ERROR";
})(BeaconErrorType || (BeaconErrorType = {}));

// node_modules/@taquito/beacon-wallet/node_modules/@airgap/beacon-types/dist/esm/types/transport/TransportStatus.js
var TransportStatus;
(function(TransportStatus2) {
  TransportStatus2["NOT_CONNECTED"] = "NOT_CONNECTED";
  TransportStatus2["CONNECTING"] = "CONNECTING";
  TransportStatus2["CONNECTED"] = "CONNECTED";
})(TransportStatus || (TransportStatus = {}));

// node_modules/@taquito/beacon-wallet/node_modules/@airgap/beacon-types/dist/esm/types/transport/TransportType.js
var TransportType;
(function(TransportType2) {
  TransportType2["CHROME_MESSAGE"] = "chrome_message";
  TransportType2["WALLETCONNECT"] = "walletconnect";
  TransportType2["POST_MESSAGE"] = "post_message";
  TransportType2["LEDGER"] = "ledger";
  TransportType2["P2P"] = "p2p";
})(TransportType || (TransportType = {}));

// node_modules/@taquito/beacon-wallet/node_modules/@airgap/beacon-types/dist/esm/types/storage/StorageKey.js
var StorageKey;
(function(StorageKey2) {
  StorageKey2["TRANSPORT_P2P_PEERS_DAPP"] = "beacon:communication-peers-dapp";
  StorageKey2["TRANSPORT_P2P_PEERS_WALLET"] = "beacon:communication-peers-wallet";
  StorageKey2["TRANSPORT_POSTMESSAGE_PEERS_DAPP"] = "beacon:postmessage-peers-dapp";
  StorageKey2["TRANSPORT_POSTMESSAGE_PEERS_WALLET"] = "beacon:postmessage-peers-wallet";
  StorageKey2["TRANSPORT_WALLETCONNECT_PEERS_DAPP"] = "beacon:walletconnect-peers-dapp";
  StorageKey2["LAST_SELECTED_WALLET"] = "beacon:last-selected-wallet";
  StorageKey2["ACCOUNTS"] = "beacon:accounts";
  StorageKey2["ACTIVE_ACCOUNT"] = "beacon:active-account";
  StorageKey2["PUSH_TOKENS"] = "beacon:push-tokens";
  StorageKey2["BEACON_SDK_SECRET_SEED"] = "beacon:sdk-secret-seed";
  StorageKey2["APP_METADATA_LIST"] = "beacon:app-metadata-list";
  StorageKey2["PERMISSION_LIST"] = "beacon:permissions";
  StorageKey2["BEACON_SDK_VERSION"] = "beacon:sdk_version";
  StorageKey2["MATRIX_PRESERVED_STATE"] = "beacon:sdk-matrix-preserved-state";
  StorageKey2["MATRIX_PEER_ROOM_IDS"] = "beacon:matrix-peer-rooms";
  StorageKey2["MATRIX_SELECTED_NODE"] = "beacon:matrix-selected-node";
  StorageKey2["MULTI_NODE_SETUP_DONE"] = "beacon:multi-node-setup";
})(StorageKey || (StorageKey = {}));

// node_modules/@taquito/beacon-wallet/node_modules/@airgap/beacon-types/dist/esm/types/storage/StorageKeyReturnDefaults.js
var defaultValues = {
  [StorageKey.TRANSPORT_P2P_PEERS_DAPP]: [],
  [StorageKey.TRANSPORT_P2P_PEERS_WALLET]: [],
  [StorageKey.TRANSPORT_POSTMESSAGE_PEERS_DAPP]: [],
  [StorageKey.TRANSPORT_POSTMESSAGE_PEERS_WALLET]: [],
  [StorageKey.TRANSPORT_WALLETCONNECT_PEERS_DAPP]: [],
  [StorageKey.LAST_SELECTED_WALLET]: void 0,
  [StorageKey.ACCOUNTS]: [],
  [StorageKey.ACTIVE_ACCOUNT]: void 0,
  [StorageKey.PUSH_TOKENS]: [],
  [StorageKey.BEACON_SDK_SECRET_SEED]: void 0,
  [StorageKey.APP_METADATA_LIST]: [],
  [StorageKey.PERMISSION_LIST]: [],
  [StorageKey.BEACON_SDK_VERSION]: void 0,
  [StorageKey.MATRIX_PRESERVED_STATE]: {},
  [StorageKey.MATRIX_PEER_ROOM_IDS]: {},
  [StorageKey.MATRIX_SELECTED_NODE]: void 0,
  [StorageKey.MULTI_NODE_SETUP_DONE]: void 0
};

// node_modules/@taquito/beacon-wallet/node_modules/@airgap/beacon-types/dist/esm/types/beacon/SigningType.js
var SigningType;
(function(SigningType2) {
  SigningType2["RAW"] = "raw";
  SigningType2["OPERATION"] = "operation";
  SigningType2["MICHELINE"] = "micheline";
})(SigningType || (SigningType = {}));

// node_modules/@taquito/beacon-wallet/node_modules/@airgap/beacon-types/dist/esm/types/ColorMode.js
var ColorMode;
(function(ColorMode2) {
  ColorMode2["LIGHT"] = "light";
  ColorMode2["DARK"] = "dark";
})(ColorMode || (ColorMode = {}));

// node_modules/@taquito/beacon-wallet/node_modules/@airgap/beacon-types/dist/esm/types/Regions.js
var Regions;
(function(Regions2) {
  Regions2["EUROPE_EAST"] = "europe-east";
  Regions2["EUROPE_WEST"] = "europe-west";
  Regions2["NORTH_AMERICA_EAST"] = "north-america-east";
  Regions2["NORTH_AMERICA_WEST"] = "north-america-west";
  Regions2["CENTRAL_AMERICA"] = "central-america";
  Regions2["SOUTH_AMERICA"] = "south-america";
  Regions2["ASIA_EAST"] = "asia-east";
  Regions2["ASIA_WEST"] = "asia-west";
  Regions2["AFRICA"] = "africa";
  Regions2["AUSTRALIA"] = "australia";
})(Regions || (Regions = {}));

// node_modules/@taquito/beacon-wallet/node_modules/@airgap/beacon-core/dist/esm/constants.js
var SDK_VERSION = "4.0.6";
var BEACON_VERSION = "3";

// node_modules/@taquito/beacon-wallet/node_modules/@airgap/beacon-core/dist/esm/MockWindow.js
var cbs = [(_2) => void 0];
var windowRef = {
  postMessage: (message, _target) => {
    console.log("GOT MOCK POST MESSAGE", message);
    cbs.forEach((callbackElement) => {
      callbackElement({ data: message });
    });
  },
  addEventListener: (_name, eventCallback) => {
    cbs.push(eventCallback);
  },
  removeEventListener: (_name, eventCallback) => {
    cbs.splice(cbs.indexOf((element) => element === eventCallback), 1);
  },
  location: {
    origin: "*"
  }
};
try {
  if (typeof window !== "undefined") {
    windowRef = window;
  }
} catch (windowError) {
  console.log(`not defined: ${windowError}`);
}

// node_modules/@taquito/beacon-wallet/node_modules/@airgap/beacon-core/dist/esm/MockAnalytics.js
var MockAnalytics = class {
  track(_trigger, _section, _label, _data) {
  }
};

// node_modules/@taquito/beacon-wallet/node_modules/@airgap/beacon-core/dist/esm/clients/beacon-client/BeaconClient.js
var __awaiter3 = function(thisArg, _arguments, P2, generator) {
  function adopt(value) {
    return value instanceof P2 ? value : new P2(function(resolve) {
      resolve(value);
    });
  }
  return new (P2 || (P2 = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var BeaconClient = class {
  constructor(config2) {
    var _a3, _b;
    this._beaconId = new ExposedPromise();
    this._keyPair = new ExposedPromise();
    if (!config2.name) {
      throw new Error("Name not set");
    }
    if (!config2.storage) {
      throw new Error("Storage not set");
    }
    this.name = config2.name;
    this.iconUrl = config2.iconUrl;
    this.appUrl = (_a3 = config2.appUrl) !== null && _a3 !== void 0 ? _a3 : windowRef.location.origin;
    this.storage = config2.storage;
    this.analytics = (_b = config2.analytics) !== null && _b !== void 0 ? _b : new MockAnalytics();
    if (windowRef.beaconCreatedClientInstance) {
      console.error("[BEACON] It looks like you created multiple Beacon SDK Client instances. This can lead to problems. Only create one instance and re-use it everywhere.");
    } else {
      ;
      windowRef.beaconCreatedClientInstance = true;
    }
    this.initSDK().catch(console.error);
  }
  get beaconId() {
    return this._beaconId.promise;
  }
  get keyPair() {
    return this._keyPair.promise;
  }
  /**
   * This resets the SDK. After using this method, this instance is no longer usable. You will have to instanciate a new client.
   */
  destroy() {
    return __awaiter3(this, void 0, void 0, function* () {
      yield this.removeBeaconEntriesFromStorage();
      windowRef.beaconCreatedClientInstance = false;
    });
  }
  /**
   * This method initializes the SDK by setting some values in the storage and generating a keypair.
   */
  initSDK() {
    return __awaiter3(this, void 0, void 0, function* () {
      this.storage.set(StorageKey.BEACON_SDK_VERSION, SDK_VERSION).catch(console.error);
      this.loadOrCreateBeaconSecret().catch(console.error);
      return this.keyPair.then((keyPair) => {
        this._beaconId.resolve(toHex(keyPair.publicKey));
      });
    });
  }
  /**
   * Removes all beacon values from the storage.
   */
  removeBeaconEntriesFromStorage() {
    return __awaiter3(this, void 0, void 0, function* () {
      const allKeys = Object.values(StorageKey);
      yield Promise.all(allKeys.map((key) => this.storage.delete(key)));
    });
  }
  /**
   * This method tries to load the seed from storage, if it doesn't exist, a new one will be created and persisted.
   */
  loadOrCreateBeaconSecret() {
    return __awaiter3(this, void 0, void 0, function* () {
      const storageValue = yield this.storage.get(StorageKey.BEACON_SDK_SECRET_SEED);
      if (storageValue && typeof storageValue === "string") {
        this._keyPair.resolve(yield getKeypairFromSeed(storageValue));
      } else {
        const key = yield generateGUID();
        yield this.storage.set(StorageKey.BEACON_SDK_SECRET_SEED, key);
        this._keyPair.resolve(yield getKeypairFromSeed(key));
      }
    });
  }
};

// node_modules/@taquito/beacon-wallet/node_modules/@airgap/beacon-core/dist/esm/managers/StorageManager.js
var __awaiter4 = function(thisArg, _arguments, P2, generator) {
  function adopt(value) {
    return value instanceof P2 ? value : new P2(function(resolve) {
      resolve(value);
    });
  }
  return new (P2 || (P2 = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
function fixArrayType(array) {
  return array;
}
var StorageManager = class {
  constructor(storage, storageKey) {
    this.storage = storage;
    this.storageKey = storageKey;
  }
  getAll() {
    return __awaiter4(this, void 0, void 0, function* () {
      return this.storage.get(this.storageKey);
    });
  }
  getOne(predicate) {
    return __awaiter4(this, void 0, void 0, function* () {
      const entities = yield this.storage.get(this.storageKey);
      return fixArrayType(entities).find(predicate);
    });
  }
  addOne(element, predicate, overwrite = true) {
    return __awaiter4(this, void 0, void 0, function* () {
      const entities = yield this.storage.get(this.storageKey);
      if (!fixArrayType(entities).some(predicate)) {
        fixArrayType(entities).push(element);
      } else if (overwrite) {
        for (let i2 = 0; i2 < entities.length; i2++) {
          if (predicate(fixArrayType(entities)[i2])) {
            entities[i2] = element;
          }
        }
      }
      return this.storage.set(this.storageKey, entities);
    });
  }
  remove(predicate) {
    return __awaiter4(this, void 0, void 0, function* () {
      const entities = yield this.storage.get(this.storageKey);
      const filteredEntities = fixArrayType(entities).filter((entity) => !predicate(entity));
      return this.storage.set(this.storageKey, filteredEntities);
    });
  }
  removeAll() {
    return __awaiter4(this, void 0, void 0, function* () {
      return this.storage.delete(this.storageKey);
    });
  }
};

// node_modules/@taquito/beacon-wallet/node_modules/@airgap/beacon-core/dist/esm/utils/get-account-identifier.js
var bs58check2 = __toESM(require_bs58check());
var import_blake2b3 = __toESM(require_blake2b());
var import_utf82 = __toESM(require_utf8());
var __awaiter5 = function(thisArg, _arguments, P2, generator) {
  function adopt(value) {
    return value instanceof P2 ? value : new P2(function(resolve) {
      resolve(value);
    });
  }
  return new (P2 || (P2 = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var getAccountIdentifier = (address, network) => __awaiter5(void 0, void 0, void 0, function* () {
  const data = [address, network.type];
  if (network.name) {
    data.push(`name:${network.name}`);
  }
  if (network.rpcUrl) {
    data.push(`rpc:${network.rpcUrl}`);
  }
  const buffer2 = Buffer.from((0, import_blake2b3.hash)((0, import_utf82.encode)(data.join("-")), 10));
  return bs58check2.encode(buffer2);
});

// node_modules/@taquito/beacon-wallet/node_modules/@airgap/beacon-core/dist/esm/managers/PermissionValidator.js
var __awaiter6 = function(thisArg, _arguments, P2, generator) {
  function adopt(value) {
    return value instanceof P2 ? value : new P2(function(resolve) {
      resolve(value);
    });
  }
  return new (P2 || (P2 = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var PermissionValidator = class {
  /**
   * Check if permissions were given for a certain message type.
   *
   * PermissionRequest and BroadcastRequest will always return true.
   *
   * @param message Beacon Message
   */
  static hasPermission(message, getOne, getAll) {
    return __awaiter6(this, void 0, void 0, function* () {
      switch (message.type) {
        case BeaconMessageType.PermissionRequest:
        case BeaconMessageType.BroadcastRequest: {
          return true;
        }
        case BeaconMessageType.OperationRequest: {
          const accountIdentifier = yield getAccountIdentifier(message.sourceAddress, message.network);
          const permission = yield getOne(accountIdentifier);
          if (!permission) {
            return false;
          }
          return permission.scopes.includes(PermissionScope.OPERATION_REQUEST);
        }
        case BeaconMessageType.SignPayloadRequest: {
          const permissions = yield getAll();
          const filteredPermissions = permissions.filter((permission) => permission.address === message.sourceAddress);
          if (filteredPermissions.length === 0) {
            return false;
          }
          return filteredPermissions.some((permission) => permission.scopes.includes(PermissionScope.SIGN));
        }
        default:
          throw new Error("Message not handled");
      }
    });
  }
};

// node_modules/@taquito/beacon-wallet/node_modules/@airgap/beacon-core/dist/esm/managers/AccountManager.js
var __awaiter7 = function(thisArg, _arguments, P2, generator) {
  function adopt(value) {
    return value instanceof P2 ? value : new P2(function(resolve) {
      resolve(value);
    });
  }
  return new (P2 || (P2 = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var AccountManager = class {
  constructor(storage) {
    this.storageManager = new StorageManager(storage, StorageKey.ACCOUNTS);
  }
  getAccounts() {
    return __awaiter7(this, void 0, void 0, function* () {
      return this.storageManager.getAll();
    });
  }
  getAccount(accountIdentifier) {
    return __awaiter7(this, void 0, void 0, function* () {
      return this.storageManager.getOne((account) => account.accountIdentifier === accountIdentifier);
    });
  }
  addAccount(accountInfo) {
    return __awaiter7(this, void 0, void 0, function* () {
      return this.storageManager.addOne(accountInfo, (account) => account.accountIdentifier === accountInfo.accountIdentifier);
    });
  }
  removeAccount(accountIdentifier) {
    return __awaiter7(this, void 0, void 0, function* () {
      return this.storageManager.remove((account) => account.accountIdentifier === accountIdentifier);
    });
  }
  removeAccounts(accountIdentifiers) {
    return __awaiter7(this, void 0, void 0, function* () {
      return this.storageManager.remove((account) => accountIdentifiers.includes(account.accountIdentifier));
    });
  }
  removeAllAccounts() {
    return __awaiter7(this, void 0, void 0, function* () {
      return this.storageManager.removeAll();
    });
  }
  hasPermission(message) {
    return __awaiter7(this, void 0, void 0, function* () {
      return PermissionValidator.hasPermission(message, this.getAccount.bind(this), this.getAccounts.bind(this));
    });
  }
};

// node_modules/@taquito/beacon-wallet/node_modules/@airgap/beacon-core/dist/esm/utils/get-sender-id.js
var import_blake2b4 = __toESM(require_blake2b());
var bs58check3 = __toESM(require_bs58check());
var __awaiter8 = function(thisArg, _arguments, P2, generator) {
  function adopt(value) {
    return value instanceof P2 ? value : new P2(function(resolve) {
      resolve(value);
    });
  }
  return new (P2 || (P2 = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var getSenderId = (publicKey) => __awaiter8(void 0, void 0, void 0, function* () {
  const buffer2 = Buffer.from((0, import_blake2b4.hash)(Buffer.from(publicKey, "hex"), 5));
  return bs58check3.encode(buffer2);
});

// node_modules/@taquito/beacon-wallet/node_modules/@airgap/beacon-core/dist/esm/debug.js
var debug = windowRef.beaconSdkDebugEnabled ? true : false;
if (debug) {
  console.log("[BEACON]: Debug mode is ON (turned on either by the developer or a browser extension)");
}
var getDebugEnabled = () => debug;

// node_modules/@taquito/beacon-wallet/node_modules/@airgap/beacon-core/dist/esm/utils/Logger.js
var InternalLogger = class {
  constructor() {
  }
  debug(name, method, ...args) {
    this._log("debug", name, method, args);
  }
  log(name, method, ...args) {
    this._log("log", name, method, args);
  }
  warn(name, method, ...args) {
    this._log("warn", name, method, args);
  }
  error(name, method, ...args) {
    this._log("error", name, method, args);
  }
  _log(type, name, method, args = []) {
    if (!getDebugEnabled()) {
      return;
    }
    let groupText = `[BEACON] ${(/* @__PURE__ */ new Date()).toISOString()} [${name}](${method})`;
    let data = args;
    if (args[0] && typeof args[0] === "string") {
      groupText += ` ${args[0]}`;
      data = args.slice(1);
    }
    switch (type) {
      case "error":
        console.group(groupText);
        console.error(...data);
        break;
      case "warn":
        console.group(groupText);
        console.warn(...data);
        break;
      case "debug":
        console.groupCollapsed(groupText);
        console.debug(...data);
        break;
      default:
        console.group(groupText);
        console.log(...data);
    }
    console.groupEnd();
  }
};
var Logger = class {
  constructor(service) {
    this.name = service;
  }
  debug(method, ...args) {
    logger.debug(this.name, method, args);
  }
  log(method, ...args) {
    logger.log(this.name, method, args);
  }
  warn(method, ...args) {
    logger.warn(this.name, method, args);
  }
  error(method, ...args) {
    logger.error(this.name, method, args);
  }
};
var loggerWrapper = new Logger("");
var logger = new InternalLogger();

// node_modules/@taquito/beacon-wallet/node_modules/@airgap/beacon-core/dist/esm/clients/client/Client.js
var __awaiter9 = function(thisArg, _arguments, P2, generator) {
  function adopt(value) {
    return value instanceof P2 ? value : new P2(function(resolve) {
      resolve(value);
    });
  }
  return new (P2 || (P2 = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var logger2 = new Logger("Client");
var Client = class extends BeaconClient {
  constructor(config2) {
    var _a3;
    super(config2);
    this.rateLimit = 2;
    this.rateLimitWindowInSeconds = 5;
    this.requestCounter = [];
    this._transport = new ExposedPromise();
    this.accountManager = new AccountManager(config2.storage);
    this.matrixNodes = (_a3 = config2.matrixNodes) !== null && _a3 !== void 0 ? _a3 : {};
    this.handleResponse = (message, connectionInfo) => {
      throw new Error(`not overwritten${JSON.stringify(message)} - ${JSON.stringify(connectionInfo)}`);
    };
  }
  get transport() {
    return this._transport.promise;
  }
  /**
   * Returns the connection status of the Client
   */
  get connectionStatus() {
    var _a3, _b;
    return (_b = (_a3 = this._transport.promiseResult) === null || _a3 === void 0 ? void 0 : _a3.connectionStatus) !== null && _b !== void 0 ? _b : TransportStatus.NOT_CONNECTED;
  }
  /**
   * Returns whether or not the transaport is ready
   */
  get ready() {
    return this.transport.then(() => void 0);
  }
  /**
   * Return all locally known accounts
   */
  getAccounts() {
    return __awaiter9(this, void 0, void 0, function* () {
      return this.accountManager.getAccounts();
    });
  }
  /**
   * Return the account by ID
   * @param accountIdentifier The ID of an account
   */
  getAccount(accountIdentifier) {
    return __awaiter9(this, void 0, void 0, function* () {
      return this.accountManager.getAccount(accountIdentifier);
    });
  }
  /**
   * Remove the account by ID
   * @param accountIdentifier The ID of an account
   */
  removeAccount(accountIdentifier) {
    return __awaiter9(this, void 0, void 0, function* () {
      return this.accountManager.removeAccount(accountIdentifier);
    });
  }
  /**
   * Remove all locally stored accounts
   */
  removeAllAccounts() {
    return __awaiter9(this, void 0, void 0, function* () {
      return this.accountManager.removeAllAccounts();
    });
  }
  /**
   * Add a new request (current timestamp) to the pending requests, remove old ones and check if we are above the limit
   */
  addRequestAndCheckIfRateLimited() {
    return __awaiter9(this, void 0, void 0, function* () {
      const now = (/* @__PURE__ */ new Date()).getTime();
      this.requestCounter = this.requestCounter.filter((date) => date + this.rateLimitWindowInSeconds * 1e3 > now);
      this.requestCounter.push(now);
      return this.requestCounter.length > this.rateLimit;
    });
  }
  /**
   * This method initializes the client. It will check if the connection should be established to a
   * browser extension or if the P2P transport should be used.
   *
   * @param transport A transport that can be provided by the user
   */
  init(transport) {
    return __awaiter9(this, void 0, void 0, function* () {
      if (this._transport.status === ExposedPromiseStatus.RESOLVED) {
        return (yield this.transport).type;
      }
      yield this.setTransport(transport);
      return transport.type;
    });
  }
  /**
   * Returns the metadata of this DApp
   */
  getOwnAppMetadata() {
    return __awaiter9(this, void 0, void 0, function* () {
      return {
        senderId: yield getSenderId(yield this.beaconId),
        name: this.name,
        icon: this.iconUrl
      };
    });
  }
  /**
   * Return all known peers
   */
  getPeers() {
    return __awaiter9(this, void 0, void 0, function* () {
      return (yield this.transport).getPeers();
    });
  }
  /**
   * Add a new peer to the known peers
   * @param peer The new peer to add
   */
  addPeer(peer) {
    return __awaiter9(this, void 0, void 0, function* () {
      return (yield this.transport).addPeer(peer);
    });
  }
  destroy() {
    const _super = Object.create(null, {
      destroy: { get: () => super.destroy }
    });
    return __awaiter9(this, void 0, void 0, function* () {
      if (this._transport.status === ExposedPromiseStatus.RESOLVED) {
        yield (yield this.transport).disconnect();
      }
      yield _super.destroy.call(this);
    });
  }
  /**
   * A "setter" for when the transport needs to be changed.
   */
  setTransport(transport) {
    return __awaiter9(this, void 0, void 0, function* () {
      if (transport) {
        if (this._transport.isSettled()) {
          this._transport = ExposedPromise.resolve(transport);
        } else {
          this._transport.resolve(transport);
        }
      } else {
        if (this._transport.isSettled()) {
          this._transport = new ExposedPromise();
        }
      }
    });
  }
  addListener(transport) {
    return __awaiter9(this, void 0, void 0, function* () {
      transport.addListener((message, connectionInfo) => __awaiter9(this, void 0, void 0, function* () {
        if (typeof message === "string") {
          const deserializedMessage = yield new Serializer().deserialize(message);
          this.handleResponse(deserializedMessage, connectionInfo);
        }
      })).catch((error) => logger2.error("addListener", error));
    });
  }
  sendDisconnectToPeer(peer, transport) {
    return __awaiter9(this, void 0, void 0, function* () {
      const request = {
        id: yield generateGUID(),
        version: peer.version,
        senderId: yield getSenderId(yield this.beaconId),
        type: BeaconMessageType.Disconnect
      };
      const payload = yield new Serializer().serialize(request);
      const selectedTransport = transport !== null && transport !== void 0 ? transport : yield this.transport;
      yield selectedTransport.send(payload, peer);
    });
  }
};

// node_modules/@taquito/beacon-wallet/node_modules/@airgap/beacon-core/dist/esm/utils/assert-never.js
function assertNever(empty2) {
  return empty2;
}

// node_modules/@taquito/beacon-wallet/node_modules/@airgap/beacon-core/dist/esm/errors/BeaconError.js
var BeaconError = class {
  constructor(errorType, message) {
    this.name = "BeaconError";
    this.title = "Error";
    this.message = `[${errorType}]:${message}`;
    this.description = message;
  }
  get fullDescription() {
    return { description: this.description };
  }
  static getError(errorType, errorData) {
    switch (errorType) {
      case BeaconErrorType.BROADCAST_ERROR:
        return new BroadcastBeaconError();
      case BeaconErrorType.NETWORK_NOT_SUPPORTED:
        return new NetworkNotSupportedBeaconError();
      case BeaconErrorType.NO_ADDRESS_ERROR:
        return new NoAddressBeaconError();
      case BeaconErrorType.NO_PRIVATE_KEY_FOUND_ERROR:
        return new NoPrivateKeyBeaconError();
      case BeaconErrorType.NOT_GRANTED_ERROR:
        return new NotGrantedBeaconError();
      case BeaconErrorType.PARAMETERS_INVALID_ERROR:
        return new ParametersInvalidBeaconError();
      case BeaconErrorType.TOO_MANY_OPERATIONS:
        return new TooManyOperationsBeaconError();
      case BeaconErrorType.TRANSACTION_INVALID_ERROR:
        return new TransactionInvalidBeaconError(errorData);
      case BeaconErrorType.SIGNATURE_TYPE_NOT_SUPPORTED:
        return new SignatureTypeNotSupportedBeaconError();
      case BeaconErrorType.ABORTED_ERROR:
        return new AbortedBeaconError();
      case BeaconErrorType.UNKNOWN_ERROR:
        return new UnknownBeaconError();
      default:
        assertNever(errorType);
    }
  }
};

// node_modules/@taquito/beacon-wallet/node_modules/@airgap/beacon-core/dist/esm/errors/BroadcastBeaconError.js
var BroadcastBeaconError = class extends BeaconError {
  constructor() {
    super(BeaconErrorType.BROADCAST_ERROR, "The transaction could not be broadcast to the network. Please try again.");
    this.name = "BroadcastBeaconError";
    this.title = "Broadcast Error";
  }
};

// node_modules/@taquito/beacon-wallet/node_modules/@airgap/beacon-core/dist/esm/errors/NetworkNotSupportedBeaconError.js
var NetworkNotSupportedBeaconError = class extends BeaconError {
  constructor() {
    super(BeaconErrorType.NETWORK_NOT_SUPPORTED, "The wallet does not support this network. Please select another one.");
    this.name = "NetworkNotSupportedBeaconError";
    this.title = "Network Error";
  }
};

// node_modules/@taquito/beacon-wallet/node_modules/@airgap/beacon-core/dist/esm/errors/NoAddressBeaconError.js
var NoAddressBeaconError = class extends BeaconError {
  constructor() {
    super(BeaconErrorType.NO_ADDRESS_ERROR, "The wallet does not have an account set up. Please make sure to set up your wallet and try again.");
    this.name = "NoAddressBeaconError";
    this.title = "No Address";
  }
};

// node_modules/@taquito/beacon-wallet/node_modules/@airgap/beacon-core/dist/esm/errors/NoPrivateKeyBeaconError.js
var NoPrivateKeyBeaconError = class extends BeaconError {
  constructor() {
    super(BeaconErrorType.NO_PRIVATE_KEY_FOUND_ERROR, "The account you are trying to interact with is not available. Please make sure to add the account to your wallet and try again.");
    this.name = "NoPrivateKeyBeaconError";
    this.title = "Account Not Found";
  }
};

// node_modules/@taquito/beacon-wallet/node_modules/@airgap/beacon-core/dist/esm/errors/NotGrantedBeaconError.js
var NotGrantedBeaconError = class extends BeaconError {
  constructor() {
    super(BeaconErrorType.NOT_GRANTED_ERROR, "You do not have the necessary permissions to perform this action. Please initiate another permission request and give the necessary permissions.");
    this.name = "NotGrantedBeaconError";
    this.title = "Permission Not Granted";
  }
};

// node_modules/@taquito/beacon-wallet/node_modules/@airgap/beacon-core/dist/esm/errors/ParametersInvalidBeaconError.js
var ParametersInvalidBeaconError = class extends BeaconError {
  constructor() {
    super(BeaconErrorType.PARAMETERS_INVALID_ERROR, "Some of the parameters you provided are invalid and the request could not be completed. Please check your inputs and try again.");
    this.name = "ParametersInvalidBeaconError";
    this.title = "Parameters Invalid";
  }
};

// node_modules/@taquito/beacon-wallet/node_modules/@airgap/beacon-core/dist/esm/errors/TooManyOperationsBeaconError.js
var TooManyOperationsBeaconError = class extends BeaconError {
  constructor() {
    super(BeaconErrorType.TOO_MANY_OPERATIONS, "The request contains too many transactions. Please include fewer operations and try again.");
    this.name = "TooManyOperationsBeaconError";
    this.title = "Too Many Operations";
  }
};

// node_modules/@taquito/beacon-wallet/node_modules/@airgap/beacon-core/dist/esm/errors/TransactionInvalidBeaconError.js
var TransactionInvalidBeaconError = class extends BeaconError {
  constructor(data) {
    super(BeaconErrorType.TRANSACTION_INVALID_ERROR, `The transaction is invalid and the node did not accept it.`);
    this.data = data;
    this.name = "TransactionInvalidBeaconError";
    this.title = "Transaction Invalid";
    this.data = data;
  }
  get fullDescription() {
    return { description: this.description, data: JSON.stringify(this.data, void 0, 2) };
  }
};

// node_modules/@taquito/beacon-wallet/node_modules/@airgap/beacon-core/dist/esm/errors/UnknownBeaconError.js
var UnknownBeaconError = class extends BeaconError {
  constructor() {
    super(BeaconErrorType.UNKNOWN_ERROR, "An unknown error occured. Please try again or report it to a developer.");
    this.name = "UnknownBeaconError";
    this.title = "Error";
  }
};

// node_modules/@taquito/beacon-wallet/node_modules/@airgap/beacon-core/dist/esm/transports/Transport.js
var __awaiter10 = function(thisArg, _arguments, P2, generator) {
  function adopt(value) {
    return value instanceof P2 ? value : new P2(function(resolve) {
      resolve(value);
    });
  }
  return new (P2 || (P2 = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var logger3 = new Logger("Transport");
var Transport = class {
  constructor(name, client, peerManager) {
    this.type = TransportType.POST_MESSAGE;
    this._isConnected = TransportStatus.NOT_CONNECTED;
    this.listeners = [];
    this.name = name;
    this.client = client;
    this.peerManager = peerManager;
  }
  /**
   * Return the status of the connection
   */
  get connectionStatus() {
    return this._isConnected;
  }
  /**
   * Returns a promise that resolves to true if the transport is available, false if it is not
   */
  static isAvailable() {
    return __awaiter10(this, void 0, void 0, function* () {
      return Promise.resolve(false);
    });
  }
  /**
   * Connect the transport
   */
  connect() {
    return __awaiter10(this, void 0, void 0, function* () {
      logger3.log("connect");
      this._isConnected = TransportStatus.CONNECTED;
      return;
    });
  }
  /**
   * Disconnect the transport
   */
  disconnect() {
    return __awaiter10(this, void 0, void 0, function* () {
      logger3.log("disconnect");
      this._isConnected = TransportStatus.NOT_CONNECTED;
      return;
    });
  }
  /**
   * Send a message through the transport
   *
   * @param message The message to send
   * @param recipient The recipient of the message
   */
  send(message, peer) {
    return __awaiter10(this, void 0, void 0, function* () {
      if (peer) {
        return this.client.sendMessage(message, peer);
      } else {
        const knownPeers = yield this.getPeers();
        const promises = knownPeers.map((peerEl) => this.client.sendMessage(message, peerEl));
        return (yield Promise.all(promises))[0];
      }
    });
  }
  /**
   * Add a listener to be called when a new message is received
   *
   * @param listener The listener that will be registered
   */
  addListener(listener) {
    return __awaiter10(this, void 0, void 0, function* () {
      logger3.debug("addListener");
      this.listeners.push(listener);
      return;
    });
  }
  /**
   * Remove a listener
   *
   * @param listener
   */
  removeListener(listener) {
    return __awaiter10(this, void 0, void 0, function* () {
      logger3.log("removeListener");
      this.listeners = this.listeners.filter((element) => element !== listener);
      return;
    });
  }
  getPeers() {
    return __awaiter10(this, void 0, void 0, function* () {
      return this.peerManager.getPeers();
    });
  }
  addPeer(newPeer, _sendPairingResponse = true) {
    return __awaiter10(this, void 0, void 0, function* () {
      logger3.log("addPeer", "adding peer", newPeer);
      yield this.peerManager.addPeer(newPeer);
      yield this.listen(newPeer.publicKey);
    });
  }
  removePeer(peerToBeRemoved) {
    return __awaiter10(this, void 0, void 0, function* () {
      logger3.log("removePeer", "removing peer", peerToBeRemoved);
      yield this.peerManager.removePeer(peerToBeRemoved.publicKey);
      if (this.client) {
        yield this.client.unsubscribeFromEncryptedMessage(peerToBeRemoved.publicKey);
      }
    });
  }
  removeAllPeers() {
    return __awaiter10(this, void 0, void 0, function* () {
      logger3.log("removeAllPeers");
      yield this.peerManager.removeAllPeers();
      if (this.client) {
        yield this.client.unsubscribeFromEncryptedMessages();
      }
    });
  }
  /**
   * Notify the listeners when a new message comes in
   *
   * @param message Message
   * @param connectionInfo Context info about the connection
   */
  notifyListeners(message, connectionInfo) {
    return __awaiter10(this, void 0, void 0, function* () {
      if (this.listeners.length === 0) {
        logger3.warn("notifyListeners", "0 listeners notified!", this);
      } else {
        logger3.log("notifyListeners", `Notifying ${this.listeners.length} listeners`, this);
      }
      this.listeners.forEach((listener) => {
        listener(message, connectionInfo);
      });
      return;
    });
  }
};

// node_modules/@taquito/beacon-wallet/node_modules/@airgap/beacon-core/dist/esm/storage/LocalStorage.js
var __awaiter11 = function(thisArg, _arguments, P2, generator) {
  function adopt(value) {
    return value instanceof P2 ? value : new P2(function(resolve) {
      resolve(value);
    });
  }
  return new (P2 || (P2 = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var LocalStorage = class {
  constructor(prefix2) {
    this.prefix = prefix2;
  }
  static isSupported() {
    return __awaiter11(this, void 0, void 0, function* () {
      return Promise.resolve(Boolean(typeof window !== "undefined") && Boolean(window.localStorage));
    });
  }
  get(key) {
    return __awaiter11(this, void 0, void 0, function* () {
      const value = localStorage.getItem(this.getPrefixedKey(key));
      if (!value) {
        if (typeof defaultValues[key] === "object") {
          return JSON.parse(JSON.stringify(defaultValues[key]));
        } else {
          return defaultValues[key];
        }
      } else {
        try {
          return JSON.parse(value);
        } catch (jsonParseError) {
          return value;
        }
      }
    });
  }
  set(key, value) {
    return __awaiter11(this, void 0, void 0, function* () {
      if (typeof value === "string") {
        return localStorage.setItem(this.getPrefixedKey(key), value);
      } else {
        return localStorage.setItem(this.getPrefixedKey(key), JSON.stringify(value));
      }
    });
  }
  delete(key) {
    return __awaiter11(this, void 0, void 0, function* () {
      return Promise.resolve(localStorage.removeItem(this.getPrefixedKey(key)));
    });
  }
  getPrefixedKey(key) {
    return this.prefix ? `${this.prefix}-${key}` : key;
  }
};

// node_modules/@taquito/beacon-wallet/node_modules/@airgap/beacon-core/dist/esm/storage/getStorage.js
var logger4 = new Logger("STORAGE");

// node_modules/@taquito/beacon-wallet/node_modules/@airgap/beacon-core/dist/esm/Serializer.js
var bs58check4 = __toESM(require_bs58check());
var __awaiter12 = function(thisArg, _arguments, P2, generator) {
  function adopt(value) {
    return value instanceof P2 ? value : new P2(function(resolve) {
      resolve(value);
    });
  }
  return new (P2 || (P2 = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var Serializer = class {
  /**
   * Serialize and bs58check encode an object
   *
   * @param message JSON object to serialize
   */
  serialize(message) {
    return __awaiter12(this, void 0, void 0, function* () {
      const str = JSON.stringify(message);
      return bs58check4.encode(Buffer.from(str));
    });
  }
  /**
   * Deserialize a bs58check encoded string
   *
   * @param encoded String to be deserialized
   */
  deserialize(encoded) {
    return __awaiter12(this, void 0, void 0, function* () {
      if (typeof encoded !== "string") {
        throw new Error("Encoded payload needs to be a string");
      }
      return JSON.parse(bs58check4.decode(encoded).toString());
    });
  }
};

// node_modules/@taquito/beacon-wallet/node_modules/@airgap/beacon-core/dist/esm/managers/AppMetadataManager.js
var __awaiter13 = function(thisArg, _arguments, P2, generator) {
  function adopt(value) {
    return value instanceof P2 ? value : new P2(function(resolve) {
      resolve(value);
    });
  }
  return new (P2 || (P2 = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var AppMetadataManager = class {
  constructor(storage) {
    this.storageManager = new StorageManager(storage, StorageKey.APP_METADATA_LIST);
  }
  getAppMetadataList() {
    return __awaiter13(this, void 0, void 0, function* () {
      return this.storageManager.getAll();
    });
  }
  getAppMetadata(senderId) {
    return __awaiter13(this, void 0, void 0, function* () {
      return this.storageManager.getOne((appMetadata) => appMetadata.senderId === senderId);
    });
  }
  addAppMetadata(appMetadata) {
    return __awaiter13(this, void 0, void 0, function* () {
      return this.storageManager.addOne(appMetadata, (appMetadataElement) => appMetadataElement.senderId === appMetadata.senderId);
    });
  }
  removeAppMetadata(senderId) {
    return __awaiter13(this, void 0, void 0, function* () {
      return this.storageManager.remove((appMetadata) => appMetadata.senderId === senderId);
    });
  }
  removeAppMetadatas(senderIds) {
    return __awaiter13(this, void 0, void 0, function* () {
      return this.storageManager.remove((appMetadata) => senderIds.includes(appMetadata.senderId));
    });
  }
  removeAllAppMetadata() {
    return __awaiter13(this, void 0, void 0, function* () {
      return this.storageManager.removeAll();
    });
  }
};

// node_modules/@taquito/beacon-wallet/node_modules/@airgap/beacon-core/dist/esm/errors/AbortedBeaconError.js
var AbortedBeaconError = class extends BeaconError {
  constructor() {
    super(BeaconErrorType.ABORTED_ERROR, "The action was aborted by the user.");
    this.name = "UnknownBeaconError";
    this.title = "Aborted";
  }
};

// node_modules/@taquito/beacon-wallet/node_modules/@airgap/beacon-core/dist/esm/managers/PeerManager.js
var __awaiter14 = function(thisArg, _arguments, P2, generator) {
  function adopt(value) {
    return value instanceof P2 ? value : new P2(function(resolve) {
      resolve(value);
    });
  }
  return new (P2 || (P2 = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var PeerManager = class {
  constructor(storage, key) {
    this.storageManager = new StorageManager(storage, key);
  }
  hasPeer(publicKey) {
    return __awaiter14(this, void 0, void 0, function* () {
      return (yield this.getPeer(publicKey)) ? true : false;
    });
  }
  getPeers() {
    return __awaiter14(this, void 0, void 0, function* () {
      return this.storageManager.getAll();
    });
  }
  getPeer(publicKey) {
    return __awaiter14(this, void 0, void 0, function* () {
      return this.storageManager.getOne((peer) => peer.publicKey === publicKey);
    });
  }
  addPeer(peerInfo) {
    return __awaiter14(this, void 0, void 0, function* () {
      return this.storageManager.addOne(peerInfo, (peer) => peer.publicKey === peerInfo.publicKey);
    });
  }
  removePeer(publicKey) {
    return __awaiter14(this, void 0, void 0, function* () {
      return this.storageManager.remove((peer) => peer.publicKey === publicKey);
    });
  }
  removePeers(publicKeys) {
    return __awaiter14(this, void 0, void 0, function* () {
      return this.storageManager.remove((peer) => publicKeys.includes(peer.publicKey));
    });
  }
  removeAllPeers() {
    return __awaiter14(this, void 0, void 0, function* () {
      return this.storageManager.removeAll();
    });
  }
};

// node_modules/@taquito/beacon-wallet/node_modules/@airgap/beacon-core/dist/esm/transports/clients/CommunicationClient.js
var import_ed255194 = __toESM(require_ed25519());
var import_x25519_session = __toESM(require_x25519_session());
var __awaiter15 = function(thisArg, _arguments, P2, generator) {
  function adopt(value) {
    return value instanceof P2 ? value : new P2(function(resolve) {
      resolve(value);
    });
  }
  return new (P2 || (P2 = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var CommunicationClient = class {
  constructor(keyPair) {
    this.keyPair = keyPair;
  }
  /**
   * Get the public key
   */
  getPublicKey() {
    var _a3;
    return __awaiter15(this, void 0, void 0, function* () {
      return toHex((_a3 = this.keyPair) === null || _a3 === void 0 ? void 0 : _a3.publicKey);
    });
  }
  /**
   * get the public key hash
   */
  getPublicKeyHash() {
    return __awaiter15(this, void 0, void 0, function* () {
      return getHexHash(this.keyPair.publicKey);
    });
  }
  /**
   * Create a cryptobox server
   *
   * @param otherPublicKey
   * @param selfKeypair
   */
  createCryptoBoxServer(otherPublicKey, selfKeypair) {
    return __awaiter15(this, void 0, void 0, function* () {
      return (0, import_x25519_session.serverSessionKeys)({
        publicKey: (0, import_ed255194.convertPublicKeyToX25519)(selfKeypair.publicKey),
        secretKey: (0, import_ed255194.convertSecretKeyToX25519)(selfKeypair.secretKey)
      }, (0, import_ed255194.convertPublicKeyToX25519)(Buffer.from(otherPublicKey, "hex")));
    });
  }
  /**
   * Create a cryptobox client
   *
   * @param otherPublicKey
   * @param selfKeypair
   */
  createCryptoBoxClient(otherPublicKey, selfKeypair) {
    return __awaiter15(this, void 0, void 0, function* () {
      return (0, import_x25519_session.clientSessionKeys)({
        publicKey: (0, import_ed255194.convertPublicKeyToX25519)(selfKeypair.publicKey),
        secretKey: (0, import_ed255194.convertSecretKeyToX25519)(selfKeypair.secretKey)
      }, (0, import_ed255194.convertPublicKeyToX25519)(Buffer.from(otherPublicKey, "hex")));
    });
  }
  /**
   * Encrypt a message for a specific publicKey (receiver, asymmetric)
   *
   * @param recipientPublicKey
   * @param message
   */
  encryptMessageAsymmetric(recipientPublicKey, message) {
    return __awaiter15(this, void 0, void 0, function* () {
      return sealCryptobox(message, Buffer.from(recipientPublicKey, "hex"));
    });
  }
};

// node_modules/@taquito/beacon-wallet/node_modules/@airgap/beacon-core/dist/esm/transports/clients/MessageBasedClient.js
var __awaiter16 = function(thisArg, _arguments, P2, generator) {
  function adopt(value) {
    return value instanceof P2 ? value : new P2(function(resolve) {
      resolve(value);
    });
  }
  return new (P2 || (P2 = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var MessageBasedClient = class extends CommunicationClient {
  constructor(name, keyPair) {
    super(keyPair);
    this.name = name;
    this.init().catch(console.error);
  }
  /**
   * start the client and make sure all dependencies are ready
   */
  start() {
    return __awaiter16(this, void 0, void 0, function* () {
      yield Promise.resolve();
    });
  }
  /**
   * Get the pairing request information. This will be shared with the peer during the connection setup
   */
  getPairingRequestInfo() {
    return __awaiter16(this, void 0, void 0, function* () {
      return {
        id: yield generateGUID(),
        type: "postmessage-pairing-request",
        name: this.name,
        version: BEACON_VERSION,
        publicKey: yield this.getPublicKey()
      };
    });
  }
  /**
   * Get the pairing response information. This will be shared with the peer during the connection setup
   */
  getPairingResponseInfo(request) {
    return __awaiter16(this, void 0, void 0, function* () {
      return {
        id: request.id,
        type: "postmessage-pairing-response",
        name: this.name,
        version: request.version,
        publicKey: yield this.getPublicKey()
      };
    });
  }
  /**
   * Unsubscribe from encrypted messages from a specific peer
   *
   * @param senderPublicKey
   */
  unsubscribeFromEncryptedMessage(senderPublicKey) {
    return __awaiter16(this, void 0, void 0, function* () {
      const listener = this.activeListeners.get(senderPublicKey);
      if (!listener) {
        return;
      }
      this.activeListeners.delete(senderPublicKey);
    });
  }
  /**
   * Unsubscribe from all encrypted messages
   */
  unsubscribeFromEncryptedMessages() {
    return __awaiter16(this, void 0, void 0, function* () {
      this.activeListeners.clear();
    });
  }
  /**
   * Decrypt a message from a specific peer
   *
   * @param senderPublicKey
   * @param payload
   */
  decryptMessage(senderPublicKey, payload) {
    return __awaiter16(this, void 0, void 0, function* () {
      const sharedKey2 = yield this.createCryptoBoxServer(senderPublicKey, this.keyPair);
      const hexPayload = Buffer.from(payload, "hex");
      if (hexPayload.length >= secretbox_NONCEBYTES2 + secretbox_MACBYTES) {
        try {
          return yield decryptCryptoboxPayload(hexPayload, sharedKey2.receive);
        } catch (decryptionError) {
        }
      }
      throw new Error("Could not decrypt message");
    });
  }
  /**
   * Encrypt a message for a specific publicKey (receiver)
   *
   * @param recipientPublicKey
   * @param message
   */
  encryptMessage(recipientPublicKey, message) {
    return __awaiter16(this, void 0, void 0, function* () {
      const sharedKey2 = yield this.createCryptoBoxClient(recipientPublicKey, this.keyPair);
      return encryptCryptoboxPayload(message, sharedKey2.send);
    });
  }
};

// node_modules/@taquito/beacon-wallet/node_modules/@airgap/beacon-core/dist/esm/errors/SignatureTypeNotSupportedBeaconError.js
var SignatureTypeNotSupportedBeaconError = class extends BeaconError {
  constructor() {
    super(BeaconErrorType.SIGNATURE_TYPE_NOT_SUPPORTED, "The wallet is not able to sign payloads of this type.");
    this.name = "SignatureTypeNotSupportedBeaconError";
    this.title = "Signature Type Not Supported";
  }
};

// node_modules/@taquito/beacon-wallet/node_modules/@airgap/beacon-transport-matrix/dist/esm/communication-client/P2PCommunicationClient.js
var import_ed255195 = __toESM(require_ed25519());
var import_axios2 = __toESM(require_axios());

// node_modules/@taquito/beacon-wallet/node_modules/@airgap/beacon-transport-matrix/dist/esm/matrix-client/models/MatrixMessage.js
var MatrixMessageType;
(function(MatrixMessageType2) {
  MatrixMessageType2["TEXT"] = "m.text";
})(MatrixMessageType || (MatrixMessageType = {}));
var MatrixMessage = class _MatrixMessage {
  constructor(type, sender, content, timestamp2) {
    this.type = type;
    this.sender = sender;
    this.content = content;
    this.timestamp = timestamp2;
  }
  /**
   * Construct a message from a message event
   *
   * @param event
   */
  static from(event) {
    if (isTextMessageEvent(event)) {
      return new _MatrixMessage(event.content.msgtype, event.sender, event.content.body, event.origin_server_ts);
    }
    return void 0;
  }
};

// node_modules/@taquito/beacon-wallet/node_modules/@airgap/beacon-transport-matrix/dist/esm/matrix-client/utils/events.js
var isCreateEvent = (event) => event.type === "m.room.create" && event.content instanceof Object && "creator" in event.content;
var isJoinEvent = (event) => event.type === "m.room.member" && event.content instanceof Object && "membership" in event.content && // eslint-disable-next-line dot-notation
event.content["membership"] === "join";
var isMessageEvent = (event) => event.type === "m.room.message";
var isTextMessageEvent = (event) => isMessageEvent(event) && event.content instanceof Object && "msgtype" in event.content && // eslint-disable-next-line dot-notation
event.content["msgtype"] === MatrixMessageType.TEXT;

// node_modules/@taquito/beacon-wallet/node_modules/@airgap/beacon-transport-matrix/dist/esm/matrix-client/models/MatrixRoom.js
var MatrixRoomStatus;
(function(MatrixRoomStatus2) {
  MatrixRoomStatus2[MatrixRoomStatus2["UNKNOWN"] = 0] = "UNKNOWN";
  MatrixRoomStatus2[MatrixRoomStatus2["JOINED"] = 1] = "JOINED";
  MatrixRoomStatus2[MatrixRoomStatus2["INVITED"] = 2] = "INVITED";
  MatrixRoomStatus2[MatrixRoomStatus2["LEFT"] = 3] = "LEFT";
})(MatrixRoomStatus || (MatrixRoomStatus = {}));
var MatrixRoom = class _MatrixRoom {
  constructor(id, status = MatrixRoomStatus.UNKNOWN, members = [], messages = []) {
    this.id = id;
    this.status = status;
    this.members = members;
    this.messages = messages;
  }
  /**
   * Reconstruct rooms from a sync response
   *
   * @param roomSync
   */
  static fromSync(roomSync) {
    var _a3, _b, _c;
    if (!roomSync) {
      return [];
    }
    function create(rooms, creator) {
      return Object.entries(rooms).map(([id, room]) => creator(id, room));
    }
    return [
      ...create((_a3 = roomSync.join) !== null && _a3 !== void 0 ? _a3 : {}, _MatrixRoom.fromJoined),
      ...create((_b = roomSync.invite) !== null && _b !== void 0 ? _b : {}, _MatrixRoom.fromInvited),
      ...create((_c = roomSync.leave) !== null && _c !== void 0 ? _c : {}, _MatrixRoom.fromLeft)
    ];
  }
  /**
   * Reconstruct a room from an ID or object
   *
   * @param roomOrId
   * @param status
   */
  static from(roomOrId, status) {
    return typeof roomOrId === "string" ? new _MatrixRoom(roomOrId, status || MatrixRoomStatus.UNKNOWN) : status !== void 0 ? new _MatrixRoom(roomOrId.id, status, roomOrId.members, roomOrId.messages) : roomOrId;
  }
  /**
   * Merge new and old state and remove duplicates
   *
   * @param newState
   * @param previousState
   */
  static merge(newState, previousState) {
    if (!previousState || previousState.id !== newState.id) {
      return _MatrixRoom.from(newState);
    }
    return new _MatrixRoom(newState.id, newState.status, [...previousState.members, ...newState.members].filter((member, index, array) => array.indexOf(member) === index), [...previousState.messages, ...newState.messages]);
  }
  /**
   * Create a room from a join
   *
   * @param id
   * @param joined
   */
  static fromJoined(id, joined) {
    const events = [...joined.state.events, ...joined.timeline.events];
    const members = _MatrixRoom.getMembersFromEvents(events);
    const messages = _MatrixRoom.getMessagesFromEvents(events);
    return new _MatrixRoom(id, MatrixRoomStatus.JOINED, members, messages);
  }
  /**
   * Create a room from an invite
   *
   * @param id
   * @param invited
   */
  static fromInvited(id, invited) {
    const members = _MatrixRoom.getMembersFromEvents(invited.invite_state.events);
    return new _MatrixRoom(id, MatrixRoomStatus.INVITED, members);
  }
  /**
   * Create a room from a leave
   *
   * @param id
   * @param left
   */
  static fromLeft(id, left) {
    const events = [...left.state.events, ...left.timeline.events];
    const members = _MatrixRoom.getMembersFromEvents(events);
    const messages = _MatrixRoom.getMessagesFromEvents(events);
    return new _MatrixRoom(id, MatrixRoomStatus.LEFT, members, messages);
  }
  /**
   * Extract members from an event
   *
   * @param events
   */
  static getMembersFromEvents(events) {
    return _MatrixRoom.getUniqueEvents(events.filter((event) => isCreateEvent(event) || isJoinEvent(event))).map((event) => event.sender).filter((member, index, array) => array.indexOf(member) === index);
  }
  /**
   * Extract messages from an event
   *
   * @param events
   */
  static getMessagesFromEvents(events) {
    return _MatrixRoom.getUniqueEvents(events.filter(isMessageEvent)).map((event) => MatrixMessage.from(event)).filter(Boolean);
  }
  /**
   * Get unique events and remove duplicates
   *
   * @param events
   */
  static getUniqueEvents(events) {
    const eventIds = {};
    const uniqueEvents = [];
    events.forEach((event, index) => {
      const eventId = event.event_id;
      if (eventId === void 0 || !(eventId in eventIds)) {
        if (eventId !== void 0) {
          eventIds[eventId] = index;
        }
        uniqueEvents.push(event);
      }
    });
    return uniqueEvents;
  }
};

// node_modules/@taquito/beacon-wallet/node_modules/@airgap/beacon-transport-matrix/dist/esm/matrix-client/MatrixClientStore.js
var __awaiter17 = function(thisArg, _arguments, P2, generator) {
  function adopt(value) {
    return value instanceof P2 ? value : new P2(function(resolve) {
      resolve(value);
    });
  }
  return new (P2 || (P2 = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var PRESERVED_FIELDS = ["syncToken", "rooms"];
var MatrixClientStore = class {
  constructor(storage) {
    this.storage = storage;
    this.state = {
      isRunning: false,
      userId: void 0,
      deviceId: void 0,
      txnNo: 0,
      accessToken: void 0,
      syncToken: void 0,
      pollingTimeout: void 0,
      pollingRetries: 0,
      rooms: {}
    };
    this.onStateChangedListeners = /* @__PURE__ */ new Map();
    this.waitReadyPromise = new Promise((resolve, reject) => __awaiter17(this, void 0, void 0, function* () {
      try {
        yield this.initFromStorage();
        resolve();
      } catch (error) {
        reject(error);
      }
    }));
  }
  /**
   * Get an item from the state
   *
   * @param key
   */
  get(key) {
    return this.state[key];
  }
  /**
   * Get the room from an ID or room instance
   *
   * @param roomOrId
   */
  getRoom(roomOrId) {
    const room = MatrixRoom.from(roomOrId, MatrixRoomStatus.UNKNOWN);
    return this.state.rooms[room.id] || room;
  }
  /**
   * Update the state with a partial state
   *
   * @param stateUpdate
   */
  update(stateUpdate) {
    return __awaiter17(this, void 0, void 0, function* () {
      yield this.waitReady();
      const oldState = Object.assign({}, this.state);
      this.setState(stateUpdate);
      this.updateStorage(stateUpdate);
      this.notifyListeners(oldState, this.state, stateUpdate);
    });
  }
  /**
   * Register listeners that are called once the state has changed
   *
   * @param listener
   * @param subscribed
   */
  onStateChanged(listener, ...subscribed) {
    if (subscribed.length > 0) {
      subscribed.forEach((key) => {
        this.onStateChangedListeners.set(key, listener);
      });
    } else {
      this.onStateChangedListeners.set("all", listener);
    }
  }
  /**
   * A promise that resolves once the client is ready
   */
  waitReady() {
    return __awaiter17(this, void 0, void 0, function* () {
      return this.waitReadyPromise;
    });
  }
  /**
   * Read state from storage
   */
  initFromStorage() {
    return __awaiter17(this, void 0, void 0, function* () {
      const preserved = yield this.storage.get(StorageKey.MATRIX_PRESERVED_STATE);
      this.setState(preserved);
    });
  }
  /**
   * Prepare data before persisting it in storage
   *
   * @param toStore
   */
  prepareData(toStore) {
    const requiresPreparation = ["rooms"];
    const toStoreCopy = requiresPreparation.some((key) => toStore[key] !== void 0) ? JSON.parse(JSON.stringify(toStore)) : toStore;
    Object.values(toStoreCopy.rooms || {}).forEach((room) => {
      room.messages = [];
    });
    return toStoreCopy;
  }
  /**
   * Persist state in storage
   *
   * @param stateUpdate
   */
  updateStorage(stateUpdate) {
    const updatedCachedFields = Object.entries(stateUpdate).filter(([key, value]) => PRESERVED_FIELDS.includes(key) && Boolean(value));
    if (updatedCachedFields.length > 0) {
      const filteredState = {};
      PRESERVED_FIELDS.forEach((key) => {
        filteredState[key] = this.state[key];
      });
      this.storage.set(StorageKey.MATRIX_PRESERVED_STATE, this.prepareData(filteredState));
    }
  }
  /**
   * Set the state
   *
   * @param partialState
   */
  setState(partialState) {
    this.state = {
      isRunning: partialState.isRunning || this.state.isRunning,
      userId: partialState.userId || this.state.userId,
      deviceId: partialState.deviceId || this.state.deviceId,
      txnNo: partialState.txnNo || this.state.txnNo,
      accessToken: partialState.accessToken || this.state.accessToken,
      syncToken: partialState.syncToken || this.state.syncToken,
      pollingTimeout: partialState.pollingTimeout || this.state.pollingTimeout,
      pollingRetries: partialState.pollingRetries || this.state.pollingRetries,
      rooms: this.mergeRooms(this.state.rooms, partialState.rooms)
    };
  }
  /**
   * Merge room records and eliminate duplicates
   *
   * @param oldRooms
   * @param _newRooms
   */
  mergeRooms(oldRooms, _newRooms) {
    if (!_newRooms) {
      return oldRooms;
    }
    const newRooms = Array.isArray(_newRooms) ? _newRooms : Object.values(_newRooms);
    const merged = Object.assign({}, oldRooms);
    newRooms.forEach((newRoom) => {
      merged[newRoom.id] = MatrixRoom.merge(newRoom, oldRooms[newRoom.id]);
    });
    return merged;
  }
  /**
   * Notify listeners of state changes
   *
   * @param oldState
   * @param newState
   * @param stateChange
   */
  notifyListeners(oldState, newState, stateChange) {
    const listenForAll = this.onStateChangedListeners.get("all");
    if (listenForAll) {
      listenForAll(oldState, newState, stateChange);
    }
    keys(stateChange).filter((key) => stateChange[key] !== void 0).forEach((key) => {
      const listener = this.onStateChangedListeners.get(key);
      if (listener) {
        listener(oldState, newState, stateChange);
      }
    });
  }
};

// node_modules/@taquito/beacon-wallet/node_modules/@airgap/beacon-transport-matrix/dist/esm/matrix-client/MatrixHttpClient.js
var import_axios = __toESM(require_axios());
var __awaiter18 = function(thisArg, _arguments, P2, generator) {
  function adopt(value) {
    return value instanceof P2 ? value : new P2(function(resolve) {
      resolve(value);
    });
  }
  return new (P2 || (P2 = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var logger5 = new Logger("MatrixHttpClient");
var CLIENT_API_R0 = "/_matrix/client/r0";
var MatrixHttpClient = class {
  constructor(baseUrl) {
    this.baseUrl = baseUrl;
    this.cancelTokenSource = import_axios.default.CancelToken.source();
  }
  /**
   * Get data from the synapse node
   *
   * @param endpoint
   * @param options
   */
  get(endpoint, params, options) {
    return __awaiter18(this, void 0, void 0, function* () {
      return this.send("GET", endpoint, options, params);
    });
  }
  /**
   * Post data to the synapse node
   *
   * @param endpoint
   * @param body
   * @param options
   * @param params
   */
  post(endpoint, body, options, params) {
    return __awaiter18(this, void 0, void 0, function* () {
      return this.send("POST", endpoint, options, params, body);
    });
  }
  /**
   * Put data to the synapse node
   *
   * @param endpoint
   * @param body
   * @param options
   * @param params
   */
  put(endpoint, body, options, params) {
    return __awaiter18(this, void 0, void 0, function* () {
      return this.send("PUT", endpoint, options, params, body);
    });
  }
  cancelAllRequests() {
    return __awaiter18(this, void 0, void 0, function* () {
      return this.cancelTokenSource.cancel("Manually cancelled");
    });
  }
  /**
   * Send a request to the synapse node
   *
   * @param method
   * @param endpoint
   * @param config
   * @param requestParams
   * @param data
   */
  send(method, endpoint, config2, requestParams, data) {
    return __awaiter18(this, void 0, void 0, function* () {
      const headers = config2 ? this.getHeaders(config2) : void 0;
      const params = requestParams ? this.getParams(requestParams) : void 0;
      let response;
      try {
        response = yield import_axios.default.request({
          method,
          url: endpoint,
          baseURL: this.apiUrl(CLIENT_API_R0),
          headers,
          data,
          params,
          cancelToken: this.cancelTokenSource.token
        });
      } catch (error) {
        const axiosError = error;
        logger5.error("send", axiosError.code, axiosError.message, axiosError.response.data);
        throw error.response.data;
      }
      return response.data;
    });
  }
  /**
   * Get the headers based on the options object
   *
   * @param options
   */
  getHeaders(options) {
    const headers = {};
    const entries = [];
    if (options.accessToken) {
      entries.push(["Authorization", `Bearer ${options.accessToken}`]);
    }
    if (entries.length === 0) {
      return void 0;
    }
    for (const [key, value] of entries) {
      headers[key] = value;
    }
    return headers;
  }
  /**
   * Get parameters
   *
   * @param _params
   */
  getParams(_params) {
    if (!_params) {
      return void 0;
    }
    const params = Object.assign(_params, {});
    keys(params).forEach((key) => params[key] === void 0 && delete params[key]);
    return params;
  }
  /**
   * Construct API URL
   */
  apiUrl(...parts) {
    const apiBase = this.baseUrl.endsWith("/") ? this.baseUrl.substr(0, this.baseUrl.length - 1) : this.baseUrl;
    const apiParts = parts.map((path) => path.startsWith("/") ? path.substr(1) : path);
    return [apiBase, ...apiParts].join("/");
  }
};

// node_modules/@taquito/beacon-wallet/node_modules/@airgap/beacon-transport-matrix/dist/esm/matrix-client/services/MatrixRoomService.js
var __awaiter19 = function(thisArg, _arguments, P2, generator) {
  function adopt(value) {
    return value instanceof P2 ? value : new P2(function(resolve) {
      resolve(value);
    });
  }
  return new (P2 || (P2 = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var MatrixRoomService = class {
  constructor(httpClient) {
    this.httpClient = httpClient;
  }
  /**
   * Create a room
   *
   * @param accessToken
   * @param config
   */
  createRoom(accessToken, config2 = {}) {
    return __awaiter19(this, void 0, void 0, function* () {
      return this.httpClient.post("/createRoom", config2, { accessToken });
    });
  }
  /**
   * Invite a user to a room
   *
   * @param accessToken
   * @param user
   * @param room
   */
  inviteToRoom(accessToken, user, room) {
    return __awaiter19(this, void 0, void 0, function* () {
      if (room.status !== MatrixRoomStatus.JOINED && room.status !== MatrixRoomStatus.UNKNOWN) {
        return Promise.reject(`User is not a member of room ${room.id}.`);
      }
      return this.httpClient.post(`/rooms/${encodeURIComponent(room.id)}/invite`, { user_id: user }, { accessToken });
    });
  }
  /**
   * Join a specific room
   *
   * @param accessToken
   * @param room
   */
  joinRoom(accessToken, room) {
    return __awaiter19(this, void 0, void 0, function* () {
      if (room.status === MatrixRoomStatus.JOINED) {
        return Promise.resolve({ room_id: room.id });
      }
      return this.httpClient.post(`/rooms/${encodeURIComponent(room.id)}/join`, {}, { accessToken });
    });
  }
  /**
   * Get all joined rooms
   *
   * @param accessToken
   */
  getJoinedRooms(accessToken) {
    return __awaiter19(this, void 0, void 0, function* () {
      return this.httpClient.get(`/joined_rooms`, void 0, { accessToken });
    });
  }
};

// node_modules/@taquito/beacon-wallet/node_modules/@airgap/beacon-transport-matrix/dist/esm/matrix-client/services/MatrixUserService.js
var __awaiter20 = function(thisArg, _arguments, P2, generator) {
  function adopt(value) {
    return value instanceof P2 ? value : new P2(function(resolve) {
      resolve(value);
    });
  }
  return new (P2 || (P2 = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var MatrixUserService = class {
  constructor(httpClient) {
    this.httpClient = httpClient;
  }
  /**
   * Log in to the matrix node with username and password
   *
   * @param user
   * @param password
   * @param deviceId
   */
  login(user, password, deviceId) {
    return __awaiter20(this, void 0, void 0, function* () {
      return this.httpClient.post("/login", {
        type: "m.login.password",
        identifier: {
          type: "m.id.user",
          user
        },
        password,
        device_id: deviceId
      });
    });
  }
};

// node_modules/@taquito/beacon-wallet/node_modules/@airgap/beacon-transport-matrix/dist/esm/matrix-client/services/MatrixEventService.js
var __awaiter21 = function(thisArg, _arguments, P2, generator) {
  function adopt(value) {
    return value instanceof P2 ? value : new P2(function(resolve) {
      resolve(value);
    });
  }
  return new (P2 || (P2 = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var MatrixEventService = class {
  constructor(httpClient) {
    this.httpClient = httpClient;
    this.cachedPromises = /* @__PURE__ */ new Map();
  }
  /**
   * Get the latest state from the matrix node
   *
   * @param accessToken
   * @param options
   */
  sync(accessToken, options) {
    return __awaiter21(this, void 0, void 0, function* () {
      return this.withCache("sync", () => this.httpClient.get("/sync", {
        timeout: options ? options.pollingTimeout : void 0,
        since: options ? options.syncToken : void 0
      }, { accessToken }));
    });
  }
  /**
   * Send a message to a room
   *
   * @param accessToken
   * @param room
   * @param content
   * @param txnId
   */
  sendMessage(accessToken, roomId, content, txnId) {
    return __awaiter21(this, void 0, void 0, function* () {
      return new Promise((resolve, reject) => this.scheduleEvent({
        accessToken,
        roomId,
        type: "m.room.message",
        content,
        txnId,
        onSuccess: resolve,
        onError: reject
      }));
    });
  }
  /**
   * Schedules an event to be sent to the node
   *
   * @param event
   */
  scheduleEvent(event) {
    this.sendEvent(event);
  }
  /**
   * Send an event to the matrix node
   *
   * @param scheduledEvent
   */
  sendEvent(scheduledEvent) {
    return __awaiter21(this, void 0, void 0, function* () {
      const { roomId, type, txnId, content, accessToken } = scheduledEvent;
      try {
        const response = yield this.httpClient.put(`/rooms/${encodeURIComponent(roomId)}/send/${type}/${encodeURIComponent(txnId)}`, content, { accessToken });
        scheduledEvent.onSuccess(response);
      } catch (error) {
        scheduledEvent.onError(error);
      }
    });
  }
  /**
   * Check the cache when interacting with the Matrix node, if there is an already ongoing call for the specified key, return its promise instead of duplicating the call.
   *
   * @param key
   * @param promiseProvider
   */
  withCache(key, promiseProvider) {
    let promise = this.cachedPromises.get(key);
    if (!promise) {
      promise = promiseProvider().finally(() => {
        this.cachedPromises.delete(key);
      });
      this.cachedPromises.set(key, promise);
    }
    return promise;
  }
};

// node_modules/@taquito/beacon-wallet/node_modules/@airgap/beacon-transport-matrix/dist/esm/matrix-client/EventEmitter.js
var EventEmitter = class {
  constructor() {
    this.events = {};
  }
  on(event, listener) {
    if (typeof this.events[event] !== "object") {
      this.events[event] = [];
    }
    this.events[event].push(listener);
    return () => this.removeListener(event, listener);
  }
  removeListener(event, listener) {
    if (typeof this.events[event] !== "object") {
      return;
    }
    if (!listener) {
      this.events[event] = [];
      return;
    }
    const idx = this.events[event].indexOf(listener);
    if (idx > -1) {
      this.events[event].splice(idx, 1);
    }
  }
  removeAllListeners() {
    Object.keys(this.events).forEach((event) => this.events[event].splice(0, this.events[event].length));
  }
  emit(event, ...args) {
    if (typeof this.events[event] !== "object") {
      return;
    }
    ;
    [...this.events[event]].forEach((listener) => listener.apply(this, args));
  }
  once(event, listener) {
    const remove = this.on(event, (...args) => {
      remove();
      listener.apply(this, args);
    });
    return remove;
  }
};

// node_modules/@taquito/beacon-wallet/node_modules/@airgap/beacon-transport-matrix/dist/esm/matrix-client/models/MatrixClientEvent.js
var MatrixClientEventType;
(function(MatrixClientEventType2) {
  MatrixClientEventType2["INVITE"] = "invite";
  MatrixClientEventType2["MESSAGE"] = "message";
})(MatrixClientEventType || (MatrixClientEventType = {}));

// node_modules/@taquito/beacon-wallet/node_modules/@airgap/beacon-transport-matrix/dist/esm/matrix-client/MatrixClientEventEmitter.js
var MatrixClientEventEmitter = class extends EventEmitter {
  constructor() {
    super(...arguments);
    this.eventEmitProviders = /* @__PURE__ */ new Map([
      [MatrixClientEventType.INVITE, () => [this.isInvite, this.emitInvite.bind(this)]],
      [MatrixClientEventType.MESSAGE, () => [this.isMessage, this.emitMessage.bind(this)]]
    ]);
  }
  /**
   * This method is called every time the state is changed
   *
   * @param _oldState
   * @param _newState
   * @param stateChange
   */
  onStateChanged(_oldState, _newState, stateChange) {
    for (const event of keys(MatrixClientEventType)) {
      this.emitIfEvent(MatrixClientEventType[event], stateChange);
    }
  }
  /**
   * Emit the message if we have listeners registered for that type
   *
   * @param eventType
   * @param object
   */
  emitIfEvent(eventType, object) {
    const provider = this.eventEmitProviders.get(eventType);
    if (provider) {
      const [predicate, emitter] = provider();
      if (predicate(object)) {
        emitter(eventType, object);
      }
    }
  }
  /**
   * Emit a client event
   *
   * @param eventType
   * @param content
   */
  emitClientEvent(eventType, content, timestamp2) {
    this.emit(eventType, {
      type: eventType,
      content,
      timestamp: timestamp2
    });
  }
  /**
   * Check if event is an invite
   *
   * @param stateChange
   */
  isInvite(stateChange) {
    return stateChange.rooms ? stateChange.rooms.some((room) => room.status === MatrixRoomStatus.INVITED) : false;
  }
  /**
   * Emit an invite
   *
   * @param eventType
   * @param stateChange
   */
  emitInvite(eventType, stateChange) {
    stateChange.rooms.filter((room) => room.status === MatrixRoomStatus.INVITED).map((room) => [room.id, room.members]).forEach(([id, members]) => {
      this.emitClientEvent(eventType, {
        roomId: id,
        members
      });
    });
  }
  /**
   * Check if event is a message
   *
   * @param stateChange
   */
  isMessage(stateChange) {
    return stateChange.rooms ? stateChange.rooms.some((room) => room.messages.length > 0) : false;
  }
  /**
   * Emit an event to all rooms
   *
   * @param eventType
   * @param stateChange
   */
  emitMessage(eventType, stateChange) {
    stateChange.rooms.filter((room) => room.messages.length > 0).map((room) => room.messages.map((message) => [room.id, message, message.timestamp])).reduce((flatten, toFlatten) => flatten.concat(toFlatten), []).forEach(([roomId, message, timestamp2]) => {
      this.emitClientEvent(eventType, {
        roomId,
        message
      }, timestamp2);
    });
  }
};

// node_modules/@taquito/beacon-wallet/node_modules/@airgap/beacon-transport-matrix/dist/esm/matrix-client/MatrixClient.js
var __awaiter22 = function(thisArg, _arguments, P2, generator) {
  function adopt(value) {
    return value instanceof P2 ? value : new P2(function(resolve) {
      resolve(value);
    });
  }
  return new (P2 || (P2 = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var logger6 = new Logger("MatrixClient");
var IMMEDIATE_POLLING_RETRIES = 3;
var RETRY_INTERVAL = 5e3;
var MatrixClient = class _MatrixClient {
  constructor(store, eventEmitter, userService, roomService, eventService, httpClient) {
    this.store = store;
    this.eventEmitter = eventEmitter;
    this.userService = userService;
    this.roomService = roomService;
    this.eventService = eventService;
    this.httpClient = httpClient;
    this.isActive = true;
    this._isReady = new ExposedPromise();
    this.store.onStateChanged((oldState, newState, stateChange) => {
      this.eventEmitter.onStateChanged(oldState, newState, stateChange);
    }, "rooms");
  }
  /**
   * Create a matrix client based on the options provided
   *
   * @param config
   */
  static create(config2) {
    const store = new MatrixClientStore(config2.storage);
    const eventEmitter = new MatrixClientEventEmitter();
    const httpClient = new MatrixHttpClient(config2.baseUrl);
    const accountService = new MatrixUserService(httpClient);
    const roomService = new MatrixRoomService(httpClient);
    const eventService = new MatrixEventService(httpClient);
    return new _MatrixClient(store, eventEmitter, accountService, roomService, eventService, httpClient);
  }
  /**
   * Return all the rooms we are currently part of
   */
  get joinedRooms() {
    return new Promise((resolve) => __awaiter22(this, void 0, void 0, function* () {
      yield this.isConnected();
      resolve(Object.values(this.store.get("rooms")).filter((room) => room.status === MatrixRoomStatus.JOINED));
    }));
  }
  /**
   * Return all the rooms to which we have received invitations
   */
  get invitedRooms() {
    return new Promise((resolve) => __awaiter22(this, void 0, void 0, function* () {
      yield this.isConnected();
      resolve(Object.values(this.store.get("rooms")).filter((room) => room.status === MatrixRoomStatus.INVITED));
    }));
  }
  /**
   * Return all the rooms that we left
   */
  get leftRooms() {
    return new Promise((resolve) => __awaiter22(this, void 0, void 0, function* () {
      yield this.isConnected();
      resolve(Object.values(this.store.get("rooms")).filter((room) => room.status === MatrixRoomStatus.LEFT));
    }));
  }
  /**
   * Initiate the connection to the matrix node and log in
   *
   * @param user
   */
  start(user) {
    return __awaiter22(this, void 0, void 0, function* () {
      const response = yield this.userService.login(user.id, user.password, user.deviceId);
      yield this.store.update({
        accessToken: response.access_token
      });
      const initialPollingResult = new Promise((resolve, reject) => __awaiter22(this, void 0, void 0, function* () {
        yield this.poll(0, (pollingResponse) => __awaiter22(this, void 0, void 0, function* () {
          if (!this.store.get("isRunning")) {
            resolve();
          }
          yield this.store.update({
            isRunning: true,
            syncToken: pollingResponse.next_batch,
            pollingTimeout: 3e4,
            pollingRetries: 0,
            rooms: MatrixRoom.fromSync(pollingResponse.rooms)
          });
        }), (error) => __awaiter22(this, void 0, void 0, function* () {
          if (!this.store.get("isRunning")) {
            reject(error);
          }
          yield this.store.update({
            isRunning: false,
            pollingRetries: this.store.get("pollingRetries") + 1
          });
        }));
      }));
      initialPollingResult.then(() => {
        this._isReady.resolve();
      }).catch(console.error);
      return initialPollingResult;
    });
  }
  isConnected() {
    return __awaiter22(this, void 0, void 0, function* () {
      return this._isReady.promise;
    });
  }
  /**
   * Stop all running requests
   */
  stop() {
    return __awaiter22(this, void 0, void 0, function* () {
      logger6.log(`MATRIX CLIENT STOPPED`);
      this.isActive = false;
      this._isReady = new ExposedPromise();
      return this.httpClient.cancelAllRequests();
    });
  }
  /**
   * Subscribe to new matrix events
   *
   * @param event
   * @param listener
   */
  subscribe(event, listener) {
    this.eventEmitter.on(event, listener);
  }
  /**
   * Unsubscribe from matrix events
   *
   * @param event
   * @param listener
   */
  unsubscribe(event, listener) {
    if (listener) {
      this.eventEmitter.removeListener(event, listener);
    }
  }
  /**
   * Unsubscribe from all matrix events of this type
   *
   * @param event
   * @param listener
   */
  unsubscribeAll(event) {
    this.eventEmitter.removeListener(event);
  }
  getRoomById(id) {
    return __awaiter22(this, void 0, void 0, function* () {
      yield this.isConnected();
      return this.store.getRoom(id);
    });
  }
  /**
   * Create a private room with the supplied members
   *
   * @param members Members that will be in the room
   */
  createTrustedPrivateRoom(...members) {
    return __awaiter22(this, void 0, void 0, function* () {
      yield this.isConnected();
      return this.requiresAuthorization("createRoom", (accessToken) => __awaiter22(this, void 0, void 0, function* () {
        const response = yield this.roomService.createRoom(accessToken, {
          room_version: "5",
          invite: members,
          preset: "public_chat",
          is_direct: true
        });
        return response.room_id;
      }));
    });
  }
  /**
   * Invite user to rooms
   *
   * @param user The user to be invited
   * @param roomsOrIds The rooms the user will be invited to
   */
  inviteToRooms(user, ...roomsOrIds) {
    return __awaiter22(this, void 0, void 0, function* () {
      yield this.isConnected();
      yield this.requiresAuthorization("invite", (accessToken) => Promise.all(roomsOrIds.map((roomOrId) => {
        const room = this.store.getRoom(roomOrId);
        this.roomService.inviteToRoom(accessToken, user, room).catch((error) => logger6.warn("inviteToRooms", error));
      })));
    });
  }
  /**
   * Join rooms
   *
   * @param roomsOrIds
   */
  joinRooms(...roomsOrIds) {
    return __awaiter22(this, void 0, void 0, function* () {
      yield this.isConnected();
      yield this.requiresAuthorization("join", (accessToken) => Promise.all(roomsOrIds.map((roomOrId) => {
        const room = this.store.getRoom(roomOrId);
        return this.roomService.joinRoom(accessToken, room);
      })));
    });
  }
  /**
   * Send a text message
   *
   * @param roomOrId
   * @param message
   */
  sendTextMessage(roomId, message) {
    return __awaiter22(this, void 0, void 0, function* () {
      yield this.isConnected();
      yield this.requiresAuthorization("send", (accessToken) => __awaiter22(this, void 0, void 0, function* () {
        const txnId = yield this.createTxnId();
        return this.eventService.sendMessage(accessToken, roomId, {
          msgtype: "m.text",
          body: message
        }, txnId);
      }));
    });
  }
  /**
   * Poll the server to get the latest data and get notified of changes
   *
   * @param interval
   * @param onSyncSuccess
   * @param onSyncError
   */
  poll(interval2, onSyncSuccess, onSyncError) {
    return __awaiter22(this, void 0, void 0, function* () {
      const store = this.store;
      const sync = this.sync.bind(this);
      const pollSync = (resolve, reject) => __awaiter22(this, void 0, void 0, function* () {
        let syncingRetries = 0;
        try {
          const response = yield sync();
          onSyncSuccess(response);
        } catch (error) {
          onSyncError(error);
          syncingRetries = store.get("pollingRetries");
          if (this.isActive) {
            logger6.log(`Retry syncing... ${syncingRetries} retries so far`);
          }
        } finally {
          if (this.isActive) {
            setTimeout(() => __awaiter22(this, void 0, void 0, function* () {
              yield pollSync(resolve, reject);
            }), syncingRetries > IMMEDIATE_POLLING_RETRIES ? RETRY_INTERVAL + interval2 : interval2);
          } else {
            reject(new Error(`Syncing stopped manually.`));
          }
        }
      });
      return new Promise(pollSync);
    });
  }
  /**
   * Get state from server
   */
  sync() {
    return __awaiter22(this, void 0, void 0, function* () {
      return this.requiresAuthorization("sync", (accessToken) => __awaiter22(this, void 0, void 0, function* () {
        return this.eventService.sync(accessToken, {
          pollingTimeout: this.store.get("pollingTimeout"),
          syncToken: this.store.get("syncToken")
        });
      }));
    });
  }
  /**
   * A helper method that makes sure an access token is provided
   *
   * @param name
   * @param action
   */
  requiresAuthorization(name, action) {
    return __awaiter22(this, void 0, void 0, function* () {
      const storedToken = this.store.get("accessToken");
      if (!storedToken) {
        return Promise.reject(`${name} requires authorization but no access token has been provided.`);
      }
      return action(storedToken);
    });
  }
  /**
   * Create a transaction ID
   */
  createTxnId() {
    return __awaiter22(this, void 0, void 0, function* () {
      const timestamp2 = (/* @__PURE__ */ new Date()).getTime();
      const counter = this.store.get("txnNo");
      yield this.store.update({
        txnNo: counter + 1
      });
      return `m${timestamp2}.${counter}`;
    });
  }
};

// node_modules/@taquito/beacon-wallet/node_modules/@airgap/beacon-transport-matrix/dist/esm/communication-client/P2PCommunicationClient.js
var import_blake2b5 = __toESM(require_blake2b());
var import_utf83 = __toESM(require_utf8());
var __awaiter23 = function(thisArg, _arguments, P2, generator) {
  function adopt(value) {
    return value instanceof P2 ? value : new P2(function(resolve) {
      resolve(value);
    });
  }
  return new (P2 || (P2 = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var logger7 = new Logger("P2PCommunicationClient");
var REGIONS_AND_SERVERS = {
  [Regions.EUROPE_WEST]: [
    "beacon-node-1.diamond.papers.tech",
    "beacon-node-1.sky.papers.tech",
    "beacon-node-2.sky.papers.tech",
    "beacon-node-1.hope.papers.tech",
    "beacon-node-1.hope-2.papers.tech",
    "beacon-node-1.hope-3.papers.tech",
    "beacon-node-1.hope-4.papers.tech",
    "beacon-node-1.hope-5.papers.tech"
  ]
};
var P2PCommunicationClient = class extends CommunicationClient {
  constructor(name, keyPair, replicationCount, storage, matrixNodes, iconUrl, appUrl) {
    super(keyPair);
    this.name = name;
    this.replicationCount = replicationCount;
    this.storage = storage;
    this.iconUrl = iconUrl;
    this.appUrl = appUrl;
    this.client = new ExposedPromise();
    this.activeListeners = /* @__PURE__ */ new Map();
    this.ignoredRooms = [];
    this.loginCounter = 0;
    logger7.log("constructor", "P2PCommunicationClient created");
    this.ENABLED_RELAY_SERVERS = REGIONS_AND_SERVERS;
    if (matrixNodes) {
      this.ENABLED_RELAY_SERVERS = Object.assign(Object.assign({}, REGIONS_AND_SERVERS), matrixNodes);
    }
  }
  getPairingRequestInfo() {
    return __awaiter23(this, void 0, void 0, function* () {
      const info = {
        id: yield generateGUID(),
        type: "p2p-pairing-request",
        name: this.name,
        version: BEACON_VERSION,
        publicKey: yield this.getPublicKey(),
        relayServer: (yield this.getRelayServer()).server
      };
      if (this.iconUrl) {
        info.icon = this.iconUrl;
      }
      if (this.appUrl) {
        info.appUrl = this.appUrl;
      }
      return info;
    });
  }
  getPairingResponseInfo(request) {
    return __awaiter23(this, void 0, void 0, function* () {
      const info = {
        id: request.id,
        type: "p2p-pairing-response",
        name: this.name,
        version: request.version,
        publicKey: yield this.getPublicKey(),
        relayServer: (yield this.getRelayServer()).server
      };
      if (this.iconUrl) {
        info.icon = this.iconUrl;
      }
      if (this.appUrl) {
        info.appUrl = this.appUrl;
      }
      return info;
    });
  }
  findBestRegion() {
    return __awaiter23(this, void 0, void 0, function* () {
      if (this.selectedRegion) {
        return this.selectedRegion;
      }
      const keys2 = Object.keys(this.ENABLED_RELAY_SERVERS);
      const allPromises = [];
      keys2.forEach((key) => {
        var _a3;
        const nodes = (_a3 = this.ENABLED_RELAY_SERVERS[key]) !== null && _a3 !== void 0 ? _a3 : [];
        if (nodes.length === 0) {
          return;
        }
        const index = Math.floor(Math.random() * nodes.length);
        allPromises.push(this.getBeaconInfo(nodes[index]).then((res) => ({
          region: key,
          server: nodes[index],
          response: res
        })).catch((err) => new Promise((_resolve, reject) => {
          setTimeout(() => reject(err), 2e3);
        })));
      });
      const region = yield Promise.race(allPromises);
      this.selectedRegion = region.region;
      return region.region;
    });
  }
  getRelayServer() {
    return __awaiter23(this, void 0, void 0, function* () {
      if (this.relayServer) {
        const relayServer = yield this.relayServer.promise;
        if (Date.now() - relayServer.localTimestamp < 60 * 1e3) {
          return { server: relayServer.server, timestamp: relayServer.timestamp };
        }
        const info = yield this.getBeaconInfo(relayServer.server);
        this.relayServer.resolve({
          server: relayServer.server,
          timestamp: info.timestamp,
          localTimestamp: (/* @__PURE__ */ new Date()).getTime()
        });
        return { server: relayServer.server, timestamp: info.timestamp };
      } else {
        this.relayServer = new ExposedPromise();
      }
      const node = yield this.storage.get(StorageKey.MATRIX_SELECTED_NODE);
      if (node && node.length > 0) {
        const info = yield this.getBeaconInfo(node);
        this.relayServer.resolve({
          server: node,
          timestamp: info.timestamp,
          localTimestamp: (/* @__PURE__ */ new Date()).getTime()
        });
        return { server: node, timestamp: info.timestamp };
      }
      const region = yield this.findBestRegion();
      const regionNodes = this.ENABLED_RELAY_SERVERS[region];
      if (!regionNodes) {
        throw new Error(`No servers found for region ${region}`);
      }
      const nodes = [...regionNodes];
      while (nodes.length > 0) {
        const index = Math.floor(Math.random() * nodes.length);
        const server = nodes[index];
        try {
          const response = yield this.getBeaconInfo(server);
          this.storage.set(StorageKey.MATRIX_SELECTED_NODE, server).catch((error) => logger7.log(error));
          this.relayServer.resolve({
            server,
            timestamp: response.timestamp,
            localTimestamp: (/* @__PURE__ */ new Date()).getTime()
          });
          return { server, timestamp: response.timestamp };
        } catch (relayError) {
          logger7.log(`Ignoring server "${server}", trying another one...`);
          nodes.splice(index, 1);
        }
      }
      this.relayServer.reject(`No matrix server reachable!`);
      throw new Error(`No matrix server reachable!`);
    });
  }
  getBeaconInfo(server) {
    return __awaiter23(this, void 0, void 0, function* () {
      return import_axios2.default.get(`https://${server}/_synapse/client/beacon/info`).then((res) => ({
        region: res.data.region,
        known_servers: res.data.known_servers,
        timestamp: Math.floor(res.data.timestamp)
      }));
    });
  }
  tryJoinRooms(roomId, retry2 = 1) {
    return __awaiter23(this, void 0, void 0, function* () {
      try {
        yield (yield this.client.promise).joinRooms(roomId);
      } catch (error) {
        if (retry2 <= 10 && error.errcode === "M_FORBIDDEN") {
          logger7.log(`Retrying to join...`, error);
          setTimeout(() => __awaiter23(this, void 0, void 0, function* () {
            yield this.tryJoinRooms(roomId, retry2 + 1);
          }), 200);
        } else {
          logger7.log(`Failed to join after ${retry2} tries.`, error);
        }
      }
    });
  }
  start() {
    var _a3, _b;
    return __awaiter23(this, void 0, void 0, function* () {
      logger7.log("start", "starting client");
      logger7.log("start", `connecting to server`);
      const relayServer = yield this.getRelayServer();
      const client = MatrixClient.create({
        baseUrl: `https://${relayServer.server}`,
        storage: this.storage
      });
      this.initialListener = (event) => __awaiter23(this, void 0, void 0, function* () {
        if (this.initialEvent && this.initialEvent.timestamp && event && event.timestamp) {
          if (this.initialEvent.timestamp < event.timestamp) {
            this.initialEvent = event;
          }
        } else {
          this.initialEvent = event;
        }
      });
      client.subscribe(MatrixClientEventType.MESSAGE, this.initialListener);
      client.subscribe(MatrixClientEventType.INVITE, (event) => __awaiter23(this, void 0, void 0, function* () {
        let member;
        if (event.content.members.length === 1) {
          member = event.content.members[0];
        }
        yield this.tryJoinRooms(event.content.roomId);
        if (member) {
          yield this.updateRelayServer(member);
          yield this.updatePeerRoom(member, event.content.roomId);
        }
      }));
      if (!relayServer.timestamp) {
        throw new Error("No timestamp received from relay server");
      }
      const time = Math.floor(relayServer.timestamp);
      const loginString = `login:${Math.floor(time / (5 * 60))}`;
      logger7.log("start", `login ${loginString}, ${yield this.getPublicKeyHash()} on ${relayServer.server}`);
      const loginRawDigest = (0, import_blake2b5.hash)((0, import_utf83.encode)(loginString), 32);
      const secretKey = (_a3 = this.keyPair.secretKey) !== null && _a3 !== void 0 ? _a3 : this.keyPair.privateKey;
      const rawSignature = (0, import_ed255195.sign)(secretKey, loginRawDigest);
      try {
        yield client.start({
          id: yield this.getPublicKeyHash(),
          password: `ed:${toHex(rawSignature)}:${yield this.getPublicKey()}`,
          deviceId: toHex(this.keyPair.publicKey)
        });
      } catch (error) {
        logger7.error("start", "Could not log in, retrying");
        yield this.reset();
        if (!this.selectedRegion) {
          throw new Error("No region selected.");
        }
        if (this.loginCounter <= ((_b = this.ENABLED_RELAY_SERVERS[this.selectedRegion]) !== null && _b !== void 0 ? _b : []).length) {
          this.loginCounter++;
          this.start();
          return;
        } else {
          logger7.error("start", "Tried to log in to every known beacon node, but no login was successful.");
          throw new Error("Could not connect to any beacon nodes. Try again later.");
        }
      }
      logger7.log("start", "login successful, client is ready");
      this.client.resolve(client);
    });
  }
  stop() {
    return __awaiter23(this, void 0, void 0, function* () {
      logger7.log("stop", "stopping client");
      if (this.client.isResolved()) {
        yield (yield this.client.promise).stop().catch((error) => logger7.error(error));
      }
      yield this.reset();
    });
  }
  reset() {
    return __awaiter23(this, void 0, void 0, function* () {
      logger7.log("reset", "resetting connection");
      yield this.storage.delete(StorageKey.MATRIX_PEER_ROOM_IDS).catch((error) => logger7.log(error));
      yield this.storage.delete(StorageKey.MATRIX_PRESERVED_STATE).catch((error) => logger7.log(error));
      yield this.storage.delete(StorageKey.MATRIX_SELECTED_NODE).catch((error) => logger7.log(error));
      this.relayServer = void 0;
      this.client = new ExposedPromise();
      this.initialEvent = void 0;
      this.initialListener = void 0;
    });
  }
  listenForEncryptedMessage(senderPublicKey, messageCallback) {
    return __awaiter23(this, void 0, void 0, function* () {
      if (this.activeListeners.has(senderPublicKey)) {
        return;
      }
      logger7.log("listenForEncryptedMessage", `start listening for encrypted messages from publicKey ${senderPublicKey}`);
      const sharedKey2 = yield this.createCryptoBoxServer(senderPublicKey, this.keyPair);
      const callbackFunction = (event) => __awaiter23(this, void 0, void 0, function* () {
        if (this.isTextMessage(event.content) && (yield this.isSender(event, senderPublicKey))) {
          let payload;
          yield this.updateRelayServer(event.content.message.sender);
          yield this.updatePeerRoom(event.content.message.sender, event.content.roomId);
          try {
            payload = Buffer.from(event.content.message.content, "hex");
          } catch (_a3) {
          }
          if (payload && payload.length >= secretbox_NONCEBYTES2 + secretbox_MACBYTES) {
            try {
              const decryptedMessage = yield decryptCryptoboxPayload(payload, sharedKey2.receive);
              logger7.log("listenForEncryptedMessage", `received a message from ${senderPublicKey}`, decryptedMessage);
              messageCallback(decryptedMessage);
            } catch (decryptionError) {
            }
          }
        }
      });
      this.activeListeners.set(senderPublicKey, callbackFunction);
      (yield this.client.promise).subscribe(MatrixClientEventType.MESSAGE, callbackFunction);
      const lastEvent = this.initialEvent;
      if (lastEvent && lastEvent.timestamp && (/* @__PURE__ */ new Date()).getTime() - lastEvent.timestamp < 5 * 60 * 1e3) {
        logger7.log("listenForEncryptedMessage", "Handling previous event");
        yield callbackFunction(lastEvent);
      } else {
        logger7.log("listenForEncryptedMessage", "No previous event found");
      }
      const initialListener = this.initialListener;
      if (initialListener) {
        ;
        (yield this.client.promise).unsubscribe(MatrixClientEventType.MESSAGE, initialListener);
      }
      this.initialListener = void 0;
      this.initialEvent = void 0;
    });
  }
  unsubscribeFromEncryptedMessage(senderPublicKey) {
    return __awaiter23(this, void 0, void 0, function* () {
      const listener = this.activeListeners.get(senderPublicKey);
      if (!listener) {
        return;
      }
      ;
      (yield this.client.promise).unsubscribe(MatrixClientEventType.MESSAGE, listener);
      this.activeListeners.delete(senderPublicKey);
    });
  }
  unsubscribeFromEncryptedMessages() {
    return __awaiter23(this, void 0, void 0, function* () {
      ;
      (yield this.client.promise).unsubscribeAll(MatrixClientEventType.MESSAGE);
      this.activeListeners.clear();
    });
  }
  sendMessage(message, peer) {
    return __awaiter23(this, void 0, void 0, function* () {
      const sharedKey2 = yield this.createCryptoBoxClient(peer.publicKey, this.keyPair);
      const recipientHash = yield getHexHash(Buffer.from(peer.publicKey, "hex"));
      const recipient = recipientString(recipientHash, peer.relayServer);
      const roomId = yield this.getRelevantRoom(recipient);
      yield this.waitForJoin(roomId);
      const encryptedMessage = yield encryptCryptoboxPayload(message, sharedKey2.send);
      logger7.log("sendMessage", "sending encrypted message", peer.publicKey, roomId, message);
      (yield this.client.promise).sendTextMessage(roomId, encryptedMessage).catch((error) => __awaiter23(this, void 0, void 0, function* () {
        if (error.errcode === "M_FORBIDDEN") {
          logger7.log(`sendMessage`, `M_FORBIDDEN`, roomId, error);
          yield this.deleteRoomIdFromRooms(roomId);
          const newRoomId = yield this.getRelevantRoom(recipient);
          logger7.log(`sendMessage`, `Old room deleted, new room created`, newRoomId);
          (yield this.client.promise).sendTextMessage(newRoomId, encryptedMessage).catch((error2) => __awaiter23(this, void 0, void 0, function* () {
            logger7.log(`sendMessage`, `inner error`, newRoomId, error2);
          }));
        } else {
          logger7.log(`sendMessage`, `unexpected error`, error);
        }
      }));
    });
  }
  updatePeerRoom(sender, roomId) {
    return __awaiter23(this, void 0, void 0, function* () {
      logger7.log(`updatePeerRoom`, sender, roomId);
      const split = sender.split(":");
      if (split.length < 2 || !split[0].startsWith("@")) {
        throw new Error("Invalid sender");
      }
      const roomIds = yield this.storage.get(StorageKey.MATRIX_PEER_ROOM_IDS);
      const room = roomIds[sender];
      if (room === roomId) {
        logger7.debug(`updatePeerRoom`, `rooms are the same, not updating`);
      }
      logger7.debug(`updatePeerRoom`, `current room`, room, "new room", roomId);
      if (room && room[1]) {
        logger7.log(`updatePeerRoom`, `adding room "${room[1]}" to ignored array`);
        this.ignoredRooms.push(room[1]);
      }
      roomIds[sender] = roomId;
      yield this.storage.set(StorageKey.MATRIX_PEER_ROOM_IDS, roomIds);
    });
  }
  deleteRoomIdFromRooms(roomId) {
    return __awaiter23(this, void 0, void 0, function* () {
      const roomIds = yield this.storage.get(StorageKey.MATRIX_PEER_ROOM_IDS);
      const newRoomIds = Object.entries(roomIds).filter((entry) => entry[1] !== roomId).reduce((pv, cv) => Object.assign(Object.assign({}, pv), { [cv[0]]: cv[1] }), {});
      yield this.storage.set(StorageKey.MATRIX_PEER_ROOM_IDS, newRoomIds);
      this.ignoredRooms.push(roomId);
    });
  }
  listenForChannelOpening(messageCallback) {
    return __awaiter23(this, void 0, void 0, function* () {
      logger7.debug(`listenForChannelOpening`);
      (yield this.client.promise).subscribe(MatrixClientEventType.MESSAGE, (event) => __awaiter23(this, void 0, void 0, function* () {
        if (this.isTextMessage(event.content) && (yield this.isChannelOpenMessage(event.content))) {
          logger7.log(`listenForChannelOpening`, `channel opening received, trying to decrypt`, JSON.stringify(event));
          yield this.updateRelayServer(event.content.message.sender);
          yield this.updatePeerRoom(event.content.message.sender, event.content.roomId);
          const splits = event.content.message.content.split(":");
          const payload = Buffer.from(splits[splits.length - 1], "hex");
          if (payload.length >= secretbox_NONCEBYTES2 + secretbox_MACBYTES) {
            try {
              const pairingResponse = JSON.parse(yield openCryptobox(payload, this.keyPair.publicKey, this.keyPair.secretKey));
              logger7.log(`listenForChannelOpening`, `channel opening received and decrypted`, JSON.stringify(pairingResponse));
              messageCallback(Object.assign(Object.assign({}, pairingResponse), { senderId: yield getSenderId(pairingResponse.publicKey) }));
            } catch (decryptionError) {
            }
          }
        }
      }));
    });
  }
  waitForJoin(roomId, retry2 = 0) {
    return __awaiter23(this, void 0, void 0, function* () {
      const room = yield (yield this.client.promise).getRoomById(roomId);
      logger7.log(`waitForJoin`, `Currently ${room.members.length} members, we need at least 2`);
      if (room.members.length >= 2 || room.members.length === 0) {
        return;
      } else {
        if (retry2 <= 200) {
          logger7.log(`Waiting for join... Try: ${retry2}`);
          return new Promise((resolve) => {
            setTimeout(() => __awaiter23(this, void 0, void 0, function* () {
              resolve(this.waitForJoin(roomId, retry2 + 1));
            }), 100 * (retry2 > 50 ? 10 : 1));
          });
        } else {
          throw new Error(`No one joined after ${retry2} tries.`);
        }
      }
    });
  }
  sendPairingResponse(pairingRequest) {
    return __awaiter23(this, void 0, void 0, function* () {
      logger7.log(`sendPairingResponse`);
      const recipientHash = yield getHexHash(Buffer.from(pairingRequest.publicKey, "hex"));
      const recipient = recipientString(recipientHash, pairingRequest.relayServer);
      const roomId = yield (yield this.client.promise).createTrustedPrivateRoom(recipient);
      logger7.debug(`sendPairingResponse`, `Connecting to room "${roomId}"`);
      yield this.updatePeerRoom(recipient, roomId);
      yield this.waitForJoin(roomId);
      logger7.debug(`sendPairingResponse`, `Successfully joined room.`);
      const message = typeof pairingRequest.version === "undefined" ? yield this.getPublicKey() : JSON.stringify(yield this.getPairingResponseInfo(pairingRequest));
      logger7.debug(`sendPairingResponse`, `Sending pairing response`, message);
      const encryptedMessage = yield this.encryptMessageAsymmetric(pairingRequest.publicKey, message);
      const msg = ["@channel-open", recipient, encryptedMessage].join(":");
      (yield this.client.promise).sendTextMessage(roomId, msg).catch((error) => __awaiter23(this, void 0, void 0, function* () {
        if (error.errcode === "M_FORBIDDEN") {
          logger7.log(`sendPairingResponse`, `M_FORBIDDEN`, roomId, error);
          yield this.deleteRoomIdFromRooms(roomId);
          const newRoomId = yield this.getRelevantRoom(recipient);
          logger7.log(`sendPairingResponse`, `Old room deleted, new room created`, newRoomId);
          (yield this.client.promise).sendTextMessage(newRoomId, msg).catch((error2) => __awaiter23(this, void 0, void 0, function* () {
            logger7.log(`sendPairingResponse`, `inner error`, newRoomId, error2);
          }));
        } else {
          logger7.log(`sendPairingResponse`, `unexpected error`, error);
        }
      }));
    });
  }
  isTextMessage(content) {
    return content.message.type === MatrixMessageType.TEXT;
  }
  updateRelayServer(sender) {
    return __awaiter23(this, void 0, void 0, function* () {
      logger7.log(`updateRelayServer`, sender);
      const split = sender.split(":");
      if (split.length < 2 || !split[0].startsWith("@")) {
        throw new Error("Invalid sender");
      }
      const senderHash = split.shift();
      const relayServer = split.join(":");
      const manager = localStorage.getItem("beacon:communication-peers-dapp") ? new PeerManager(this.storage, StorageKey.TRANSPORT_P2P_PEERS_DAPP) : new PeerManager(this.storage, StorageKey.TRANSPORT_P2P_PEERS_WALLET);
      const peers = yield manager.getPeers();
      const promiseArray = peers.map((peer) => __awaiter23(this, void 0, void 0, function* () {
        const hash6 = `@${yield getHexHash(Buffer.from(peer.publicKey, "hex"))}`;
        if (hash6 === senderHash) {
          if (peer.relayServer !== relayServer) {
            peer.relayServer = relayServer;
            yield manager.addPeer(peer);
          }
        }
      }));
      yield Promise.all(promiseArray);
    });
  }
  isChannelOpenMessage(content) {
    return __awaiter23(this, void 0, void 0, function* () {
      return content.message.content.startsWith(`@channel-open:@${yield getHexHash(Buffer.from(yield this.getPublicKey(), "hex"))}`);
    });
  }
  isSender(event, senderPublicKey) {
    return __awaiter23(this, void 0, void 0, function* () {
      return event.content.message.sender.startsWith(`@${yield getHexHash(Buffer.from(senderPublicKey, "hex"))}`);
    });
  }
  getRelevantRoom(recipient) {
    return __awaiter23(this, void 0, void 0, function* () {
      const roomIds = yield this.storage.get(StorageKey.MATRIX_PEER_ROOM_IDS);
      let roomId = roomIds[recipient];
      if (!roomId) {
        logger7.log(`getRelevantRoom`, `No room found for peer ${recipient}, checking joined ones.`);
        const room = yield this.getRelevantJoinedRoom(recipient);
        roomId = room.id;
        roomIds[recipient] = room.id;
        yield this.storage.set(StorageKey.MATRIX_PEER_ROOM_IDS, roomIds);
      }
      logger7.log(`getRelevantRoom`, `Using room ${roomId}`);
      return roomId;
    });
  }
  getRelevantJoinedRoom(recipient) {
    return __awaiter23(this, void 0, void 0, function* () {
      const joinedRooms = yield (yield this.client.promise).joinedRooms;
      logger7.log("checking joined rooms", joinedRooms, recipient);
      const relevantRooms = joinedRooms.filter((roomElement) => !this.ignoredRooms.some((id) => roomElement.id === id)).filter((roomElement) => roomElement.members.some((member) => member === recipient));
      let room;
      if (relevantRooms.length === 0 || this.ignoredRooms.length > 0) {
        logger7.log(`getRelevantJoinedRoom`, `no relevant rooms found, creating new one`);
        const roomId = yield (yield this.client.promise).createTrustedPrivateRoom(recipient);
        room = yield (yield this.client.promise).getRoomById(roomId);
        logger7.log(`getRelevantJoinedRoom`, `waiting for other party to join room: ${room.id}`);
        yield this.waitForJoin(roomId);
        logger7.log(`getRelevantJoinedRoom`, `new room created and peer invited: ${room.id}`);
      } else {
        room = relevantRooms[0];
        logger7.log(`getRelevantJoinedRoom`, `channel already open, reusing room ${room.id}`);
      }
      return room;
    });
  }
};

// node_modules/@taquito/beacon-wallet/node_modules/@airgap/beacon-transport-matrix/dist/esm/P2PTransport.js
var __awaiter24 = function(thisArg, _arguments, P2, generator) {
  function adopt(value) {
    return value instanceof P2 ? value : new P2(function(resolve) {
      resolve(value);
    });
  }
  return new (P2 || (P2 = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var logger8 = new Logger("P2PTransport");
var P2PTransport = class extends Transport {
  constructor(name, keyPair, storage, matrixNodes, storageKey, iconUrl, appUrl) {
    super(name, new P2PCommunicationClient(name, keyPair, 1, storage, matrixNodes, iconUrl, appUrl), new PeerManager(storage, storageKey));
    this.type = TransportType.P2P;
  }
  static isAvailable() {
    return __awaiter24(this, void 0, void 0, function* () {
      return Promise.resolve(true);
    });
  }
  connect() {
    const _super = Object.create(null, {
      connect: { get: () => super.connect }
    });
    return __awaiter24(this, void 0, void 0, function* () {
      if (this._isConnected !== TransportStatus.NOT_CONNECTED) {
        return;
      }
      logger8.log("connect");
      this._isConnected = TransportStatus.CONNECTING;
      yield this.client.start();
      const knownPeers = yield this.getPeers();
      if (knownPeers.length > 0) {
        logger8.log("connect", `connecting to ${knownPeers.length} peers`);
        const connectionPromises = knownPeers.map((peer) => __awaiter24(this, void 0, void 0, function* () {
          return this.listen(peer.publicKey);
        }));
        Promise.all(connectionPromises).catch((error) => logger8.error("connect", error));
      }
      yield this.startOpenChannelListener();
      return _super.connect.call(this);
    });
  }
  disconnect() {
    const _super = Object.create(null, {
      disconnect: { get: () => super.disconnect }
    });
    return __awaiter24(this, void 0, void 0, function* () {
      yield this.client.stop();
      return _super.disconnect.call(this);
    });
  }
  startOpenChannelListener() {
    return __awaiter24(this, void 0, void 0, function* () {
    });
  }
  getPairingRequestInfo() {
    return __awaiter24(this, void 0, void 0, function* () {
      return this.client.getPairingRequestInfo();
    });
  }
  listen(publicKey) {
    return __awaiter24(this, void 0, void 0, function* () {
      yield this.client.listenForEncryptedMessage(publicKey, (message) => {
        const connectionContext = {
          origin: Origin.P2P,
          id: publicKey
        };
        this.notifyListeners(message, connectionContext).catch((error) => {
          throw error;
        });
      }).catch((error) => {
        throw error;
      });
    });
  }
};

// node_modules/@taquito/beacon-wallet/node_modules/@airgap/beacon-transport-postmessage/dist/esm/PostMessageClient.js
var __awaiter25 = function(thisArg, _arguments, P2, generator) {
  function adopt(value) {
    return value instanceof P2 ? value : new P2(function(resolve) {
      resolve(value);
    });
  }
  return new (P2 || (P2 = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var PostMessageClient = class extends MessageBasedClient {
  constructor() {
    super(...arguments);
    this.activeListeners = /* @__PURE__ */ new Map();
  }
  init() {
    return __awaiter25(this, void 0, void 0, function* () {
      this.subscribeToMessages().catch(console.error);
    });
  }
  listenForEncryptedMessage(senderPublicKey, messageCallback) {
    return __awaiter25(this, void 0, void 0, function* () {
      if (this.activeListeners.has(senderPublicKey)) {
        return;
      }
      const callbackFunction = (message, context2) => __awaiter25(this, void 0, void 0, function* () {
        try {
          const decryptedMessage = yield this.decryptMessage(senderPublicKey, message.encryptedPayload);
          messageCallback(decryptedMessage, context2);
        } catch (decryptionError) {
        }
      });
      this.activeListeners.set(senderPublicKey, callbackFunction);
    });
  }
  sendMessage(message, peer) {
    return __awaiter25(this, void 0, void 0, function* () {
      const payload = yield this.encryptMessage(peer.publicKey, message);
      const targetId = peer === null || peer === void 0 ? void 0 : peer.extensionId;
      const msg = {
        target: ExtensionMessageTarget.EXTENSION,
        encryptedPayload: payload,
        targetId
      };
      windowRef.postMessage(msg, windowRef.location.origin);
    });
  }
  listenForChannelOpening(messageCallback) {
    return __awaiter25(this, void 0, void 0, function* () {
      const fn2 = (event) => __awaiter25(this, void 0, void 0, function* () {
        var _a3, _b;
        if (event.source !== windowRef || event.origin !== windowRef.location.origin) {
          return;
        }
        const data = (_a3 = event === null || event === void 0 ? void 0 : event.data) === null || _a3 === void 0 ? void 0 : _a3.message;
        if (data && data.target === ExtensionMessageTarget.PAGE && (yield this.isChannelOpenMessage(data))) {
          const payload = Buffer.from(data.payload, "hex");
          if (payload.length >= secretbox_NONCEBYTES2 + secretbox_MACBYTES) {
            try {
              const pairingResponse = JSON.parse(yield openCryptobox(payload, this.keyPair.publicKey, this.keyPair.secretKey));
              messageCallback(Object.assign(Object.assign({}, pairingResponse), { senderId: yield getSenderId(pairingResponse.publicKey), extensionId: (_b = event === null || event === void 0 ? void 0 : event.data) === null || _b === void 0 ? void 0 : _b.sender.id }));
            } catch (decryptionError) {
            }
          }
        }
      });
      windowRef.addEventListener("message", fn2);
    });
  }
  sendPairingRequest(id) {
    return __awaiter25(this, void 0, void 0, function* () {
      const message = {
        target: ExtensionMessageTarget.EXTENSION,
        payload: yield new Serializer().serialize(yield this.getPairingRequestInfo()),
        targetId: id
      };
      windowRef.postMessage(message, windowRef.location.origin);
    });
  }
  isChannelOpenMessage(message) {
    return __awaiter25(this, void 0, void 0, function* () {
      return typeof message === "object" && message.hasOwnProperty("payload");
    });
  }
  subscribeToMessages() {
    return __awaiter25(this, void 0, void 0, function* () {
      windowRef.addEventListener("message", (message) => {
        if (message.source !== windowRef || message.origin !== windowRef.location.origin) {
          return;
        }
        if (typeof message === "object" && message) {
          const data = message.data;
          if (data.message && data.message.target === ExtensionMessageTarget.PAGE) {
            this.activeListeners.forEach((listener) => {
              listener(data.message, {
                origin: Origin.EXTENSION,
                id: data.sender.id || ""
              });
            });
          }
        }
      });
    });
  }
};

// node_modules/@taquito/beacon-wallet/node_modules/@airgap/beacon-transport-postmessage/dist/esm/PostMessageTransport.js
var __awaiter26 = function(thisArg, _arguments, P2, generator) {
  function adopt(value) {
    return value instanceof P2 ? value : new P2(function(resolve) {
      resolve(value);
    });
  }
  return new (P2 || (P2 = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var logger9 = new Logger("PostMessageTransport");
var listeningForExtensions = false;
var extensionsPromise;
var extensions;
var addExtension = (extension) => {
  if (!extensions) {
    extensions = [];
  }
  if (!extensions.some((ext) => ext.id === extension.id)) {
    extensions.push(extension);
    windowRef.postMessage("extensionsUpdated", windowRef.location.origin);
  }
};
var PostMessageTransport = class _PostMessageTransport extends Transport {
  constructor(name, keyPair, storage, storageKey) {
    super(name, new PostMessageClient(name, keyPair), new PeerManager(storage, storageKey));
    this.type = TransportType.POST_MESSAGE;
  }
  static isAvailable() {
    return __awaiter26(this, void 0, void 0, function* () {
      return new Promise((resolve) => {
        const fn2 = (event) => {
          const data = event.data;
          if (data && data.payload === "pong") {
            resolve(true);
            windowRef.removeEventListener("message", fn2);
          }
        };
        windowRef.addEventListener("message", fn2);
        const message = {
          target: ExtensionMessageTarget.EXTENSION,
          payload: "ping"
        };
        windowRef.postMessage(message, windowRef.location.origin);
      });
    });
  }
  static getAvailableExtensions() {
    return __awaiter26(this, void 0, void 0, function* () {
      if (extensionsPromise) {
        return extensionsPromise;
      }
      if (extensions) {
        return extensions;
      }
      extensions = [];
      extensionsPromise = new Promise((resolve) => {
        _PostMessageTransport.listenForExtensions();
        setTimeout(() => {
          resolve(extensions !== null && extensions !== void 0 ? extensions : []);
        }, 1e3);
      }).finally(() => {
        extensionsPromise = void 0;
      });
      return extensionsPromise;
    });
  }
  static listenForExtensions() {
    if (listeningForExtensions) {
      return;
    }
    const fn2 = (event) => {
      if (event.source !== windowRef || event.origin !== windowRef.location.origin) {
        return;
      }
      const data = event.data;
      const sender = data.sender;
      if (data && data.payload === "pong" && sender) {
        logger9.log("getAvailableExtensions", `extension "${sender.name}" is available`, sender);
        addExtension(sender);
      }
    };
    windowRef.addEventListener("message", fn2);
    const message = {
      target: ExtensionMessageTarget.EXTENSION,
      payload: "ping"
    };
    windowRef.postMessage(message, windowRef.location.origin);
    listeningForExtensions = true;
  }
  connect() {
    const _super = Object.create(null, {
      connect: { get: () => super.connect }
    });
    return __awaiter26(this, void 0, void 0, function* () {
      logger9.log("connect");
      if (this._isConnected !== TransportStatus.NOT_CONNECTED) {
        return;
      }
      this._isConnected = TransportStatus.CONNECTING;
      const knownPeers = yield this.getPeers();
      if (knownPeers.length > 0) {
        logger9.log("connect", `connecting to ${knownPeers.length} peers`);
        const connectionPromises = knownPeers.map((peer) => __awaiter26(this, void 0, void 0, function* () {
          return this.listen(peer.publicKey);
        }));
        Promise.all(connectionPromises).catch((error) => logger9.error("connect", error));
      }
      yield this.startOpenChannelListener();
      yield _super.connect.call(this);
    });
  }
  startOpenChannelListener() {
    return __awaiter26(this, void 0, void 0, function* () {
    });
  }
  getPairingRequestInfo() {
    return __awaiter26(this, void 0, void 0, function* () {
      return this.client.getPairingRequestInfo();
    });
  }
  listen(publicKey) {
    return __awaiter26(this, void 0, void 0, function* () {
      logger9.log("listen", publicKey);
      yield this.client.listenForEncryptedMessage(publicKey, (message, context2) => {
        const connectionContext = {
          origin: Origin.EXTENSION,
          id: context2.id
        };
        this.notifyListeners(message, connectionContext).catch((error) => {
          throw error;
        });
      }).catch((error) => {
        throw error;
      });
    });
  }
};
PostMessageTransport.getAvailableExtensions();

// node_modules/@taquito/beacon-wallet/node_modules/@airgap/beacon-ui/dist/esm/index.js
var import_qrcode_svg = __toESM(require_qrcode());
function __awaiter27(thisArg, _arguments, P2, generator) {
  function adopt(value) {
    return value instanceof P2 ? value : new P2(function(resolve) {
      resolve(value);
    });
  }
  return new (P2 || (P2 = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
}
var extensionList = [{
  "key": "spire_chrome",
  "id": "gpfndedineagiepkpinficbcbbgjoenn",
  "name": "Spire",
  "shortName": "Spire",
  "color": "",
  "logo": "data:image/png;base64,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",
  "link": "https://spirewallet.com/"
}, {
  "key": "temple_chrome",
  "id": "ookjlbkiijinhpmnjffcofjonbfbgaoc",
  "name": "Temple Wallet Chrome",
  "shortName": "Temple",
  "color": "",
  "logo": "data:image/png;base64,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",
  "link": "https://templewallet.com/"
}, {
  "key": "temple_firefox",
  "id": "{34ac229e-1cf5-4e4c-8a77-988155c4360f}",
  "name": "Temple Wallet Firefox",
  "shortName": "Temple",
  "color": "",
  "logo": "data:image/png;base64,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",
  "link": "https://templewallet.com/"
}];
var desktopList = [{
  "key": "infinity_wallet",
  "name": "Infinity Wallet",
  "shortName": "Infinity Wallet",
  "color": "rgb(52, 147, 218)",
  "logo": "data:image/png;base64,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",
  "deepLink": "infinity://",
  "downloadLink": "https://infinitywallet.io/download"
}, {
  "key": "galleon_desktop",
  "name": "Galleon",
  "shortName": "Galleon",
  "color": "",
  "logo": "data:image/png;base64,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",
  "deepLink": "galleon://",
  "downloadLink": "https://cryptonomic.tech/galleon.html"
}, {
  "key": "umami_desktop",
  "name": "Umami",
  "shortName": "Umami",
  "color": "",
  "logo": "data:image/png;base64,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",
  "deepLink": "umami://",
  "downloadLink": "https://umamiwallet.com/#download"
}, {
  "key": "atomex_desktop",
  "name": "Atomex Wallet",
  "shortName": "Atomex",
  "color": "",
  "logo": "data:image/png;base64,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",
  "deepLink": "atomex://",
  "downloadLink": "https://atomex.me/"
}];
var webList = [{
  "key": "kukai_web",
  "name": "Kukai Wallet",
  "shortName": "Kukai",
  "color": "",
  "logo": "data:image/png;base64,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",
  "links": {
    "mainnet": "https://wallet.kukai.app",
    "ghostnet": "https://ghostnet.kukai.app",
    "mondaynet": "https://dailynet.kukai.app",
    "delphinet": "https://testnet.kukai.app",
    "edonet": "https://edonet.kukai.app",
    "florencenet": "https://florencenet.kukai.app",
    "granadanet": "https://granadanet.kukai.app",
    "hangzhounet": "https://hangzhounet.kukai.app",
    "ithacanet": "https://ithacanet.kukai.app",
    "jakartanet": "https://jakartanet.kukai.app",
    "kathmandunet": "https://kathmandunet.kukai.app",
    "limanet": "https://limanet.kukai.app",
    "mumbainet": "https://mumbainet.kukai.app",
    "nairobinet": "https://nairobinet.kukai.app"
  }
}];
var iOSList = [{
  "key": "airgap_ios",
  "name": "AirGap Wallet",
  "shortName": "AirGap",
  "color": "rgb(4, 235, 204)",
  "logo": "data:image/png;base64,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",
  "universalLink": "https://wallet.airgap.it",
  "deepLink": "airgap-wallet://"
}, {
  "key": "plenty_wallet_ios",
  "name": "Plenty Wallet - your portal to web3 ",
  "shortName": "Plenty Wallet",
  "color": "",
  "logo": "data:image/png;base64,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",
  "universalLink": "https://www.naan.app/",
  "deepLink": "naan://"
}, {
  "key": "altme_wallet",
  "name": "Altme Wallet",
  "shortName": "Altme",
  "color": "",
  "logo": "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAQAAAAEACAYAAABccqhmAAA0IElEQVR4AezBWZOl930Y5uf3f9+z9Ol1enqmp9fZMYOVxCaSEkhKohnZsZxU5LLLuUmuU5WbfANf5xPkJhepuFK+cMVW4jiOZUXWForUapIiCS4CSIAEMAPM3vs57y9Tp1kDU6QozN6Dfp8n/olMrVbrUCpardahVbRarUOraLVah1bRarUOraLVah1aRavVOrSKVqt1aBWtVuvQKlqt1qFVtFqtQ6totVqHVtFqtQ6totVqHVpFq9U6tIpWq3VoFa1W69AqWq3WoVW0Wq1Dq2i1WodW0Wq1Dq2i1WodWkWr1Tq0ilardWgVrVbr0CpardahVbRarUOraLVah1bRarUOraLVah1aRavVOrSKVqt1aBWtVuvQKlqt1qFVtFqtQ6totVqHVtFqtQ6totVqHVpFq9U6tIpWq3VoFa1W69AqWq3WoVVrHR7hJ6UPhZ+UWodArfXxEz6UpB9Lf7P0U8KPBVLrY6jW+ngJMo1FIbpUfaJLVAgEEe5ItyUSSY7IPZotcpdMY+G2QGp9TNRaT75A2lcoXaJGRRSaiqzIiiZoChmkfYFISlIaitsaygR6JHKP3MNI62Ok1nqyBYJEJFFTL1BNIdjbYvtdtrfYCXawg100YaxOuuiii17Sx8QS3XlKYXiV4XVGNwm3BQKN1hOs1npyhTuqAdU0WbN1hVtX2UOnYWaX+RNMnqG/QGeWeoJSIWh2GW6ye52t99l4j823uXaFnZuUYLpiYkBvntEVmi2aERH2pdYTqNZ6MoWx6FImyJot7O3Q3WLhFFMrHJnj+ID5ZWZOMThKf47ugFIQjHbZ3WD7Bhvvc+M9rr/N5RtcvcnGVXZ+yPYOTU1/QNSUHXIbqfWEqrWePIFAIQbEDKNttvYQrJ3g4hc480ssn2buOJPT9Pp0etQ9qpoIY9kw2mO4y94uO9ts3eLKJS69xQ+/wzf+LT/4Hlc3qSfpdokOoxH27EutJ0yt9eQId2TSPc5Ow8Y7dJPnPsvzX+SpZ1g8w8xxugPqmlIRQRQiiHBHFKoupaYzwcQMM0dZWOHU02x9hk/8Im9+k9f/nK/+O269T6fDxCKjK4xuEW4LpNYTotZ6MgTSWPSo59jYo9Nn/RkufJJnP8+5V5k/wcQkdRcF6adk+ilRCPuqmm6f/iRTs0zNcewkaxdZXOLbf8Db32Rjg06PEuRNpNYTpNZ6okQXA4YDypATZ3jpc7z6n7P6FNPz7kgfynRPIqg6TB1hao4TJzlxmoUT/Mn/yet/SYOoiF1yD43WE6LWejKksTLPTs37b/FL/4DX/gte/SLTR+l0jTWNOyKIIMJdyySTTCKM1V2WzzD5j1m+wG//b3z197l+ibkFRh+QO0itJ0Ct9USIDvUCN/foDvjFv88v/0Oe+RSzx6hqBJlEuCPCPYtwR4SxTKIwNc/pF/hCUFV8/fe48i6DHqXQbGo9AWqtAy96xICdQjXB6lk+/xs8/0ssrFBqPyHCAxXhp9QdZo/x9Ke4+QHb1/nK9xhNoxAdcojUOsCK1sEVZFCmyVmuvMfiEq/+Kr/49zm6TKnJJBBBhIcqgghjURjM8sIv88qvMt+j2WBvjxigaB1wRevgCQSCeo5myPBdZkY8/wov/DITM5TKWAmERyoQyGR6nnOf4Vf+ByZPsufHAqF1gBWtgyftC6LPDoYdLrzG07/E6lNUHaLYFx69IIJM6i7HT/Hir3PyeQZz7O6iRtE6wIrWgRRB6dAEuxWdRV76R5x9lZl5d4THKNwxmOHMczz9KgurbO2QHaLWOsCK1oGTiD7lCJvXmEzOneTCC8weJZPRyL7wWJWCJAr9SS58muWn2Q30UNsXWgdQ0Tpwwm0VWbM9YnaNpz7NidNMTBmLcKAESsXSGdbOcHSG3KYZotI6oIrWgRMdBMMdsmFhnTOvMr1A3TEWQYQDIQJhbO44a2dZO0fTMELpaR1QRevAKQMaDC8zvcfyMVZOU9c0SSYRDo4gwlh/kqVnOfcF9qbYm6BMk4FAaB0gRevgqRgWdjosv8LaJzm6RKkIB1QiiWDuOKefYaZPhSYJrYOoaB0cQdTkiNGI7LD6CZYvMjlLFAQRDrSpWVbPsXqO/iS7u8QEKq0DpmgdGFGIHs0uduj2WLvAwip1l0xjEQ6eIMJYf5LFk1z8LNPH2NqiOkJ0yURoHRBF6+AoRI+9hk6HlSXWzjJ3lEwyHWxBJlHoT3HuJWaW2a6IAVFrHTBF62AIBFnYTSYWOPMKJ04zmDEW4YnR6bFyjpVVZnvsXSNRekitA6JoHQxBBs0eo2RqiXOvcWSZTt9YBBEOvAiqmoVlTp1lZZHND2gqygSpdVAUrYOhMtbcpDPk6DynnqE/QEM2RDjwIoyViokZ1l5m7bNcqdmbpJq0LxBaj1nROhCi0BS2GxZOs/4cSyfp9BBEeKJkUgrH1lh/iumKMqJB6SKQWo9Z0ToYCk3FFhYvsv4cswvUtX3hiTR3lLWzrK1Tgp09qimi0joAitaBEBVZsYOli6xcoNMj7YvwRBrMsvwUz/0a1YCNHeoFdEi3hdZjVLQeuyiMdqg2WcLJVY4teaKFfaVi+ggXXmHyKMNATQThttR6jIrW41WICfZQJjjzMivnmZ43FuGJFsHENCcvsrTCZJft6+gSPa3HrGg9HoFAoUyx26U6wdP/kGNP0Z8kEUGEJ0+Qaazb48Q6Z86xMMuNdzBBmSLdFlqPSdF6vIIslGB2hgsvMX2ETDJ9LFQdpuY48yqLL3A1GE1QulqPWdF6PJKoiS7bG8zMs36R1XNMTBoLT7YIMglUXZbOsHKKySQ3aEaUCYTWY1K0HotE9DBgc4Ojq5x9kflFOj0ifGykffMnWDvF6jFyi+GQahqh9ZgUrUcvjEUXU2wUFs5x5pN0J4hCJhE+VqbmWH2WC7/G7oCtinoGFQKh9YgVrceidGn2yGssNKydYHGdKD62Oj3mlzn/MoMpmhGjEVEhkFqPWNF6LKoBw2Bvl/WzrJ3lyHEiiCDCx0KEsUxKxfQ8Jy9yfIluzc4G0Sc6Wo9B0Xp0AoGgmmW3z/Yk5/9Lll9iMO1jKZANmUxMsnyKsxeZmWLjGmWG6JNuC61HqGg9Ookk0CAw2ef008wdQ5DpYymCQKfH7HFOv8zcKTaDrCiFcFtqPUJF65GKLtUMO5v0u6ydY/UcU7M+vgJBIgq9SVYvsLhMf8TwBk1S+lqPWNF6NIJE9KkWuHWLyVkuvsLiOhOTPtYi3FEKi2usrrDQZ/cKI5QpMrQeoaL1SEWFPhuFqTXO/wKTc5TaWPgYSyRRmFtg/SXWPs/2gL2a6BJaj1LReviCTMoEiZ33mNllZYGV83T6RCARPr4CYaw74NgpTr5Ap0ezS7NL9FC0HpGi9XCFO6pJRhUbH7B0lJOnOLZMXZNJ+niLMJYoNfOLnLzAkSNEw+4OZUDUWo9I0XpkqkmGk1zpsPpFTn6GqVlKcahkg2R6jtWznHyK/oCdITFJVFqPSNF6uBJB6dI0GDKoOHmBY+uUmgwC4SFKMskkk0wyySSTTDLJJBPpoYkg0BuwsMq5TzG1zG5DjhAIrUegaD10UVHNsLNLSVbWWTvH3AIRSNJt4cFKMpHuSSaZSA9MBBEkSs3kEU5/gqPHqUYMN8kgaq1HoGg9PGEsOtRH2dyi6vDMZ1g5w9SssUwPXCaZZJJBBhFE+BsFIoggw1gmmUgPTATZkEm3x+p5lo4xjd1rZCF6Wo9ArfXwpH2Bip3CsWNc+DRzJ6h7xiI8GEmmfUEUwocyGe0x3GU0pGmMRVAVqi51h1ITbgsijGWiQRDh/gUR1B0Wllh/lb/6Lt/+YzqFklqPQK31UJU+0WX7ChM7LM5x8mkGM5RCprEI9yXTvkASGA3Z3WLzJpu32LzFxjU2rrB9k+E2iaqm02cwz+QckzMMppmYoj9Jr29fGMsk3BbuWYR9wcQUyxdZfpZv/QnNHgI1Rkith6TWejiCTGJA9rj1HsemOLXE0km6PTLJpBT3JROJMDYasrvNratceYf3fsDld/ngMtfe4+a7bH3A3oaxqkNniqklZo4zd4yFRRZXWFjh6DK9AXWXqiYbMgj3LoJMY1WH4+usnafXxx5NoIMGqfWQ1FoPTaB02O1xDc++xpkvMHeMTtcDkUkmEUSwu8PV9/j+N/nen/GdP+L7r3P5GreGVCM6Q+oR0RBuC0aFnZphRamZqVhf58zznH+NM89z4hSzR4lCNjRJCYT7duQ4a2dZW+eDtxju0q1oQushqrUejqD0aUY0G/SS5TMsnafTQxiLcM8yyTQ23OX9H/H9r/KNf833fsR777L5DntDSsXUBFVDNaI0hA9l0KkYFRLNLu+8wdXLfOM7nDvOUy9z4e+wfJqJGaqaTGMR7lrYl8lgisXTPPUaf/rv2HyHbkFoPUS11sMRlCn2hjQjji+yeoaFJaLQJIFwbzLJpBmxu817b/KNr/DV3+bb/5JL2KuZSAbTTPQpFRpyiMZYprEIokZFYlTY2eD9S2y+z5Ut3nmdd2/y4mdZv8iRJeoOgUwi3J0gkKi7HFniqV/kW3/K1R+RjX2B1HoIaq0HK+wrlEm2b1B6nP9F1i4yu2Bf2lfctUyyIQp7O1z6Ab/7L/i9/4vv/gUzI2bW6E1jh9E1RlfZ2yX97aJQ+kzMMnkMXW59n69/nb94k7e/xef+K176AnPHEcYyiXDXmoZSmJjm7AscneXSiGabkqTWw1JrPViJQtQ0Q0Yj+nOcfZGFVboTJCLck0wyicLNK3zrS/zR/8GffZkbVzh2jG5SbrF3HSNyD0Nj4SNoyG2GI+ImUeh1qRYZ1rz+J2xf5r2v87n/lmNr9CbtS4SPLijFWK/P4jqnf4FL7/Lu6wz6xJDc1XoIaq0HLjpEj91N6oajRzj9LDMLlJpMAhHuSiaZNA3DHV7/Cl/+v/nKb3HtFr3CREWMGG2SOyTCj4WPLEcYkdvGqhm6FXXDxjZ/9ZdsXaM/x4t/l7WL1D37EuGuVTVTc5z6BG98kzdfp9+lRu5qPQS11gOVKF0M2L7MzCTrS6ydZzCNJBuiuCuZZBLY2+b9H/Kl3+Qr/54fvcuJJaotRldpdog0FoG0L92dcMfwBnGL0uPIMjdu8cYb7P7PTEwze4z5ZdK+8NFFkImg1KxeYPEMo4IORgj7UusBKloPVLgtaAqbmL3Imc+xsEKvbyzCXclEEkEz5NIP+P1/xZ9/hes3WVwkrjC6Su4S/hPp3iUSSQSSZofdHzJRmFzgjXf48u/ytT9kuIMkgkz3bGGZ9TWWB7jJcIeotB6CovVARY9MRjeoGo6vsfYs/QFRGYsgwt0JIrhyidf/lD/4TW5copN09sgtcheNh6uh2cYt6h3607z+Df7od3j7O2xvGotwV8KHpuZYfoqzn2LUZ6+mTCG0HrCi9eAE0adJRreYGbC8ztIpSk0mmUT4yDLdMdrj7W/zl/8f3/gSZcigYnSdHNoXSA9eIhHGRjdxjflZPvghX/tDvvpbXH+PZuTuBREkun2OneX8F4hZhl3KAIFAaD0gReuBig7DimGflU+w/ixHl4jinmQaa4bcusZ3vsx3/4gO6ppIRltIJNLDlQhjzZDRVWZ3aL7F7/6P/PBr7GwZy3T3GiSzRzn7PLMDKjRaD0PRejCCqMkRoxHRY/05jp+mP2ksgggfWSYRBHZ3+OH3eP3r/Ohd5pYoOzQ3iQbp0UkEGkY36A0YTvHtK3zvu3zwjnsWgWBimuUznHuJmXk2b1FmiR4SofUAFK0Ho6BDs0vsMehy8mmOLlN1yTQW4SPJNBZBJlu3ePNb/PD73Npg8gh2abY8Pg3NNqWQXW4mb36Ld9+kGbkvnR5HFjn/CjMn2NihzBBdUutBKVoPRBSix94unV2O9zh5ltmjSLJx1zKNDfe4eYU3vsqt96mDqiDJRHj0Ekmg2aLeZLbh7b/g7W+yt40kk0wfXZBJBL0BZ15k7iRbBT2iQiAQWvepaD0YYWwHk2c4//dYPMvEFIFS3JUIIoztbHHlLb7/OwzfZmLI8CY5tC89VrlFDOnP8v6bvPs6199nNHRfSsXSOqcXWNlj722aIdUEmUit+1S07l8xlkOaZG6FM59meoG6Q7otiHBPtjf44D1+9DZD9HqMrmNIePxyZKwecGOD9y9z7QNGI2OZ7kogUCrmjnHyadafZXOPYYcyidR6AIrWfYsgMdqjU7GwxKln6A1IZBLhI8skkwhjW5tcucblhuEsnWmam+TQ4xckIig128H1Ta5fZjQ0FuGeRNCfZPllTv0aWxMMJygDBAKhdR+K1v2raILdPY6tsvYUJ9bodIhw34a7bG6wmTQVpSIbB0sSQ0rDzi2uvMdoiEC4O4EgE8H8IifPM1tThjQjSo1Aat2HonXfoqap2cbys6w9w9QRojIW4d4lu9tsb5ANEQgy7QuPXbgtMaLCcJtb12iGBML9mZpj5RznX6LbZ2ub+ijR0bpPRev+VWRFBqvPsHSeTt8dEe5ZNuztsLNJSSIdTEk2lKTZY3uTpkHal+5Zf8DxNZ55jYlZNneo54mOfaF1j4rWvQtjzS7VLrPB+mkWljwwmQyHDHcpSSTSwZE+lMYyaYZoPBBVh6l5zr/C4Dg7BR2iaN2nonXvCmWa7aA+wsUvsnKBqTljEYT7E4W6pu4yCjIcLOFDYSyCUiHclwgyjXX7LJ3i1ArHam6+RXYpU2QitO5B0bon6baKMsVeoXuUp3+Zo2t0J8gk3BbuSwSdLt0+TZCBcPAEETRBqen2iYJw3zKpOxw9wemLLK5x7QpNjzLQug9F6+4FEShkl1HN5DwXXmVyzlgmwv0LOj16kwgyjYWDI90WqBih6jE5S6lJpNvCfalqpuY4+SonXuUqhj2ii9C6R0Xr7iXRQcX2JY5OcuYMK2foD4xFeGA6XQYDBkEZ0YyIQCIdDIXo0hQ6k8weo6qRSPcsgggyESyssLbOUbfdYLRHNY2idQ+K1t0JY9HHgBs7HDvDmU8wt0DdIYII9yzCT+hNMDfLfKG6xWiDMonKgRBuS5qkg6kBc8eoKmOZ7kumfcHcUVbPcfZ5BDtDqhlUWvegaH10gSCD6JIDtoITz3DqJboDoiLdvwgyjfUnmV9gcY56m90NqiNEh3QAFDIZbTPV4egccwtUtbEID8xghuVzPPOrxCTbSRkQBYHQugtF66NLJCVoRthhHmsrnFizLz0QmWQa6w9YOMnpX6GzymZNNU3U9oXHJpPSJyu2rnB0jaXzzC1Q1R64usvcIudfZjBL09AMiRoFqXUXitbdCaoj7AbD5NynWHuamaPGIggPRoSxusv0UU59kokF9twWRBBuS49eIIyVAaMB1xuWnmH5Ar1JohBBhPsSYSwbAoNp1p5ibZ2pLptXMaD07Qutj6hofTSBQKHMsFfIDhc/z4nz9Cc9UBHGMikVgxnWn2ZhiW6HnQ1UlK7HJ4gOWSEohZPPsHyWuoPwwAQSid4EJ9Y5fZG5BW7dRJ/okVp3o2jdlQjUNIXuFE+9zJFFSuWBiyCTTLo91s5x7gyLk1z/ATmgzJJuKwiPRthXqKYYbVBf5WRw7hzHV+1LD04QCHS6zB3j9KvMP8VGMKoQhNtS6yMqWn+7QBI9yiybl5npcP4cK6cZTBvL9MBFGKs6zB7j4mc580tsNOwVdCg9HwoPVxhLRIfucW50KSf53H/P6gv0p41FeKAiSCSiYvEky0vMjBhdotmjTCG0PqKi9ZEkSo8yw60tZhZ46kWOLtHre2gijEXQm+DUCzz9WZYuMAp2kmoWBenhCmOJakCZYWOX/hFOvcQrv8HCOnXHwxH2JREsLLF6lhPrDPcYokwgtD6iovWRRBAd9LlVmD3LuU8xeYSq46HLNHZ8lec+xWt/n6rHxh7VEUoPBYnw4IV9gYpqDke49DanTvGZX+GpFxlMG8v0cKQ7Zo+y+iynfpHRFHs1OkRofURF62+XlAkyGF5nfsTKAidOUVXGMonwUEQQQdNQ1Zw4xed+g0++yGyP99+hHKeeM5aJQHgwColMVEyss4vNt1nt8MpneP6z1H2ikEmEhyICQZN0eiyscvp5+hM0uzS7RI+otD6CovWRVFPsVWxssvo0J5/hyCJRkemhiyAQhcE0J5/h07/Oc59iUHFri90u9VFKD8W9C4Q7MomKeobOMTZ2aW5ybIrP/dc8/8scX6cUYxEenrAvicLsUU5e4PgJOhW728QEaq2PoNb6+YJETDAcsjnk9KdYfZ6pWUqQHo0IElWHqTle/DWM2LzEN77Hbk01IBrsYEgOkT6UPpqwrxAdShfTDGfYucziLC+8zK/+dyydZ2KKTCI8EtkQFZMzrJzm5HluvMu1y/RmiC1S629Ta/2tSiGTpqHusP40x1aoagTSoxFIY4mZBT75a8wtM/8v+PIf8NZbrMzSnSN2GX5As0s27gg/XyaSqKmm6J5guMeVm1x7m0++wOd+nV/4uyw9RadPpkcmUAqB3gQLq5z5DN//Ae9dpmmIIArZaP0ctdbPFkiiSz3H1gbdLivnWTvL9DyCTGMRHokIMglEYXqBMy9SOsyf4mt/yNt/xNUNomHQUB0hCobkECM0ZGNfEAWFqFETNc0uOyOuXqLfsLTKp17l5de4+BInztPtI4xFeDSCQKax7oD1pzm+yPeHjG5QBTrY0fo5aq2fKzpUR9h8m/kjXHiREycZTBvLJMIjFUGmsbrD7ALPfIa5RRZP8OWGt9/j5iVik92CmkAkkUQi7AuaICuyImt0KHvUHWYWODHH05/ipX/AmWeZOUrdJdNYhEcryAZB3WH5NMunmZ1n8woxoOqQO1o/R631c0Uh+mwUlk5w/jMcWabbNxYIj14EmfYF3QlOPcvSaZ57jW9+ha/9G772z7l8mW3U6KODGsW+RIM97GAHeziGcxd46b/huU+z/jRHl4xlkmkswmMRYayqWVhm/RMsfYJv/j5VUIXW36LW+pkyqSbJis03mN1kdY7Vc/R6ZBqLQHgsItyRSQSdHsdW6P8KJ8/xyn/Gjy7x/rtce4+bl9i6ys51RteNlR7VDL0ZphaYWWTuBCcWWVpn+VmmjzCYNpZJhMcugkQmnR4nTrP+LH/5JUZDFKImR0itn6HW+htFn1HNjfdYWufkBY6vUveMZRLFgRBhrFT0p+hPcWSR5Yuc/YDr73P9Mjcus3GVrWvsXTdWenRnmZhl+iizx5g7xuwCU3NMTPkJ4YAIJJmUwsIK6+eYrhhtM6ooNRqk1s9Qa/20MFa67NbcwCdf4uTLzC1Q18YiHDxJIoK6w/QRpo+weo5MmiF7Owx3Ge4ZK4W6S6dH1aFUfkqmsXBbOFAiEMwdZe0UK7O8s83ekF4fe6TWz1Jr/bSg6tOMaIZ0sHqWE2fo9BEOriB8KNNYBBGUmm6h00faF0QQQYSxTHdEEOFACreFsd4Ux5/i6X/MtX/NrTfpd8gdjLR+hqL1U6KiTLE3xIjlddbOcvQEUcg0FuHAiyDCHRFEoVSUmlJTKqIgEMYCgQgHWxDIpBSm5jn3GWaOG0utn6dofSgQKJQJdkaUmvMvsHKWmSOeeJk+lP5mgfBkCKSx/oBTT3N8hYkBoyEZKAitv6ZofSiRxppkN+nMc+GzHD9Ff8pYeHJFEEEEUYgggggiPLEijHX7nFjj7Cc5foaNDZqa6CC1/pqi9ROijz67V+ltsTjN6eeYnEPQNAgiPDmSbMiGpqFpaBqahqahaWgamoamIZNMT5QI+4LugLVnOXGRjST7RI90W2j9J4rWT4gOemxvMj3L6llWzzIxaV96ImSSSSbp3mSSSaYnRqCqWTrDyhm6bmvIhgitv6bW+klBFjZx5jnOvMaxFTo9d4SDLZNMMo2VQhRjkaSfLdwWxhLZkEm4rRDhibGwxPoKS4WtG4yCqpCN1n+i1toXRI8cMbpO1XB8leVzdPooxkpBOHiSRCYRRBBhLIJmyN4uu1vs7TIckiMEpVDVdHp0e3R6REUUIo1lkkkgigMpAmFsYpql53n2n/DH/y87N5geMLyKIQLp0Ku17ogewyHNiLkFVs6wuE6paRr7woGTaV8SYWy4y84WmzfZuMHGNW5d49YHbL3PznVGu0RQ9ejMMJhnap6peSbnmJxhMM3EJFGIMJZpLMKBVXeYX+Hi5/nan7G1RfQRCK0fq7X2BWqGDdll5Tyr5zi66I5MIhwomWQay6TZY2+HG+/z/o94903efYv33+Hau9y6xOb32XmXvW0C1STdY0yuMn2CIydYWGVxhRNrLJ5iYpbegLom0x0RDpxMIpia48wLzC9w631GSVTkCKl1W61FEIUcMRzRmebsp1l6iolZEhEOnGyMlWJs4xqXf8ib3+SNv+DNv+Ctr3Fjj509ckg1pOxi6ENb5I9oLpMd1HQ7HOlwYp3Tn+f8S5x6hqWTVD1KMdY0RBDhwAj7+gNOrPPUK9z8gMtvMDVLbDC6RQTSoVZriYIOzQ7VkOkJTj/DkUVKIRsiiHAgZNoXNCN2Nnjv+3z3D/j2l3nzHa6/w6132b7MaJLSJWrqQukgiTSWQaIpNEHTsHeLK9tsXOWdG/zVn3Lyac69zKnnOb7G1BwRxjKJcDCEsapmcpazL/JX3+KvvsvUJLGn9WO1FgUdhhv0JjixwtpTTM3ZlwgHQqaxTIa7XL/MO9/jq1/iG/+GN77MB6iDHro1Ez2iSxSiIRMN0r5AoLIvaQp7DVs7XHud9/6St77K97/FM5/h6U9z6jlmjlIqojhwotDpsf40x9eM5YgIosbIoVdrEShsB/OnOft5ls4wmCLcFoTHLxsiEASuXeI//gf+4F/y519i7wP6wfwMVYdw2w65QXONTHek25LwY+GOCKJHp09nhqnC6Bobl/jqv+cb/4EX/g6v/SNe+SLT89QVmYQfC49VprEoLK5y8hjLe+z9EH2qCYa3CIdb7bALBIkh5pY4/Rz9KRQyiUB4bDKNRSDYuM6Pvscf/K9840u8/Tb1Ht1J6oayQ24hyRGGZCLdEf6adEcGdjDCFhlE0ulTVWTy3a9y4xbvfIcXv8jp55maI/1YEuGxi2BqjvWXOf/3+Mrv0+sz3WN4y6FXO+wKmTR7TFQsLrF6nm7fWCLCY5PpQ8H19/ne1/ijf8PXfpNLbzHqMVFT3NaQu+SQTPcmyRFG7ogOVaFCBltXeePrbH7A1gdsXeKZL9Cfoqo9dhFkGuv0WDzPmdf4yp8yKugQBQ3SoVU75KIwSoZbHDvC2ionTlLVhMcvkwhjw13+6uv87r/gX/1PzCaDKQZTjD6g2fXQ5B65ZyyCySOMuvzgm1z/Gle+wcwyKxeYnCMKmUR4bCLIJIK5Y5y6yNwkWxuMRpQOzS7SoVU955/+U4dRGCuT7FZsBc9+kU/+XU6/QKlQCLeFRy7TWASBzRt884/5t/8Lf/bb9GomJqgaRjcxRHo0ghxiyMQco4Ybl/nBHzO3wvQxJiaNhR8Lj00EpZDJ5be4fomb1xgskLvkHsKhVBxG4UMFhbrm5CdYPEvdsS8RHr10RwTX3uebf8z/8894/U/Yvk6/oozIXewhPVI5JHco25Qum7u8/qf84T/ja7/FzSs0IxLp8ev0OHKci7/A5HE2h5RJonaoFYdR2lcxaqgq5o6w/hTzi8YyPTbpQztbvPGX/OG/5vf/FdcvMzlBbNPcInfsS49OItCwd50K9QS7hT/+Tb78z3njT9i6SdMYy/RYlYrBDGc+yfwSidEQhagdWsUhFRXVNLu79Ke48BmWzzE1ayyC8OhlIhCMhrz1Or/3v/M7/5zpKSa72GJ4AyP70qPX/P/twWuTXHedGODn9z/dM9Nz0YzutmVZtnzZGLCXZNnKLknVVpIPkMonCp8hb/dFUpW8yyabVEEBSbGAASdgfMEXWb5Jsu7WXXPt6e5zfpnqARFSC5gsbtnd53nQUAr1JvosHWU4xzs/5Fv/lstvs7ttLJNMExdBprFOl+MneeoojzZsnaepKCtkIsycYlZ1iGV2KxaO8id/ydoxqi6ZhD3hodnd5vo5Xvr3fPASMaQT2KHeQiKRHp5EoiYH5AZzy2wl73/IT7/NxTOMBvYlmR6KTEqH1cOc+iec+Br3akbzlAW/FmZKMWsCQQaJwMHDPPOPWVylFPvCQ9OMuHOVMz/i1W9x6zxLPWKHZpscEOHzoSHsGVFvUtkzz/2an32Pd/4Xt68i7Uukh6IEC4uceIHHv8aoorGnIroIpJnSMWuS6JANg1usDXn8ACefZn4BgTRxmcYi2N3i/Ov83X/ik5vEHAtz9G8QDSXI2udHIohgdIfuATqrvPsLlo+x9giHH6M7jySTCBMT9iWi4shjPPEUh4LYop6js0y9QTZmSjFLgkRZJle5O+TRf8bT/5KVw3S6xiJMVhJB2JN88AavvMS779I5yFzF4AaRSLLx+ZNIIsldYpO1Ba68yU/+hvdeZeMuiUwyTU6Qfm15jRPP8fy/IJbYGlGtoWNfmBnFjAnEHDnPsOHEC5z8U+Z6RPFQpD3JcMCda7z6fc68wmBINSJ2abbRIJE+n9K+IblDb46t23z0Kq9+i+sfMdxFGMv0UCwscvQkz32d+VUGNbqoEGZKMUuSKDT2LS5w4jTHThrLJNPEZdIkm/d4/zVe+S6Xz3L0MHmb+j4RaJA+97LGgIJOYesW//s/c+51Nu9SCplkmpgID1RdDhzhma9y4JCx0YCoiAppZhSzIOzr0DnC7gBDvvJ1nvgTDhzycCSZlGDY59r7/OA/sPkxCwNynaztS18o2dDcZ65LWeLcFd76OefPoKEEEWSaqKYhk/lFHn+aJ59gbY7NT9CjLJL2hJlQzIpAoaywW7DI83/JsZPMLxiLIMLEpF8Kbl3lvTf4xc8YDJjrUG+gsS99sSTNkGioktLnw5d55/vcuspwYCzTxER4YG6OI4/y5IscforNAdkluoQ9aSYUs6IQHTJpkt4Bnv0aq8coHQ9NJsNdPn6bMz/h+lXqpFPR7KDxxRRk0gwoA1bnuf4uZ37MR2+zvUEmEWSamAhjpcPSKk+8yPHnGCb1iEyigzATimkXZBLzlEV2rrB2n6d7PPEsiyvGMk1U05CoR9y5zplv8/43OVjT2aTZIuxJpC+eJILsk0PmH2O4yJXrvPY97lyjHhLIJNNERJBJJlE49gQnHme1ob5JPaCsIMyEYkaUBRzgTrL6FZ79Vxw6TnfexGUSQWB3m/de46Pz3N1lfplAjnzxJRoMyW168+ys8/r3OP8O67cRhIfn4DFOPs+TX6NZZFCIBSLMhGIGREV0yA7D4MjzPPV1egeoOiYqk0wiGA24e523v8f1C9RBmSPsSVMja+p1FubImotn+fAX3LhMPUIYyzQREcYSSwd49BlO/1OqFUZ+qUKYesUMKHMkmj7LyYnHeOw0pSKRCJOTDZls3efyGd76b2x9wFJihMb0CDTUW5RCmWNY89EbXH6PwQ7SRAUiyKQzz6HHePqrLCzTDKn7RJeoTL1iBlRr7AbbWzzz5zz5AmtHEUgkwsSUisCtq7z/Jrd3GfXo9Mg+2ZgeiSTQ3Kc74OARzr3Fuz/j+seMhkQYy/TZC2PZIFla4dQznDzOUofdHaJHdE29YtoFscAoGOHpP+OxZ+ktE2GiMj2ws8XVM3z4I3a3iQ6lwghpKtU7lBGLy6zf5eL7nHubnS2ahggTFfb1ljh+ilMvsvIIuzVZUBCmWjHFIigV2ZCYX+LJFzhygs6cicskk2y4d4OLr3Phx1S7dOxJskGaPkGOUFOCUnHzCmd/ysZt6iGZZJLpMxdBhLHuPGvHeeovOHiaYdKMjEUx1YppFKQ9C1RH2bnDwjZPHeHxUyytGmsaYxE+c5lEEEHTcO0Cl65xu6GzQgmaXdMrCTR96tusLrN9izMvce0CO5tEEEGEiYhCJk1SdTn5HI88ynzNaJ2mwZypVkyx6BDLbNX0jvPsX3DsJAuLSAJhAhJprKnpb3DpLDev0KCapyCHpl6OqLeYW2CYXL/BxQ9Yv0MmEWSauFI4eoLH/xHHnqYO6kBlqhVTKipUNMkQqyd5+uusHqM7T9oTJiKRaWw04P4tLr7J3Ut0g6qgQW26BWpyQAkUdnY4/zq3r1CPPJBpIiKIIAqrh3n8eU5+lXqeUSAQplYxhTIpPVQMb7I04JEjnHyOuZ4HIhAmIu3rb3PjEhdfZfMCC4khGtMvjWVSbzLfp7fBR/+Ta2/T30CaqAhj2dCZ59gpnnyRmCNroiEKwlQqplTpUXfY6HP8eU69yJFH6XTsS5ORxkohsL3B5Y+4ucHuPN01coccmBmR1Ot0KrpHuHiHS1e4e5NEBBEmLrB2lFOnOdqlO2Q0QIUwlYppE0RBRR30a058mce/xMohSmWi0p4kgtGQezf4+G22tsg5qkVyQI7MlOxTCtUSG7tcv8KNS2SNNFGBCBLLazx2mlPPs7DKoCG6RJhKxbQJoksmdU1UnHiOR04zv4hiX5iITNK+nU1uXuDcz2k2mAtKkmZP2lMTIzq4fZkrHzAakmks02QEEQjmFzlymuf+NUtPs1sRC6hMpWLKRIdqjcEO1Q5PHOLkKdYOG8vGWITPXhKBMLZ+h2vnufQuUdNFvY3GbEkCzQ65zlqPu2f48O+4d4PhrskLskGy0OPpFzl0lIKmkH4pTJVi2hTKAv2GzjKn/4xHT7O8ZuLSvkA23LnOtUvcXqf0qCqabTRmUg7Qp7fC+g4fX+TaBfrbHqruPCdO8/gzrB1jd4esiC7SVCmmSUHQ1AyThWM881ccOcXCIpkmKtO+ZDTgkwtcv8gAZYlSkTtIsyfIhmZEZ5GdLp9sceEsW+tkEmGiIox1uhw+zpNf5tGn2dqk6RBzpk4xRWIeXQY3mNvhyCqnv8LiAQSZRBBhokZD7t/m41e49RYrKCOyJu0JsytpdlgY4h7v/5T7N2hG9qWJiTCW6Mxz4nlOvMBGUPeIBdKeMDWKKRIdssv2iLUTPPElTpxmoWdfEmEiMolAMBxw+xqXLnJ3nZXDxC7ZJ+xJsyeRGNHcZT4w4r2fcP0c2xt+LU1UIApHH+fkkxxE1acZEJWpUkyLgkJT6OPw0zzxAoceoTtnLMJEZNoXSHa3uXaBT26wVbNwEAOyr9VQb9KtSFz8gKvnuH/LWCJNTtgTxlYP8/hTPHmKKhkOKQsIU6OYBkF0yIZ6QJ0cfZLHnqO3TFT2hYnJJNDUbN3n4zPcv09WdOYwImuE2RYkotBUbODyJW5e9XAEEcYWlzn+HF/6N8RR+l06h4iOfeELr5gGQcyRNbZZSo4d5dAxBJlIIkxMhLH+Fjc+4t3/TnOJxSH1JlmTiTTbkkDTp2yxmtx4m8tvs7tFNkSQaaIyESyu8uQLVCsMK2IeBWEqFNOiQ51I1tY4dJyVg/YlaXIiPLC1zvVLnHuPuqE3R32fHBFav5K7lAErS9z4mEtnuX+bekSmhyOY73H8CRYXCTTp19IXXjENAkETxAIHT7F2nN6yfWFiMskkAsn6Ha5e42pDfZjuCvVdjLR+Jcghkcwf4tZtLp3nxhWGA2Pp4ejOsXaU1TkWRtS7xsJ0KKZIg5ynd5LeYeYWPBBhojIZ7nL9AlfOMl9T1RiR9oTWr6R9SQyJ5P4dzr1NfxtBhIeidOitsNih26e5iwodU6GYImlPobNEd4GqMhZh4pqa9Tt8/BaX3mJ5hc6QepuwJ7X+XzW5RXfE1kXOfoc7lxj2jWWSaaKiUHWoglKTfQSKqVBMm6QZ0dRkGss0caMB1z/m/FtcP8fKGmVIs6n1W2RNs8V80r/O+z/g8rts3kXSpMlLmppMMogKiTQViilSkAO2rrB1m92+BzJ95jKJQLKzybs/5epFRkGni5ocIbT+Pkk2dBYZ9bg55L23+OQSEUQYyzQxzYjdLXZqRj3KITQYmQrFNEg0VIkdbn3E7cts3rcvfeYyyTS2foeP3uSV73LvBsvL1DfIvn2p9TvkiKqm9HnnO5x9iVtXyZpMMk1EJoNdbl/n3i79DlUPSaapUEyDJIdUQQT3b3H9Arevko0HMv3RZZLpgd1tLp/htW9y4VUG9+l1qO+RA61PIQdUDXPBlbc582M++Dk7GzQ1kkykz0SmsWzYus+Fd9jcIJNIpH3hC6+YBknuULpUq+wGFz/i0vvUQyIINDXSH1UmmcYiuPsJb36bH/478jbdPrlJk1qfVk2p6Kwy6vDBG7z8X7h1mdGAKDQ1TUOmP6pMMomgGXH3Gm9+n/oWC0PqLbI2Naqv+MY3TIuKCDrJzn3qEYceZ2mV+QUiSGR6IMKnl6TfFEEE/W1uXOCl/8ir3+HGJ3RXiYamT6R9qfUpZGJEZ4nBkPW77G4zv8TKQeZ7lLAvkR6I8AfJ9BsiiOD8GV75H/zob8mGDnITNdJUqL7iG98wJSIJdLr019ndZNind4D5JeYWiEKEByL8f8ukGXH/Fudf55W/5eff5toF6kKnYIChfan1aSUaqi5N0u9z7yZ1H0nvAJ0uVce+MBbhH6Sp6W9x9SNe+TavfZdr7zEXVDXZJ9LU6JgiOSIQc8wV7p3nh39N3dDf4bmvsnSQzhxVRRQkwu+WxhKZZENTM9hl6y4f/ILXvsnLf81OobNIb5H6Dmr7UusP1ZAbdFdoKi6fZesGN8/T3+WZP+XQo8z1KBWloBD2hN8vSWRDNtQ12+t8coHXvs/Lf8PFN1iZJ7ZRE6ZLx5TJmtwg5uks0PT58X/l3Bme/3Oe/+c8+hQHj7K0SqdLFL9bGhsNGeywuc7dG1z9kLMv897rfPIhNRYWCTR3USO1/gEyyS1iyOoBBtu882MuvMeX/4pn/5wnv8zBYyyv0luiO4/w+yXDAf0tNu9z4zIf/pyzL/PeL9i9w3yXUpMNmaZOx7RJ1BiiEIXBOlfPsHWTc+9x9AhHj3HkNAsH6MwTfrtMmobdTTZvcusyt+9w5yb3znH/NsMd5uYoNWpyqPXHUpMDSiEaRgPuXuLtH3DpQ9Ye5cgKhx9j9VEWD1J1/G5J3bBzj/VPuH2JT+5y+2PuXWRrk86QqiFrpKnUMa2GKJSKXpfRFtfvcO5DesnaMgefpXeQzjwl/L0SiWbE7jqbN7hzhc0BdbLYMDdPr0OgGaDW+mOrabao5ul0SNy9yLWPGQUHGlaPc+AEi0eoOkT4rTKpa3busHGNu5fZKFQNi0Fv0b4R2ZhaHdOsIZPcoOqytMjyMs2Qfp+Lb1AHTfi9AqWhg84KB5eJJLfIXXKHtCe1PkM5IAcIej16Pcxhl4173LlJXUi/X6Bq6HTornKkSwzJbXITDdJU65h2aSxHBLImGkrSnaNbyPCpRE2piW0EmRihRmpNQtqX2EWNCjVVEF2aDhH2pd8uiZrSEFsoZIMRGqSp1zErGnJADgiUiqpLFITfL8kw1uySDYnQelhyhBGJQJmjqlAIvxR+q0w0aMhd0uzpmDERSLImN0l/mLAnEIQ9qfWQRSDJATkgfXrh/xL2pZnRMWvSbwh7wqeT9qXW50n6DRE+vfRraeYUrVZrZnW0SK1pklqfUtFqtWZW0Wq1ZlbRarVmVtFqtWZW0Wq1ZlbRarVmVtFqtWZW0Wq1ZlbRarVmVtFqtWZW0Wq1ZlbRarVmVtFqtWZW0Wq1ZlbRarVmVtFqtWZW0Wq1ZlbRarVmVtFqtWZW0Wq1ZlbRarVmVtFqtWZW0Wq1ZlbRarVmVtFqtWZW0Wq1ZlbRarVmVtFqtWZW0Wq1ZlbRarVmVtFqtWZW0Wq1ZlbRarVmVtFqtWZW0Wq1ZlbRarVmVtFqtWZW0Wq1ZlbRarVmVtFqtWZW0Wq1Ztb/AVsUdTNabiCPAAAAAElFTkSuQmCC",
  "universalLink": "https://app.altme.io/app/download"
}, {
  "key": "autonomy-app",
  "name": "Autonomy: Digital Art Wallet",
  "shortName": "Autonomy",
  "color": "",
  "logo": "data:image/png;base64,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",
  "universalLink": "https://autonomy.io/apps/tezos",
  "deepLink": "autonomy-tezos://"
}, {
  "key": "temple_ios",
  "name": "Temple Wallet",
  "shortName": "Temple",
  "color": "",
  "logo": "data:image/png;base64,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",
  "universalLink": "https://templewallet.com",
  "deepLink": "temple://"
}, {
  "key": "atomex_ios",
  "name": "Atomex Wallet",
  "shortName": "Atomex",
  "color": "",
  "logo": "data:image/png;base64,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",
  "universalLink": "https://atomex.me",
  "deepLink": "atomex://"
}, {
  "key": "umami_ios",
  "name": "Umami Mobile",
  "shortName": "Umami Mobile",
  "color": "",
  "logo": "data:image/png;base64,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",
  "deepLink": "umami://",
  "universalLink": "https://umamiwallet.com/"
}, {
  "key": "trust_ios",
  "name": "Trust Wallet",
  "shortName": "Trust Wallet",
  "color": "",
  "supportedInteractionStandards": ["wallet_connect"],
  "logo": "data:image/png;base64,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",
  "universalLink": "https://trustwallet.com",
  "deepLink": "trust://"
}];
var _tmpl$$a = template(`<svg stroke-width="0" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" height="1em" width="1em"><path d="m289.94 256 95-95A24 24 0 0 0 351 127l-95 95-95-95a24 24 0 0 0-34 34l95 95-95 95a24 24 0 1 0 34 34l95-95 95 95a24 24 0 0 0 34-34Z"></path></svg>`, 4);
var _tmpl$2$8 = template(`<svg stroke-width="0" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 320 512" height="1em" width="1em"><path d="M224 480c-8.188 0-16.38-3.125-22.62-9.375l-192-192c-12.5-12.5-12.5-32.75 0-45.25l192-192c12.5-12.5 32.75-12.5 45.25 0s12.5 32.75 0 45.25L77.25 256l169.4 169.4c12.5 12.5 12.5 32.75 0 45.25C240.4 476.9 232.2 480 224 480z"></path></svg>`, 4);
var _tmpl$3$7 = template(`<svg xmlns="http://www.w3.org/2000/svg" id="Guides" x="0" y="0" version="1.1" viewBox="0 0 179.2 43" width="140" height="40"><path fill="#3880FF" d="M45 19v.9c0 .3-.2 7.5-3.4 13.2-3.3 5.6-9.4 9.3-9.7 9.5l-.8.4-1.3-.8-7.6-4.4c-.5-.3-.9-.6-1.4-.9-.4-.3-.7-.5-1.1-.8-.8-.7-1.5-1.4-2.1-2.2-.9-1.1-1.6-2.4-2.1-3.7-.9-2.3-1.3-4.8-1.2-7.5.8-.4 1.6-.6 2.4-.6h.6c-.2 2.4.1 4.6.8 6.6 1 2.8 2.9 5.1 5.5 6.6l7.4 4.3c.2-.1.4-.2.6-.4 1.9-1.3 5.3-4.1 7.3-7.6 2.2-3.9 2.8-8.9 3-10.8L38.8 19c.3-1 .4-2.1.5-3.2L45 19z" class="st0"></path><path fill="#3880FF" d="M36.3 4.1v10.3c0 .5 0 1.1-.1 1.6s-.1.9-.2 1.3c-.2 1-.5 2-.9 3-.5 1.3-1.3 2.6-2.2 3.7-1.5 1.9-3.5 3.6-5.9 4.8-.9-.6-1.6-1.3-2-2.4 2.1-1 3.9-2.3 5.2-4 1.9-2.3 3-5.1 3-8.1V5.9l-.6-.3c-2-1-6.1-2.6-10.1-2.6-4.5 0-9.1 2-10.9 2.9v3.6c-1 .3-2 .7-3 1.1V4.1l.8-.4C9.7 3.5 16 0 22.5 0s12.8 3.5 13.1 3.6l.7.5z" class="st0"></path><path fill="#3880FF" d="M10.5 16.5l-7.4 4.3v.7c.2 2.1.9 6.5 2.9 10 2.2 3.9 6.2 6.9 7.9 8l3.1-1.8c.8.7 1.6 1.4 2.5 2L13.8 43l-.8-.5c-.3-.2-6.4-3.9-9.7-9.5C.1 27.4 0 20.2 0 19.9V19l1.3-.8L9 13.9c.5-.3.9-.5 1.4-.7.4-.2.8-.4 1.3-.5 1-.4 2-.6 3-.7 1.4-.2 2.9-.2 4.3 0 2.4.3 4.8 1.2 7.1 2.7 0 1-.4 2-1 2.9-1.9-1.3-4-2.2-6-2.5-3.1-.6-6-.1-8.6 1.4z" class="st0"></path><g><path d="M73.9 23c.9 1 1.3 2.3 1.3 3.7 0 1.9-.6 3.4-1.9 4.5-1.3 1.1-3.1 1.7-5.5 1.7h-8.6v-23h8.4c2.3 0 4.1.5 5.3 1.5 1.2 1 1.8 2.4 1.8 4.2 0 1.5-.4 2.7-1.2 3.6-.8.9-1.8 1.5-3.1 1.8 1.5.3 2.6 1 3.5 2zm-11.7-3h5c1.5 0 2.6-.3 3.4-1 .8-.7 1.2-1.6 1.2-2.8 0-1.2-.4-2.1-1.1-2.8-.8-.7-1.9-1-3.5-1h-4.8V20zm8.7 9.4c.9-.7 1.3-1.7 1.3-3s-.4-2.3-1.3-3c-.9-.7-2.1-1.1-3.7-1.1h-5v8.2h5c1.6-.1 2.8-.4 3.7-1.1zM95.3 24.6H81c.1 2.1.6 3.6 1.7 4.6s2.4 1.5 4 1.5c1.4 0 2.6-.4 3.6-1.1 1-.7 1.6-1.7 1.8-2.9h3.2c-.2 1.2-.7 2.4-1.5 3.3-.8 1-1.7 1.7-2.9 2.3-1.2.5-2.6.8-4.1.8-1.7 0-3.2-.4-4.6-1.1-1.3-.7-2.4-1.8-3.1-3.2-.8-1.4-1.1-3-1.1-4.9 0-1.9.4-3.5 1.1-4.9.8-1.4 1.8-2.5 3.1-3.2 1.3-.7 2.9-1.1 4.6-1.1 1.7 0 3.3.4 4.6 1.1 1.3.7 2.3 1.7 3 3 .7 1.2 1 2.6 1 4.1.1.7 0 1.2-.1 1.7zm-3.5-4.8c-.5-.9-1.2-1.6-2.1-2-.9-.4-1.8-.7-2.8-.7-1.6 0-3 .5-4.1 1.5-1.1 1-1.7 2.5-1.8 4.5h11.5c0-1.3-.2-2.4-.7-3.3zM111.2 16c1.2.9 2.1 2 2.5 3.5V15h3v18h-3v-4.6c-.5 1.5-1.3 2.6-2.5 3.5-1.2.9-2.7 1.3-4.4 1.3-1.6 0-3-.4-4.3-1.1-1.2-.7-2.2-1.8-2.9-3.2-.7-1.4-1.1-3-1.1-4.9 0-1.9.4-3.5 1.1-4.9.7-1.4 1.7-2.5 2.9-3.2 1.2-.7 2.7-1.1 4.3-1.1 1.7-.1 3.1.4 4.4 1.2zm-8 3.1c-1.1 1.2-1.7 2.8-1.7 4.8 0 2.1.5 3.7 1.7 4.8 1.1 1.2 2.6 1.8 4.4 1.8 1.2 0 2.2-.3 3.2-.8.9-.5 1.7-1.3 2.2-2.3.5-1 .8-2.1.8-3.5 0-1.3-.3-2.5-.8-3.5s-1.2-1.8-2.2-2.3c-.9-.5-2-.8-3.2-.8-1.9.1-3.3.7-4.4 1.8zM135 16.6c1.5 1.2 2.4 2.9 2.8 4.9h-3.1c-.2-1.3-.8-2.3-1.8-3-1-.7-2.2-1.1-3.6-1.1-1 0-2 .2-2.9.7-.9.5-1.6 1.2-2.1 2.2-.5 1-.8 2.2-.8 3.7s.3 2.7.8 3.7 1.2 1.7 2.1 2.2c.9.5 1.8.7 2.9.7 1.4 0 2.6-.4 3.6-1.1 1-.7 1.6-1.8 1.8-3h3.1c-.3 2.1-1.3 3.7-2.8 4.9-1.5 1.2-3.4 1.8-5.7 1.8-1.7 0-3.2-.4-4.6-1.1-1.3-.7-2.4-1.8-3.1-3.2-.8-1.4-1.1-3-1.1-4.9 0-1.9.4-3.5 1.1-4.9.8-1.4 1.8-2.5 3.1-3.2 1.3-.7 2.9-1.1 4.6-1.1 2.3-.1 4.2.6 5.7 1.8zM154.5 15.9c1.4.7 2.4 1.8 3.2 3.2.8 1.4 1.2 3 1.2 4.9 0 1.9-.4 3.5-1.2 4.9-.8 1.4-1.8 2.4-3.2 3.2-1.4.7-2.9 1.1-4.6 1.1-1.7 0-3.3-.4-4.6-1.1-1.4-.7-2.4-1.8-3.2-3.2-.8-1.4-1.2-3-1.2-4.9 0-1.9.4-3.5 1.2-4.9.8-1.4 1.9-2.5 3.2-3.2 1.4-.7 2.9-1.1 4.6-1.1 1.7-.1 3.2.3 4.6 1.1zm-7.6 2.2c-.9.5-1.6 1.2-2.2 2.2-.6 1-.8 2.2-.8 3.7 0 1.4.3 2.7.8 3.6.6 1 1.3 1.7 2.2 2.2.9.5 1.9.7 3 .7s2.1-.2 3-.7c.9-.5 1.6-1.2 2.2-2.2.6-1 .8-2.2.8-3.6 0-1.5-.3-2.7-.8-3.7-.6-1-1.3-1.7-2.2-2.2-.9-.5-1.9-.7-3-.7s-2.1.2-3 .7zM177.3 16.7c1.3 1.3 1.9 3.3 1.9 5.8v10.4h-3V22.8c0-1.8-.5-3.2-1.4-4.1-.9-1-2.2-1.4-3.7-1.4-1.6 0-2.9.5-3.9 1.6s-1.5 2.6-1.5 4.6V33h-3V15h3v4.3c.5-1.5 1.3-2.6 2.4-3.4 1.2-.8 2.5-1.2 4-1.2 2.2 0 3.9.6 5.2 2z" class="st1"></path></g></svg>`, 12);
function CloseIcon(props) {
  return (() => {
    const _el$ = _tmpl$$a.cloneNode(true);
    createRenderEffect((_$p) => style(_el$, props.style ? Object.assign({
      overflow: "visible",
      "font-size": "22px"
    }, props.style) : {
      overflow: "visible",
      "font-size": "22px"
    }, _$p));
    return _el$;
  })();
}
function LeftIcon(props) {
  return (() => {
    const _el$2 = _tmpl$2$8.cloneNode(true);
    createRenderEffect((_$p) => style(_el$2, props.style ? Object.assign({
      overflow: "visible"
    }, props.style) : {
      overflow: "visible"
    }, _$p));
    return _el$2;
  })();
}
function LogoIcon(props) {
  return (() => {
    const _el$3 = _tmpl$3$7.cloneNode(true);
    createRenderEffect((_$p) => style(_el$3, props.style ? Object.assign({}, props.style) : {}, _$p));
    return _el$3;
  })();
}
var styles$8 = ".loader {\n  height: 3px;\n  position: relative;\n  background-color: #ddd;\n  position: absolute;\n  width: 100%;\n  left: 0px;\n  bottom: 0px;\n  overflow: hidden;\n}\n\n.loader:before {\n  content: '';\n  position: absolute;\n  left: -50%;\n  height: 3px;\n  width: 40%;\n  background-color: #3880ff;\n  -webkit-animation: lineAnim 1s linear infinite;\n  -moz-animation: lineAnim 1s linear infinite;\n  animation: lineAnim 1s linear infinite;\n}\n\n@keyframes lineAnim {\n  0% {\n    left: -40%;\n  }\n  50% {\n    left: 20%;\n    width: 80%;\n  }\n  100% {\n    left: 100%;\n    width: 100%;\n  }\n}\n";
var _tmpl$$9 = template(`<div class="loader"></div>`, 2);
var Loader = (_2) => {
  return _tmpl$$9.cloneNode(true);
};
var _tmpl$$8 = template(`<div><div><div class="alert-header"><div class="alert-logo"></div><div class="alert-button-icon"></div></div><div class="alert-modal-loading-wrapper"></div><div class="alert-body"></div></div></div>`, 14);
var _tmpl$2$7 = template(`<div class="alert-button-icon"></div>`, 2);
var _tmpl$3$6 = template(`<div class="alert-button-icon-empty"></div>`, 2);
var _tmpl$4$5 = template(`<div></div>`, 2);
var _tmpl$5$5 = template(`<div class="alert-divider"></div>`, 2);
var _tmpl$6$3 = template(`<div class="alert-footer"></div>`, 2);
var Alert = (props) => {
  let prevBodyOverflow = null;
  onMount(() => {
    prevBodyOverflow = document.body.style.overflow;
    document.body.style.overflow = "hidden";
  });
  onCleanup(() => {
    document.body.style.overflow = prevBodyOverflow;
  });
  const isMobile2 = window.innerWidth <= 800;
  return (() => {
    const _el$ = _tmpl$$8.cloneNode(true), _el$2 = _el$.firstChild, _el$3 = _el$2.firstChild, _el$4 = _el$3.firstChild, _el$5 = _el$4.nextSibling, _el$6 = _el$3.nextSibling, _el$7 = _el$6.nextSibling;
    _el$.$$click = () => {
      props.onCloseClick();
    };
    _el$2.$$click = (e) => {
      e.stopPropagation();
    };
    insert(_el$3, (() => {
      const _c$ = createMemo(() => !!props.onBackClick);
      return () => _c$() && (() => {
        const _el$8 = _tmpl$2$7.cloneNode(true);
        addEventListener(_el$8, "click", props.onBackClick, true);
        insert(_el$8, createComponent(LeftIcon, {}));
        return _el$8;
      })();
    })(), _el$4);
    insert(_el$3, (() => {
      const _c$2 = createMemo(() => !!!props.onBackClick);
      return () => _c$2() && _tmpl$3$6.cloneNode(true);
    })(), _el$4);
    insert(_el$4, createComponent(LogoIcon, {}));
    addEventListener(_el$5, "click", props.onCloseClick, true);
    insert(_el$5, createComponent(CloseIcon, {}));
    insert(_el$6, createComponent(Loader, {}));
    insert(_el$7, () => props.content, null);
    insert(_el$7, !isMobile2 && (() => {
      const _el$10 = _tmpl$4$5.cloneNode(true);
      insert(_el$10, (() => {
        const _c$4 = createMemo(() => !!props.extraContent);
        return () => _c$4() && _tmpl$5$5.cloneNode(true);
      })(), null);
      insert(_el$10, () => props.extraContent, null);
      createRenderEffect(() => className(_el$10, props.showMore ? "alert-body-extra-show" : "alert-body-extra-hide"));
      return _el$10;
    })(), null);
    insert(_el$2, (() => {
      const _c$3 = createMemo(() => !!(!isMobile2 && props.extraContent));
      return () => _c$3() && (() => {
        const _el$12 = _tmpl$6$3.cloneNode(true);
        _el$12.$$click = () => {
          if (props.onClickShowMore)
            props.onClickShowMore();
        };
        insert(_el$12, () => props.showMore ? "Show less" : "Show more");
        return _el$12;
      })();
    })(), null);
    createRenderEffect((_p$) => {
      const _v$ = props.open ? "alert-wrapper-show" : "alert-wrapper-hide", _v$2 = props.open ? "alert-modal-show" : "alert-modal-hide", _v$3 = props.loading ? {
        opacity: 1,
        transition: "all ease 0.3s",
        height: "14px",
        overflow: "unset",
        width: "unset"
      } : {
        opacity: 0,
        transition: "all ease 0.3s",
        height: 0,
        overflow: "hidden",
        width: 0
      }, _v$4 = props.extraContent ? "" : "1.8em";
      _v$ !== _p$._v$ && className(_el$, _p$._v$ = _v$);
      _v$2 !== _p$._v$2 && className(_el$2, _p$._v$2 = _v$2);
      _p$._v$3 = style(_el$6, _v$3, _p$._v$3);
      _v$4 !== _p$._v$4 && _el$7.style.setProperty("margin-bottom", _p$._v$4 = _v$4);
      return _p$;
    }, {
      _v$: void 0,
      _v$2: void 0,
      _v$3: void 0,
      _v$4: void 0
    });
    return _el$;
  })();
};
delegateEvents(["click"]);
var styles$7 = ".wallet-main {\n  display: flex;\n  gap: 1.25em;\n  justify-content: space-between;\n  border-radius: 12px;\n  padding: 15px;\n  cursor: pointer;\n  transition: all ease 0.2s;\n\n  -webkit-box-shadow: 0px 0px 12px -4px rgb(0 0 0 / 30%);\n  -moz-box-shadow: 0px 0px 12px -4px rgb(0 0 0 / 30%);\n  box-shadow: 0px 0px 12px -4px rgb(0 0 0 / 30%);\n}\n\n.wallet-disabled {\n  opacity: 0.5;\n}\n\n.wallet-main:hover {\n  transform: scale(1.01);\n}\n\n.wallet-main:active {\n  transform: scale(0.99);\n}\n\n.wallet-main-left {\n  max-width: 148px;\n  flex: 1;\n}\n\n.theme__dark .wallet-main-left h3 {\n  color: white;\n}\n\n.theme__dark .top-wallets-info p {\n  color: #b5b8be;\n}\n\n.theme__dark .wallet-main-right {\n  -webkit-box-shadow: 0px 0px 12px -4px rgb(0 0 0 / 63%);\n  -moz-box-shadow: 0px 0px 12px -4px rgb(0 0 0 / 63%);\n  box-shadow: 0px 0px 12px -4px rgb(0 0 0 / 63%);\n}\n\n.theme__dark .wallet-small img {\n  -webkit-box-shadow: 0px 0px 12px -4px rgb(0 0 0 / 63%);\n  -moz-box-shadow: 0px 0px 12px -4px rgb(0 0 0 / 63%);\n  box-shadow: 0px 0px 12px -4px rgb(0 0 0 / 63%);\n}\n\n.theme__dark .wallet-small h3 {\n  color: white;\n}\n\n.wallet-main-left h3 {\n  color: #1c1e21;\n  margin: 0px;\n  font-size: 1em;\n}\n\n.wallet-main-left p {\n  max-width: 400px;\n  font-weight: 300;\n  color: #7c828b;\n  line-height: 1.35em;\n  margin: 0px;\n  font-size: 0.65em;\n}\n\n.wallet-main-right {\n  display: flex;\n  justify-content: center;\n  align-items: center;\n  border-radius: 8px;\n  overflow: hidden;\n  -webkit-box-shadow: 0px 0px 12px -4px rgb(0 0 0 / 30%);\n  -moz-box-shadow: 0px 0px 12px -4px rgb(0 0 0 / 30%);\n  box-shadow: 0px 0px 12px -4px rgb(0 0 0 / 30%);\n}\n\n.wallet-main-right img {\n  width: 3.2em;\n  height: 3.2em;\n}\n\n.wallet-main-tags {\n  display: flex;\n  gap: 6px;\n}\n\n.wallet-main-tag {\n  color: #3880ff;\n  margin: 0px;\n  font-size: 0.75em;\n  font-weight: 600;\n  margin-top: 6px;\n  text-transform: uppercase;\n}\n\n.wallet-small {\n  display: flex;\n  align-items: center;\n  justify-content: center;\n  flex-direction: column;\n  gap: 0.5em;\n}\n\n.wallet-small img {\n  padding: 0.4em;\n  border-radius: 10px;\n  width: 2.5em;\n  height: 2.5em;\n  cursor: pointer;\n  transition: all ease 0.2s;\n\n  -webkit-box-shadow: 0px 0px 12px -4px rgb(0 0 0 / 30%);\n  -moz-box-shadow: 0px 0px 12px -4px rgb(0 0 0 / 30%);\n  box-shadow: 0px 0px 12px -4px rgb(0 0 0 / 30%);\n}\n\n.wallet-small img:hover {\n  transform: scale(1.01);\n}\n\n.wallet-small img:active {\n  transform: scale(0.99);\n}\n\n.wallet-small h3 {\n  color: #334155;\n  margin: 0px;\n  font-size: 0.8em;\n  text-align: center;\n}\n\n.wallet-main-mobile {\n  flex-direction: column;\n  justify-content: center;\n  align-items: center;\n  gap: 1em;\n}\n\n.wallet-main-left-mobile {\n  order: 1;\n}\n\n.wallet-main-left-mobile h3 {\n  font-size: 0.9em;\n  text-align: center;\n}\n\n.wallet-main-left-mobile p {\n  font-size: 0.65em;\n  text-align: center;\n}\n\n@media only screen and (max-width: 800px) {\n  .wallet-main {\n    padding: 0.65em 15px;\n  }\n\n  .wallet-main-mobile {\n    padding: 1.25em;\n  }\n}\n";
var _tmpl$$7 = template(`<div></div>`, 2);
var _tmpl$2$6 = template(`<div><div><h3></h3></div><div class="wallet-main-right"><img></div></div>`, 9);
var _tmpl$3$5 = template(`<p></p>`, 2);
var _tmpl$4$4 = template(`<div class="wallet-main-tags"></div>`, 2);
var _tmpl$5$4 = template(`<span class="wallet-main-tag"></span>`, 2);
var _tmpl$6$2 = template(`<div class="wallet-small"><img><h3></h3></div>`, 5);
var Wallet = (props) => {
  return (() => {
    const _el$ = _tmpl$$7.cloneNode(true);
    insert(_el$, (() => {
      const _c$ = createMemo(() => !!!props.small);
      return () => _c$() && (() => {
        const _el$2 = _tmpl$2$6.cloneNode(true), _el$3 = _el$2.firstChild, _el$4 = _el$3.firstChild, _el$5 = _el$3.nextSibling, _el$6 = _el$5.firstChild;
        addEventListener(_el$2, "click", props.onClick, true);
        insert(_el$4, () => props.name);
        insert(_el$3, (() => {
          const _c$3 = createMemo(() => !!props.description);
          return () => _c$3() && (() => {
            const _el$7 = _tmpl$3$5.cloneNode(true);
            insert(_el$7, () => props.description);
            return _el$7;
          })();
        })(), null);
        insert(_el$3, (() => {
          const _c$4 = createMemo(() => !!(props.tags && props.tags.length > 0));
          return () => _c$4() && (() => {
            const _el$8 = _tmpl$4$4.cloneNode(true);
            insert(_el$8, createComponent(For, {
              get each() {
                return props.tags;
              },
              children: (tag) => (() => {
                const _el$9 = _tmpl$5$4.cloneNode(true);
                insert(_el$9, tag);
                return _el$9;
              })()
            }));
            return _el$8;
          })();
        })(), null);
        createRenderEffect((_p$) => {
          const _v$ = `wallet-main ${props.mobile ? "wallet-main-mobile" : ""}`, _v$2 = `wallet-main-left ${props.mobile ? "wallet-main-left-mobile" : ""}`, _v$3 = props.image;
          _v$ !== _p$._v$ && className(_el$2, _p$._v$ = _v$);
          _v$2 !== _p$._v$2 && className(_el$3, _p$._v$2 = _v$2);
          _v$3 !== _p$._v$3 && setAttribute(_el$6, "src", _p$._v$3 = _v$3);
          return _p$;
        }, {
          _v$: void 0,
          _v$2: void 0,
          _v$3: void 0
        });
        return _el$2;
      })();
    })(), null);
    insert(_el$, (() => {
      const _c$2 = createMemo(() => !!props.small);
      return () => _c$2() && (() => {
        const _el$10 = _tmpl$6$2.cloneNode(true), _el$11 = _el$10.firstChild, _el$12 = _el$11.nextSibling;
        addEventListener(_el$10, "click", props.onClick, true);
        insert(_el$12, () => props.name);
        createRenderEffect(() => setAttribute(_el$11, "src", props.image));
        return _el$10;
      })();
    })(), null);
    createRenderEffect(() => className(_el$, props.disabled ? "wallet-disabled" : ""));
    return _el$;
  })();
};
delegateEvents(["click"]);
var styles$6 = ".top-wallets-wrapper {\n  margin-bottom: 1.8em;\n}\n\n.top-wallets-info {\n  display: flex;\n  flex-direction: column;\n  align-items: center;\n  justify-content: center;\n}\n\n.theme__dark .top-wallets-info h3 {\n  color: white;\n}\n\n.theme__dark .top-wallets-info span {\n  color: #b5b8be;\n}\n\n.theme__dark .top-wallets-other-wallets-left h3 {\n  color: white;\n}\n\n.top-wallets-info h3 {\n  text-align: center;\n  color: #334155;\n  margin: 0px;\n  font-size: 0.938rem;\n}\n\n.top-wallets-info span {\n  text-align: center;\n  max-width: 300px;\n  font-size: 0.8em;\n  font-weight: 300;\n  color: #7c828b;\n  line-height: 1.35em;\n  margin: 6px 0px 12px 0px;\n}\n\n.top-wallets-learn-more {\n  text-decoration: underline;\n  cursor: pointer;\n  font-size: 0.95em !important;\n}\n\n.top-wallets-wallets-main {\n  margin-top: 1em;\n  grid-template-columns: repeat(2, 1fr);\n  display: grid;\n  gap: 1em;\n}\n\n.top-wallets-other-wallets {\n  display: flex;\n  gap: 1.25em;\n  justify-content: space-between;\n  border-radius: 12px;\n  padding: 1.25em;\n  cursor: pointer;\n  transition: all ease 0.2s;\n\n  -webkit-box-shadow: 0px 0px 12px -4px rgb(0 0 0 / 30%);\n  -moz-box-shadow: 0px 0px 12px -4px rgb(0 0 0 / 30%);\n  box-shadow: 0px 0px 12px -4px rgb(0 0 0 / 30%);\n}\n\n.top-wallets-other-wallets-left {\n  max-width: 148px;\n}\n\n.top-wallets-other-wallets-left h3 {\n  color: #334155;\n  margin: 0px;\n  font-size: 1em;\n}\n\n.top-wallets-other-wallets-left p {\n  max-width: 400px;\n  font-size: 0.85em;\n  font-weight: 300;\n  color: #94a3b8;\n  line-height: 1.35em;\n  margin: 0px;\n  font-size: 0.75em;\n}\n\n.top-wallets-other-wallets-right {\n  display: flex;\n  justify-content: center;\n  align-items: center;\n}\n\n.top-wallets-other-wallets-right img {\n  border-radius: 8px;\n  width: 2.4em;\n  height: 2.4em;\n  -webkit-box-shadow: 0px 0px 12px -4px rgb(0 0 0 / 30%);\n  -moz-box-shadow: 0px 0px 12px -4px rgb(0 0 0 / 30%);\n  box-shadow: 0px 0px 12px -4px rgb(0 0 0 / 30%);\n}\n\n.top-wallets-other-wallets-center-wallet {\n  transform: perspective(500px) translateZ(100px);\n}\n\n@media only screen and (max-width: 800px) {\n  .top-wallets-info h3 {\n    font-size: 1em;\n  }\n\n  .top-wallets-info p {\n    font-size: 0.75em;\n  }\n\n  .top-wallets-other-wallets {\n    flex-direction: column;\n    text-align: center;\n    justify-content: center;\n    align-items: center;\n  }\n\n  .top-wallets-other-wallets-left {\n    order: 1;\n  }\n\n  .top-wallets-other-wallets-left h3 {\n    font-size: 0.85em;\n  }\n\n  .top-wallets-other-wallets-left p {\n    font-size: 0.65em;\n  }\n}\n\n@media only screen and (max-width: 400px) {\n  .top-wallets-other-wallets-right {\n    max-width: 50px;\n    transform: scale(0.8);\n  }\n}\n";
var _tmpl$$6 = template(`<div class="top-wallets-wrapper"><div class="top-wallets-info"><h3>Connect Wallet</h3><span>If you don't have a wallet, you can select a provider and create one now. <span class="top-wallets-learn-more">Learn more</span></span></div><div class="top-wallets-wallets-main"></div></div>`, 12);
var _tmpl$2$5 = template(`<div class="top-wallets-other-wallets"><div class="top-wallets-other-wallets-left"><h3>Other Wallets</h3><p>See other wallets you can use to connect</p></div><div class="top-wallets-other-wallets-right"><img><img class="top-wallets-other-wallets-center-wallet"><img></div></div>`, 13);
var TopWallets = (props) => {
  const isMobile2 = window.innerWidth <= 800;
  return (() => {
    const _el$ = _tmpl$$6.cloneNode(true), _el$2 = _el$.firstChild, _el$3 = _el$2.firstChild, _el$4 = _el$3.nextSibling, _el$5 = _el$4.firstChild, _el$7 = _el$5.nextSibling, _el$8 = _el$2.nextSibling;
    _el$7.$$click = () => props.onClickLearnMore();
    insert(_el$8, createComponent(For, {
      get each() {
        return props.wallets;
      },
      children: (wallet) => createComponent(Wallet, {
        get disabled() {
          return props.disabled;
        },
        mobile: isMobile2,
        get name() {
          return wallet.name;
        },
        get description() {
          return wallet.descriptions.join(" & ");
        },
        get image() {
          return wallet.image;
        },
        onClick: () => props.onClickWallet(wallet.id),
        get tags() {
          return wallet.tags;
        }
      })
    }), null);
    insert(_el$8, (() => {
      const _c$ = createMemo(() => !!props.otherWallets);
      return () => _c$() && (() => {
        const _el$9 = _tmpl$2$5.cloneNode(true), _el$10 = _el$9.firstChild, _el$11 = _el$10.nextSibling, _el$12 = _el$11.firstChild, _el$13 = _el$12.nextSibling, _el$14 = _el$13.nextSibling;
        _el$9.$$click = () => {
          if (props.otherWallets)
            props.otherWallets.onClick();
        };
        createRenderEffect((_p$) => {
          const _v$ = props.otherWallets.images[0], _v$2 = props.otherWallets.images[1], _v$3 = props.otherWallets.images[2];
          _v$ !== _p$._v$ && setAttribute(_el$12, "src", _p$._v$ = _v$);
          _v$2 !== _p$._v$2 && setAttribute(_el$13, "src", _p$._v$2 = _v$2);
          _v$3 !== _p$._v$3 && setAttribute(_el$14, "src", _p$._v$3 = _v$3);
          return _p$;
        }, {
          _v$: void 0,
          _v$2: void 0,
          _v$3: void 0
        });
        return _el$9;
      })();
    })(), null);
    return _el$;
  })();
};
delegateEvents(["click"]);
var styles$5 = ".wallets-button {\n  border-radius: 6px;\n  background-color: transparent;\n  border: 1px solid #3880ff;\n  color: #3880ff;\n  width: 100%;\n  padding: 12px 0px;\n  margin-bottom: 1.8em;\n  transition: all ease 0.2s;\n  cursor: pointer;\n  font-size: 0.9em;\n}\n\n.wallets-button:hover {\n  color: white;\n  background-color: #3880ff;\n}\n\n.wallets-list-main-wrapper {\n  position: relative;\n}\n\n.wallets-list-wrapper {\n  display: grid;\n  overflow-y: auto;\n  grid-template-columns: repeat(4, 1fr);\n  padding: 1.8em 0px;\n  gap: 1.2em 0em;\n  max-height: 180px;\n}\n\n@media only screen and (max-width: 800px) {\n  .wallets-list-wrapper {\n    display: flex;\n    flex-direction: column;\n    gap: 12px;\n    max-height: 300px;\n    padding: 1.6em 0.6em;\n    margin-top: 0px;\n  }\n\n  .wallets-list-main-wrapper::before {\n    position: absolute;\n    top: 0px;\n    content: '';\n    left: -24px;\n    width: calc(100% + 48px);\n    background: radial-gradient(\n      circle,\n      rgba(171, 171, 171, 0.7329525560224089) 0%,\n      rgba(193, 193, 193, 0.1279105392156863) 100%\n    );\n    height: 1px;\n  }\n}\n";
var _tmpl$$5 = template(`<div class="wallets-list-main-wrapper"><div class="wallets-list-wrapper"></div><button class="wallets-button"></button></div>`, 6);
var Wallets = (props) => {
  return (() => {
    const _el$ = _tmpl$$5.cloneNode(true), _el$2 = _el$.firstChild, _el$3 = _el$2.nextSibling;
    insert(_el$2, createComponent(For, {
      get each() {
        return props.wallets;
      },
      children: (wallet) => createComponent(Wallet, {
        get disabled() {
          return props.disabled;
        },
        get name() {
          return wallet.name;
        },
        get description() {
          return wallet.descriptions.join(" & ");
        },
        get image() {
          return wallet.image;
        },
        get small() {
          return props.small;
        },
        onClick: () => {
          if (props.onClickWallet) {
            props.onClickWallet(wallet.id);
          }
        }
      })
    }));
    _el$3.$$click = () => props.onClickOther();
    insert(_el$3, () => props.isMobile ? "Pair wallet on another device" : "Show QR code");
    return _el$;
  })();
};
delegateEvents(["click"]);
var styles$4 = ".info-wrapper {\n  display: flex;\n  flex-direction: column;\n  align-items: center;\n  justify-content: center;\n  gap: 0.5em;\n  border-radius: 10px;\n  padding: 30px;\n}\n\n.info-border {\n  border: 1px solid #aaaaaa42;\n}\n\n.info-icon {\n  width: 40px;\n  height: 40px;\n  border-radius: 6px;\n  display: flex;\n  justify-content: center;\n  align-items: center;\n  font-size: 28px;\n  margin-bottom: 0.2em;\n}\n\n.info-badge {\n  background-color: #3880ff;\n  font-size: 38px;\n  -webkit-box-shadow: 0px 0px 12px -4px rgb(0 0 0 / 30%);\n  -moz-box-shadow: 0px 0px 12px -4px rgb(0 0 0 / 30%);\n  box-shadow: 0px 0px 12px -4px rgb(0 0 0 / 30%);\n}\n\n.theme__dark .info-title {\n  color: white;\n}\n\n.theme__dark .info-description {\n  color: #aeaeae;\n}\n\n.info-title {\n  text-align: center;\n  color: #334155;\n  margin: 0px;\n  font-size: 1em;\n}\n\n.info-description {\n  text-align: center;\n  font-size: 0.8em;\n  font-weight: 300;\n  color: #7c828b;\n  line-height: 1.25em;\n  margin: 6px 0px 12px 0px;\n  margin: 0px;\n  max-width: 300px;\n}\n\n.info-data {\n  font-size: 0.8em;\n  font-weight: 300;\n  color: #7c828b;\n  line-height: 1.25em;\n  margin: 6px 0px 12px 0px;\n  margin: 0px;\n  overflow: scroll;\n  max-height: 300px;\n}\n\n.info-buttons {\n  display: flex;\n  align-items: center;\n  gap: 0.6em;\n}\n\n.info-button {\n  border-radius: 6px;\n  background-color: #3880ff;\n  border: 1px solid #3880ff;\n  color: white;\n  padding: 0.6em 1.2em;\n  width: 180px;\n  transition: all ease 0.2s;\n  cursor: pointer;\n  margin-top: 1em;\n  font-size: 0.8em;\n}\n\n.info-button:hover {\n  background-color: #166afc;\n}\n\n.info-button-secondary {\n  border-radius: 6px;\n  background-color: transparent;\n  border: 1px solid #3880ff;\n  color: #3880ff;\n  padding: 0.6em 1.2em;\n  width: 180px;\n  transition: all ease 0.2s;\n  cursor: pointer;\n  margin-top: 1em;\n}\n\n.info-button-secondary:hover {\n  background-color: #e8f0ff;\n}\n\n@media only screen and (max-width: 800px) {\n  .info-title {\n    font-size: 0.9em;\n    line-height: 1em;\n  }\n\n  .info-description {\n    font-size: 0.65em;\n  }\n\n  .qr-more-info {\n    font-size: 0.75em;\n  }\n\n  .info-wrapper {\n    max-height: 180px;\n    padding: 1.2em;\n  }\n\n  .info-icon {\n    width: 40px;\n    height: 40px;\n    font-size: 1.8em;\n  }\n\n  .info-button {\n    padding: 0.5em 1.6em;\n    font-size: 0.7em;\n  }\n}\n";
var _tmpl$$4 = template(`<div><h3 class="info-title"></h3><div class="info-buttons"></div></div>`, 6);
var _tmpl$2$4 = template(`<div></div>`, 2);
var _tmpl$3$4 = template(`<div class="info-description"></div>`, 2);
var _tmpl$4$3 = template(`<pre class="info-data"></pre>`, 2);
var _tmpl$5$3 = template(`<button></button>`, 2);
var Info = (props) => {
  return (() => {
    const _el$ = _tmpl$$4.cloneNode(true), _el$2 = _el$.firstChild, _el$3 = _el$2.nextSibling;
    insert(_el$, (() => {
      const _c$ = createMemo(() => !!props.icon);
      return () => _c$() && (() => {
        const _el$4 = _tmpl$2$4.cloneNode(true);
        insert(_el$4, () => props.icon);
        createRenderEffect((_p$) => {
          const _v$ = `info-icon ${props.iconBadge ? "info-badge" : ""}`, _v$2 = props.bigIcon ? {
            "font-size": "3.4em"
          } : {};
          _v$ !== _p$._v$ && className(_el$4, _p$._v$ = _v$);
          _p$._v$2 = style(_el$4, _v$2, _p$._v$2);
          return _p$;
        }, {
          _v$: void 0,
          _v$2: void 0
        });
        return _el$4;
      })();
    })(), _el$2);
    insert(_el$2, () => props.title);
    insert(_el$, (() => {
      const _c$2 = createMemo(() => !!props.description);
      return () => _c$2() && (() => {
        const _el$5 = _tmpl$3$4.cloneNode(true);
        insert(_el$5, () => props.description);
        return _el$5;
      })();
    })(), _el$3);
    insert(_el$, (() => {
      const _c$3 = createMemo(() => !!props.data);
      return () => _c$3() && (() => {
        const _el$6 = _tmpl$4$3.cloneNode(true);
        insert(_el$6, () => props.data);
        return _el$6;
      })();
    })(), _el$3);
    insert(_el$3, createComponent(For, {
      get each() {
        return props.buttons;
      },
      children: (button) => (() => {
        const _el$7 = _tmpl$5$3.cloneNode(true);
        addEventListener(_el$7, "click", button.onClick, true);
        insert(_el$7, () => button.label);
        createRenderEffect(() => className(_el$7, button.type !== "secondary" ? "info-button" : "info-button-secondary"));
        return _el$7;
      })()
    }));
    createRenderEffect(() => className(_el$, `info-wrapper ${props.border ? "info-border" : ""}`));
    return _el$;
  })();
};
delegateEvents(["click"]);
var getTzip10Link = (url, payload) => `${url}?type=tzip10&data=${payload}`;
var logger10 = new Logger("QR");
var getQrData = (payload, height, width) => {
  if (payload.length > 500) {
    logger10.warn("getQrData", 'The size of the payload in the QR code is quite long and some devices might not be able to scan it anymore. To reduce the QR size, try using a shorter "name", "appUrl" and "iconUrl"');
  }
  try {
    const qrcode = new import_qrcode_svg.default({
      color: "black",
      content: payload,
      join: true,
      ecl: "L",
      height,
      width
    });
    return qrcode.svg();
  } catch (qrError) {
    console.error("error", qrError);
    throw qrError;
  }
};
var styles$3 = ".qr-wrapper {\n  display: flex;\n  align-items: flex-start;\n  justify-content: center;\n  gap: 0.5em;\n  border: 1px solid #aaaaaa42;\n  border-radius: 10px;\n  padding: 30px;\n  height: 200px;\n}\n\n.qr-left {\n  display: flex;\n  flex-direction: column;\n  max-width: 16em;\n  height: 100%;\n}\n\n.qr-left h3 {\n  color: #334155;\n  margin: 0px;\n  margin-bottom: 0.4em;\n  font-size: 1em;\n}\n\n.theme__dark .qr-left h3 {\n  color: white;\n}\n\n.theme__dark .qr-left span {\n  color: #aeaeae;\n}\n\n.theme__dark .qr-copy-wrapper p {\n  color: #aeaeae;\n}\n\n.qr-left span {\n  font-size: 0.8em;\n  font-weight: 300;\n  color: #7c828b;\n  line-height: 1.35em;\n  margin: 0px;\n}\n\n.qr-more-info {\n  font-size: 0.95em !important;\n  text-decoration: underline;\n  margin-left: 6px !important;\n  cursor: pointer;\n}\n\n.qr-right {\n  display: flex;\n  flex-direction: column;\n  align-items: center;\n  justify-content: center;\n  height: 100%;\n  border-radius: 6px;\n  transition: all ease 0.2s;\n  cursor: pointer;\n}\n\n.theme__dark .qr-right:hover {\n  background-color: rgba(238, 238, 238, 0.492);\n}\n\n.qr-right:hover {\n  background-color: rgb(238, 238, 238);\n}\n\n.qr-copy-wrapper {\n  display: flex;\n  align-items: center;\n  gap: 0.6em;\n  color: #7c828b;\n  margin-bottom: 8px;\n  margin-top: 18px;\n}\n\n.qr-copy-wrapper svg {\n  font-size: 1em;\n}\n\n.qr-copy-wrapper p {\n  font-size: 0.8em;\n  margin: 0px;\n}\n\n.qr-svg-wrapper {\n  background-color: white;\n  border-radius: 10px;\n}\n\n.qr-svg-wrapper svg rect {\n  fill: transparent !important;\n}\n\n@media only screen and (max-width: 800px) {\n  .qr-wrapper {\n    flex-direction: column;\n    align-items: center;\n    justify-content: center;\n    height: 340px;\n  }\n\n  .qr-left {\n    margin: 0.6em 0px;\n  }\n\n  .qr-left h3 {\n    font-size: 1em;\n    line-height: 1em;\n  }\n\n  .qr-left p {\n    font-size: 0.75em;\n    text-align: center;\n  }\n\n  .qr-left > div {\n    display: flex;\n    align-items: center;\n    justify-content: center;\n  }\n\n  .qr-more-info {\n    font-size: 0.75em;\n  }\n}\n";
var _tmpl$$3 = template(`<div class="qr-wrapper"><div class="qr-left"></div><div class="qr-right"></div></div>`, 6);
var _tmpl$2$3 = template(`<h3>Or scan to connect</h3>`, 2);
var _tmpl$3$3 = template(`<span></span>`, 2);
var _tmpl$4$2 = template(`<span class="qr-more-info">Learn more</span>`, 2);
var _tmpl$5$2 = template(`<div class="qr-copy-wrapper"><svg fill="currentColor" stroke-width="0" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" height="1em" width="1em" style="overflow: visible;"><path d="M243.8 339.8c-10.9 10.9-28.7 10.9-39.6 0l-64-64c-10.9-10.9-10.9-28.7 0-39.6 10.9-10.9 28.7-10.9 39.6 0l44.2 44.2 108.2-108.2c10.9-10.9 28.7-10.9 39.6 0 10.9 10.9 10.9 28.7 0 39.6l-128 128zM512 256c0 141.4-114.6 256-256 256S0 397.4 0 256 114.6 0 256 0s256 114.6 256 256zM256 48C141.1 48 48 141.1 48 256s93.1 208 208 208 208-93.1 208-208S370.9 48 256 48z"></path></svg><p>Copied!</p></div>`, 8);
var _tmpl$6$1 = template(`<div class="qr-copy-wrapper"><svg fill="currentColor" stroke-width="0" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" height="1em" width="1em" style="overflow: visible;"><path d="M502.6 70.63 441.35 9.38C435.4 3.371 427.2 0 418.7 0H255.1c-35.35 0-64 28.66-64 64l.02 256c.88 35.4 29.58 64 64.88 64h192c35.2 0 64-28.8 64-64V93.25c0-8.48-3.4-16.62-9.4-22.62zM464 320c0 8.836-7.164 16-16 16H255.1c-8.838 0-16-7.164-16-16V64.13c0-8.836 7.164-16 16-16h128L384 96c0 17.67 14.33 32 32 32h47.1v192zM272 448c0 8.836-7.164 16-16 16H63.1c-8.838 0-16-7.164-16-16l.88-255.9c0-8.836 7.164-16 16-16H160V128H63.99c-35.35 0-64 28.65-64 64L0 448c.002 35.3 28.66 64 64 64h192c35.2 0 64-28.8 64-64v-32h-47.1l-.9 32z"></path></svg><p>Copy to clipboard</p></div>`, 8);
var COPY_RESET_TIMEOUT = 3e3;
var QR = (props) => {
  const [copied, setCopied] = createSignal(false);
  const div = document.createElement("div");
  div.classList.add("qr-svg-wrapper");
  createEffect(() => {
    const payload = props.code.startsWith("wc:") ? props.code : getTzip10Link("tezos://", props.code);
    const qrSVG = props.isMobile ? getQrData(payload, 300, 300) : getQrData(payload, 160, 160);
    div.innerHTML = qrSVG;
  });
  function handleCopyClipboard() {
    return __awaiter27(this, void 0, void 0, function* () {
      if (props.onClickQrCode) {
        props.onClickQrCode();
      }
      navigator.clipboard.writeText(props.code).then(() => {
        if (!copied()) {
          setCopied(true);
          setTimeout(() => {
            setCopied(false);
          }, COPY_RESET_TIMEOUT);
        }
      }).catch((error) => {
        console.error("Error copying text: ", error);
      });
    });
  }
  return (() => {
    const _el$ = _tmpl$$3.cloneNode(true), _el$2 = _el$.firstChild, _el$3 = _el$2.nextSibling;
    insert(_el$2, (() => {
      const _c$ = createMemo(() => !!!props.isMobile);
      return () => _c$() && _tmpl$2$3.cloneNode(true);
    })(), null);
    insert(_el$2, (() => {
      const _c$2 = createMemo(() => !!!props.isMobile);
      return () => _c$2() && (() => {
        const _el$5 = _tmpl$3$3.cloneNode(true);
        insert(_el$5, () => `Open ${props.walletName} Wallet on your mobile phone and scan.`);
        return _el$5;
      })();
    })(), null);
    insert(_el$2, (() => {
      const _c$3 = createMemo(() => !!props.isMobile);
      return () => _c$3() && (() => {
        const _el$6 = _tmpl$3$3.cloneNode(true);
        insert(_el$6, () => `Scan QR code with a ${props.isWalletConnect ? "WalletConnect" : "Beacon"}-compatible wallet.`, null);
        insert(_el$6, (() => {
          const _c$7 = createMemo(() => !!props.onClickLearnMore);
          return () => _c$7() && (() => {
            const _el$7 = _tmpl$4$2.cloneNode(true);
            _el$7.$$click = () => {
              if (props.onClickLearnMore)
                props.onClickLearnMore();
            };
            return _el$7;
          })();
        })(), null);
        return _el$6;
      })();
    })(), null);
    insert(_el$2, (() => {
      const _c$4 = createMemo(() => !!(!props.isMobile && props.onClickLearnMore));
      return () => _c$4() && (() => {
        const _el$8 = _tmpl$4$2.cloneNode(true);
        _el$8.$$click = () => {
          if (props.onClickLearnMore)
            props.onClickLearnMore();
        };
        _el$8.style.setProperty("margin-top", "auto");
        return _el$8;
      })();
    })(), null);
    _el$3.$$click = handleCopyClipboard;
    insert(_el$3, div, null);
    insert(_el$3, (() => {
      const _c$5 = createMemo(() => !!copied());
      return () => _c$5() && _tmpl$5$2.cloneNode(true);
    })(), null);
    insert(_el$3, (() => {
      const _c$6 = createMemo(() => !!!copied());
      return () => _c$6() && _tmpl$6$1.cloneNode(true);
    })(), null);
    createRenderEffect((_p$) => {
      const _v$ = props.isMobile ? {
        "flex-direction": "column",
        "align-items": "center",
        "justify-content": "center",
        height: "340px",
        "text-align": "center",
        border: "none"
      } : {}, _v$2 = props.isMobile ? {
        "background-color": "transparent"
      } : {};
      _p$._v$ = style(_el$, _v$, _p$._v$);
      _p$._v$2 = style(_el$3, _v$2, _p$._v$2);
      return _p$;
    }, {
      _v$: void 0,
      _v$2: void 0
    });
    return _el$;
  })();
};
delegateEvents(["click"]);
var styles$2 = ".alert-wrapper-show {\n  display: flex;\n  align-items: center;\n  justify-content: center;\n  position: fixed;\n  height: 100%;\n  width: 100vw;\n  overflow: hidden;\n  top: 0px;\n  left: 0px;\n  background-color: rgba(0, 0, 0, 0.6);\n  opacity: 1;\n  transition: all ease 0.3s;\n  z-index: 99999;\n}\n\n.alert-wrapper-hide {\n  display: flex;\n  align-items: center;\n  justify-content: center;\n  position: fixed;\n  height: 100%;\n  width: 100vw;\n  overflow: hidden;\n  top: 0px;\n  left: 0px;\n  background-color: rgba(0, 0, 0, 0.6);\n  opacity: 0;\n  transition: all ease 0.3s;\n  z-index: 99999;\n}\n\n.theme__dark .alert-modal-show {\n  background-color: #27334c;\n}\n\n.theme__dark .alert-modal-hide {\n  background-color: #27334c;\n}\n\n.theme__dark .alert-footer {\n  color: white;\n  -webkit-box-shadow: 0px -4px 12px rgb(0 0 0 / 20%);\n  -moz-box-shadow: 0px -4px 12px rgb(0 0 0 / 20%);\n  box-shadow: 0px -4px 12px rgb(0 0 0 / 20%);\n}\n\n.theme__dark .alert-logo svg g {\n  fill: white;\n}\n\n.alert-modal-show {\n  background-color: white;\n  border-radius: 32px;\n  transition: all ease 0.3s;\n  transform: translateY(0px);\n  opacity: 1;\n  width: 480px;\n}\n\n.alert-modal-hide {\n  background-color: white;\n  border-radius: 32px;\n  transition: all ease 0.3s;\n  transform: translateY(24px);\n  opacity: 1;\n  width: 480px;\n}\n\n.alert-modal-loading-wrapper {\n  width: 480px;\n  display: flex;\n  align-items: center;\n  justify-content: center;\n  position: relative;\n}\n\n.alert-header {\n  display: flex;\n  align-items: center;\n  justify-content: space-between;\n  padding: 1.8em;\n  padding-top: 1.2em;\n  padding-bottom: 0px;\n}\n\n.alert-button-icon-empty {\n  width: 24px;\n  height: 24px;\n  padding: 2px;\n}\n\n.alert-button-icon {\n  width: 24px;\n  height: 24px;\n  padding: 2px;\n  border-radius: 100%;\n  border: 1px solid #f0f0f1;\n  display: flex;\n  align-items: center;\n  justify-content: center;\n  cursor: pointer;\n  fill: #64748b;\n  transition: all ease 0.2s;\n}\n\n.alert-button-icon:hover {\n  background-color: #475569;\n  border: 1px solid #475569;\n  fill: #e2e8f0;\n}\n\n.alert-logo {\n  margin: 0px 6em;\n  display: flex;\n  align-items: center;\n  justify-content: center;\n}\n\n.alert-logo svg {\n  height: 28px;\n}\n\n.alert-body {\n  padding: 1.8em;\n  padding-bottom: 0px;\n  transition: all ease 0.3s;\n}\n\n.alert-footer {\n  display: flex;\n  align-items: center;\n  justify-content: center;\n  color: grey;\n  cursor: pointer;\n  -webkit-box-shadow: 0px -4px 12px rgb(50 50 50 / 6%);\n  -moz-box-shadow: 0px -4px 12px rgb(50 50 50 / 6%);\n  box-shadow: 0px -4px 12px rgb(50 50 50 / 6%);\n  font-size: 0.938rem;\n  font-weight: bold;\n  height: 64px;\n}\n\n.alert-body-extra-show {\n  transition: all ease 0.3s;\n  overflow: hidden;\n  max-height: 35vh;\n  overflow-y: auto;\n}\n\n.alert-body-extra-hide {\n  transition: all ease 0.3s;\n  overflow: hidden;\n  max-height: 0px;\n}\n\n.alert-divider {\n  border-top: 1px solid #aaaaaa42;\n  width: 100%;\n  border-radius: 6px;\n}\n\n@media only screen and (max-width: 800px) {\n  .alert-logo {\n    margin: 0px 2em;\n  }\n\n  .alert-wrapper-show {\n    align-items: flex-end;\n    width: 100%;\n  }\n\n  .alert-wrapper-hide {\n    align-items: flex-end;\n    width: 100%;\n  }\n\n  .alert-modal-show {\n    border-bottom-left-radius: 0px;\n    border-bottom-right-radius: 0px;\n    padding-bottom: 1.8em;\n    width: 100%;\n  }\n\n  .alert-modal-hide {\n    border-bottom-left-radius: 0px;\n    border-bottom-right-radius: 0px;\n    padding-bottom: 1.8em;\n  }\n}\n\n@media only screen and (max-width: 300px) {\n  .alert-wrapper-show {\n    align-items: flex-end;\n    width: 100vw;\n  }\n\n  .alert-wrapper-hide {\n    align-items: flex-end;\n    width: 100vw;\n  }\n\n  .alert-body {\n    padding: 0.8em;\n  }\n\n  .alert-body {\n    padding: 0.8em;\n    padding-top: 0.4em;\n  }\n\n  .alert-logo {\n    margin: 0px;\n    transform: scale(0.8);\n  }\n}\n";
var styles$1 = ".pair-other-info {\n  display: flex;\n  flex-direction: column;\n  align-items: center;\n  justify-content: center;\n  color: #b5b8be;\n}";
function parseWallets(wallets) {
  return wallets.map((wallet) => {
    const tokens2 = ["Web", "web", "App", "app", "Mobile", "mobile"];
    for (let i2 = 0; i2 < tokens2.length; i2++) {
      if (wallet.name.includes(tokens2[i2]))
        wallet.name = wallet.name.replace(tokens2[i2], "");
    }
    wallet.name = wallet.name.trim();
    return wallet;
  });
}
function arrangeTopWallets(arr, walletIds) {
  const idsToMoveToFront = walletIds.slice(0, 4);
  const itemsToMoveToFront = [];
  const itemsToSortByName = [];
  for (let item of arr) {
    let position = void 0;
    idsToMoveToFront.some((id, index) => {
      const isWallet = item.key.startsWith(id);
      if (isWallet) {
        position = index;
      }
      return isWallet;
    });
    if (typeof position !== "undefined") {
      itemsToMoveToFront[position] = item;
    } else {
      itemsToSortByName.push(item);
    }
  }
  itemsToSortByName.sort((a2, b3) => {
    if (a2.name < b3.name) {
      return -1;
    } else if (a2.name > b3.name) {
      return 1;
    } else {
      return 0;
    }
  });
  return [...itemsToMoveToFront, ...itemsToSortByName];
}
function mergeWallets(wallets) {
  const mergedWallets = [];
  for (let i2 = 0; i2 < wallets.length; i2++) {
    const wallet = wallets[i2];
    const mergedWalletsNames = mergedWallets.map((_wallet) => _wallet.name);
    if (mergedWalletsNames.includes(wallet.name)) {
      const index = mergedWallets.findIndex((_wallet) => _wallet.name === wallet.name);
      if (index < 0)
        console.error("There should be a wallet");
      if (!mergedWallets[index].descriptions.includes(wallet.description))
        mergedWallets[index].descriptions.push(wallet.description);
      mergedWallets[index].types.push(wallet.type);
      mergedWallets[index].deepLink = wallet.deepLink;
      mergedWallets[index].firefoxId = wallet.key.includes("firefox") ? wallet.id : mergedWallets[index].firefoxId;
    } else {
      mergedWallets.push(Object.assign(Object.assign({}, wallet), {
        descriptions: [wallet.description],
        types: [wallet.type],
        firefoxId: wallet.key.includes("firefox") ? wallet.id : void 0
      }));
    }
  }
  return mergedWallets;
}
var testUserAgent = (win, expr) => expr.test(win.navigator.userAgent);
var matchMedia = (win, query) => win.matchMedia(query).matches;
var isMobile = (win) => matchMedia(win, "(any-pointer:coarse)");
var isIpad = (win) => {
  if (testUserAgent(win, /iPad/i)) {
    return true;
  }
  if (testUserAgent(win, /Macintosh/i) && isMobile(win)) {
    return true;
  }
  return false;
};
var isIOS = (win) => testUserAgent(win, /iPhone|iPod/i) || isIpad(win);
var isAndroid = (win) => testUserAgent(win, /android|sink/i);
var isTwBrowser = (win) => {
  var _a3;
  return win && ((_a3 = win.ethereum) === null || _a3 === void 0 ? void 0 : _a3.isTrust) == true;
};
var colorMode = ColorMode.LIGHT;
var setColorMode = (mode) => {
  colorMode = mode;
};
var getColorMode = () => colorMode;
var _tmpl$$2 = template(`<div><span class="pair-other-info">Select QR Type</span><br></div>`, 5);
var _tmpl$2$2 = template(`<button class="wallets-button">Beacon</button>`, 2);
var _tmpl$3$2 = template(`<button class="wallets-button">WalletConnect</button>`, 2);
var [uiState, setUiState] = createSignal("selection");
var [hasBeacon, setHasBeacon] = createSignal(false);
var [hasWalletConnect, setHasWalletConnect] = createSignal(false);
var [qrData, setQrData] = createSignal("");
var PairOther = (props) => {
  onMount(() => {
    setUiState("selection");
    setQrData("");
  });
  setHasBeacon(!!props.p2pPayload);
  setHasWalletConnect(!!props.wcPayload);
  const buttonClickHandler = (state) => {
    if (state === "p2p" && !!props.p2pPayload) {
      props.p2pPayload.then((payload) => __awaiter27(void 0, void 0, void 0, function* () {
        const serializer = new Serializer();
        const codeQR2 = yield serializer.serialize(payload);
        setQrData(codeQR2);
      }));
    } else if (state === "walletconnect" && !!props.wcPayload) {
      props.wcPayload.then((payload) => __awaiter27(void 0, void 0, void 0, function* () {
        setQrData(payload.uri);
      }));
    }
    setUiState(state);
  };
  return [createMemo((() => {
    const _c$ = createMemo(() => uiState() === "selection");
    return () => _c$() && (() => {
      const _el$ = _tmpl$$2.cloneNode(true), _el$2 = _el$.firstChild;
      _el$2.nextSibling;
      insert(_el$, (() => {
        const _c$3 = createMemo(() => !!hasBeacon());
        return () => _c$3() && (() => {
          const _el$4 = _tmpl$2$2.cloneNode(true);
          _el$4.$$click = () => {
            buttonClickHandler("p2p");
          };
          return _el$4;
        })();
      })(), null);
      insert(_el$, (() => {
        const _c$4 = createMemo(() => !!hasWalletConnect());
        return () => _c$4() && (() => {
          const _el$5 = _tmpl$3$2.cloneNode(true);
          _el$5.$$click = () => {
            buttonClickHandler("walletconnect");
          };
          return _el$5;
        })();
      })(), null);
      return _el$;
    })();
  })()), createMemo((() => {
    const _c$2 = createMemo(() => !!(uiState() !== "selection" && !!qrData()));
    return () => _c$2() && createComponent(QR, {
      get isWalletConnect() {
        return uiState() === "walletconnect";
      },
      isMobile: true,
      walletName: "AirGap",
      get code() {
        return qrData();
      },
      get onClickLearnMore() {
        return props.onClickLearnMore;
      }
    });
  })())];
};
delegateEvents(["click"]);
var _tmpl$$1 = template(`<div></div>`, 2);
var _tmpl$2$1 = template(`<div><div></div><div></div><div></div></div>`, 8);
var _tmpl$3$1 = template(`<svg fill="currentColor" stroke-width="0" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" height="1em" width="1em" style="overflow: visible;" color="white"><path d="M16 12h2v4h-2z"></path><path d="M20 7V5c0-1.103-.897-2-2-2H5C3.346 3 2 4.346 2 6v12c0 2.201 1.794 3 3 3h15c1.103 0 2-.897 2-2V9c0-1.103-.897-2-2-2zM5 5h13v2H5a1.001 1.001 0 0 1 0-2zm15 14H5.012C4.55 18.988 4 18.805 4 18V8.815c.314.113.647.185 1 .185h15v10z"></path></svg>`, 6);
var _tmpl$4$1 = template(`<svg fill="none" stroke-width="2" xmlns="http://www.w3.org/2000/svg" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" viewBox="0 0 24 24" height="1em" width="1em" style="overflow: visible;" color="white"><path stroke="none" d="M0 0h24v24H0z"></path><rect width="16" height="16" x="4" y="4" rx="2"></rect><path d="M9 12h6M12 9v6"></path></svg>`, 8);
var _tmpl$5$1 = template(`<svg fill="currentColor" stroke-width="0" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" height="1em" width="1em" style="overflow: visible;" color="#494949"><path d="M85.57 446.25h340.86a32 32 0 0 0 28.17-47.17L284.18 82.58c-12.09-22.44-44.27-22.44-56.36 0L57.4 399.08a32 32 0 0 0 28.17 47.17Z" fill="none" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="32px"></path><path d="m250.26 195.39 5.74 122 5.73-121.95a5.74 5.74 0 0 0-5.79-6h0a5.74 5.74 0 0 0-5.68 5.95Z" fill="none" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="32px"></path><path d="M256 397.25a20 20 0 1 1 20-20 20 20 0 0 1-20 20Z"></path></svg>`, 8);
var [isOpen$1, setIsOpen$1] = createSignal(false);
var [isLoading, setIsLoading] = createSignal(false);
var [showMoreContent, setShowMoreContent] = createSignal(false);
var [codeQR, setCodeQR] = createSignal("");
var [walletList, setWalletList] = createSignal([]);
var [currentWallet, setCurrentWallet] = createSignal(void 0);
var [previousInfo, setPreviousInfo] = createSignal("top-wallets");
var [currentInfo, setCurrentInfo] = createSignal("top-wallets");
var [analytics, setAnalytics] = createSignal(void 0);
var dispose$1 = null;
var closeAlert = (_2) => {
  return new Promise((resolve) => __awaiter27(void 0, void 0, void 0, function* () {
    if (isServer) {
      console.log("DO NOT RUN ON SERVER");
      resolve();
    }
    if (dispose$1 && isOpen$1()) {
      setIsOpen$1(false);
      setTimeout(() => {
        if (dispose$1)
          dispose$1();
        if (document.getElementById("beacon-alert-wrapper"))
          document.getElementById("beacon-alert-wrapper").remove();
      }, 500);
    }
    resolve();
  }));
};
var closeAlerts = () => __awaiter27(void 0, void 0, void 0, function* () {
  return new Promise((resolve) => __awaiter27(void 0, void 0, void 0, function* () {
    if (isServer) {
      console.log("DO NOT RUN ON SERVER");
      resolve();
    }
    if (dispose$1 && isOpen$1()) {
      setIsOpen$1(false);
      setTimeout(() => {
        if (dispose$1)
          dispose$1();
        if (document.getElementById("beacon-alert-wrapper"))
          document.getElementById("beacon-alert-wrapper").remove();
      }, 500);
    }
    resolve();
  }));
});
var openAlert = (config2) => __awaiter27(void 0, void 0, void 0, function* () {
  var _a3, _b;
  const p2pPayload = (_a3 = config2.pairingPayload) === null || _a3 === void 0 ? void 0 : _a3.p2pSyncCode();
  const wcPayload = (_b = config2.pairingPayload) === null || _b === void 0 ? void 0 : _b.walletConnectSyncCode();
  setAnalytics(config2.analytics);
  p2pPayload === null || p2pPayload === void 0 ? void 0 : p2pPayload.then(() => {
    console.log("P2P LOADED");
  });
  wcPayload === null || wcPayload === void 0 ? void 0 : wcPayload.then(() => {
    console.log("WC LOADED");
  });
  if (isServer) {
    console.log("DO NOT RUN ON SERVER");
    return "";
  }
  if (!isOpen$1()) {
    let availableExtensions = yield PostMessageTransport.getAvailableExtensions();
    const extensionsUpdatedFn = (event) => __awaiter27(void 0, void 0, void 0, function* () {
      if (event.data === "extensionsUpdated") {
        availableExtensions = yield PostMessageTransport.getAvailableExtensions();
        setWalletList(createWalletList());
      }
    });
    windowRef.addEventListener("message", extensionsUpdatedFn);
    const setDefaultPayload = () => __awaiter27(void 0, void 0, void 0, function* () {
      if (config2.pairingPayload) {
        const serializer = new Serializer();
        const codeQR2 = yield serializer.serialize(yield p2pPayload);
        setCodeQR(codeQR2);
      }
    });
    setCurrentInfo("top-wallets");
    setCurrentWallet(void 0);
    localStorage.removeItem(StorageKey.LAST_SELECTED_WALLET);
    const shadowRootEl = document.createElement("div");
    shadowRootEl.setAttribute("id", "beacon-alert-wrapper");
    shadowRootEl.style.height = "0px";
    const shadowRoot = shadowRootEl.attachShadow({
      mode: "open"
    });
    const style$1 = document.createElement("style");
    style$1.textContent = styles$2;
    shadowRoot.appendChild(style$1);
    const style2 = document.createElement("style");
    style2.textContent = styles$6;
    shadowRoot.appendChild(style2);
    const style3 = document.createElement("style");
    style3.textContent = styles$5;
    shadowRoot.appendChild(style3);
    const style4 = document.createElement("style");
    style4.textContent = styles$7;
    shadowRoot.appendChild(style4);
    const style5 = document.createElement("style");
    style5.textContent = styles$4;
    shadowRoot.appendChild(style5);
    const style6 = document.createElement("style");
    style6.textContent = styles$3;
    shadowRoot.appendChild(style6);
    const style7 = document.createElement("style");
    style7.textContent = styles$8;
    shadowRoot.appendChild(style7);
    const style8 = document.createElement("style");
    style8.textContent = styles$1;
    shadowRoot.appendChild(style8);
    const styleFonts = document.createElement("style");
    styleFonts.textContent = "* { font-family: system-ui, -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Roboto', 'Oxygen', 'Ubuntu', 'Cantarell', 'Fira Sans', 'Droid Sans', 'Helvetica Neue', 'Segoe UI Emoji', 'Apple Color Emoji', 'Noto Color Emoji', sans-serif;}";
    shadowRoot.appendChild(styleFonts);
    const createWalletList = () => {
      var _a4;
      const wallets = [...desktopList.filter((wallet) => !availableExtensions.some((extWallet) => wallet.name === extWallet.name)).map((wallet) => {
        return {
          id: wallet.key,
          key: wallet.key,
          name: wallet.shortName,
          image: wallet.logo,
          description: "Desktop App",
          type: "desktop",
          link: wallet.downloadLink,
          deepLink: wallet.deepLink
        };
      }), ...extensionList.map((wallet) => {
        return {
          id: wallet.id,
          key: wallet.key,
          name: wallet.shortName,
          image: wallet.logo,
          description: "Browser Extension",
          type: "extension",
          link: wallet.link
        };
      }), ...iOSList.map((wallet) => {
        return {
          id: wallet.key,
          key: wallet.key,
          name: wallet.shortName,
          image: wallet.logo,
          description: "Mobile App",
          supportedInteractionStandards: wallet.supportedInteractionStandards,
          type: "ios",
          link: wallet.universalLink,
          deepLink: wallet.deepLink
        };
      }), ...webList.map((wallet) => {
        var _a5, _b2;
        const link = wallet.links[(_b2 = (_a5 = config2.pairingPayload) === null || _a5 === void 0 ? void 0 : _a5.networkType) !== null && _b2 !== void 0 ? _b2 : NetworkType.MAINNET];
        return {
          id: wallet.key,
          key: wallet.key,
          name: wallet.shortName,
          image: wallet.logo,
          description: "Web App",
          type: "web",
          link: link !== null && link !== void 0 ? link : wallet.links.mainnet
        };
      }), ...availableExtensions.filter((newExt) => !extensionList.some((ext) => ext.id === newExt.id)).map((wallet) => {
        var _a5, _b2, _c, _d;
        return {
          id: wallet.id,
          key: wallet.id,
          name: (_b2 = (_a5 = wallet.shortName) !== null && _a5 !== void 0 ? _a5 : wallet.name) !== null && _b2 !== void 0 ? _b2 : "",
          image: (_c = wallet.iconUrl) !== null && _c !== void 0 ? _c : "",
          description: "Browser Extension",
          type: "extension",
          link: (_d = wallet.link) !== null && _d !== void 0 ? _d : ""
        };
      })];
      const parsedWallets = parseWallets(wallets);
      const mergedWallets = mergeWallets(parsedWallets);
      const defaultWalletList = ["kukai", "temple", "plenty", "umami"];
      const arrangedWallets = arrangeTopWallets(mergedWallets, (_a4 = config2.featuredWallets) !== null && _a4 !== void 0 ? _a4 : defaultWalletList);
      return arrangedWallets;
    };
    setWalletList(createWalletList());
    const isMobile2 = window.innerWidth <= 800;
    const handleClickShowMoreContent = () => {
      var _a4;
      (_a4 = analytics()) === null || _a4 === void 0 ? void 0 : _a4.track("click", "ui", "show more wallets");
      setShowMoreContent(!showMoreContent());
    };
    const handleClickLearnMore = () => {
      var _a4;
      (_a4 = analytics()) === null || _a4 === void 0 ? void 0 : _a4.track("click", "ui", "learn more");
      setPreviousInfo(currentInfo());
      setCurrentInfo("help");
      setShowMoreContent(false);
    };
    const handleClickQrCode = () => {
      var _a4;
      (_a4 = analytics()) === null || _a4 === void 0 ? void 0 : _a4.track("click", "ui", "copy QR code to clipboard");
    };
    const handleCloseAlert = () => {
      closeAlert();
      windowRef.removeEventListener("message", extensionsUpdatedFn);
      if (config2.closeButtonCallback)
        config2.closeButtonCallback();
    };
    const handleClickWallet = (id) => __awaiter27(void 0, void 0, void 0, function* () {
      var _c, _d, _e3;
      if (isLoading())
        return;
      setIsLoading(true);
      setShowMoreContent(false);
      const wallet = walletList().find((wallet2) => wallet2.id === id);
      setCurrentWallet(wallet);
      if (wallet === null || wallet === void 0 ? void 0 : wallet.key) {
        (_c = analytics()) === null || _c === void 0 ? void 0 : _c.track("click", "ui", "opened wallet", {
          key: wallet.key
        });
        localStorage.setItem(StorageKey.LAST_SELECTED_WALLET, wallet.key);
      }
      if (wallet === null || wallet === void 0 ? void 0 : wallet.types.includes("web")) {
        if (p2pPayload) {
          const newTab = window.open("", "_blank");
          if (newTab) {
            newTab.opener = null;
          }
          const serializer = new Serializer();
          const code = yield serializer.serialize(yield p2pPayload);
          const link = getTzip10Link(wallet.link, code);
          if (newTab) {
            newTab.location.href = link;
          } else {
            window.open(link, "_blank", "noopener");
          }
        }
        setIsLoading(false);
        return;
      }
      if (wallet && ((_d = wallet.supportedInteractionStandards) === null || _d === void 0 ? void 0 : _d.includes("wallet_connect"))) {
        const uri = (_e3 = yield wcPayload) === null || _e3 === void 0 ? void 0 : _e3.uri;
        if (uri) {
          if (isAndroid(window) || isIOS(window)) {
            let link = `https://link.trustwallet.com/wc?uri=${encodeURIComponent(uri)}`;
            if (isTwBrowser(window) && isAndroid(window)) {
              link = `${uri}`;
              window.location.href = link;
            } else if (isAndroid(window)) {
              window.open(link, "_blank", "noopener");
            } else if (isIOS(window)) {
              const a2 = document.createElement("a");
              a2.setAttribute("href", link);
              a2.setAttribute("rel", "noopener");
              a2.dispatchEvent(new MouseEvent("click", {
                view: window,
                bubbles: true,
                cancelable: true
              }));
            }
          } else {
            setCodeQR(uri);
            setCurrentInfo("install");
          }
        }
        setIsLoading(false);
      } else if ((wallet === null || wallet === void 0 ? void 0 : wallet.types.includes("ios")) && isMobile2) {
        setCodeQR("");
        if (config2.pairingPayload) {
          const serializer = new Serializer();
          const code = yield serializer.serialize(yield p2pPayload);
          const link = getTzip10Link(isIOS(window) && wallet.deepLink ? wallet.deepLink : isAndroid(window) ? "tezos://" : wallet.link, code);
          if (isAndroid(window))
            window.open(link, "_blank", "noopener");
          else if (isIOS(window)) {
            const a2 = document.createElement("a");
            a2.setAttribute("href", link);
            a2.setAttribute("rel", "noopener");
            a2.dispatchEvent(new MouseEvent("click", {
              view: window,
              bubbles: true,
              cancelable: true
            }));
          }
        }
        setIsLoading(false);
      } else {
        yield setDefaultPayload();
        setIsLoading(false);
        setCurrentInfo("install");
      }
    });
    const handleClickOther = () => __awaiter27(void 0, void 0, void 0, function* () {
      var _f;
      (_f = analytics()) === null || _f === void 0 ? void 0 : _f.track("click", "ui", "other wallet");
      setCurrentInfo("qr");
    });
    const handleClickConnectExtension = () => __awaiter27(void 0, void 0, void 0, function* () {
      var _g, _h, _j, _k, _l, _m;
      (_g = analytics()) === null || _g === void 0 ? void 0 : _g.track("click", "ui", "open extension", {
        key: (_h = currentWallet()) === null || _h === void 0 ? void 0 : _h.key
      });
      setShowMoreContent(false);
      if ((_j = config2.pairingPayload) === null || _j === void 0 ? void 0 : _j.postmessageSyncCode) {
        const serializer = new Serializer();
        const postmessageCode = yield serializer.serialize(yield config2.pairingPayload.postmessageSyncCode());
        const message = {
          target: ExtensionMessageTarget.EXTENSION,
          payload: postmessageCode,
          targetId: (_k = currentWallet()) === null || _k === void 0 ? void 0 : _k.id
        };
        windowRef.postMessage(message, windowRef.location.origin);
        if ((_l = currentWallet()) === null || _l === void 0 ? void 0 : _l.firefoxId) {
          const message2 = {
            target: ExtensionMessageTarget.EXTENSION,
            payload: postmessageCode,
            targetId: (_m = currentWallet()) === null || _m === void 0 ? void 0 : _m.firefoxId
          };
          windowRef.postMessage(message2, windowRef.location.origin);
        }
      }
    });
    const handleClickInstallExtension = () => __awaiter27(void 0, void 0, void 0, function* () {
      var _o, _p, _q;
      (_o = analytics()) === null || _o === void 0 ? void 0 : _o.track("click", "ui", "install extension", {
        key: (_p = currentWallet()) === null || _p === void 0 ? void 0 : _p.key
      });
      setShowMoreContent(false);
      window.open(((_q = currentWallet()) === null || _q === void 0 ? void 0 : _q.link) || "", "_blank", "noopener");
    });
    const handleClickOpenDesktopApp = () => __awaiter27(void 0, void 0, void 0, function* () {
      var _r2, _s2, _t3;
      setShowMoreContent(false);
      (_r2 = analytics()) === null || _r2 === void 0 ? void 0 : _r2.track("click", "ui", "open desktop", {
        key: (_s2 = currentWallet()) === null || _s2 === void 0 ? void 0 : _s2.key
      });
      if (p2pPayload) {
        const serializer = new Serializer();
        const code = yield serializer.serialize(yield p2pPayload);
        const link = getTzip10Link(((_t3 = currentWallet()) === null || _t3 === void 0 ? void 0 : _t3.deepLink) || "", code);
        window.open(link, "_blank", "noopener");
      }
    });
    const handleClickDownloadDesktopApp = () => __awaiter27(void 0, void 0, void 0, function* () {
      var _u, _v, _w;
      (_u = analytics()) === null || _u === void 0 ? void 0 : _u.track("click", "ui", "download desktop", {
        key: (_v = currentWallet()) === null || _v === void 0 ? void 0 : _v.key
      });
      setShowMoreContent(false);
      window.open(((_w = currentWallet()) === null || _w === void 0 ? void 0 : _w.link) || "", "_blank", "noopener");
    });
    const hasExtension = () => {
      var _a4, _b2;
      return availableExtensions.map((extension) => extension.id).includes(((_a4 = currentWallet()) === null || _a4 === void 0 ? void 0 : _a4.firefoxId) || "") || availableExtensions.map((extension) => extension.id).includes(((_b2 = currentWallet()) === null || _b2 === void 0 ? void 0 : _b2.id) || "");
    };
    const colorMode2 = getColorMode();
    dispose$1 = render(() => {
      var _a4, _b2, _c, _d, _e3, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r2, _s2, _t3;
      return (() => {
        const _el$ = _tmpl$$1.cloneNode(true);
        className(_el$, `theme__${colorMode2}`);
        insert(_el$, (() => {
          const _c$ = createMemo(() => !!config2.pairingPayload);
          return () => _c$() && createComponent(Alert, {
            get loading() {
              return isLoading();
            },
            get open() {
              return isOpen$1();
            },
            get showMore() {
              return showMoreContent();
            },
            get content() {
              return (() => {
                const _el$2 = _tmpl$2$1.cloneNode(true), _el$3 = _el$2.firstChild, _el$4 = _el$3.nextSibling, _el$5 = _el$4.nextSibling;
                insert(_el$2, (() => {
                  const _c$3 = createMemo(() => currentInfo() === "install");
                  return () => _c$3() && (() => {
                    const _el$6 = _tmpl$$1.cloneNode(true);
                    insert(_el$6, (() => {
                      const _c$5 = createMemo(() => !!(!isMobile2 && ((_a4 = currentWallet()) === null || _a4 === void 0 ? void 0 : _a4.types.includes("extension"))));
                      return () => _c$5() && createComponent(Info, {
                        border: true,
                        get title() {
                          return createMemo(() => !!hasExtension())() ? `Use Browser Extension` : `Install ${(_b2 = currentWallet()) === null || _b2 === void 0 ? void 0 : _b2.name} Wallet`;
                        },
                        get description() {
                          return createMemo(() => !!hasExtension())() ? `Please connect below to use your ${(_c = currentWallet()) === null || _c === void 0 ? void 0 : _c.name} Wallet browser extension.` : `To connect your ${(_d = currentWallet()) === null || _d === void 0 ? void 0 : _d.name} Wallet, install the browser extension.`;
                        },
                        get buttons() {
                          return hasExtension() ? [{
                            label: "Connect now",
                            type: "primary",
                            onClick: () => handleClickConnectExtension()
                          }] : [{
                            label: "Install extension",
                            type: "primary",
                            onClick: () => handleClickInstallExtension()
                          }];
                        }
                      });
                    })(), null);
                    insert(_el$6, (() => {
                      const _c$6 = createMemo(() => !!(!isMobile2 && ((_e3 = currentWallet()) === null || _e3 === void 0 ? void 0 : _e3.types.includes("desktop"))));
                      return () => _c$6() && createComponent(Info, {
                        border: true,
                        title: `Open Desktop App`,
                        description: `If you don't have the desktop app installed, click below to download it.`,
                        buttons: [{
                          label: "Open desktop app",
                          type: "primary",
                          onClick: () => handleClickOpenDesktopApp()
                        }, {
                          label: "Download desktop app",
                          type: "secondary",
                          onClick: () => handleClickDownloadDesktopApp()
                        }]
                      });
                    })(), null);
                    insert(_el$6, (() => {
                      const _c$7 = createMemo(() => !!(!isMobile2 && codeQR().length > 0 && ((_f = currentWallet()) === null || _f === void 0 ? void 0 : _f.types.includes("ios")) && ((_g = currentWallet()) === null || _g === void 0 ? void 0 : _g.types.length) > 1));
                      return () => _c$7() && createComponent(QR, {
                        get isWalletConnect() {
                          return ((_j = (_h = currentWallet()) === null || _h === void 0 ? void 0 : _h.supportedInteractionStandards) === null || _j === void 0 ? void 0 : _j.includes("wallet_connect")) || false;
                        },
                        isMobile: false,
                        get walletName() {
                          return ((_k = currentWallet()) === null || _k === void 0 ? void 0 : _k.name) || "AirGap";
                        },
                        get code() {
                          return codeQR();
                        },
                        onClickLearnMore: handleClickLearnMore,
                        onClickQrCode: handleClickQrCode
                      });
                    })(), null);
                    insert(_el$6, (() => {
                      const _c$8 = createMemo(() => !!(!isMobile2 && codeQR().length > 0 && ((_l = currentWallet()) === null || _l === void 0 ? void 0 : _l.types.includes("ios")) && ((_m = currentWallet()) === null || _m === void 0 ? void 0 : _m.types.length) <= 1));
                      return () => _c$8() && createComponent(QR, {
                        get isWalletConnect() {
                          return ((_p = (_o = currentWallet()) === null || _o === void 0 ? void 0 : _o.supportedInteractionStandards) === null || _p === void 0 ? void 0 : _p.includes("wallet_connect")) || false;
                        },
                        isMobile: true,
                        get walletName() {
                          return ((_q = currentWallet()) === null || _q === void 0 ? void 0 : _q.name) || "AirGap";
                        },
                        get code() {
                          return codeQR();
                        },
                        onClickLearnMore: handleClickLearnMore,
                        onClickQrCode: handleClickQrCode
                      });
                    })(), null);
                    insert(_el$6, (() => {
                      const _c$9 = createMemo(() => !!(isMobile2 && codeQR().length > 0));
                      return () => _c$9() && createComponent(QR, {
                        get isWalletConnect() {
                          return ((_s2 = (_r2 = currentWallet()) === null || _r2 === void 0 ? void 0 : _r2.supportedInteractionStandards) === null || _s2 === void 0 ? void 0 : _s2.includes("wallet_connect")) || false;
                        },
                        isMobile: true,
                        get walletName() {
                          return ((_t3 = currentWallet()) === null || _t3 === void 0 ? void 0 : _t3.name) || "AirGap";
                        },
                        get code() {
                          return codeQR();
                        },
                        onClickLearnMore: handleClickLearnMore,
                        onClickQrCode: handleClickQrCode
                      });
                    })(), null);
                    createRenderEffect((_$p) => style(_el$6, currentInfo() === "install" || currentInfo() === "qr" ? {
                      opacity: 1,
                      height: "unset",
                      overflow: "unset",
                      transform: "scale(1)",
                      transition: "all ease 0.3s",
                      display: "flex",
                      "flex-direction": "column",
                      gap: "0.9em"
                    } : {
                      opacity: 0,
                      height: 0,
                      overflow: "hidden",
                      transform: "scale(1.1)",
                      transition: "all ease 0.3s",
                      display: "flex",
                      "flex-direction": "column",
                      gap: "0.9em"
                    }, _$p));
                    return _el$6;
                  })();
                })(), _el$3);
                insert(_el$2, (() => {
                  const _c$4 = createMemo(() => currentInfo() === "qr");
                  return () => _c$4() && (() => {
                    const _el$7 = _tmpl$$1.cloneNode(true);
                    insert(_el$7, createComponent(PairOther, {
                      get walletList() {
                        return walletList();
                      },
                      onClickLearnMore: handleClickLearnMore,
                      p2pPayload,
                      wcPayload
                    }));
                    createRenderEffect((_$p) => style(_el$7, currentInfo() === "install" || currentInfo() === "qr" ? {
                      opacity: 1,
                      height: "unset",
                      overflow: "unset",
                      transform: "scale(1)",
                      transition: "all ease 0.3s",
                      display: "flex",
                      "flex-direction": "column",
                      gap: "0.9em"
                    } : {
                      opacity: 0,
                      height: 0,
                      overflow: "hidden",
                      transform: "scale(1.1)",
                      transition: "all ease 0.3s",
                      display: "flex",
                      "flex-direction": "column",
                      gap: "0.9em"
                    }, _$p));
                    return _el$7;
                  })();
                })(), _el$3);
                insert(_el$3, createComponent(Wallets, {
                  get disabled() {
                    return isLoading();
                  },
                  get wallets() {
                    return walletList().slice(-(walletList().length - (isMobile2 ? 3 : 4)));
                  },
                  isMobile: isMobile2,
                  onClickWallet: handleClickWallet,
                  onClickOther: handleClickOther
                }));
                insert(_el$4, createComponent(Info, {
                  iconBadge: true,
                  get icon() {
                    return _tmpl$3$1.cloneNode(true);
                  },
                  title: "What is a wallet?",
                  description: "Wallets let you send, receive, store and interact with digital assets. Your wallet can be used as an easy way to login, instead of having to remember a password."
                }), null);
                insert(_el$4, createComponent(Info, {
                  iconBadge: true,
                  get icon() {
                    return _tmpl$4$1.cloneNode(true);
                  },
                  title: "Not sure where to start?",
                  description: "If you are new to the Web3, we recommend that you start by creating a Kukai wallet. Kukai is a fast way of creating your first wallet using your preffered social account."
                }), null);
                insert(_el$5, createComponent(TopWallets, {
                  get disabled() {
                    return isLoading();
                  },
                  get wallets() {
                    return isMobile2 ? walletList().slice(0, 3) : walletList().slice(0, 4);
                  },
                  onClickWallet: handleClickWallet,
                  onClickLearnMore: handleClickLearnMore,
                  get otherWallets() {
                    return isMobile2 ? {
                      images: [walletList()[3].image, walletList()[4].image, walletList()[5].image],
                      onClick: () => setCurrentInfo("wallets")
                    } : void 0;
                  }
                }));
                createRenderEffect((_p$) => {
                  const _v$ = currentInfo() === "wallets" ? {
                    opacity: 1,
                    height: "unset",
                    overflow: "unset",
                    transform: "scale(1)",
                    transition: "all ease 0.3s"
                  } : {
                    opacity: 0,
                    height: 0,
                    overflow: "hidden",
                    transform: "scale(1.1)",
                    transition: "all ease 0.3s"
                  }, _v$2 = currentInfo() === "help" ? {
                    opacity: 1,
                    height: "unset",
                    overflow: "unset",
                    transform: "scale(1)",
                    transition: "all ease 0.3s",
                    display: "flex",
                    "flex-direction": "column",
                    gap: "0.9em"
                  } : {
                    opacity: 0,
                    height: 0,
                    overflow: "hidden",
                    transform: "scale(1.1)",
                    transition: "all ease 0.3s",
                    display: "flex",
                    "flex-direction": "column",
                    gap: "0.9em"
                  }, _v$3 = currentInfo() !== "install" && currentInfo() !== "qr" && currentInfo() !== "wallets" && currentInfo() !== "help" ? {
                    opacity: 1,
                    height: "unset",
                    overflow: "unset",
                    transform: "scale(1)",
                    transition: "all ease 0.3s"
                  } : {
                    opacity: 0,
                    height: 0,
                    overflow: "hidden",
                    transform: "scale(1.1)",
                    transition: "all ease 0.3s"
                  };
                  _p$._v$ = style(_el$3, _v$, _p$._v$);
                  _p$._v$2 = style(_el$4, _v$2, _p$._v$2);
                  _p$._v$3 = style(_el$5, _v$3, _p$._v$3);
                  return _p$;
                }, {
                  _v$: void 0,
                  _v$2: void 0,
                  _v$3: void 0
                });
                return _el$2;
              })();
            },
            get extraContent() {
              return createMemo(() => !!(currentInfo() !== "top-wallets" || isMobile2))() ? void 0 : createComponent(Wallets, {
                get disabled() {
                  return isLoading();
                },
                small: true,
                get wallets() {
                  return walletList().slice(-(walletList().length - 4));
                },
                isMobile: isMobile2,
                onClickWallet: handleClickWallet,
                onClickOther: handleClickOther
              });
            },
            onClickShowMore: handleClickShowMoreContent,
            onCloseClick: () => handleCloseAlert(),
            get onBackClick() {
              return createMemo(() => !!(currentInfo() === "install" && !isMobile2))() ? () => setCurrentInfo("top-wallets") : createMemo(() => currentInfo() === "qr")() ? () => setCurrentInfo("top-wallets") : createMemo(() => !!(currentInfo() === "install" && isMobile2))() ? () => setCurrentInfo("wallets") : createMemo(() => !!(currentInfo() === "wallets" && isMobile2))() ? () => setCurrentInfo("top-wallets") : currentInfo() === "help" ? () => setCurrentInfo(previousInfo()) : void 0;
            }
          });
        })(), null);
        insert(_el$, (() => {
          const _c$2 = createMemo(() => !!!config2.pairingPayload);
          return () => _c$2() && createComponent(Alert, {
            get open() {
              return isOpen$1();
            },
            get content() {
              return createComponent(Info, {
                bigIcon: true,
                get icon() {
                  return _tmpl$5$1.cloneNode(true);
                },
                get title() {
                  return config2.title || "No title";
                },
                get description() {
                  return config2.body || "No description";
                },
                get data() {
                  return config2.data;
                },
                buttons: [{
                  label: "Close",
                  type: "primary",
                  onClick: () => handleCloseAlert()
                }]
              });
            },
            onCloseClick: () => handleCloseAlert()
          });
        })(), null);
        return _el$;
      })();
    }, shadowRoot);
    document.body.prepend(shadowRootEl);
    setTimeout(() => {
      setIsOpen$1(true);
    }, 50);
  }
  return "";
});
var localDesktopList = desktopList;
var localExtensionList = extensionList;
var localWebList = webList;
var localiOSList = iOSList;
var getDesktopList = () => {
  return localDesktopList;
};
var setDesktopList = (desktopList2) => {
  localDesktopList = desktopList2;
};
var getExtensionList = () => {
  return localExtensionList;
};
var setExtensionList = (extensionList2) => {
  localExtensionList = extensionList2;
};
var getWebList = () => {
  return localWebList;
};
var setWebList = (webList2) => {
  localWebList = webList2;
};
var getiOSList = () => {
  return localiOSList;
};
var setiOSList = (iosList) => {
  localiOSList = iosList;
};
var Platform;
(function(Platform2) {
  Platform2[Platform2["DESKTOP"] = 0] = "DESKTOP";
  Platform2[Platform2["IOS"] = 1] = "IOS";
  Platform2[Platform2["ANDROID"] = 2] = "ANDROID";
})(Platform || (Platform = {}));
var WalletType;
(function(WalletType2) {
  WalletType2["IOS"] = "ios";
  WalletType2["ANDROID"] = "android";
  WalletType2["EXTENSION"] = "extension";
  WalletType2["DESKTOP"] = "desktop";
  WalletType2["WEB"] = "web";
})(WalletType || (WalletType = {}));
var _tmpl$ = template(`<img>`, 1);
var _tmpl$2 = template(`<h3></h3>`, 2);
var _tmpl$3 = template(`<p class="toast-label"></p>`, 2);
var _tmpl$4 = template(`<div><div class="toast-header"><div class="toast-button-icon"></div></div></div>`, 6);
var _tmpl$5 = template(`<p class="toast-label">props.label</p>`, 2);
var _tmpl$6 = template(`<div class="toast-action-button">Open Wallet</div>`, 2);
var _tmpl$7 = template(`<div class="toast-body"></div>`, 2);
var _tmpl$8 = template(`<div class="toast-action-wrapper"><p></p></div>`, 4);
var _tmpl$9 = template(`<div class="toast-action-button"></div>`, 2);
function parseWallet(inputString, walletInfo) {
  const regex = /({{\s*wallet\s*}})/g;
  const parts = inputString.split(regex);
  return parts.map((part) => {
    if (part.match(regex)) {
      return [(() => {
        const _el$ = _tmpl$.cloneNode(true);
        createRenderEffect(() => setAttribute(_el$, "src", walletInfo.icon));
        return _el$;
      })(), (() => {
        const _el$2 = _tmpl$2.cloneNode(true);
        insert(_el$2, () => walletInfo.name);
        return _el$2;
      })()];
    } else {
      return (() => {
        const _el$3 = _tmpl$3.cloneNode(true);
        insert(_el$3, part);
        return _el$3;
      })();
    }
  });
}
var [showMoreInfo, setShowMoreInfo] = createSignal(true);
var Toast = (props) => {
  const hasWalletObject = props.label.includes("{{wallet}}") && props.walletInfo;
  const isRequestSentToast = props.label.includes("Request sent to");
  if (isRequestSentToast) {
    setShowMoreInfo(false);
    setTimeout(() => {
      setShowMoreInfo(true);
    }, 3e3);
  }
  return (() => {
    const _el$4 = _tmpl$4.cloneNode(true), _el$5 = _el$4.firstChild, _el$6 = _el$5.firstChild;
    insert(_el$5, createComponent(Loader, {}), _el$6);
    insert(_el$5, (() => {
      const _c$ = createMemo(() => !!(hasWalletObject && props.walletInfo));
      return () => _c$() && createMemo(() => parseWallet(props.label, props.walletInfo));
    })(), _el$6);
    insert(_el$5, !hasWalletObject && _tmpl$5.cloneNode(true), _el$6);
    insert(_el$5, (() => {
      const _c$2 = createMemo(() => !!props.openWalletAction);
      return () => _c$2() && (() => {
        const _el$8 = _tmpl$6.cloneNode(true);
        _el$8.$$click = () => {
          if (props && props.openWalletAction) {
            props === null || props === void 0 ? void 0 : props.openWalletAction();
          }
        };
        return _el$8;
      })();
    })(), _el$6);
    addEventListener(_el$6, "click", props.onClickClose, true);
    insert(_el$6, createComponent(CloseIcon, {}));
    insert(_el$4, (() => {
      const _c$3 = createMemo(() => !!(props.actions && showMoreInfo()));
      return () => _c$3() && (() => {
        const _el$9 = _tmpl$7.cloneNode(true);
        insert(_el$9, createComponent(For, {
          get each() {
            return props.actions;
          },
          children: (action) => (() => {
            const _el$10 = _tmpl$8.cloneNode(true), _el$11 = _el$10.firstChild;
            insert(_el$11, () => action.text);
            insert(_el$10, (() => {
              const _c$4 = createMemo(() => !!action.actionText);
              return () => _c$4() && (() => {
                const _el$12 = _tmpl$9.cloneNode(true);
                _el$12.$$click = () => {
                  if (action.actionCallback)
                    action.actionCallback();
                };
                insert(_el$12, () => action.actionText);
                return _el$12;
              })();
            })(), null);
            createRenderEffect(() => className(_el$11, `toast-action-label ${action.isBold ? "toast-action-bold" : ""}`));
            return _el$10;
          })()
        }));
        return _el$9;
      })();
    })(), null);
    createRenderEffect(() => className(_el$4, props.open ? "toast-wrapper-show" : "toast-wrapper-hide"));
    return _el$4;
  })();
};
delegateEvents(["click"]);
var styles = ".toast-wrapper-show {\n  max-width: 460px;\n  overflow: hidden;\n  background-color: white;\n  position: fixed;\n  top: 12px;\n  right: 12px;\n  border-radius: 6px;\n  transition: all ease 0.3s;\n  transform: translateY(0px) scale(1);\n  z-index: 1000000;\n  -webkit-box-shadow: 0px 4px 11px -4px rgba(0, 0, 0, 0.45);\n  -moz-box-shadow: 0px 4px 11px -4px rgba(0, 0, 0, 0.45);\n  box-shadow: 0px 4px 11px -4px rgba(0, 0, 0, 0.45);\n}\n\n.toast-wrapper-hide {\n  max-width: 460px;\n  overflow: hidden;\n  background-color: white;\n  position: fixed;\n  top: 12px;\n  right: 12px;\n  border-radius: 6px;\n  transition: all ease 0.3s;\n  transform: translateY(-150px) scale(0.2);\n  z-index: 1000000;\n  -webkit-box-shadow: 0px 4px 11px -4px rgba(0, 0, 0, 0.45);\n  -moz-box-shadow: 0px 4px 11px -4px rgba(0, 0, 0, 0.45);\n  box-shadow: 0px 4px 11px -4px rgba(0, 0, 0, 0.45);\n}\n\n.toast-header {\n  padding: 0px 0.6em 0px 1.2em;\n  display: flex;\n  align-items: center;\n  gap: 6px;\n  overflow: hidden;\n  position: relative;\n}\n\n.toast-header img {\n  width: 24px;\n}\n\n.toast-header h3 {\n  font-weight: bold;\n  color: #334155;\n  font-size: 0.8em;\n  margin-right: auto;\n}\n\n.toast-label {\n  margin: 1em 0em 1em 0em;\n  color: #334155;\n  font-size: 0.9em;\n}\n\n.toast-button-icon {\n  width: 24px;\n  height: 24px;\n  padding: 2px;\n  border-radius: 100%;\n  border: 1px solid #cbd5e1;\n  display: flex;\n  align-items: center;\n  justify-content: center;\n  cursor: pointer;\n  fill: #64748b;\n  transition: all ease 0.2s;\n  margin-left: auto;\n}\n\n.toast-button-icon:hover {\n  background-color: #475569;\n  border: 1px solid #475569;\n  fill: #e2e8f0;\n}\n\n.toast-body {\n  padding: 0.6em 1.2em;\n}\n\n.toast-action-wrapper {\n  display: flex;\n  align-items: center;\n  justify-content: space-between;\n}\n\n.toast-action-label {\n  margin: 0.8em 0em;\n  font-size: 0.8em;\n  color: #64748b;\n}\n\n.toast-action-bold {\n  font-weight: bold;\n  color: #334155;\n}\n\n.toast-action-button {\n  cursor: pointer;\n  font-size: 0.8em;\n  font-weight: 600;\n  color: #3880ff;\n  transition: all ease 0.2s;\n  border-radius: 6px;\n  padding: 0.4em 0.8em;\n}\n\n.toast-action-button:hover {\n  background-color: #e4eeff;\n  transition: all ease 0.2s;\n}\n\n@media only screen and (max-width: 800px) {\n  .toast-wrapper-show {\n    width: calc(100% - 24px);\n  }\n\n  .toast-wrapper-hide {\n    width: calc(100% - 24px);\n  }\n}\n";
var dispose = null;
var [isOpen, setIsOpen] = createSignal(false);
var [renderLast, setRenderLast] = createSignal("");
var ANIMATION_TIME = 300;
var globalTimeout;
var createToast = (config2) => {
  const shadowRootEl = document.createElement("div");
  shadowRootEl.setAttribute("id", "beacon-toast-wrapper");
  shadowRootEl.style.height = "0px";
  const shadowRoot = shadowRootEl.attachShadow({
    mode: "open"
  });
  const style2 = document.createElement("style");
  style2.textContent = styles;
  shadowRoot.appendChild(style2);
  const style22 = document.createElement("style");
  style22.textContent = styles$8;
  shadowRoot.appendChild(style22);
  const styleFonts = document.createElement("style");
  styleFonts.textContent = "* { font-family: system-ui, -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Roboto', 'Oxygen', 'Ubuntu', 'Cantarell', 'Fira Sans', 'Droid Sans', 'Helvetica Neue', 'Segoe UI Emoji', 'Apple Color Emoji', 'Noto Color Emoji', sans-serif;}";
  shadowRoot.appendChild(styleFonts);
  dispose = render(() => createComponent(Toast, {
    get label() {
      return config2.body;
    },
    get open() {
      return isOpen();
    },
    onClickClose: () => {
      closeToast();
    },
    get actions() {
      return config2.actions;
    },
    get walletInfo() {
      return config2.walletInfo;
    },
    get openWalletAction() {
      return config2.openWalletAction;
    }
  }), shadowRoot);
  document.body.prepend(shadowRootEl);
  setTimeout(() => {
    setIsOpen(true);
  }, 50);
  clearTimeout(globalTimeout);
  if (config2.timer) {
    globalTimeout = setTimeout(() => closeToast(), config2.timer);
  }
};
var closeToast = () => new Promise((resolve) => {
  if (isServer) {
    console.log("DO NOT RUN ON SERVER");
    resolve();
  }
  setIsOpen(false);
  setTimeout(() => {
    if (dispose)
      dispose();
    if (document.getElementById("beacon-toast-wrapper"))
      document.getElementById("beacon-toast-wrapper").remove();
    resolve();
  }, ANIMATION_TIME);
});
var openToast = (config2) => __awaiter27(void 0, void 0, void 0, function* () {
  if (isServer) {
    console.log("DO NOT RUN ON SERVER");
    return;
  }
  const id = yield generateGUID();
  setRenderLast(id);
  yield closeToast();
  if (id === renderLast())
    createToast(config2);
});

// node_modules/@taquito/beacon-wallet/node_modules/@airgap/beacon-dapp/dist/esm/dapp-client/DAppClient.js
var import_axios3 = __toESM(require_axios());
var bs58check5 = __toESM(require_bs58check());

// node_modules/@taquito/beacon-wallet/node_modules/@airgap/beacon-dapp/dist/esm/utils/shorten-string.js
var shortenString = (text) => {
  if (text.length >= 12) {
    return `${text.substr(0, 5)}...${text.substr(-5)}`;
  }
  return text;
};

// node_modules/@taquito/beacon-wallet/node_modules/@airgap/beacon-dapp/dist/esm/events.js
var __awaiter28 = function(thisArg, _arguments, P2, generator) {
  function adopt(value) {
    return value instanceof P2 ? value : new P2(function(resolve) {
      resolve(value);
    });
  }
  return new (P2 || (P2 = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var logger11 = new Logger("BeaconEvents");
var SUCCESS_TIMER = 5 * 1e3;
var BeaconEvent;
(function(BeaconEvent2) {
  BeaconEvent2["PERMISSION_REQUEST_SENT"] = "PERMISSION_REQUEST_SENT";
  BeaconEvent2["PERMISSION_REQUEST_SUCCESS"] = "PERMISSION_REQUEST_SUCCESS";
  BeaconEvent2["PERMISSION_REQUEST_ERROR"] = "PERMISSION_REQUEST_ERROR";
  BeaconEvent2["OPERATION_REQUEST_SENT"] = "OPERATION_REQUEST_SENT";
  BeaconEvent2["OPERATION_REQUEST_SUCCESS"] = "OPERATION_REQUEST_SUCCESS";
  BeaconEvent2["OPERATION_REQUEST_ERROR"] = "OPERATION_REQUEST_ERROR";
  BeaconEvent2["SIGN_REQUEST_SENT"] = "SIGN_REQUEST_SENT";
  BeaconEvent2["SIGN_REQUEST_SUCCESS"] = "SIGN_REQUEST_SUCCESS";
  BeaconEvent2["SIGN_REQUEST_ERROR"] = "SIGN_REQUEST_ERROR";
  BeaconEvent2["BROADCAST_REQUEST_SENT"] = "BROADCAST_REQUEST_SENT";
  BeaconEvent2["BROADCAST_REQUEST_SUCCESS"] = "BROADCAST_REQUEST_SUCCESS";
  BeaconEvent2["BROADCAST_REQUEST_ERROR"] = "BROADCAST_REQUEST_ERROR";
  BeaconEvent2["ACKNOWLEDGE_RECEIVED"] = "ACKNOWLEDGE_RECEIVED";
  BeaconEvent2["LOCAL_RATE_LIMIT_REACHED"] = "LOCAL_RATE_LIMIT_REACHED";
  BeaconEvent2["NO_PERMISSIONS"] = "NO_PERMISSIONS";
  BeaconEvent2["ACTIVE_ACCOUNT_SET"] = "ACTIVE_ACCOUNT_SET";
  BeaconEvent2["ACTIVE_TRANSPORT_SET"] = "ACTIVE_TRANSPORT_SET";
  BeaconEvent2["SHOW_PREPARE"] = "SHOW_PREPARE";
  BeaconEvent2["HIDE_UI"] = "HIDE_UI";
  BeaconEvent2["PAIR_INIT"] = "PAIR_INIT";
  BeaconEvent2["PAIR_SUCCESS"] = "PAIR_SUCCESS";
  BeaconEvent2["CHANNEL_CLOSED"] = "CHANNEL_CLOSED";
  BeaconEvent2["INTERNAL_ERROR"] = "INTERNAL_ERROR";
  BeaconEvent2["UNKNOWN"] = "UNKNOWN";
})(BeaconEvent || (BeaconEvent = {}));
var showSentToast = (data) => __awaiter28(void 0, void 0, void 0, function* () {
  let openWalletAction;
  const actions = [];
  if (data.walletInfo.deeplink) {
    if (data.walletInfo.type === "web" || data.walletInfo.type === "mobile" && isMobile(window) || data.walletInfo.type === "desktop" && !isMobile(window)) {
      const link = data.walletInfo.deeplink;
      openWalletAction = () => __awaiter28(void 0, void 0, void 0, function* () {
        const a2 = document.createElement("a");
        a2.setAttribute("rel", "noopener");
        a2.setAttribute("href", link);
        a2.setAttribute("target", "_blank");
        a2.dispatchEvent(new MouseEvent("click", { view: window, bubbles: true, cancelable: true }));
      });
    }
  }
  actions.push({
    text: `No answer from your wallet received yet. Please make sure the wallet is open.`,
    isBold: true
  });
  actions.push({
    text: "Did you make a mistake?",
    actionText: "Cancel Request",
    actionCallback: () => __awaiter28(void 0, void 0, void 0, function* () {
      yield closeToast();
    })
  });
  actions.push({
    text: "Wallet not receiving request?",
    actionText: "Reset Connection",
    actionCallback: () => __awaiter28(void 0, void 0, void 0, function* () {
      yield closeToast();
      const resetCallback = data.extraInfo.resetCallback;
      if (resetCallback) {
        logger11.log("showSentToast", "resetCallback invoked");
        yield resetCallback();
      }
    })
  });
  openToast({
    body: `Request sent to {{wallet}}`,
    walletInfo: data.walletInfo,
    state: "loading",
    actions,
    openWalletAction
  }).catch((toastError) => console.error(toastError));
});
var showAcknowledgedToast = (data) => __awaiter28(void 0, void 0, void 0, function* () {
  openToast({
    body: "Awaiting confirmation in {{wallet}}",
    state: "acknowledge",
    walletInfo: data.walletInfo
  }).catch((toastError) => console.error(toastError));
});
var showPrepare = (data) => __awaiter28(void 0, void 0, void 0, function* () {
  const text = data.walletInfo ? `Preparing Request for {{wallet}}...` : "Preparing Request...";
  openToast({
    body: text,
    state: "prepare",
    walletInfo: data.walletInfo
  }).catch((toastError) => console.error(toastError));
});
var hideUI = (elements) => __awaiter28(void 0, void 0, void 0, function* () {
  if (elements) {
    if (elements.includes("alert")) {
      closeAlerts();
    }
    if (elements.includes("toast")) {
      closeToast();
    }
  } else {
    closeToast();
  }
});
var showNoPermissionAlert = () => __awaiter28(void 0, void 0, void 0, function* () {
  yield openAlert({
    title: "No Permission",
    body: "Please allow the wallet to handle this type of request."
  });
});
var showErrorToast = (response, buttons) => __awaiter28(void 0, void 0, void 0, function* () {
  var _a3, _b, _c, _d, _e3, _f;
  const error = response.errorResponse.errorType ? BeaconError.getError(response.errorResponse.errorType, response.errorResponse.errorData) : new UnknownBeaconError();
  const actions = [
    {
      text: error.title,
      isBold: true
    }
  ];
  if (response.errorResponse.errorType === BeaconErrorType.TRANSACTION_INVALID_ERROR && response.errorResponse.errorData) {
    const err = response.errorResponse.errorData;
    const errorMessages = response.errorMessages;
    let hasHumandReadableError = false;
    if (((_a3 = err[0]) === null || _a3 === void 0 ? void 0 : _a3.contract_handle) && errorMessages && (errorMessages === null || errorMessages === void 0 ? void 0 : errorMessages[err[0].contract_handle])) {
      const errCode = (_d = (_c = (_b = err[1]) === null || _b === void 0 ? void 0 : _b.with) === null || _c === void 0 ? void 0 : _c.int) !== null && _d !== void 0 ? _d : (_f = (_e3 = err[1]) === null || _e3 === void 0 ? void 0 : _e3.with) === null || _f === void 0 ? void 0 : _f.string;
      const contractErrors = errorMessages === null || errorMessages === void 0 ? void 0 : errorMessages[err[0].contract_handle];
      if (errCode && (contractErrors === null || contractErrors === void 0 ? void 0 : contractErrors[errCode])) {
        actions.push({
          text: contractErrors === null || contractErrors === void 0 ? void 0 : contractErrors[errCode],
          isBold: true
        });
        hasHumandReadableError = true;
      }
    }
    if (!hasHumandReadableError) {
      actions.push({
        text: error.description
      });
    }
    actions.push({
      text: "",
      actionText: "Show Details",
      actionCallback: () => __awaiter28(void 0, void 0, void 0, function* () {
        yield closeToast();
        yield openAlert({
          title: error.title,
          // eslint-disable-next-line @typescript-eslint/unbound-method
          body: error.fullDescription.description,
          data: error.fullDescription.data,
          buttons
        });
      })
    });
  }
  yield openToast({
    body: `{{wallet}} has returned an error`,
    timer: response.errorResponse.errorType === BeaconErrorType.ABORTED_ERROR ? SUCCESS_TIMER : void 0,
    state: "finished",
    walletInfo: response.walletInfo,
    actions
  });
});
var showRateLimitReached = () => __awaiter28(void 0, void 0, void 0, function* () {
  openAlert({
    title: "Error",
    body: "Rate limit reached. Please slow down",
    buttons: [{ text: "Done", style: "outline" }],
    timer: 3e3
  }).catch((toastError) => console.error(toastError));
});
var showExtensionConnectedAlert = () => __awaiter28(void 0, void 0, void 0, function* () {
  yield closeAlerts();
});
var showChannelClosedAlert = () => __awaiter28(void 0, void 0, void 0, function* () {
  yield openAlert({
    title: "Channel closed",
    body: `Your peer has closed the connection.`,
    buttons: [{ text: "Done", style: "outline" }],
    timer: 1500
  });
});
var showInternalErrorAlert = (data) => __awaiter28(void 0, void 0, void 0, function* () {
  var _g;
  const buttons = [...(_g = data.buttons) !== null && _g !== void 0 ? _g : []];
  buttons.push({ text: "Done", style: "outline" });
  const alertConfig = {
    title: "Internal Error",
    body: data.text,
    buttons
  };
  yield openAlert(alertConfig);
});
var showPairAlert = (data) => __awaiter28(void 0, void 0, void 0, function* () {
  console.log("showPairAlert");
  const alertConfig = {
    title: "Choose your preferred wallet",
    body: `<p></p>`,
    pairingPayload: {
      p2pSyncCode: data.p2pPeerInfo,
      walletConnectSyncCode: data.walletConnectPeerInfo,
      postmessageSyncCode: data.postmessagePeerInfo,
      networkType: data.networkType
    },
    // eslint-disable-next-line @typescript-eslint/unbound-method
    closeButtonCallback: data.abortedHandler,
    disclaimerText: data.disclaimerText,
    analytics: data.analytics,
    featuredWallets: data.featuredWallets
  };
  yield openAlert(alertConfig);
});
var showPermissionSuccessAlert = (data) => __awaiter28(void 0, void 0, void 0, function* () {
  const { output } = data;
  yield openToast({
    body: `{{wallet}} has granted permission`,
    timer: SUCCESS_TIMER,
    walletInfo: data.walletInfo,
    state: "finished",
    actions: [
      {
        text: "Address",
        actionText: shortenString(output.address),
        isBold: true
      },
      {
        text: "Network",
        actionText: `${output.network.type}`
      },
      {
        text: "Permissions",
        actionText: output.scopes.join(", ")
      }
    ]
  });
});
var showOperationSuccessAlert = (data) => __awaiter28(void 0, void 0, void 0, function* () {
  const { account, output, blockExplorer } = data;
  yield openToast({
    body: `{{wallet}} successfully submitted operation`,
    timer: SUCCESS_TIMER,
    state: "finished",
    walletInfo: data.walletInfo,
    actions: [
      {
        text: shortenString(output.transactionHash),
        isBold: true,
        actionText: `Open Blockexplorer`,
        actionLogo: "external",
        actionCallback: () => __awaiter28(void 0, void 0, void 0, function* () {
          const link = yield blockExplorer.getTransactionLink(output.transactionHash, account.network);
          window.open(link, "_blank", "noopener");
          yield closeToast();
        })
      }
    ]
  });
});
var showSignSuccessAlert = (data) => __awaiter28(void 0, void 0, void 0, function* () {
  const output = data.output;
  yield openToast({
    body: `{{wallet}} successfully signed payload`,
    timer: SUCCESS_TIMER,
    state: "finished",
    walletInfo: data.walletInfo,
    actions: [
      {
        text: `Signature: ${shortenString(output.signature)}`,
        actionText: "Copy to clipboard",
        actionCallback: () => __awaiter28(void 0, void 0, void 0, function* () {
          navigator.clipboard.writeText(output.signature).then(() => {
            logger11.log("showSignSuccessAlert", "Copying to clipboard was successful!");
          }, (err) => {
            logger11.error("showSignSuccessAlert", "Could not copy text to clipboard: ", err);
          });
          yield closeToast();
        })
      }
    ]
  });
});
var showBroadcastSuccessAlert = (data) => __awaiter28(void 0, void 0, void 0, function* () {
  const { network, output, blockExplorer } = data;
  yield openToast({
    body: `{{wallet}} successfully injected operation`,
    timer: SUCCESS_TIMER,
    state: "finished",
    walletInfo: data.walletInfo,
    actions: [
      {
        text: shortenString(output.transactionHash),
        isBold: true,
        actionText: `Open Blockexplorer`,
        actionLogo: "external",
        actionCallback: () => __awaiter28(void 0, void 0, void 0, function* () {
          const link = yield blockExplorer.getTransactionLink(output.transactionHash, network);
          window.open(link, "_blank", "noopener");
          yield closeToast();
        })
      }
    ]
  });
});
var emptyHandler = () => () => __awaiter28(void 0, void 0, void 0, function* () {
});
var defaultEventCallbacks = {
  [BeaconEvent.PERMISSION_REQUEST_SENT]: showSentToast,
  [BeaconEvent.PERMISSION_REQUEST_SUCCESS]: showPermissionSuccessAlert,
  [BeaconEvent.PERMISSION_REQUEST_ERROR]: showErrorToast,
  [BeaconEvent.OPERATION_REQUEST_SENT]: showSentToast,
  [BeaconEvent.OPERATION_REQUEST_SUCCESS]: showOperationSuccessAlert,
  [BeaconEvent.OPERATION_REQUEST_ERROR]: showErrorToast,
  [BeaconEvent.SIGN_REQUEST_SENT]: showSentToast,
  [BeaconEvent.SIGN_REQUEST_SUCCESS]: showSignSuccessAlert,
  [BeaconEvent.SIGN_REQUEST_ERROR]: showErrorToast,
  // TODO: ENCRYPTION
  // [BeaconEvent.ENCRYPT_REQUEST_SENT]: showSentToast,
  // [BeaconEvent.ENCRYPT_REQUEST_SUCCESS]: showEncryptSuccessAlert,
  // [BeaconEvent.ENCRYPT_REQUEST_ERROR]: showErrorToast,
  [BeaconEvent.BROADCAST_REQUEST_SENT]: showSentToast,
  [BeaconEvent.BROADCAST_REQUEST_SUCCESS]: showBroadcastSuccessAlert,
  [BeaconEvent.BROADCAST_REQUEST_ERROR]: showErrorToast,
  [BeaconEvent.ACKNOWLEDGE_RECEIVED]: showAcknowledgedToast,
  [BeaconEvent.LOCAL_RATE_LIMIT_REACHED]: showRateLimitReached,
  [BeaconEvent.NO_PERMISSIONS]: showNoPermissionAlert,
  [BeaconEvent.ACTIVE_ACCOUNT_SET]: emptyHandler(),
  [BeaconEvent.ACTIVE_TRANSPORT_SET]: emptyHandler(),
  [BeaconEvent.SHOW_PREPARE]: showPrepare,
  [BeaconEvent.HIDE_UI]: hideUI,
  [BeaconEvent.PAIR_INIT]: showPairAlert,
  [BeaconEvent.PAIR_SUCCESS]: showExtensionConnectedAlert,
  [BeaconEvent.CHANNEL_CLOSED]: showChannelClosedAlert,
  [BeaconEvent.INTERNAL_ERROR]: showInternalErrorAlert,
  [BeaconEvent.UNKNOWN]: emptyHandler()
};
var BeaconEventHandler = class {
  constructor(eventsToOverride = {}, overrideAll) {
    this.callbackMap = {
      [BeaconEvent.PERMISSION_REQUEST_SENT]: [defaultEventCallbacks.PERMISSION_REQUEST_SENT],
      [BeaconEvent.PERMISSION_REQUEST_SUCCESS]: [defaultEventCallbacks.PERMISSION_REQUEST_SUCCESS],
      [BeaconEvent.PERMISSION_REQUEST_ERROR]: [defaultEventCallbacks.PERMISSION_REQUEST_ERROR],
      [BeaconEvent.OPERATION_REQUEST_SENT]: [defaultEventCallbacks.OPERATION_REQUEST_SENT],
      [BeaconEvent.OPERATION_REQUEST_SUCCESS]: [defaultEventCallbacks.OPERATION_REQUEST_SUCCESS],
      [BeaconEvent.OPERATION_REQUEST_ERROR]: [defaultEventCallbacks.OPERATION_REQUEST_ERROR],
      [BeaconEvent.SIGN_REQUEST_SENT]: [defaultEventCallbacks.SIGN_REQUEST_SENT],
      [BeaconEvent.SIGN_REQUEST_SUCCESS]: [defaultEventCallbacks.SIGN_REQUEST_SUCCESS],
      [BeaconEvent.SIGN_REQUEST_ERROR]: [defaultEventCallbacks.SIGN_REQUEST_ERROR],
      // TODO: ENCRYPTION
      // [BeaconEvent.ENCRYPT_REQUEST_SENT]: [defaultEventCallbacks.ENCRYPT_REQUEST_SENT],
      // [BeaconEvent.ENCRYPT_REQUEST_SUCCESS]: [defaultEventCallbacks.ENCRYPT_REQUEST_SUCCESS],
      // [BeaconEvent.ENCRYPT_REQUEST_ERROR]: [defaultEventCallbacks.ENCRYPT_REQUEST_ERROR],
      [BeaconEvent.BROADCAST_REQUEST_SENT]: [defaultEventCallbacks.BROADCAST_REQUEST_SENT],
      [BeaconEvent.BROADCAST_REQUEST_SUCCESS]: [defaultEventCallbacks.BROADCAST_REQUEST_SUCCESS],
      [BeaconEvent.BROADCAST_REQUEST_ERROR]: [defaultEventCallbacks.BROADCAST_REQUEST_ERROR],
      [BeaconEvent.ACKNOWLEDGE_RECEIVED]: [defaultEventCallbacks.ACKNOWLEDGE_RECEIVED],
      [BeaconEvent.LOCAL_RATE_LIMIT_REACHED]: [defaultEventCallbacks.LOCAL_RATE_LIMIT_REACHED],
      [BeaconEvent.NO_PERMISSIONS]: [defaultEventCallbacks.NO_PERMISSIONS],
      [BeaconEvent.ACTIVE_ACCOUNT_SET]: [defaultEventCallbacks.ACTIVE_ACCOUNT_SET],
      [BeaconEvent.ACTIVE_TRANSPORT_SET]: [defaultEventCallbacks.ACTIVE_TRANSPORT_SET],
      [BeaconEvent.SHOW_PREPARE]: [defaultEventCallbacks.SHOW_PREPARE],
      [BeaconEvent.HIDE_UI]: [defaultEventCallbacks.HIDE_UI],
      [BeaconEvent.PAIR_INIT]: [defaultEventCallbacks.PAIR_INIT],
      [BeaconEvent.PAIR_SUCCESS]: [defaultEventCallbacks.PAIR_SUCCESS],
      [BeaconEvent.CHANNEL_CLOSED]: [defaultEventCallbacks.CHANNEL_CLOSED],
      [BeaconEvent.INTERNAL_ERROR]: [defaultEventCallbacks.INTERNAL_ERROR],
      [BeaconEvent.UNKNOWN]: [defaultEventCallbacks.UNKNOWN]
    };
    if (overrideAll) {
      this.setAllHandlers();
    }
    this.overrideDefaults(eventsToOverride);
  }
  /**
   * A method to subscribe to a specific beacon event and register a callback
   *
   * @param event The event being emitted
   * @param eventCallback The callback that will be invoked
   */
  on(event, eventCallback) {
    return __awaiter28(this, void 0, void 0, function* () {
      const listeners = this.callbackMap[event] || [];
      listeners.push(eventCallback);
      this.callbackMap[event] = listeners;
    });
  }
  /**
   * Emit a beacon event
   *
   * @param event The event being emitted
   * @param data The data to be emit
   */
  emit(event, data, eventCallback) {
    return __awaiter28(this, void 0, void 0, function* () {
      const listeners = this.callbackMap[event];
      if (listeners && listeners.length > 0) {
        listeners.forEach((listener) => __awaiter28(this, void 0, void 0, function* () {
          try {
            yield listener(data, eventCallback);
          } catch (listenerError) {
            logger11.error(`error handling event ${event}`, listenerError);
          }
        }));
      }
    });
  }
  /**
   * Override beacon event default callbacks. This can be used to disable default alert/toast behaviour
   *
   * @param eventsToOverride An object with the events to override
   */
  overrideDefaults(eventsToOverride) {
    Object.keys(eventsToOverride).forEach((untypedEvent) => {
      const eventType = untypedEvent;
      const event = eventsToOverride[eventType];
      if (event) {
        this.callbackMap[eventType] = [event.handler];
      }
    });
  }
  /**
   * Set all event callbacks to a specific handler.
   */
  setAllHandlers(handler) {
    Object.keys(this.callbackMap).forEach((untypedEvent) => {
      const eventType = untypedEvent;
      this.callbackMap[eventType] = [];
      if (handler) {
        this.callbackMap[eventType].push(handler);
      } else {
        this.callbackMap[eventType].push((...data) => {
          logger11.log(untypedEvent, ...data);
        });
      }
    });
  }
};

// node_modules/@taquito/beacon-wallet/node_modules/@airgap/beacon-dapp/dist/esm/beacon-message-events.js
var messageEvents = {
  [BeaconMessageType.BlockchainRequest]: {
    sent: BeaconEvent.UNKNOWN,
    success: BeaconEvent.UNKNOWN,
    error: BeaconEvent.UNKNOWN
  },
  [BeaconMessageType.BlockchainResponse]: {
    sent: BeaconEvent.UNKNOWN,
    success: BeaconEvent.UNKNOWN,
    error: BeaconEvent.UNKNOWN
  },
  [BeaconMessageType.PermissionRequest]: {
    sent: BeaconEvent.PERMISSION_REQUEST_SENT,
    success: BeaconEvent.PERMISSION_REQUEST_SUCCESS,
    error: BeaconEvent.PERMISSION_REQUEST_ERROR
  },
  [BeaconMessageType.PermissionResponse]: {
    sent: BeaconEvent.UNKNOWN,
    success: BeaconEvent.UNKNOWN,
    error: BeaconEvent.UNKNOWN
  },
  [BeaconMessageType.OperationRequest]: {
    sent: BeaconEvent.OPERATION_REQUEST_SENT,
    success: BeaconEvent.OPERATION_REQUEST_SUCCESS,
    error: BeaconEvent.OPERATION_REQUEST_ERROR
  },
  [BeaconMessageType.OperationResponse]: {
    sent: BeaconEvent.UNKNOWN,
    success: BeaconEvent.UNKNOWN,
    error: BeaconEvent.UNKNOWN
  },
  [BeaconMessageType.SignPayloadRequest]: {
    sent: BeaconEvent.SIGN_REQUEST_SENT,
    success: BeaconEvent.SIGN_REQUEST_SUCCESS,
    error: BeaconEvent.SIGN_REQUEST_ERROR
  },
  [BeaconMessageType.SignPayloadResponse]: {
    sent: BeaconEvent.UNKNOWN,
    success: BeaconEvent.UNKNOWN,
    error: BeaconEvent.UNKNOWN
  },
  // TODO: ENCRYPTION
  // [BeaconMessageType.EncryptPayloadRequest]: {
  //   sent: BeaconEvent.ENCRYPT_REQUEST_SENT,
  //   success: BeaconEvent.ENCRYPT_REQUEST_SUCCESS,
  //   error: BeaconEvent.ENCRYPT_REQUEST_ERROR
  // },
  // [BeaconMessageType.EncryptPayloadResponse]: {
  //   sent: BeaconEvent.UNKNOWN,
  //   success: BeaconEvent.UNKNOWN,
  //   error: BeaconEvent.UNKNOWN
  // },
  [BeaconMessageType.BroadcastRequest]: {
    sent: BeaconEvent.BROADCAST_REQUEST_SENT,
    success: BeaconEvent.BROADCAST_REQUEST_SUCCESS,
    error: BeaconEvent.BROADCAST_REQUEST_ERROR
  },
  [BeaconMessageType.BroadcastResponse]: {
    sent: BeaconEvent.UNKNOWN,
    success: BeaconEvent.UNKNOWN,
    error: BeaconEvent.UNKNOWN
  },
  [BeaconMessageType.Acknowledge]: {
    sent: BeaconEvent.UNKNOWN,
    success: BeaconEvent.UNKNOWN,
    error: BeaconEvent.UNKNOWN
  },
  [BeaconMessageType.Disconnect]: {
    sent: BeaconEvent.UNKNOWN,
    success: BeaconEvent.UNKNOWN,
    error: BeaconEvent.UNKNOWN
  },
  [BeaconMessageType.Error]: {
    sent: BeaconEvent.UNKNOWN,
    success: BeaconEvent.UNKNOWN,
    error: BeaconEvent.UNKNOWN
  }
};

// node_modules/@taquito/beacon-wallet/node_modules/@airgap/beacon-dapp/dist/esm/utils/block-explorer.js
var __awaiter29 = function(thisArg, _arguments, P2, generator) {
  function adopt(value) {
    return value instanceof P2 ? value : new P2(function(resolve) {
      resolve(value);
    });
  }
  return new (P2 || (P2 = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var BlockExplorer = class {
  constructor(rpcUrls) {
    this.rpcUrls = rpcUrls;
  }
  getLinkForNetwork(network) {
    return __awaiter29(this, void 0, void 0, function* () {
      return this.rpcUrls[network.type];
    });
  }
};

// node_modules/@taquito/beacon-wallet/node_modules/@airgap/beacon-dapp/dist/esm/utils/tzkt-blockexplorer.js
var __awaiter30 = function(thisArg, _arguments, P2, generator) {
  function adopt(value) {
    return value instanceof P2 ? value : new P2(function(resolve) {
      resolve(value);
    });
  }
  return new (P2 || (P2 = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var TzktBlockExplorer = class extends BlockExplorer {
  constructor(rpcUrls = {
    [NetworkType.MAINNET]: "https://tzkt.io",
    [NetworkType.GHOSTNET]: "https://ghostnet.tzkt.io",
    [NetworkType.MONDAYNET]: "https://mondaynet.tzkt.io",
    [NetworkType.DAILYNET]: "https://dailynet.tzkt.io",
    [NetworkType.DELPHINET]: "https://delphinet.tzkt.io",
    [NetworkType.EDONET]: "https://edonet.tzkt.io",
    [NetworkType.FLORENCENET]: "https://florencenet.tzkt.io",
    [NetworkType.GRANADANET]: "https://granadanet.tzkt.io",
    [NetworkType.HANGZHOUNET]: "https://hangzhounet.tzkt.io",
    [NetworkType.ITHACANET]: "https://ithacanet.tzkt.io",
    [NetworkType.JAKARTANET]: "https://jakartanet.tzkt.io",
    [NetworkType.KATHMANDUNET]: "https://kathmandunet.tzkt.io",
    [NetworkType.LIMANET]: "https://limanet.tzkt.io",
    [NetworkType.MUMBAINET]: "https://mumbainet.tzkt.io",
    [NetworkType.NAIROBINET]: "https://nairobinet.tzkt.io",
    [NetworkType.CUSTOM]: "https://nairobinet.tzkt.io"
  }) {
    super(rpcUrls);
    this.rpcUrls = rpcUrls;
  }
  getAddressLink(address, network) {
    return __awaiter30(this, void 0, void 0, function* () {
      const blockExplorer = yield this.getLinkForNetwork(network);
      return `${blockExplorer}/${address}`;
    });
  }
  getTransactionLink(transactionId, network) {
    return __awaiter30(this, void 0, void 0, function* () {
      const blockExplorer = yield this.getLinkForNetwork(network);
      return `${blockExplorer}/${transactionId}`;
    });
  }
};

// node_modules/@taquito/beacon-wallet/node_modules/@airgap/beacon-dapp/dist/esm/transports/DappPostMessageTransport.js
var __awaiter31 = function(thisArg, _arguments, P2, generator) {
  function adopt(value) {
    return value instanceof P2 ? value : new P2(function(resolve) {
      resolve(value);
    });
  }
  return new (P2 || (P2 = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var logger12 = new Logger("DappPostMessageTransport");
var DappPostMessageTransport = class extends PostMessageTransport {
  constructor(name, keyPair, storage) {
    super(name, keyPair, storage, StorageKey.TRANSPORT_POSTMESSAGE_PEERS_DAPP);
  }
  startOpenChannelListener() {
    return __awaiter31(this, void 0, void 0, function* () {
      return this.client.listenForChannelOpening((peer) => __awaiter31(this, void 0, void 0, function* () {
        logger12.log("connect", `received PostMessagePairingResponse`, peer);
        yield this.addPeer(peer);
        this._isConnected = TransportStatus.CONNECTED;
        if (this.newPeerListener) {
          this.newPeerListener(peer);
          this.newPeerListener = void 0;
        }
      }));
    });
  }
  listenForNewPeer(newPeerListener) {
    return __awaiter31(this, void 0, void 0, function* () {
      logger12.log("listenForNewPeer");
      this.newPeerListener = newPeerListener;
    });
  }
  stopListeningForNewPeers() {
    return __awaiter31(this, void 0, void 0, function* () {
      logger12.log("stopListeningForNewPeers");
      this.newPeerListener = void 0;
    });
  }
};

// node_modules/@taquito/beacon-wallet/node_modules/@airgap/beacon-dapp/dist/esm/transports/DappP2PTransport.js
var __awaiter32 = function(thisArg, _arguments, P2, generator) {
  function adopt(value) {
    return value instanceof P2 ? value : new P2(function(resolve) {
      resolve(value);
    });
  }
  return new (P2 || (P2 = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var logger13 = new Logger("DappP2PTransport");
var DappP2PTransport = class extends P2PTransport {
  constructor(name, keyPair, storage, matrixNodes, iconUrl, appUrl) {
    super(name, keyPair, storage, matrixNodes, StorageKey.TRANSPORT_P2P_PEERS_DAPP, iconUrl, appUrl);
  }
  startOpenChannelListener() {
    return __awaiter32(this, void 0, void 0, function* () {
      return this.client.listenForChannelOpening((peer) => __awaiter32(this, void 0, void 0, function* () {
        logger13.log("listenForNewPeer", `new publicKey`, peer.publicKey);
        yield this.addPeer(peer);
        this._isConnected = TransportStatus.CONNECTED;
        if (this.newPeerListener) {
          this.newPeerListener(peer);
          this.newPeerListener = void 0;
        }
      }));
    });
  }
  listenForNewPeer(newPeerListener) {
    return __awaiter32(this, void 0, void 0, function* () {
      logger13.log("listenForNewPeer");
      this.newPeerListener = newPeerListener;
    });
  }
  stopListeningForNewPeers() {
    return __awaiter32(this, void 0, void 0, function* () {
      logger13.log("stopListeningForNewPeers");
      this.newPeerListener = void 0;
    });
  }
};

// node_modules/@taquito/beacon-wallet/node_modules/@walletconnect/core/dist/index.es.js
var import_events6 = __toESM(require_events());
var import_keyvaluestorage = __toESM(require_browser());
var import_heartbeat = __toESM(require_cjs2());
var import_logger = __toESM(require_cjs3());

// node_modules/@taquito/beacon-wallet/node_modules/@walletconnect/types/dist/index.es.js
init_esm();
var import_events5 = __toESM(require_events());
var n = class extends IEvents {
  constructor(s) {
    super(), this.opts = s, this.protocol = "wc", this.version = 2;
  }
};
var h = class extends IEvents {
  constructor(s, t) {
    super(), this.core = s, this.logger = t, this.records = /* @__PURE__ */ new Map();
  }
};
var a = class {
  constructor(s, t) {
    this.logger = s, this.core = t;
  }
};
var u = class extends IEvents {
  constructor(s, t) {
    super(), this.relayer = s, this.logger = t;
  }
};
var g = class extends IEvents {
  constructor(s) {
    super();
  }
};
var p = class {
  constructor(s, t, o, w3) {
    this.core = s, this.logger = t, this.name = o;
  }
};
var d = class extends IEvents {
  constructor(s, t) {
    super(), this.relayer = s, this.logger = t;
  }
};
var E = class extends IEvents {
  constructor(s, t) {
    super(), this.core = s, this.logger = t;
  }
};
var y = class {
  constructor(s, t) {
    this.projectId = s, this.logger = t;
  }
};
var b = class {
  constructor(s) {
    this.opts = s, this.protocol = "wc", this.version = 2;
  }
};
var S = class {
  constructor(s) {
    this.client = s;
  }
};

// node_modules/@taquito/beacon-wallet/node_modules/@walletconnect/utils/dist/index.es.js
var import_chacha20poly1305 = __toESM(require_chacha20poly1305());
var import_hkdf = __toESM(require_hkdf());
var import_random3 = __toESM(require_random());
var import_sha256 = __toESM(require_sha256());
var fe = __toESM(require_x25519());
var import_time = __toESM(require_cjs());
var import_window_getters = __toESM(require_cjs4());
var import_window_metadata = __toESM(require_cjs5());
var k = __toESM(require_query_string());
function M(e, n2) {
  return e.includes(":") ? [e] : n2.chains || [];
}
var J = "base10";
var p2 = "base16";
var L = "base64pad";
var x = "utf8";
var Q = 0;
var _ = 1;
var $n = 0;
var Ie = 1;
var Z = 12;
var X = 32;
function jn() {
  const e = fe.generateKeyPair();
  return { privateKey: toString(e.secretKey, p2), publicKey: toString(e.publicKey, p2) };
}
function Dn() {
  const e = (0, import_random3.randomBytes)(X);
  return toString(e, p2);
}
function kn(e, n2) {
  const t = fe.sharedKey(fromString(e, p2), fromString(n2, p2)), r = new import_hkdf.HKDF(import_sha256.SHA256, t).expand(X);
  return toString(r, p2);
}
function Vn(e) {
  const n2 = (0, import_sha256.hash)(fromString(e, p2));
  return toString(n2, p2);
}
function Mn(e) {
  const n2 = (0, import_sha256.hash)(fromString(e, x));
  return toString(n2, p2);
}
function Pe(e) {
  return fromString(`${e}`, J);
}
function $(e) {
  return Number(toString(e, J));
}
function Kn(e) {
  const n2 = Pe(typeof e.type < "u" ? e.type : Q);
  if ($(n2) === _ && typeof e.senderPublicKey > "u")
    throw new Error("Missing sender public key for type 1 envelope");
  const t = typeof e.senderPublicKey < "u" ? fromString(e.senderPublicKey, p2) : void 0, r = typeof e.iv < "u" ? fromString(e.iv, p2) : (0, import_random3.randomBytes)(Z), o = new import_chacha20poly1305.ChaCha20Poly1305(fromString(e.symKey, p2)).seal(r, fromString(e.message, x));
  return Te({ type: n2, sealed: o, iv: r, senderPublicKey: t });
}
function Ln(e) {
  const n2 = new import_chacha20poly1305.ChaCha20Poly1305(fromString(e.symKey, p2)), { sealed: t, iv: r } = ee(e.encoded), o = n2.open(r, t);
  if (o === null)
    throw new Error("Failed to decrypt");
  return toString(o, x);
}
function Te(e) {
  if ($(e.type) === _) {
    if (typeof e.senderPublicKey > "u")
      throw new Error("Missing sender public key for type 1 envelope");
    return toString(concat([e.type, e.senderPublicKey, e.iv, e.sealed]), L);
  }
  return toString(concat([e.type, e.iv, e.sealed]), L);
}
function ee(e) {
  const n2 = fromString(e, L), t = n2.slice($n, Ie), r = Ie;
  if ($(t) === _) {
    const l = r + X, d2 = l + Z, c2 = n2.slice(r, l), u2 = n2.slice(l, d2), a2 = n2.slice(d2);
    return { type: t, sealed: a2, iv: u2, senderPublicKey: c2 };
  }
  const o = r + Z, s = n2.slice(r, o), i2 = n2.slice(o);
  return { type: t, sealed: i2, iv: s };
}
function xn(e, n2) {
  const t = ee(e);
  return Re({ type: $(t.type), senderPublicKey: typeof t.senderPublicKey < "u" ? toString(t.senderPublicKey, p2) : void 0, receiverPublicKey: n2 == null ? void 0 : n2.receiverPublicKey });
}
function Re(e) {
  const n2 = (e == null ? void 0 : e.type) || Q;
  if (n2 === _) {
    if (typeof (e == null ? void 0 : e.senderPublicKey) > "u")
      throw new Error("missing sender public key");
    if (typeof (e == null ? void 0 : e.receiverPublicKey) > "u")
      throw new Error("missing receiver public key");
  }
  return { type: n2, senderPublicKey: e == null ? void 0 : e.senderPublicKey, receiverPublicKey: e == null ? void 0 : e.receiverPublicKey };
}
function Fn(e) {
  return e.type === _ && typeof e.senderPublicKey == "string" && typeof e.receiverPublicKey == "string";
}
var Hn = Object.defineProperty;
var Ae = Object.getOwnPropertySymbols;
var qn = Object.prototype.hasOwnProperty;
var Bn = Object.prototype.propertyIsEnumerable;
var Ue = (e, n2, t) => n2 in e ? Hn(e, n2, { enumerable: true, configurable: true, writable: true, value: t }) : e[n2] = t;
var _e = (e, n2) => {
  for (var t in n2 || (n2 = {}))
    qn.call(n2, t) && Ue(e, t, n2[t]);
  if (Ae)
    for (var t of Ae(n2))
      Bn.call(n2, t) && Ue(e, t, n2[t]);
  return e;
};
var Ce = "ReactNative";
var m = { reactNative: "react-native", node: "node", browser: "browser", unknown: "unknown" };
var je = "js";
function te() {
  return typeof process < "u" && typeof process.versions < "u" && typeof process.versions.node < "u";
}
function H() {
  return !(0, import_window_getters.getDocument)() && !!(0, import_window_getters.getNavigator)() && navigator.product === Ce;
}
function q() {
  return !te() && !!(0, import_window_getters.getNavigator)();
}
function R() {
  return H() ? m.reactNative : te() ? m.node : q() ? m.browser : m.unknown;
}
function De(e, n2) {
  let t = k.parse(e);
  return t = _e(_e({}, t), n2), e = k.stringify(t), e;
}
function zn() {
  return (0, import_window_metadata.getWindowMetadata)() || { name: "", description: "", url: "", icons: [""] };
}
function ke() {
  if (R() === m.reactNative && typeof global < "u" && typeof (global == null ? void 0 : global.Platform) < "u") {
    const { OS: t, Version: r } = global.Platform;
    return [t, r].join("-");
  }
  const e = detect();
  if (e === null)
    return "unknown";
  const n2 = e.os ? e.os.replace(" ", "").toLowerCase() : "unknown";
  return e.type === "browser" ? [n2, e.name, e.version].join("-") : [n2, e.version].join("-");
}
function Ve() {
  var e;
  const n2 = R();
  return n2 === m.browser ? [n2, ((e = (0, import_window_getters.getLocation)()) == null ? void 0 : e.host) || "unknown"].join(":") : n2;
}
function Me(e, n2, t) {
  const r = ke(), o = Ve();
  return [[e, n2].join("-"), [je, t].join("-"), r, o].join("/");
}
function Jn({ protocol: e, version: n2, relayUrl: t, sdkVersion: r, auth: o, projectId: s, useOnCloseEvent: i2 }) {
  const l = t.split("?"), d2 = Me(e, n2, r), c2 = { auth: o, ua: d2, projectId: s, useOnCloseEvent: i2 || void 0 }, u2 = De(l[1] || "", c2);
  return l[0] + "?" + u2;
}
function O(e, n2) {
  return e.filter((t) => n2.includes(t)).length === e.length;
}
function et(e) {
  return Object.fromEntries(e.entries());
}
function nt(e) {
  return new Map(Object.entries(e));
}
function st(e = import_time.FIVE_MINUTES, n2) {
  const t = (0, import_time.toMiliseconds)(e || import_time.FIVE_MINUTES);
  let r, o, s;
  return { resolve: (i2) => {
    s && r && (clearTimeout(s), r(i2));
  }, reject: (i2) => {
    s && o && (clearTimeout(s), o(i2));
  }, done: () => new Promise((i2, l) => {
    s = setTimeout(() => {
      l(new Error(n2));
    }, t), r = i2, o = l;
  }) };
}
function it(e, n2, t) {
  return new Promise(async (r, o) => {
    const s = setTimeout(() => o(new Error(t)), n2);
    try {
      const i2 = await e;
      r(i2);
    } catch (i2) {
      o(i2);
    }
    clearTimeout(s);
  });
}
function re(e, n2) {
  if (typeof n2 == "string" && n2.startsWith(`${e}:`))
    return n2;
  if (e.toLowerCase() === "topic") {
    if (typeof n2 != "string")
      throw new Error('Value must be "string" for expirer target type: topic');
    return `topic:${n2}`;
  } else if (e.toLowerCase() === "id") {
    if (typeof n2 != "number")
      throw new Error('Value must be "number" for expirer target type: id');
    return `id:${n2}`;
  }
  throw new Error(`Unknown expirer target type: ${e}`);
}
function ct(e) {
  return re("topic", e);
}
function at(e) {
  return re("id", e);
}
function ut(e) {
  const [n2, t] = e.split(":"), r = { id: void 0, topic: void 0 };
  if (n2 === "topic" && typeof t == "string")
    r.topic = t;
  else if (n2 === "id" && Number.isInteger(Number(t)))
    r.id = Number(t);
  else
    throw new Error(`Invalid target, expected id:number or topic:string, got ${n2}:${t}`);
  return r;
}
function lt(e, n2) {
  return (0, import_time.fromMiliseconds)((n2 || Date.now()) + (0, import_time.toMiliseconds)(e));
}
function dt(e) {
  return Date.now() >= (0, import_time.toMiliseconds)(e);
}
function ft(e, n2) {
  return `${e}${n2 ? `:${n2}` : ""}`;
}
async function pt({ id: e, topic: n2, wcDeepLink: t }) {
  try {
    if (!t)
      return;
    const r = typeof t == "string" ? JSON.parse(t) : t;
    let o = r == null ? void 0 : r.href;
    if (typeof o != "string")
      return;
    o.endsWith("/") && (o = o.slice(0, -1));
    const s = `${o}/wc?requestId=${e}&sessionTopic=${n2}`, i2 = R();
    i2 === m.browser ? s.startsWith("https://") ? window.open(s, "_blank", "noreferrer noopener") : window.open(s, "_self", "noreferrer noopener") : i2 === m.reactNative && typeof (global == null ? void 0 : global.Linking) < "u" && await global.Linking.openURL(s);
  } catch (r) {
    console.error(r);
  }
}
var Fe = "irn";
function mt(e) {
  return (e == null ? void 0 : e.relay) || { protocol: Fe };
}
function yt(e) {
  const n2 = RELAY_JSONRPC[e];
  if (typeof n2 > "u")
    throw new Error(`Relay Protocol not supported: ${e}`);
  return n2;
}
var ht = Object.defineProperty;
var He = Object.getOwnPropertySymbols;
var vt = Object.prototype.hasOwnProperty;
var gt = Object.prototype.propertyIsEnumerable;
var qe = (e, n2, t) => n2 in e ? ht(e, n2, { enumerable: true, configurable: true, writable: true, value: t }) : e[n2] = t;
var Et = (e, n2) => {
  for (var t in n2 || (n2 = {}))
    vt.call(n2, t) && qe(e, t, n2[t]);
  if (He)
    for (var t of He(n2))
      gt.call(n2, t) && qe(e, t, n2[t]);
  return e;
};
function Be(e, n2 = "-") {
  const t = {}, r = "relay" + n2;
  return Object.keys(e).forEach((o) => {
    if (o.startsWith(r)) {
      const s = o.replace(r, ""), i2 = e[o];
      t[s] = i2;
    }
  }), t;
}
function bt(e) {
  const n2 = e.indexOf(":"), t = e.indexOf("?") !== -1 ? e.indexOf("?") : void 0, r = e.substring(0, n2), o = e.substring(n2 + 1, t).split("@"), s = typeof t < "u" ? e.substring(t) : "", i2 = k.parse(s);
  return { protocol: r, topic: Ge(o[0]), version: parseInt(o[1], 10), symKey: i2.symKey, relay: Be(i2) };
}
function Ge(e) {
  return e.startsWith("//") ? e.substring(2) : e;
}
function We(e, n2 = "-") {
  const t = "relay", r = {};
  return Object.keys(e).forEach((o) => {
    const s = t + n2 + o;
    e[o] && (r[s] = e[o]);
  }), r;
}
function Nt(e) {
  return `${e.protocol}:${e.topic}@${e.version}?` + k.stringify(Et({ symKey: e.symKey }, We(e.relay)));
}
function A(e) {
  const n2 = [];
  return e.forEach((t) => {
    const [r, o] = t.split(":");
    n2.push(`${r}:${o}`);
  }), n2;
}
function Je(e) {
  const n2 = [];
  return Object.values(e).forEach((t) => {
    n2.push(...A(t.accounts));
  }), n2;
}
function Qe(e, n2) {
  const t = [];
  return Object.values(e).forEach((r) => {
    A(r.accounts).includes(n2) && t.push(...r.methods);
  }), t;
}
function Ze(e, n2) {
  const t = [];
  return Object.values(e).forEach((r) => {
    A(r.accounts).includes(n2) && t.push(...r.events);
  }), t;
}
function At(e, n2) {
  const t = cn(e, n2);
  if (t)
    throw new Error(t.message);
  const r = {};
  for (const [o, s] of Object.entries(e))
    r[o] = { methods: s.methods, events: s.events, chains: s.accounts.map((i2) => `${i2.split(":")[0]}:${i2.split(":")[1]}`) };
  return r;
}
var _t = { INVALID_METHOD: { message: "Invalid method.", code: 1001 }, INVALID_EVENT: { message: "Invalid event.", code: 1002 }, INVALID_UPDATE_REQUEST: { message: "Invalid update request.", code: 1003 }, INVALID_EXTEND_REQUEST: { message: "Invalid extend request.", code: 1004 }, INVALID_SESSION_SETTLE_REQUEST: { message: "Invalid session settle request.", code: 1005 }, UNAUTHORIZED_METHOD: { message: "Unauthorized method.", code: 3001 }, UNAUTHORIZED_EVENT: { message: "Unauthorized event.", code: 3002 }, UNAUTHORIZED_UPDATE_REQUEST: { message: "Unauthorized update request.", code: 3003 }, UNAUTHORIZED_EXTEND_REQUEST: { message: "Unauthorized extend request.", code: 3004 }, USER_REJECTED: { message: "User rejected.", code: 5e3 }, USER_REJECTED_CHAINS: { message: "User rejected chains.", code: 5001 }, USER_REJECTED_METHODS: { message: "User rejected methods.", code: 5002 }, USER_REJECTED_EVENTS: { message: "User rejected events.", code: 5003 }, UNSUPPORTED_CHAINS: { message: "Unsupported chains.", code: 5100 }, UNSUPPORTED_METHODS: { message: "Unsupported methods.", code: 5101 }, UNSUPPORTED_EVENTS: { message: "Unsupported events.", code: 5102 }, UNSUPPORTED_ACCOUNTS: { message: "Unsupported accounts.", code: 5103 }, UNSUPPORTED_NAMESPACE_KEY: { message: "Unsupported namespace key.", code: 5104 }, USER_DISCONNECTED: { message: "User disconnected.", code: 6e3 }, SESSION_SETTLEMENT_FAILED: { message: "Session settlement failed.", code: 7e3 }, WC_METHOD_UNSUPPORTED: { message: "Unsupported wc_ method.", code: 10001 } };
var Ct = { NOT_INITIALIZED: { message: "Not initialized.", code: 1 }, NO_MATCHING_KEY: { message: "No matching key.", code: 2 }, RESTORE_WILL_OVERRIDE: { message: "Restore will override.", code: 3 }, RESUBSCRIBED: { message: "Resubscribed.", code: 4 }, MISSING_OR_INVALID: { message: "Missing or invalid.", code: 5 }, EXPIRED: { message: "Expired.", code: 6 }, UNKNOWN_TYPE: { message: "Unknown type.", code: 7 }, MISMATCHED_TOPIC: { message: "Mismatched topic.", code: 8 }, NON_CONFORMING_NAMESPACES: { message: "Non conforming namespaces.", code: 9 } };
function N(e, n2) {
  const { message: t, code: r } = Ct[e];
  return { message: n2 ? `${t} ${n2}` : t, code: r };
}
function U(e, n2) {
  const { message: t, code: r } = _t[e];
  return { message: n2 ? `${t} ${n2}` : t, code: r };
}
function j(e, n2) {
  return Array.isArray(e) ? typeof n2 < "u" && e.length ? e.every(n2) : true : false;
}
function B(e) {
  return Object.getPrototypeOf(e) === Object.prototype && Object.keys(e).length;
}
function w(e) {
  return typeof e > "u";
}
function h2(e, n2) {
  return n2 && w(e) ? true : typeof e == "string" && !!e.trim().length;
}
function G(e, n2) {
  return n2 && w(e) ? true : typeof e == "number" && !isNaN(e);
}
function $t(e, n2) {
  const { requiredNamespaces: t } = n2, r = Object.keys(e.namespaces), o = Object.keys(t);
  let s = true;
  return O(o, r) ? (r.forEach((i2) => {
    const { accounts: l, methods: d2, events: c2 } = e.namespaces[i2], u2 = A(l), a2 = t[i2];
    (!O(M(i2, a2), u2) || !O(a2.methods, d2) || !O(a2.events, c2)) && (s = false);
  }), s) : false;
}
function D(e) {
  return h2(e, false) && e.includes(":") ? e.split(":").length === 2 : false;
}
function en(e) {
  if (h2(e, false) && e.includes(":")) {
    const n2 = e.split(":");
    if (n2.length === 3) {
      const t = n2[0] + ":" + n2[1];
      return !!n2[2] && D(t);
    }
  }
  return false;
}
function jt(e) {
  if (h2(e, false))
    try {
      return typeof new URL(e) < "u";
    } catch {
      return false;
    }
  return false;
}
function Dt(e) {
  var n2;
  return (n2 = e == null ? void 0 : e.proposer) == null ? void 0 : n2.publicKey;
}
function kt(e) {
  return e == null ? void 0 : e.topic;
}
function Vt(e, n2) {
  let t = null;
  return h2(e == null ? void 0 : e.publicKey, false) || (t = N("MISSING_OR_INVALID", `${n2} controller public key should be a string`)), t;
}
function ie(e) {
  let n2 = true;
  return j(e) ? e.length && (n2 = e.every((t) => h2(t, false))) : n2 = false, n2;
}
function nn(e, n2, t) {
  let r = null;
  return j(n2) && n2.length ? n2.forEach((o) => {
    r || D(o) || (r = U("UNSUPPORTED_CHAINS", `${t}, chain ${o} should be a string and conform to "namespace:chainId" format`));
  }) : D(e) || (r = U("UNSUPPORTED_CHAINS", `${t}, chains must be defined as "namespace:chainId" e.g. "eip155:1": {...} in the namespace key OR as an array of CAIP-2 chainIds e.g. eip155: { chains: ["eip155:1", "eip155:5"] }`)), r;
}
function tn(e, n2, t) {
  let r = null;
  return Object.entries(e).forEach(([o, s]) => {
    if (r)
      return;
    const i2 = nn(o, M(o, s), `${n2} ${t}`);
    i2 && (r = i2);
  }), r;
}
function rn(e, n2) {
  let t = null;
  return j(e) ? e.forEach((r) => {
    t || en(r) || (t = U("UNSUPPORTED_ACCOUNTS", `${n2}, account ${r} should be a string and conform to "namespace:chainId:address" format`));
  }) : t = U("UNSUPPORTED_ACCOUNTS", `${n2}, accounts should be an array of strings conforming to "namespace:chainId:address" format`), t;
}
function on(e, n2) {
  let t = null;
  return Object.values(e).forEach((r) => {
    if (t)
      return;
    const o = rn(r == null ? void 0 : r.accounts, `${n2} namespace`);
    o && (t = o);
  }), t;
}
function sn(e, n2) {
  let t = null;
  return ie(e == null ? void 0 : e.methods) ? ie(e == null ? void 0 : e.events) || (t = U("UNSUPPORTED_EVENTS", `${n2}, events should be an array of strings or empty array for no events`)) : t = U("UNSUPPORTED_METHODS", `${n2}, methods should be an array of strings or empty array for no methods`), t;
}
function ce(e, n2) {
  let t = null;
  return Object.values(e).forEach((r) => {
    if (t)
      return;
    const o = sn(r, `${n2}, namespace`);
    o && (t = o);
  }), t;
}
function Mt(e, n2, t) {
  let r = null;
  if (e && B(e)) {
    const o = ce(e, n2);
    o && (r = o);
    const s = tn(e, n2, t);
    s && (r = s);
  } else
    r = N("MISSING_OR_INVALID", `${n2}, ${t} should be an object with data`);
  return r;
}
function cn(e, n2) {
  let t = null;
  if (e && B(e)) {
    const r = ce(e, n2);
    r && (t = r);
    const o = on(e, n2);
    o && (t = o);
  } else
    t = N("MISSING_OR_INVALID", `${n2}, namespaces should be an object with data`);
  return t;
}
function an(e) {
  return h2(e.protocol, true);
}
function Kt(e, n2) {
  let t = false;
  return n2 && !e ? t = true : e && j(e) && e.length && e.forEach((r) => {
    t = an(r);
  }), t;
}
function Lt(e) {
  return typeof e == "number";
}
function xt(e) {
  return typeof e < "u" && typeof e !== null;
}
function Ft(e) {
  return !(!e || typeof e != "object" || !e.code || !G(e.code, false) || !e.message || !h2(e.message, false));
}
function Ht(e) {
  return !(w(e) || !h2(e.method, false));
}
function qt(e) {
  return !(w(e) || w(e.result) && w(e.error) || !G(e.id, false) || !h2(e.jsonrpc, false));
}
function Bt(e) {
  return !(w(e) || !h2(e.name, false));
}
function Gt(e, n2) {
  return !(!D(n2) || !Je(e).includes(n2));
}
function Wt(e, n2, t) {
  return h2(t, false) ? Qe(e, n2).includes(t) : false;
}
function zt(e, n2, t) {
  return h2(t, false) ? Ze(e, n2).includes(t) : false;
}
function un(e, n2, t) {
  let r = null;
  const o = Yt(e), s = Jt(n2), i2 = Object.keys(o), l = Object.keys(s), d2 = ln(Object.keys(e)), c2 = ln(Object.keys(n2)), u2 = d2.filter((a2) => !c2.includes(a2));
  return u2.length && (r = N("NON_CONFORMING_NAMESPACES", `${t} namespaces keys don't satisfy requiredNamespaces.
      Required: ${u2.toString()}
      Received: ${Object.keys(n2).toString()}`)), O(i2, l) || (r = N("NON_CONFORMING_NAMESPACES", `${t} namespaces chains don't satisfy required namespaces.
      Required: ${i2.toString()}
      Approved: ${l.toString()}`)), Object.keys(n2).forEach((a2) => {
    if (!a2.includes(":") || r)
      return;
    const b3 = A(n2[a2].accounts);
    b3.includes(a2) || (r = N("NON_CONFORMING_NAMESPACES", `${t} namespaces accounts don't satisfy namespace accounts for ${a2}
        Required: ${a2}
        Approved: ${b3.toString()}`));
  }), i2.forEach((a2) => {
    r || (O(o[a2].methods, s[a2].methods) ? O(o[a2].events, s[a2].events) || (r = N("NON_CONFORMING_NAMESPACES", `${t} namespaces events don't satisfy namespace events for ${a2}`)) : r = N("NON_CONFORMING_NAMESPACES", `${t} namespaces methods don't satisfy namespace methods for ${a2}`));
  }), r;
}
function Yt(e) {
  const n2 = {};
  return Object.keys(e).forEach((t) => {
    var r;
    t.includes(":") ? n2[t] = e[t] : (r = e[t].chains) == null || r.forEach((o) => {
      n2[o] = { methods: e[t].methods, events: e[t].events };
    });
  }), n2;
}
function ln(e) {
  return [...new Set(e.map((n2) => n2.includes(":") ? n2.split(":")[0] : n2))];
}
function Jt(e) {
  const n2 = {};
  return Object.keys(e).forEach((t) => {
    if (t.includes(":"))
      n2[t] = e[t];
    else {
      const r = A(e[t].accounts);
      r == null ? void 0 : r.forEach((o) => {
        n2[o] = { accounts: e[t].accounts.filter((s) => s.includes(`${o}:`)), methods: e[t].methods, events: e[t].events };
      });
    }
  }), n2;
}
function Qt(e, n2) {
  return G(e, false) && e <= n2.max && e >= n2.min;
}
function Zt() {
  const e = R();
  return new Promise((n2) => {
    switch (e) {
      case m.browser:
        n2(dn());
        break;
      case m.reactNative:
        n2(fn());
        break;
      case m.node:
        n2(pn());
        break;
      default:
        n2(true);
    }
  });
}
function dn() {
  return q() && (navigator == null ? void 0 : navigator.onLine);
}
async function fn() {
  if (H() && typeof global < "u" && global != null && global.NetInfo) {
    const e = await (global == null ? void 0 : global.NetInfo.fetch());
    return e == null ? void 0 : e.isConnected;
  }
  return true;
}
function pn() {
  return true;
}
function Xt(e) {
  switch (R()) {
    case m.browser:
      mn(e);
      break;
    case m.reactNative:
      yn(e);
      break;
    case m.node:
      break;
  }
}
function mn(e) {
  q() && (window.addEventListener("online", () => e(true)), window.addEventListener("offline", () => e(false)));
}
function yn(e) {
  H() && typeof global < "u" && global != null && global.NetInfo && (global == null ? void 0 : global.NetInfo.addEventListener((n2) => e(n2 == null ? void 0 : n2.isConnected)));
}
var ae = {};
var er = class {
  static get(n2) {
    return ae[n2];
  }
  static set(n2, t) {
    ae[n2] = t;
  }
  static delete(n2) {
    delete ae[n2];
  }
};

// node_modules/@taquito/beacon-wallet/node_modules/@walletconnect/core/dist/index.es.js
var import_time2 = __toESM(require_cjs());
var import_lodash = __toESM(require_lodash());
function ki(r, e) {
  if (r.length >= 255)
    throw new TypeError("Alphabet too long");
  for (var t = new Uint8Array(256), i2 = 0; i2 < t.length; i2++)
    t[i2] = 255;
  for (var s = 0; s < r.length; s++) {
    var n2 = r.charAt(s), a2 = n2.charCodeAt(0);
    if (t[a2] !== 255)
      throw new TypeError(n2 + " is ambiguous");
    t[a2] = s;
  }
  var o = r.length, h3 = r.charAt(0), l = Math.log(o) / Math.log(256), d2 = Math.log(256) / Math.log(o);
  function p3(c2) {
    if (c2 instanceof Uint8Array || (ArrayBuffer.isView(c2) ? c2 = new Uint8Array(c2.buffer, c2.byteOffset, c2.byteLength) : Array.isArray(c2) && (c2 = Uint8Array.from(c2))), !(c2 instanceof Uint8Array))
      throw new TypeError("Expected Uint8Array");
    if (c2.length === 0)
      return "";
    for (var b3 = 0, z = 0, v = 0, _2 = c2.length; v !== _2 && c2[v] === 0; )
      v++, b3++;
    for (var T = (_2 - v) * d2 + 1 >>> 0, m2 = new Uint8Array(T); v !== _2; ) {
      for (var S2 = c2[v], A2 = 0, I = T - 1; (S2 !== 0 || A2 < z) && I !== -1; I--, A2++)
        S2 += 256 * m2[I] >>> 0, m2[I] = S2 % o >>> 0, S2 = S2 / o >>> 0;
      if (S2 !== 0)
        throw new Error("Non-zero carry");
      z = A2, v++;
    }
    for (var O3 = T - z; O3 !== T && m2[O3] === 0; )
      O3++;
    for (var V2 = h3.repeat(b3); O3 < T; ++O3)
      V2 += r.charAt(m2[O3]);
    return V2;
  }
  function y3(c2) {
    if (typeof c2 != "string")
      throw new TypeError("Expected String");
    if (c2.length === 0)
      return new Uint8Array();
    var b3 = 0;
    if (c2[b3] !== " ") {
      for (var z = 0, v = 0; c2[b3] === h3; )
        z++, b3++;
      for (var _2 = (c2.length - b3) * l + 1 >>> 0, T = new Uint8Array(_2); c2[b3]; ) {
        var m2 = t[c2.charCodeAt(b3)];
        if (m2 === 255)
          return;
        for (var S2 = 0, A2 = _2 - 1; (m2 !== 0 || S2 < v) && A2 !== -1; A2--, S2++)
          m2 += o * T[A2] >>> 0, T[A2] = m2 % 256 >>> 0, m2 = m2 / 256 >>> 0;
        if (m2 !== 0)
          throw new Error("Non-zero carry");
        v = S2, b3++;
      }
      if (c2[b3] !== " ") {
        for (var I = _2 - v; I !== _2 && T[I] === 0; )
          I++;
        for (var O3 = new Uint8Array(z + (_2 - I)), V2 = z; I !== _2; )
          O3[V2++] = T[I++];
        return O3;
      }
    }
  }
  function $2(c2) {
    var b3 = y3(c2);
    if (b3)
      return b3;
    throw new Error(`Non-${e} character`);
  }
  return { encode: p3, decodeUnsafe: y3, decode: $2 };
}
var Ki = ki;
var Bi = Ki;
var Ae2 = (r) => {
  if (r instanceof Uint8Array && r.constructor.name === "Uint8Array")
    return r;
  if (r instanceof ArrayBuffer)
    return new Uint8Array(r);
  if (ArrayBuffer.isView(r))
    return new Uint8Array(r.buffer, r.byteOffset, r.byteLength);
  throw new Error("Unknown type, must be binary type");
};
var Vi = (r) => new TextEncoder().encode(r);
var qi = (r) => new TextDecoder().decode(r);
var ji = class {
  constructor(e, t, i2) {
    this.name = e, this.prefix = t, this.baseEncode = i2;
  }
  encode(e) {
    if (e instanceof Uint8Array)
      return `${this.prefix}${this.baseEncode(e)}`;
    throw Error("Unknown type, must be binary type");
  }
};
var Yi = class {
  constructor(e, t, i2) {
    if (this.name = e, this.prefix = t, t.codePointAt(0) === void 0)
      throw new Error("Invalid prefix character");
    this.prefixCodePoint = t.codePointAt(0), this.baseDecode = i2;
  }
  decode(e) {
    if (typeof e == "string") {
      if (e.codePointAt(0) !== this.prefixCodePoint)
        throw Error(`Unable to decode multibase string ${JSON.stringify(e)}, ${this.name} decoder only supports inputs prefixed with ${this.prefix}`);
      return this.baseDecode(e.slice(this.prefix.length));
    } else
      throw Error("Can only multibase decode strings");
  }
  or(e) {
    return ze(this, e);
  }
};
var Gi = class {
  constructor(e) {
    this.decoders = e;
  }
  or(e) {
    return ze(this, e);
  }
  decode(e) {
    const t = e[0], i2 = this.decoders[t];
    if (i2)
      return i2.decode(e);
    throw RangeError(`Unable to decode multibase string ${JSON.stringify(e)}, only inputs prefixed with ${Object.keys(this.decoders)} are supported`);
  }
};
var ze = (r, e) => new Gi({ ...r.decoders || { [r.prefix]: r }, ...e.decoders || { [e.prefix]: e } });
var Hi = class {
  constructor(e, t, i2, s) {
    this.name = e, this.prefix = t, this.baseEncode = i2, this.baseDecode = s, this.encoder = new ji(e, t, i2), this.decoder = new Yi(e, t, s);
  }
  encode(e) {
    return this.encoder.encode(e);
  }
  decode(e) {
    return this.decoder.decode(e);
  }
};
var J2 = ({ name: r, prefix: e, encode: t, decode: i2 }) => new Hi(r, e, t, i2);
var K = ({ prefix: r, name: e, alphabet: t }) => {
  const { encode: i2, decode: s } = Bi(t, e);
  return J2({ prefix: r, name: e, encode: i2, decode: (n2) => Ae2(s(n2)) });
};
var Ji = (r, e, t, i2) => {
  const s = {};
  for (let d2 = 0; d2 < e.length; ++d2)
    s[e[d2]] = d2;
  let n2 = r.length;
  for (; r[n2 - 1] === "="; )
    --n2;
  const a2 = new Uint8Array(n2 * t / 8 | 0);
  let o = 0, h3 = 0, l = 0;
  for (let d2 = 0; d2 < n2; ++d2) {
    const p3 = s[r[d2]];
    if (p3 === void 0)
      throw new SyntaxError(`Non-${i2} character`);
    h3 = h3 << t | p3, o += t, o >= 8 && (o -= 8, a2[l++] = 255 & h3 >> o);
  }
  if (o >= t || 255 & h3 << 8 - o)
    throw new SyntaxError("Unexpected end of data");
  return a2;
};
var Wi = (r, e, t) => {
  const i2 = e[e.length - 1] === "=", s = (1 << t) - 1;
  let n2 = "", a2 = 0, o = 0;
  for (let h3 = 0; h3 < r.length; ++h3)
    for (o = o << 8 | r[h3], a2 += 8; a2 > t; )
      a2 -= t, n2 += e[s & o >> a2];
  if (a2 && (n2 += e[s & o << t - a2]), i2)
    for (; n2.length * t & 7; )
      n2 += "=";
  return n2;
};
var g2 = ({ name: r, prefix: e, bitsPerChar: t, alphabet: i2 }) => J2({ prefix: e, name: r, encode(s) {
  return Wi(s, i2, t);
}, decode(s) {
  return Ji(s, i2, t, r);
} });
var Xi = J2({ prefix: "\0", name: "identity", encode: (r) => qi(r), decode: (r) => Vi(r) });
var Qi = Object.freeze({ __proto__: null, identity: Xi });
var Zi = g2({ prefix: "0", name: "base2", alphabet: "01", bitsPerChar: 1 });
var es = Object.freeze({ __proto__: null, base2: Zi });
var ts = g2({ prefix: "7", name: "base8", alphabet: "01234567", bitsPerChar: 3 });
var is = Object.freeze({ __proto__: null, base8: ts });
var ss = K({ prefix: "9", name: "base10", alphabet: "0123456789" });
var rs = Object.freeze({ __proto__: null, base10: ss });
var ns = g2({ prefix: "f", name: "base16", alphabet: "0123456789abcdef", bitsPerChar: 4 });
var as = g2({ prefix: "F", name: "base16upper", alphabet: "0123456789ABCDEF", bitsPerChar: 4 });
var os = Object.freeze({ __proto__: null, base16: ns, base16upper: as });
var hs = g2({ prefix: "b", name: "base32", alphabet: "abcdefghijklmnopqrstuvwxyz234567", bitsPerChar: 5 });
var cs = g2({ prefix: "B", name: "base32upper", alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567", bitsPerChar: 5 });
var us = g2({ prefix: "c", name: "base32pad", alphabet: "abcdefghijklmnopqrstuvwxyz234567=", bitsPerChar: 5 });
var ls = g2({ prefix: "C", name: "base32padupper", alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567=", bitsPerChar: 5 });
var ds = g2({ prefix: "v", name: "base32hex", alphabet: "0123456789abcdefghijklmnopqrstuv", bitsPerChar: 5 });
var gs = g2({ prefix: "V", name: "base32hexupper", alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV", bitsPerChar: 5 });
var ps = g2({ prefix: "t", name: "base32hexpad", alphabet: "0123456789abcdefghijklmnopqrstuv=", bitsPerChar: 5 });
var Ds = g2({ prefix: "T", name: "base32hexpadupper", alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV=", bitsPerChar: 5 });
var ys = g2({ prefix: "h", name: "base32z", alphabet: "ybndrfg8ejkmcpqxot1uwisza345h769", bitsPerChar: 5 });
var bs = Object.freeze({ __proto__: null, base32: hs, base32upper: cs, base32pad: us, base32padupper: ls, base32hex: ds, base32hexupper: gs, base32hexpad: ps, base32hexpadupper: Ds, base32z: ys });
var ms = K({ prefix: "k", name: "base36", alphabet: "0123456789abcdefghijklmnopqrstuvwxyz" });
var fs = K({ prefix: "K", name: "base36upper", alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ" });
var Es = Object.freeze({ __proto__: null, base36: ms, base36upper: fs });
var ws = K({ name: "base58btc", prefix: "z", alphabet: "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz" });
var vs = K({ name: "base58flickr", prefix: "Z", alphabet: "123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ" });
var Is = Object.freeze({ __proto__: null, base58btc: ws, base58flickr: vs });
var Cs = g2({ prefix: "m", name: "base64", alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/", bitsPerChar: 6 });
var Rs = g2({ prefix: "M", name: "base64pad", alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=", bitsPerChar: 6 });
var _s = g2({ prefix: "u", name: "base64url", alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_", bitsPerChar: 6 });
var Ts = g2({ prefix: "U", name: "base64urlpad", alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_=", bitsPerChar: 6 });
var Ss = Object.freeze({ __proto__: null, base64: Cs, base64pad: Rs, base64url: _s, base64urlpad: Ts });
var Ne = Array.from("");
var Ps = Ne.reduce((r, e, t) => (r[t] = e, r), []);
var Os = Ne.reduce((r, e, t) => (r[e.codePointAt(0)] = t, r), []);
function xs(r) {
  return r.reduce((e, t) => (e += Ps[t], e), "");
}
function As(r) {
  const e = [];
  for (const t of r) {
    const i2 = Os[t.codePointAt(0)];
    if (i2 === void 0)
      throw new Error(`Non-base256emoji character: ${t}`);
    e.push(i2);
  }
  return new Uint8Array(e);
}
var zs = J2({ prefix: "", name: "base256emoji", encode: xs, decode: As });
var Ns = Object.freeze({ __proto__: null, base256emoji: zs });
var Ls = Ue2;
var Le = 128;
var Us = 127;
var Fs = ~Us;
var $s = Math.pow(2, 31);
function Ue2(r, e, t) {
  e = e || [], t = t || 0;
  for (var i2 = t; r >= $s; )
    e[t++] = r & 255 | Le, r /= 128;
  for (; r & Fs; )
    e[t++] = r & 255 | Le, r >>>= 7;
  return e[t] = r | 0, Ue2.bytes = t - i2 + 1, e;
}
var Ms = ae2;
var ks = 128;
var Fe2 = 127;
function ae2(r, i2) {
  var t = 0, i2 = i2 || 0, s = 0, n2 = i2, a2, o = r.length;
  do {
    if (n2 >= o)
      throw ae2.bytes = 0, new RangeError("Could not decode varint");
    a2 = r[n2++], t += s < 28 ? (a2 & Fe2) << s : (a2 & Fe2) * Math.pow(2, s), s += 7;
  } while (a2 >= ks);
  return ae2.bytes = n2 - i2, t;
}
var Ks = Math.pow(2, 7);
var Bs = Math.pow(2, 14);
var Vs = Math.pow(2, 21);
var qs = Math.pow(2, 28);
var js = Math.pow(2, 35);
var Ys = Math.pow(2, 42);
var Gs = Math.pow(2, 49);
var Hs = Math.pow(2, 56);
var Js = Math.pow(2, 63);
var Ws = function(r) {
  return r < Ks ? 1 : r < Bs ? 2 : r < Vs ? 3 : r < qs ? 4 : r < js ? 5 : r < Ys ? 6 : r < Gs ? 7 : r < Hs ? 8 : r < Js ? 9 : 10;
};
var Xs = { encode: Ls, decode: Ms, encodingLength: Ws };
var $e = Xs;
var Me2 = (r, e, t = 0) => ($e.encode(r, e, t), e);
var ke2 = (r) => $e.encodingLength(r);
var oe = (r, e) => {
  const t = e.byteLength, i2 = ke2(r), s = i2 + ke2(t), n2 = new Uint8Array(s + t);
  return Me2(r, n2, 0), Me2(t, n2, i2), n2.set(e, s), new Qs(r, t, e, n2);
};
var Qs = class {
  constructor(e, t, i2, s) {
    this.code = e, this.size = t, this.digest = i2, this.bytes = s;
  }
};
var Ke = ({ name: r, code: e, encode: t }) => new Zs(r, e, t);
var Zs = class {
  constructor(e, t, i2) {
    this.name = e, this.code = t, this.encode = i2;
  }
  digest(e) {
    if (e instanceof Uint8Array) {
      const t = this.encode(e);
      return t instanceof Uint8Array ? oe(this.code, t) : t.then((i2) => oe(this.code, i2));
    } else
      throw Error("Unknown type, must be binary type");
  }
};
var Be2 = (r) => async (e) => new Uint8Array(await crypto.subtle.digest(r, e));
var er2 = Ke({ name: "sha2-256", code: 18, encode: Be2("SHA-256") });
var tr = Ke({ name: "sha2-512", code: 19, encode: Be2("SHA-512") });
var ir = Object.freeze({ __proto__: null, sha256: er2, sha512: tr });
var Ve2 = 0;
var sr = "identity";
var qe2 = Ae2;
var rr = (r) => oe(Ve2, qe2(r));
var nr = { code: Ve2, name: sr, encode: qe2, digest: rr };
var ar = Object.freeze({ __proto__: null, identity: nr });
new TextEncoder(), new TextDecoder();
var je2 = { ...Qi, ...es, ...is, ...rs, ...os, ...bs, ...Es, ...Is, ...Ss, ...Ns };
({ ...ir, ...ar });
function Ye(r) {
  return globalThis.Buffer != null ? new Uint8Array(r.buffer, r.byteOffset, r.byteLength) : r;
}
function or(r = 0) {
  return globalThis.Buffer != null && globalThis.Buffer.allocUnsafe != null ? Ye(globalThis.Buffer.allocUnsafe(r)) : new Uint8Array(r);
}
function Ge2(r, e, t, i2) {
  return { name: r, prefix: e, encoder: { name: r, prefix: e, encode: t }, decoder: { decode: i2 } };
}
var He2 = Ge2("utf8", "u", (r) => "u" + new TextDecoder("utf8").decode(r), (r) => new TextEncoder().encode(r.substring(1)));
var he2 = Ge2("ascii", "a", (r) => {
  let e = "a";
  for (let t = 0; t < r.length; t++)
    e += String.fromCharCode(r[t]);
  return e;
}, (r) => {
  r = r.substring(1);
  const e = or(r.length);
  for (let t = 0; t < r.length; t++)
    e[t] = r.charCodeAt(t);
  return e;
});
var hr = { utf8: He2, "utf-8": He2, hex: je2.base16, latin1: he2, ascii: he2, binary: he2, ...je2 };
function cr(r, e = "utf8") {
  const t = hr[e];
  if (!t)
    throw new Error(`Unsupported encoding "${e}"`);
  return (e === "utf8" || e === "utf-8") && globalThis.Buffer != null && globalThis.Buffer.from != null ? Ye(globalThis.Buffer.from(r, "utf-8")) : t.decoder.decode(`${t.prefix}${r}`);
}
var ce2 = "wc";
var Je2 = 2;
var W2 = "core";
var x2 = `${ce2}@2:${W2}:`;
var We2 = { name: W2, logger: "error" };
var Xe = { database: ":memory:" };
var Qe2 = "crypto";
var ue2 = "client_ed25519_seed";
var Ze2 = import_time2.ONE_DAY;
var et2 = "keychain";
var tt = "0.3";
var it2 = "messages";
var st2 = "0.3";
var rt = import_time2.SIX_HOURS;
var nt2 = "publisher";
var at2 = "irn";
var ot = "error";
var le2 = "wss://relay.walletconnect.com";
var de2 = "wss://relay.walletconnect.org";
var ht2 = "relayer";
var D2 = { message: "relayer_message", message_ack: "relayer_message_ack", connect: "relayer_connect", disconnect: "relayer_disconnect", error: "relayer_error", connection_stalled: "relayer_connection_stalled", transport_closed: "relayer_transport_closed", publish: "relayer_publish" };
var ct2 = "_subscription";
var P = { payload: "payload", connect: "connect", disconnect: "disconnect", error: "error" };
var ut2 = import_time2.ONE_SECOND;
var lt2 = "2.10.0";
var dt2 = 1e4;
var gt2 = "0.3";
var pt2 = "WALLETCONNECT_CLIENT_ID";
var C = { created: "subscription_created", deleted: "subscription_deleted", expired: "subscription_expired", disabled: "subscription_disabled", sync: "subscription_sync", resubscribed: "subscription_resubscribed" };
var Dt2 = "subscription";
var yt2 = "0.3";
var bt2 = import_time2.FIVE_SECONDS * 1e3;
var mt2 = "pairing";
var ft2 = "0.3";
var F = { wc_pairingDelete: { req: { ttl: import_time2.ONE_DAY, prompt: false, tag: 1e3 }, res: { ttl: import_time2.ONE_DAY, prompt: false, tag: 1001 } }, wc_pairingPing: { req: { ttl: import_time2.THIRTY_SECONDS, prompt: false, tag: 1002 }, res: { ttl: import_time2.THIRTY_SECONDS, prompt: false, tag: 1003 } }, unregistered_method: { req: { ttl: import_time2.ONE_DAY, prompt: false, tag: 0 }, res: { ttl: import_time2.ONE_DAY, prompt: false, tag: 0 } } };
var R2 = { created: "history_created", updated: "history_updated", deleted: "history_deleted", sync: "history_sync" };
var Et2 = "history";
var wt = "0.3";
var vt2 = "expirer";
var w2 = { created: "expirer_created", deleted: "expirer_deleted", expired: "expirer_expired", sync: "expirer_sync" };
var It = "0.3";
var X2 = "verify-api";
var Q2 = "https://verify.walletconnect.com";
var ge = "https://verify.walletconnect.org";
var Ct2 = class {
  constructor(e, t) {
    this.core = e, this.logger = t, this.keychain = /* @__PURE__ */ new Map(), this.name = et2, this.version = tt, this.initialized = false, this.storagePrefix = x2, this.init = async () => {
      if (!this.initialized) {
        const i2 = await this.getKeyChain();
        typeof i2 < "u" && (this.keychain = i2), this.initialized = true;
      }
    }, this.has = (i2) => (this.isInitialized(), this.keychain.has(i2)), this.set = async (i2, s) => {
      this.isInitialized(), this.keychain.set(i2, s), await this.persist();
    }, this.get = (i2) => {
      this.isInitialized();
      const s = this.keychain.get(i2);
      if (typeof s > "u") {
        const { message: n2 } = N("NO_MATCHING_KEY", `${this.name}: ${i2}`);
        throw new Error(n2);
      }
      return s;
    }, this.del = async (i2) => {
      this.isInitialized(), this.keychain.delete(i2), await this.persist();
    }, this.core = e, this.logger = (0, import_logger.generateChildLogger)(t, this.name);
  }
  get context() {
    return (0, import_logger.getLoggerContext)(this.logger);
  }
  get storageKey() {
    return this.storagePrefix + this.version + "//" + this.name;
  }
  async setKeyChain(e) {
    await this.core.storage.setItem(this.storageKey, et(e));
  }
  async getKeyChain() {
    const e = await this.core.storage.getItem(this.storageKey);
    return typeof e < "u" ? nt(e) : void 0;
  }
  async persist() {
    await this.setKeyChain(this.keychain);
  }
  isInitialized() {
    if (!this.initialized) {
      const { message: e } = N("NOT_INITIALIZED", this.name);
      throw new Error(e);
    }
  }
};
var Rt = class {
  constructor(e, t, i2) {
    this.core = e, this.logger = t, this.name = Qe2, this.initialized = false, this.init = async () => {
      this.initialized || (await this.keychain.init(), this.initialized = true);
    }, this.hasKeys = (s) => (this.isInitialized(), this.keychain.has(s)), this.getClientId = async () => {
      this.isInitialized();
      const s = await this.getClientSeed(), n2 = generateKeyPair(s);
      return encodeIss(n2.publicKey);
    }, this.generateKeyPair = () => {
      this.isInitialized();
      const s = jn();
      return this.setPrivateKey(s.publicKey, s.privateKey);
    }, this.signJWT = async (s) => {
      this.isInitialized();
      const n2 = await this.getClientSeed(), a2 = generateKeyPair(n2), o = Dn(), h3 = Ze2;
      return await signJWT(o, s, h3, a2);
    }, this.generateSharedKey = (s, n2, a2) => {
      this.isInitialized();
      const o = this.getPrivateKey(s), h3 = kn(o, n2);
      return this.setSymKey(h3, a2);
    }, this.setSymKey = async (s, n2) => {
      this.isInitialized();
      const a2 = n2 || Vn(s);
      return await this.keychain.set(a2, s), a2;
    }, this.deleteKeyPair = async (s) => {
      this.isInitialized(), await this.keychain.del(s);
    }, this.deleteSymKey = async (s) => {
      this.isInitialized(), await this.keychain.del(s);
    }, this.encode = async (s, n2, a2) => {
      this.isInitialized();
      const o = Re(a2), h3 = safeJsonStringify(n2);
      if (Fn(o)) {
        const y3 = o.senderPublicKey, $2 = o.receiverPublicKey;
        s = await this.generateSharedKey(y3, $2);
      }
      const l = this.getSymKey(s), { type: d2, senderPublicKey: p3 } = o;
      return Kn({ type: d2, symKey: l, message: h3, senderPublicKey: p3 });
    }, this.decode = async (s, n2, a2) => {
      this.isInitialized();
      const o = xn(n2, a2);
      if (Fn(o)) {
        const h3 = o.receiverPublicKey, l = o.senderPublicKey;
        s = await this.generateSharedKey(h3, l);
      }
      try {
        const h3 = this.getSymKey(s), l = Ln({ symKey: h3, encoded: n2 });
        return safeJsonParse(l);
      } catch (h3) {
        this.logger.error(`Failed to decode message from topic: '${s}', clientId: '${await this.getClientId()}'`), this.logger.error(h3);
      }
    }, this.getPayloadType = (s) => {
      const n2 = ee(s);
      return $(n2.type);
    }, this.getPayloadSenderPublicKey = (s) => {
      const n2 = ee(s);
      return n2.senderPublicKey ? toString(n2.senderPublicKey, p2) : void 0;
    }, this.core = e, this.logger = (0, import_logger.generateChildLogger)(t, this.name), this.keychain = i2 || new Ct2(this.core, this.logger);
  }
  get context() {
    return (0, import_logger.getLoggerContext)(this.logger);
  }
  async setPrivateKey(e, t) {
    return await this.keychain.set(e, t), e;
  }
  getPrivateKey(e) {
    return this.keychain.get(e);
  }
  async getClientSeed() {
    let e = "";
    try {
      e = this.keychain.get(ue2);
    } catch {
      e = Dn(), await this.keychain.set(ue2, e);
    }
    return cr(e, "base16");
  }
  getSymKey(e) {
    return this.keychain.get(e);
  }
  isInitialized() {
    if (!this.initialized) {
      const { message: e } = N("NOT_INITIALIZED", this.name);
      throw new Error(e);
    }
  }
};
var _t2 = class extends a {
  constructor(e, t) {
    super(e, t), this.logger = e, this.core = t, this.messages = /* @__PURE__ */ new Map(), this.name = it2, this.version = st2, this.initialized = false, this.storagePrefix = x2, this.init = async () => {
      if (!this.initialized) {
        this.logger.trace("Initialized");
        try {
          const i2 = await this.getRelayerMessages();
          typeof i2 < "u" && (this.messages = i2), this.logger.debug(`Successfully Restored records for ${this.name}`), this.logger.trace({ type: "method", method: "restore", size: this.messages.size });
        } catch (i2) {
          this.logger.debug(`Failed to Restore records for ${this.name}`), this.logger.error(i2);
        } finally {
          this.initialized = true;
        }
      }
    }, this.set = async (i2, s) => {
      this.isInitialized();
      const n2 = Mn(s);
      let a2 = this.messages.get(i2);
      return typeof a2 > "u" && (a2 = {}), typeof a2[n2] < "u" || (a2[n2] = s, this.messages.set(i2, a2), await this.persist()), n2;
    }, this.get = (i2) => {
      this.isInitialized();
      let s = this.messages.get(i2);
      return typeof s > "u" && (s = {}), s;
    }, this.has = (i2, s) => {
      this.isInitialized();
      const n2 = this.get(i2), a2 = Mn(s);
      return typeof n2[a2] < "u";
    }, this.del = async (i2) => {
      this.isInitialized(), this.messages.delete(i2), await this.persist();
    }, this.logger = (0, import_logger.generateChildLogger)(e, this.name), this.core = t;
  }
  get context() {
    return (0, import_logger.getLoggerContext)(this.logger);
  }
  get storageKey() {
    return this.storagePrefix + this.version + "//" + this.name;
  }
  async setRelayerMessages(e) {
    await this.core.storage.setItem(this.storageKey, et(e));
  }
  async getRelayerMessages() {
    const e = await this.core.storage.getItem(this.storageKey);
    return typeof e < "u" ? nt(e) : void 0;
  }
  async persist() {
    await this.setRelayerMessages(this.messages);
  }
  isInitialized() {
    if (!this.initialized) {
      const { message: e } = N("NOT_INITIALIZED", this.name);
      throw new Error(e);
    }
  }
};
var pr = class extends u {
  constructor(e, t) {
    super(e, t), this.relayer = e, this.logger = t, this.events = new import_events6.EventEmitter(), this.name = nt2, this.queue = /* @__PURE__ */ new Map(), this.publishTimeout = (0, import_time2.toMiliseconds)(import_time2.TEN_SECONDS), this.needsTransportRestart = false, this.publish = async (i2, s, n2) => {
      var a2;
      this.logger.debug("Publishing Payload"), this.logger.trace({ type: "method", method: "publish", params: { topic: i2, message: s, opts: n2 } });
      try {
        const o = (n2 == null ? void 0 : n2.ttl) || rt, h3 = mt(n2), l = (n2 == null ? void 0 : n2.prompt) || false, d2 = (n2 == null ? void 0 : n2.tag) || 0, p3 = (n2 == null ? void 0 : n2.id) || getBigIntRpcId().toString(), y3 = { topic: i2, message: s, opts: { ttl: o, relay: h3, prompt: l, tag: d2, id: p3 } }, $2 = setTimeout(() => this.queue.set(p3, y3), this.publishTimeout);
        try {
          await await it(this.rpcPublish(i2, s, o, h3, l, d2, p3), this.publishTimeout, "Failed to publish payload, please try again."), this.removeRequestFromQueue(p3), this.relayer.events.emit(D2.publish, y3);
        } catch (c2) {
          if (this.logger.debug("Publishing Payload stalled"), this.needsTransportRestart = true, (a2 = n2 == null ? void 0 : n2.internal) != null && a2.throwOnFailedPublish)
            throw this.removeRequestFromQueue(p3), c2;
          return;
        } finally {
          clearTimeout($2);
        }
        this.logger.debug("Successfully Published Payload"), this.logger.trace({ type: "method", method: "publish", params: { topic: i2, message: s, opts: n2 } });
      } catch (o) {
        throw this.logger.debug("Failed to Publish Payload"), this.logger.error(o), o;
      }
    }, this.on = (i2, s) => {
      this.events.on(i2, s);
    }, this.once = (i2, s) => {
      this.events.once(i2, s);
    }, this.off = (i2, s) => {
      this.events.off(i2, s);
    }, this.removeListener = (i2, s) => {
      this.events.removeListener(i2, s);
    }, this.relayer = e, this.logger = (0, import_logger.generateChildLogger)(t, this.name), this.registerEventListeners();
  }
  get context() {
    return (0, import_logger.getLoggerContext)(this.logger);
  }
  rpcPublish(e, t, i2, s, n2, a2, o) {
    var h3, l, d2, p3;
    const y3 = { method: yt(s.protocol).publish, params: { topic: e, message: t, ttl: i2, prompt: n2, tag: a2 }, id: o };
    return w((h3 = y3.params) == null ? void 0 : h3.prompt) && ((l = y3.params) == null || delete l.prompt), w((d2 = y3.params) == null ? void 0 : d2.tag) && ((p3 = y3.params) == null || delete p3.tag), this.logger.debug("Outgoing Relay Payload"), this.logger.trace({ type: "message", direction: "outgoing", request: y3 }), this.relayer.request(y3);
  }
  removeRequestFromQueue(e) {
    this.queue.delete(e);
  }
  checkQueue() {
    this.queue.forEach(async (e) => {
      const { topic: t, message: i2, opts: s } = e;
      await this.publish(t, i2, s);
    });
  }
  registerEventListeners() {
    this.relayer.core.heartbeat.on(import_heartbeat.HEARTBEAT_EVENTS.pulse, () => {
      if (this.needsTransportRestart) {
        this.needsTransportRestart = false, this.relayer.events.emit(D2.connection_stalled);
        return;
      }
      this.checkQueue();
    }), this.relayer.on(D2.message_ack, (e) => {
      this.removeRequestFromQueue(e.id.toString());
    });
  }
};
var Dr = class {
  constructor() {
    this.map = /* @__PURE__ */ new Map(), this.set = (e, t) => {
      const i2 = this.get(e);
      this.exists(e, t) || this.map.set(e, [...i2, t]);
    }, this.get = (e) => this.map.get(e) || [], this.exists = (e, t) => this.get(e).includes(t), this.delete = (e, t) => {
      if (typeof t > "u") {
        this.map.delete(e);
        return;
      }
      if (!this.map.has(e))
        return;
      const i2 = this.get(e);
      if (!this.exists(e, t))
        return;
      const s = i2.filter((n2) => n2 !== t);
      if (!s.length) {
        this.map.delete(e);
        return;
      }
      this.map.set(e, s);
    }, this.clear = () => {
      this.map.clear();
    };
  }
  get topics() {
    return Array.from(this.map.keys());
  }
};
var yr = Object.defineProperty;
var br = Object.defineProperties;
var mr = Object.getOwnPropertyDescriptors;
var Tt = Object.getOwnPropertySymbols;
var fr = Object.prototype.hasOwnProperty;
var Er = Object.prototype.propertyIsEnumerable;
var St = (r, e, t) => e in r ? yr(r, e, { enumerable: true, configurable: true, writable: true, value: t }) : r[e] = t;
var B2 = (r, e) => {
  for (var t in e || (e = {}))
    fr.call(e, t) && St(r, t, e[t]);
  if (Tt)
    for (var t of Tt(e))
      Er.call(e, t) && St(r, t, e[t]);
  return r;
};
var pe = (r, e) => br(r, mr(e));
var Pt = class extends d {
  constructor(e, t) {
    super(e, t), this.relayer = e, this.logger = t, this.subscriptions = /* @__PURE__ */ new Map(), this.topicMap = new Dr(), this.events = new import_events6.EventEmitter(), this.name = Dt2, this.version = yt2, this.pending = /* @__PURE__ */ new Map(), this.cached = [], this.initialized = false, this.pendingSubscriptionWatchLabel = "pending_sub_watch_label", this.pollingInterval = 20, this.storagePrefix = x2, this.subscribeTimeout = 1e4, this.restartInProgress = false, this.batchSubscribeTopicsLimit = 500, this.init = async () => {
      this.initialized || (this.logger.trace("Initialized"), this.registerEventListeners(), this.clientId = await this.relayer.core.crypto.getClientId());
    }, this.subscribe = async (i2, s) => {
      await this.restartToComplete(), this.isInitialized(), this.logger.debug("Subscribing Topic"), this.logger.trace({ type: "method", method: "subscribe", params: { topic: i2, opts: s } });
      try {
        const n2 = mt(s), a2 = { topic: i2, relay: n2 };
        this.pending.set(i2, a2);
        const o = await this.rpcSubscribe(i2, n2);
        return this.onSubscribe(o, a2), this.logger.debug("Successfully Subscribed Topic"), this.logger.trace({ type: "method", method: "subscribe", params: { topic: i2, opts: s } }), o;
      } catch (n2) {
        throw this.logger.debug("Failed to Subscribe Topic"), this.logger.error(n2), n2;
      }
    }, this.unsubscribe = async (i2, s) => {
      await this.restartToComplete(), this.isInitialized(), typeof (s == null ? void 0 : s.id) < "u" ? await this.unsubscribeById(i2, s.id, s) : await this.unsubscribeByTopic(i2, s);
    }, this.isSubscribed = async (i2) => this.topics.includes(i2) ? true : await new Promise((s, n2) => {
      const a2 = new import_time2.Watch();
      a2.start(this.pendingSubscriptionWatchLabel);
      const o = setInterval(() => {
        !this.pending.has(i2) && this.topics.includes(i2) && (clearInterval(o), a2.stop(this.pendingSubscriptionWatchLabel), s(true)), a2.elapsed(this.pendingSubscriptionWatchLabel) >= bt2 && (clearInterval(o), a2.stop(this.pendingSubscriptionWatchLabel), n2(new Error("Subscription resolution timeout")));
      }, this.pollingInterval);
    }).catch(() => false), this.on = (i2, s) => {
      this.events.on(i2, s);
    }, this.once = (i2, s) => {
      this.events.once(i2, s);
    }, this.off = (i2, s) => {
      this.events.off(i2, s);
    }, this.removeListener = (i2, s) => {
      this.events.removeListener(i2, s);
    }, this.restart = async () => {
      this.restartInProgress = true, await this.restore(), await this.reset(), this.restartInProgress = false;
    }, this.relayer = e, this.logger = (0, import_logger.generateChildLogger)(t, this.name), this.clientId = "";
  }
  get context() {
    return (0, import_logger.getLoggerContext)(this.logger);
  }
  get storageKey() {
    return this.storagePrefix + this.version + "//" + this.name;
  }
  get length() {
    return this.subscriptions.size;
  }
  get ids() {
    return Array.from(this.subscriptions.keys());
  }
  get values() {
    return Array.from(this.subscriptions.values());
  }
  get topics() {
    return this.topicMap.topics;
  }
  hasSubscription(e, t) {
    let i2 = false;
    try {
      i2 = this.getSubscription(e).topic === t;
    } catch {
    }
    return i2;
  }
  onEnable() {
    this.cached = [], this.initialized = true;
  }
  onDisable() {
    this.cached = this.values, this.subscriptions.clear(), this.topicMap.clear();
  }
  async unsubscribeByTopic(e, t) {
    const i2 = this.topicMap.get(e);
    await Promise.all(i2.map(async (s) => await this.unsubscribeById(e, s, t)));
  }
  async unsubscribeById(e, t, i2) {
    this.logger.debug("Unsubscribing Topic"), this.logger.trace({ type: "method", method: "unsubscribe", params: { topic: e, id: t, opts: i2 } });
    try {
      const s = mt(i2);
      await this.rpcUnsubscribe(e, t, s);
      const n2 = U("USER_DISCONNECTED", `${this.name}, ${e}`);
      await this.onUnsubscribe(e, t, n2), this.logger.debug("Successfully Unsubscribed Topic"), this.logger.trace({ type: "method", method: "unsubscribe", params: { topic: e, id: t, opts: i2 } });
    } catch (s) {
      throw this.logger.debug("Failed to Unsubscribe Topic"), this.logger.error(s), s;
    }
  }
  async rpcSubscribe(e, t) {
    const i2 = { method: yt(t.protocol).subscribe, params: { topic: e } };
    this.logger.debug("Outgoing Relay Payload"), this.logger.trace({ type: "payload", direction: "outgoing", request: i2 });
    try {
      await await it(this.relayer.request(i2), this.subscribeTimeout);
    } catch {
      this.logger.debug("Outgoing Relay Subscribe Payload stalled"), this.relayer.events.emit(D2.connection_stalled);
    }
    return Mn(e + this.clientId);
  }
  async rpcBatchSubscribe(e) {
    if (!e.length)
      return;
    const t = e[0].relay, i2 = { method: yt(t.protocol).batchSubscribe, params: { topics: e.map((s) => s.topic) } };
    this.logger.debug("Outgoing Relay Payload"), this.logger.trace({ type: "payload", direction: "outgoing", request: i2 });
    try {
      return await await it(this.relayer.request(i2), this.subscribeTimeout);
    } catch {
      this.logger.debug("Outgoing Relay Payload stalled"), this.relayer.events.emit(D2.connection_stalled);
    }
  }
  rpcUnsubscribe(e, t, i2) {
    const s = { method: yt(i2.protocol).unsubscribe, params: { topic: e, id: t } };
    return this.logger.debug("Outgoing Relay Payload"), this.logger.trace({ type: "payload", direction: "outgoing", request: s }), this.relayer.request(s);
  }
  onSubscribe(e, t) {
    this.setSubscription(e, pe(B2({}, t), { id: e })), this.pending.delete(t.topic);
  }
  onBatchSubscribe(e) {
    e.length && e.forEach((t) => {
      this.setSubscription(t.id, B2({}, t)), this.pending.delete(t.topic);
    });
  }
  async onUnsubscribe(e, t, i2) {
    this.events.removeAllListeners(t), this.hasSubscription(t, e) && this.deleteSubscription(t, i2), await this.relayer.messages.del(e);
  }
  async setRelayerSubscriptions(e) {
    await this.relayer.core.storage.setItem(this.storageKey, e);
  }
  async getRelayerSubscriptions() {
    return await this.relayer.core.storage.getItem(this.storageKey);
  }
  setSubscription(e, t) {
    this.subscriptions.has(e) || (this.logger.debug("Setting subscription"), this.logger.trace({ type: "method", method: "setSubscription", id: e, subscription: t }), this.addSubscription(e, t));
  }
  addSubscription(e, t) {
    this.subscriptions.set(e, B2({}, t)), this.topicMap.set(t.topic, e), this.events.emit(C.created, t);
  }
  getSubscription(e) {
    this.logger.debug("Getting subscription"), this.logger.trace({ type: "method", method: "getSubscription", id: e });
    const t = this.subscriptions.get(e);
    if (!t) {
      const { message: i2 } = N("NO_MATCHING_KEY", `${this.name}: ${e}`);
      throw new Error(i2);
    }
    return t;
  }
  deleteSubscription(e, t) {
    this.logger.debug("Deleting subscription"), this.logger.trace({ type: "method", method: "deleteSubscription", id: e, reason: t });
    const i2 = this.getSubscription(e);
    this.subscriptions.delete(e), this.topicMap.delete(i2.topic, e), this.events.emit(C.deleted, pe(B2({}, i2), { reason: t }));
  }
  async persist() {
    await this.setRelayerSubscriptions(this.values), this.events.emit(C.sync);
  }
  async reset() {
    if (this.cached.length) {
      const e = Math.ceil(this.cached.length / this.batchSubscribeTopicsLimit);
      for (let t = 0; t < e; t++) {
        const i2 = this.cached.splice(0, this.batchSubscribeTopicsLimit);
        await this.batchSubscribe(i2);
      }
    }
    this.events.emit(C.resubscribed);
  }
  async restore() {
    try {
      const e = await this.getRelayerSubscriptions();
      if (typeof e > "u" || !e.length)
        return;
      if (this.subscriptions.size) {
        const { message: t } = N("RESTORE_WILL_OVERRIDE", this.name);
        throw this.logger.error(t), this.logger.error(`${this.name}: ${JSON.stringify(this.values)}`), new Error(t);
      }
      this.cached = e, this.logger.debug(`Successfully Restored subscriptions for ${this.name}`), this.logger.trace({ type: "method", method: "restore", subscriptions: this.values });
    } catch (e) {
      this.logger.debug(`Failed to Restore subscriptions for ${this.name}`), this.logger.error(e);
    }
  }
  async batchSubscribe(e) {
    if (!e.length)
      return;
    const t = await this.rpcBatchSubscribe(e);
    j(t) && this.onBatchSubscribe(t.map((i2, s) => pe(B2({}, e[s]), { id: i2 })));
  }
  async onConnect() {
    this.restartInProgress || (await this.restart(), this.onEnable());
  }
  onDisconnect() {
    this.onDisable();
  }
  async checkPending() {
    if (!this.initialized || this.relayer.transportExplicitlyClosed)
      return;
    const e = [];
    this.pending.forEach((t) => {
      e.push(t);
    }), await this.batchSubscribe(e);
  }
  registerEventListeners() {
    this.relayer.core.heartbeat.on(import_heartbeat.HEARTBEAT_EVENTS.pulse, async () => {
      await this.checkPending();
    }), this.relayer.on(D2.connect, async () => {
      await this.onConnect();
    }), this.relayer.on(D2.disconnect, () => {
      this.onDisconnect();
    }), this.events.on(C.created, async (e) => {
      const t = C.created;
      this.logger.info(`Emitting ${t}`), this.logger.debug({ type: "event", event: t, data: e }), await this.persist();
    }), this.events.on(C.deleted, async (e) => {
      const t = C.deleted;
      this.logger.info(`Emitting ${t}`), this.logger.debug({ type: "event", event: t, data: e }), await this.persist();
    });
  }
  isInitialized() {
    if (!this.initialized) {
      const { message: e } = N("NOT_INITIALIZED", this.name);
      throw new Error(e);
    }
  }
  async restartToComplete() {
    this.restartInProgress && await new Promise((e) => {
      const t = setInterval(() => {
        this.restartInProgress || (clearInterval(t), e());
      }, this.pollingInterval);
    });
  }
};
var wr = Object.defineProperty;
var Ot = Object.getOwnPropertySymbols;
var vr = Object.prototype.hasOwnProperty;
var Ir = Object.prototype.propertyIsEnumerable;
var xt2 = (r, e, t) => e in r ? wr(r, e, { enumerable: true, configurable: true, writable: true, value: t }) : r[e] = t;
var Cr = (r, e) => {
  for (var t in e || (e = {}))
    vr.call(e, t) && xt2(r, t, e[t]);
  if (Ot)
    for (var t of Ot(e))
      Ir.call(e, t) && xt2(r, t, e[t]);
  return r;
};
var At2 = class extends g {
  constructor(e) {
    super(e), this.protocol = "wc", this.version = 2, this.events = new import_events6.EventEmitter(), this.name = ht2, this.transportExplicitlyClosed = false, this.initialized = false, this.connectionAttemptInProgress = false, this.connectionStatusPollingInterval = 20, this.staleConnectionErrors = ["socket hang up", "socket stalled"], this.hasExperiencedNetworkDisruption = false, this.request = async (t) => {
      this.logger.debug("Publishing Request Payload");
      try {
        return await this.toEstablishConnection(), await this.provider.request(t);
      } catch (i2) {
        throw this.logger.debug("Failed to Publish Request"), this.logger.error(i2), i2;
      }
    }, this.onPayloadHandler = (t) => {
      this.onProviderPayload(t);
    }, this.onConnectHandler = () => {
      this.events.emit(D2.connect);
    }, this.onDisconnectHandler = () => {
      this.onProviderDisconnect();
    }, this.onProviderErrorHandler = (t) => {
      this.logger.error(t), this.events.emit(D2.error, t);
    }, this.registerProviderListeners = () => {
      this.provider.on(P.payload, this.onPayloadHandler), this.provider.on(P.connect, this.onConnectHandler), this.provider.on(P.disconnect, this.onDisconnectHandler), this.provider.on(P.error, this.onProviderErrorHandler);
    }, this.core = e.core, this.logger = typeof e.logger < "u" && typeof e.logger != "string" ? (0, import_logger.generateChildLogger)(e.logger, this.name) : (0, import_logger.pino)((0, import_logger.getDefaultLoggerOptions)({ level: e.logger || ot })), this.messages = new _t2(this.logger, e.core), this.subscriber = new Pt(this, this.logger), this.publisher = new pr(this, this.logger), this.relayUrl = (e == null ? void 0 : e.relayUrl) || le2, this.projectId = e.projectId, this.provider = {};
  }
  async init() {
    this.logger.trace("Initialized"), this.registerEventListeners(), await this.createProvider(), await Promise.all([this.messages.init(), this.subscriber.init()]);
    try {
      await this.transportOpen();
    } catch {
      this.logger.warn(`Connection via ${this.relayUrl} failed, attempting to connect via failover domain ${de2}...`), await this.restartTransport(de2);
    }
    this.initialized = true, setTimeout(async () => {
      this.subscriber.topics.length === 0 && (this.logger.info("No topics subscribed to after init, closing transport"), await this.transportClose(), this.transportExplicitlyClosed = false);
    }, dt2);
  }
  get context() {
    return (0, import_logger.getLoggerContext)(this.logger);
  }
  get connected() {
    return this.provider.connection.connected;
  }
  get connecting() {
    return this.provider.connection.connecting;
  }
  async publish(e, t, i2) {
    this.isInitialized(), await this.publisher.publish(e, t, i2), await this.recordMessageEvent({ topic: e, message: t, publishedAt: Date.now() });
  }
  async subscribe(e, t) {
    var i2;
    this.isInitialized();
    let s = ((i2 = this.subscriber.topicMap.get(e)) == null ? void 0 : i2[0]) || "";
    return s || (await Promise.all([new Promise((n2) => {
      this.subscriber.once(C.created, (a2) => {
        a2.topic === e && n2();
      });
    }), new Promise(async (n2) => {
      s = await this.subscriber.subscribe(e, t), n2();
    })]), s);
  }
  async unsubscribe(e, t) {
    this.isInitialized(), await this.subscriber.unsubscribe(e, t);
  }
  on(e, t) {
    this.events.on(e, t);
  }
  once(e, t) {
    this.events.once(e, t);
  }
  off(e, t) {
    this.events.off(e, t);
  }
  removeListener(e, t) {
    this.events.removeListener(e, t);
  }
  async transportClose() {
    this.transportExplicitlyClosed = true, this.hasExperiencedNetworkDisruption && this.connected ? await it(this.provider.disconnect(), 1e3, "provider.disconnect()").catch(() => this.onProviderDisconnect()) : this.connected && await this.provider.disconnect();
  }
  async transportOpen(e) {
    if (this.transportExplicitlyClosed = false, await this.confirmOnlineStateOrThrow(), !this.connectionAttemptInProgress) {
      e && e !== this.relayUrl && (this.relayUrl = e, await this.transportClose(), await this.createProvider()), this.connectionAttemptInProgress = true;
      try {
        await Promise.all([new Promise((t) => {
          if (!this.initialized)
            return t();
          this.subscriber.once(C.resubscribed, () => {
            t();
          });
        }), new Promise(async (t, i2) => {
          try {
            await it(this.provider.connect(), 1e4, `Socket stalled when trying to connect to ${this.relayUrl}`);
          } catch (s) {
            i2(s);
            return;
          }
          t();
        })]);
      } catch (t) {
        this.logger.error(t);
        const i2 = t;
        if (!this.isConnectionStalled(i2.message))
          throw t;
        this.provider.events.emit(P.disconnect);
      } finally {
        this.connectionAttemptInProgress = false, this.hasExperiencedNetworkDisruption = false;
      }
    }
  }
  async restartTransport(e) {
    await this.confirmOnlineStateOrThrow(), !this.connectionAttemptInProgress && (this.relayUrl = e || this.relayUrl, await this.transportClose(), await this.createProvider(), await this.transportOpen());
  }
  async confirmOnlineStateOrThrow() {
    if (!await Zt())
      throw new Error("No internet connection detected. Please restart your network and try again.");
  }
  isConnectionStalled(e) {
    return this.staleConnectionErrors.some((t) => e.includes(t));
  }
  async createProvider() {
    this.provider.connection && this.unregisterProviderListeners();
    const e = await this.core.crypto.signJWT(this.relayUrl);
    this.provider = new JsonRpcProvider(new esm_default(Jn({ sdkVersion: lt2, protocol: this.protocol, version: this.version, relayUrl: this.relayUrl, projectId: this.projectId, auth: e, useOnCloseEvent: true }))), this.registerProviderListeners();
  }
  async recordMessageEvent(e) {
    const { topic: t, message: i2 } = e;
    await this.messages.set(t, i2);
  }
  async shouldIgnoreMessageEvent(e) {
    const { topic: t, message: i2 } = e;
    if (!i2 || i2.length === 0)
      return this.logger.debug(`Ignoring invalid/empty message: ${i2}`), true;
    if (!await this.subscriber.isSubscribed(t))
      return this.logger.debug(`Ignoring message for non-subscribed topic ${t}`), true;
    const s = this.messages.has(t, i2);
    return s && this.logger.debug(`Ignoring duplicate message: ${i2}`), s;
  }
  async onProviderPayload(e) {
    if (this.logger.debug("Incoming Relay Payload"), this.logger.trace({ type: "payload", direction: "incoming", payload: e }), isJsonRpcRequest(e)) {
      if (!e.method.endsWith(ct2))
        return;
      const t = e.params, { topic: i2, message: s, publishedAt: n2 } = t.data, a2 = { topic: i2, message: s, publishedAt: n2 };
      this.logger.debug("Emitting Relayer Payload"), this.logger.trace(Cr({ type: "event", event: t.id }, a2)), this.events.emit(t.id, a2), await this.acknowledgePayload(e), await this.onMessageEvent(a2);
    } else
      isJsonRpcResponse(e) && this.events.emit(D2.message_ack, e);
  }
  async onMessageEvent(e) {
    await this.shouldIgnoreMessageEvent(e) || (this.events.emit(D2.message, e), await this.recordMessageEvent(e));
  }
  async acknowledgePayload(e) {
    const t = formatJsonRpcResult(e.id, true);
    await this.provider.connection.send(t);
  }
  unregisterProviderListeners() {
    this.provider.off(P.payload, this.onPayloadHandler), this.provider.off(P.connect, this.onConnectHandler), this.provider.off(P.disconnect, this.onDisconnectHandler), this.provider.off(P.error, this.onProviderErrorHandler);
  }
  async registerEventListeners() {
    this.events.on(D2.connection_stalled, () => {
      this.restartTransport().catch((t) => this.logger.error(t));
    });
    let e = await Zt();
    Xt(async (t) => {
      this.initialized && e !== t && (e = t, t ? await this.restartTransport().catch((i2) => this.logger.error(i2)) : (this.hasExperiencedNetworkDisruption = true, await this.transportClose().catch((i2) => this.logger.error(i2))));
    });
  }
  onProviderDisconnect() {
    this.events.emit(D2.disconnect), this.attemptToReconnect();
  }
  attemptToReconnect() {
    this.transportExplicitlyClosed || (this.logger.info("attemptToReconnect called. Connecting..."), setTimeout(async () => {
      await this.restartTransport().catch((e) => this.logger.error(e));
    }, (0, import_time2.toMiliseconds)(ut2)));
  }
  isInitialized() {
    if (!this.initialized) {
      const { message: e } = N("NOT_INITIALIZED", this.name);
      throw new Error(e);
    }
  }
  async toEstablishConnection() {
    if (await this.confirmOnlineStateOrThrow(), !this.connected) {
      if (this.connectionAttemptInProgress)
        return await new Promise((e) => {
          const t = setInterval(() => {
            this.connected && (clearInterval(t), e());
          }, this.connectionStatusPollingInterval);
        });
      await this.restartTransport();
    }
  }
};
var Rr = Object.defineProperty;
var zt2 = Object.getOwnPropertySymbols;
var _r = Object.prototype.hasOwnProperty;
var Tr = Object.prototype.propertyIsEnumerable;
var Nt2 = (r, e, t) => e in r ? Rr(r, e, { enumerable: true, configurable: true, writable: true, value: t }) : r[e] = t;
var Lt2 = (r, e) => {
  for (var t in e || (e = {}))
    _r.call(e, t) && Nt2(r, t, e[t]);
  if (zt2)
    for (var t of zt2(e))
      Tr.call(e, t) && Nt2(r, t, e[t]);
  return r;
};
var Ut = class extends p {
  constructor(e, t, i2, s = x2, n2 = void 0) {
    super(e, t, i2, s), this.core = e, this.logger = t, this.name = i2, this.map = /* @__PURE__ */ new Map(), this.version = gt2, this.cached = [], this.initialized = false, this.storagePrefix = x2, this.init = async () => {
      this.initialized || (this.logger.trace("Initialized"), await this.restore(), this.cached.forEach((a2) => {
        this.getKey && a2 !== null && !w(a2) ? this.map.set(this.getKey(a2), a2) : Dt(a2) ? this.map.set(a2.id, a2) : kt(a2) && this.map.set(a2.topic, a2);
      }), this.cached = [], this.initialized = true);
    }, this.set = async (a2, o) => {
      this.isInitialized(), this.map.has(a2) ? await this.update(a2, o) : (this.logger.debug("Setting value"), this.logger.trace({ type: "method", method: "set", key: a2, value: o }), this.map.set(a2, o), await this.persist());
    }, this.get = (a2) => (this.isInitialized(), this.logger.debug("Getting value"), this.logger.trace({ type: "method", method: "get", key: a2 }), this.getData(a2)), this.getAll = (a2) => (this.isInitialized(), a2 ? this.values.filter((o) => Object.keys(a2).every((h3) => (0, import_lodash.default)(o[h3], a2[h3]))) : this.values), this.update = async (a2, o) => {
      this.isInitialized(), this.logger.debug("Updating value"), this.logger.trace({ type: "method", method: "update", key: a2, update: o });
      const h3 = Lt2(Lt2({}, this.getData(a2)), o);
      this.map.set(a2, h3), await this.persist();
    }, this.delete = async (a2, o) => {
      this.isInitialized(), this.map.has(a2) && (this.logger.debug("Deleting value"), this.logger.trace({ type: "method", method: "delete", key: a2, reason: o }), this.map.delete(a2), await this.persist());
    }, this.logger = (0, import_logger.generateChildLogger)(t, this.name), this.storagePrefix = s, this.getKey = n2;
  }
  get context() {
    return (0, import_logger.getLoggerContext)(this.logger);
  }
  get storageKey() {
    return this.storagePrefix + this.version + "//" + this.name;
  }
  get length() {
    return this.map.size;
  }
  get keys() {
    return Array.from(this.map.keys());
  }
  get values() {
    return Array.from(this.map.values());
  }
  async setDataStore(e) {
    await this.core.storage.setItem(this.storageKey, e);
  }
  async getDataStore() {
    return await this.core.storage.getItem(this.storageKey);
  }
  getData(e) {
    const t = this.map.get(e);
    if (!t) {
      const { message: i2 } = N("NO_MATCHING_KEY", `${this.name}: ${e}`);
      throw this.logger.error(i2), new Error(i2);
    }
    return t;
  }
  async persist() {
    await this.setDataStore(this.values);
  }
  async restore() {
    try {
      const e = await this.getDataStore();
      if (typeof e > "u" || !e.length)
        return;
      if (this.map.size) {
        const { message: t } = N("RESTORE_WILL_OVERRIDE", this.name);
        throw this.logger.error(t), new Error(t);
      }
      this.cached = e, this.logger.debug(`Successfully Restored value for ${this.name}`), this.logger.trace({ type: "method", method: "restore", value: this.values });
    } catch (e) {
      this.logger.debug(`Failed to Restore value for ${this.name}`), this.logger.error(e);
    }
  }
  isInitialized() {
    if (!this.initialized) {
      const { message: e } = N("NOT_INITIALIZED", this.name);
      throw new Error(e);
    }
  }
};
var Ft2 = class {
  constructor(e, t) {
    this.core = e, this.logger = t, this.name = mt2, this.version = ft2, this.events = new import_events6.default(), this.initialized = false, this.storagePrefix = x2, this.ignoredPayloadTypes = [_], this.registeredMethods = [], this.init = async () => {
      this.initialized || (await this.pairings.init(), await this.cleanup(), this.registerRelayerEvents(), this.registerExpirerEvents(), this.initialized = true, this.logger.trace("Initialized"));
    }, this.register = ({ methods: i2 }) => {
      this.isInitialized(), this.registeredMethods = [.../* @__PURE__ */ new Set([...this.registeredMethods, ...i2])];
    }, this.create = async () => {
      this.isInitialized();
      const i2 = Dn(), s = await this.core.crypto.setSymKey(i2), n2 = lt(import_time2.FIVE_MINUTES), a2 = { protocol: at2 }, o = { topic: s, expiry: n2, relay: a2, active: false }, h3 = Nt({ protocol: this.core.protocol, version: this.core.version, topic: s, symKey: i2, relay: a2 });
      return await this.pairings.set(s, o), await this.core.relayer.subscribe(s), this.core.expirer.set(s, n2), { topic: s, uri: h3 };
    }, this.pair = async (i2) => {
      this.isInitialized(), this.isValidPair(i2);
      const { topic: s, symKey: n2, relay: a2 } = bt(i2.uri);
      if (this.pairings.keys.includes(s))
        throw new Error(`Pairing already exists: ${s}`);
      if (this.core.crypto.hasKeys(s))
        throw new Error(`Keychain already exists: ${s}`);
      const o = lt(import_time2.FIVE_MINUTES), h3 = { topic: s, relay: a2, expiry: o, active: false };
      return await this.pairings.set(s, h3), await this.core.crypto.setSymKey(n2, s), await this.core.relayer.subscribe(s, { relay: a2 }), this.core.expirer.set(s, o), i2.activatePairing && await this.activate({ topic: s }), h3;
    }, this.activate = async ({ topic: i2 }) => {
      this.isInitialized();
      const s = lt(import_time2.THIRTY_DAYS);
      await this.pairings.update(i2, { active: true, expiry: s }), this.core.expirer.set(i2, s);
    }, this.ping = async (i2) => {
      this.isInitialized(), await this.isValidPing(i2);
      const { topic: s } = i2;
      if (this.pairings.keys.includes(s)) {
        const n2 = await this.sendRequest(s, "wc_pairingPing", {}), { done: a2, resolve: o, reject: h3 } = st();
        this.events.once(ft("pairing_ping", n2), ({ error: l }) => {
          l ? h3(l) : o();
        }), await a2();
      }
    }, this.updateExpiry = async ({ topic: i2, expiry: s }) => {
      this.isInitialized(), await this.pairings.update(i2, { expiry: s });
    }, this.updateMetadata = async ({ topic: i2, metadata: s }) => {
      this.isInitialized(), await this.pairings.update(i2, { peerMetadata: s });
    }, this.getPairings = () => (this.isInitialized(), this.pairings.values), this.disconnect = async (i2) => {
      this.isInitialized(), await this.isValidDisconnect(i2);
      const { topic: s } = i2;
      this.pairings.keys.includes(s) && (await this.sendRequest(s, "wc_pairingDelete", U("USER_DISCONNECTED")), await this.deletePairing(s));
    }, this.sendRequest = async (i2, s, n2) => {
      const a2 = formatJsonRpcRequest(s, n2), o = await this.core.crypto.encode(i2, a2), h3 = F[s].req;
      return this.core.history.set(i2, a2), this.core.relayer.publish(i2, o, h3), a2.id;
    }, this.sendResult = async (i2, s, n2) => {
      const a2 = formatJsonRpcResult(i2, n2), o = await this.core.crypto.encode(s, a2), h3 = await this.core.history.get(s, i2), l = F[h3.request.method].res;
      await this.core.relayer.publish(s, o, l), await this.core.history.resolve(a2);
    }, this.sendError = async (i2, s, n2) => {
      const a2 = formatJsonRpcError(i2, n2), o = await this.core.crypto.encode(s, a2), h3 = await this.core.history.get(s, i2), l = F[h3.request.method] ? F[h3.request.method].res : F.unregistered_method.res;
      await this.core.relayer.publish(s, o, l), await this.core.history.resolve(a2);
    }, this.deletePairing = async (i2, s) => {
      await this.core.relayer.unsubscribe(i2), await Promise.all([this.pairings.delete(i2, U("USER_DISCONNECTED")), this.core.crypto.deleteSymKey(i2), s ? Promise.resolve() : this.core.expirer.del(i2)]);
    }, this.cleanup = async () => {
      const i2 = this.pairings.getAll().filter((s) => dt(s.expiry));
      await Promise.all(i2.map((s) => this.deletePairing(s.topic)));
    }, this.onRelayEventRequest = (i2) => {
      const { topic: s, payload: n2 } = i2;
      switch (n2.method) {
        case "wc_pairingPing":
          return this.onPairingPingRequest(s, n2);
        case "wc_pairingDelete":
          return this.onPairingDeleteRequest(s, n2);
        default:
          return this.onUnknownRpcMethodRequest(s, n2);
      }
    }, this.onRelayEventResponse = async (i2) => {
      const { topic: s, payload: n2 } = i2, a2 = (await this.core.history.get(s, n2.id)).request.method;
      switch (a2) {
        case "wc_pairingPing":
          return this.onPairingPingResponse(s, n2);
        default:
          return this.onUnknownRpcMethodResponse(a2);
      }
    }, this.onPairingPingRequest = async (i2, s) => {
      const { id: n2 } = s;
      try {
        this.isValidPing({ topic: i2 }), await this.sendResult(n2, i2, true), this.events.emit("pairing_ping", { id: n2, topic: i2 });
      } catch (a2) {
        await this.sendError(n2, i2, a2), this.logger.error(a2);
      }
    }, this.onPairingPingResponse = (i2, s) => {
      const { id: n2 } = s;
      setTimeout(() => {
        isJsonRpcResult(s) ? this.events.emit(ft("pairing_ping", n2), {}) : isJsonRpcError(s) && this.events.emit(ft("pairing_ping", n2), { error: s.error });
      }, 500);
    }, this.onPairingDeleteRequest = async (i2, s) => {
      const { id: n2 } = s;
      try {
        this.isValidDisconnect({ topic: i2 }), await this.deletePairing(i2), this.events.emit("pairing_delete", { id: n2, topic: i2 });
      } catch (a2) {
        await this.sendError(n2, i2, a2), this.logger.error(a2);
      }
    }, this.onUnknownRpcMethodRequest = async (i2, s) => {
      const { id: n2, method: a2 } = s;
      try {
        if (this.registeredMethods.includes(a2))
          return;
        const o = U("WC_METHOD_UNSUPPORTED", a2);
        await this.sendError(n2, i2, o), this.logger.error(o);
      } catch (o) {
        await this.sendError(n2, i2, o), this.logger.error(o);
      }
    }, this.onUnknownRpcMethodResponse = (i2) => {
      this.registeredMethods.includes(i2) || this.logger.error(U("WC_METHOD_UNSUPPORTED", i2));
    }, this.isValidPair = (i2) => {
      if (!xt(i2)) {
        const { message: s } = N("MISSING_OR_INVALID", `pair() params: ${i2}`);
        throw new Error(s);
      }
      if (!jt(i2.uri)) {
        const { message: s } = N("MISSING_OR_INVALID", `pair() uri: ${i2.uri}`);
        throw new Error(s);
      }
    }, this.isValidPing = async (i2) => {
      if (!xt(i2)) {
        const { message: n2 } = N("MISSING_OR_INVALID", `ping() params: ${i2}`);
        throw new Error(n2);
      }
      const { topic: s } = i2;
      await this.isValidPairingTopic(s);
    }, this.isValidDisconnect = async (i2) => {
      if (!xt(i2)) {
        const { message: n2 } = N("MISSING_OR_INVALID", `disconnect() params: ${i2}`);
        throw new Error(n2);
      }
      const { topic: s } = i2;
      await this.isValidPairingTopic(s);
    }, this.isValidPairingTopic = async (i2) => {
      if (!h2(i2, false)) {
        const { message: s } = N("MISSING_OR_INVALID", `pairing topic should be a string: ${i2}`);
        throw new Error(s);
      }
      if (!this.pairings.keys.includes(i2)) {
        const { message: s } = N("NO_MATCHING_KEY", `pairing topic doesn't exist: ${i2}`);
        throw new Error(s);
      }
      if (dt(this.pairings.get(i2).expiry)) {
        await this.deletePairing(i2);
        const { message: s } = N("EXPIRED", `pairing topic: ${i2}`);
        throw new Error(s);
      }
    }, this.core = e, this.logger = (0, import_logger.generateChildLogger)(t, this.name), this.pairings = new Ut(this.core, this.logger, this.name, this.storagePrefix);
  }
  get context() {
    return (0, import_logger.getLoggerContext)(this.logger);
  }
  isInitialized() {
    if (!this.initialized) {
      const { message: e } = N("NOT_INITIALIZED", this.name);
      throw new Error(e);
    }
  }
  registerRelayerEvents() {
    this.core.relayer.on(D2.message, async (e) => {
      const { topic: t, message: i2 } = e;
      if (!this.pairings.keys.includes(t) || this.ignoredPayloadTypes.includes(this.core.crypto.getPayloadType(i2)))
        return;
      const s = await this.core.crypto.decode(t, i2);
      try {
        isJsonRpcRequest(s) ? (this.core.history.set(t, s), this.onRelayEventRequest({ topic: t, payload: s })) : isJsonRpcResponse(s) && (await this.core.history.resolve(s), await this.onRelayEventResponse({ topic: t, payload: s }), this.core.history.delete(t, s.id));
      } catch (n2) {
        this.logger.error(n2);
      }
    });
  }
  registerExpirerEvents() {
    this.core.expirer.on(w2.expired, async (e) => {
      const { topic: t } = ut(e.target);
      t && this.pairings.keys.includes(t) && (await this.deletePairing(t, true), this.events.emit("pairing_expire", { topic: t }));
    });
  }
};
var $t2 = class extends h {
  constructor(e, t) {
    super(e, t), this.core = e, this.logger = t, this.records = /* @__PURE__ */ new Map(), this.events = new import_events6.EventEmitter(), this.name = Et2, this.version = wt, this.cached = [], this.initialized = false, this.storagePrefix = x2, this.init = async () => {
      this.initialized || (this.logger.trace("Initialized"), await this.restore(), this.cached.forEach((i2) => this.records.set(i2.id, i2)), this.cached = [], this.registerEventListeners(), this.initialized = true);
    }, this.set = (i2, s, n2) => {
      if (this.isInitialized(), this.logger.debug("Setting JSON-RPC request history record"), this.logger.trace({ type: "method", method: "set", topic: i2, request: s, chainId: n2 }), this.records.has(s.id))
        return;
      const a2 = { id: s.id, topic: i2, request: { method: s.method, params: s.params || null }, chainId: n2, expiry: lt(import_time2.THIRTY_DAYS) };
      this.records.set(a2.id, a2), this.events.emit(R2.created, a2);
    }, this.resolve = async (i2) => {
      if (this.isInitialized(), this.logger.debug("Updating JSON-RPC response history record"), this.logger.trace({ type: "method", method: "update", response: i2 }), !this.records.has(i2.id))
        return;
      const s = await this.getRecord(i2.id);
      typeof s.response > "u" && (s.response = isJsonRpcError(i2) ? { error: i2.error } : { result: i2.result }, this.records.set(s.id, s), this.events.emit(R2.updated, s));
    }, this.get = async (i2, s) => (this.isInitialized(), this.logger.debug("Getting record"), this.logger.trace({ type: "method", method: "get", topic: i2, id: s }), await this.getRecord(s)), this.delete = (i2, s) => {
      this.isInitialized(), this.logger.debug("Deleting record"), this.logger.trace({ type: "method", method: "delete", id: s }), this.values.forEach((n2) => {
        if (n2.topic === i2) {
          if (typeof s < "u" && n2.id !== s)
            return;
          this.records.delete(n2.id), this.events.emit(R2.deleted, n2);
        }
      });
    }, this.exists = async (i2, s) => (this.isInitialized(), this.records.has(s) ? (await this.getRecord(s)).topic === i2 : false), this.on = (i2, s) => {
      this.events.on(i2, s);
    }, this.once = (i2, s) => {
      this.events.once(i2, s);
    }, this.off = (i2, s) => {
      this.events.off(i2, s);
    }, this.removeListener = (i2, s) => {
      this.events.removeListener(i2, s);
    }, this.logger = (0, import_logger.generateChildLogger)(t, this.name);
  }
  get context() {
    return (0, import_logger.getLoggerContext)(this.logger);
  }
  get storageKey() {
    return this.storagePrefix + this.version + "//" + this.name;
  }
  get size() {
    return this.records.size;
  }
  get keys() {
    return Array.from(this.records.keys());
  }
  get values() {
    return Array.from(this.records.values());
  }
  get pending() {
    const e = [];
    return this.values.forEach((t) => {
      if (typeof t.response < "u")
        return;
      const i2 = { topic: t.topic, request: formatJsonRpcRequest(t.request.method, t.request.params, t.id), chainId: t.chainId };
      return e.push(i2);
    }), e;
  }
  async setJsonRpcRecords(e) {
    await this.core.storage.setItem(this.storageKey, e);
  }
  async getJsonRpcRecords() {
    return await this.core.storage.getItem(this.storageKey);
  }
  getRecord(e) {
    this.isInitialized();
    const t = this.records.get(e);
    if (!t) {
      const { message: i2 } = N("NO_MATCHING_KEY", `${this.name}: ${e}`);
      throw new Error(i2);
    }
    return t;
  }
  async persist() {
    await this.setJsonRpcRecords(this.values), this.events.emit(R2.sync);
  }
  async restore() {
    try {
      const e = await this.getJsonRpcRecords();
      if (typeof e > "u" || !e.length)
        return;
      if (this.records.size) {
        const { message: t } = N("RESTORE_WILL_OVERRIDE", this.name);
        throw this.logger.error(t), new Error(t);
      }
      this.cached = e, this.logger.debug(`Successfully Restored records for ${this.name}`), this.logger.trace({ type: "method", method: "restore", records: this.values });
    } catch (e) {
      this.logger.debug(`Failed to Restore records for ${this.name}`), this.logger.error(e);
    }
  }
  registerEventListeners() {
    this.events.on(R2.created, (e) => {
      const t = R2.created;
      this.logger.info(`Emitting ${t}`), this.logger.debug({ type: "event", event: t, record: e }), this.persist();
    }), this.events.on(R2.updated, (e) => {
      const t = R2.updated;
      this.logger.info(`Emitting ${t}`), this.logger.debug({ type: "event", event: t, record: e }), this.persist();
    }), this.events.on(R2.deleted, (e) => {
      const t = R2.deleted;
      this.logger.info(`Emitting ${t}`), this.logger.debug({ type: "event", event: t, record: e }), this.persist();
    }), this.core.heartbeat.on(import_heartbeat.HEARTBEAT_EVENTS.pulse, () => {
      this.cleanup();
    });
  }
  cleanup() {
    try {
      this.records.forEach((e) => {
        (0, import_time2.toMiliseconds)(e.expiry || 0) - Date.now() <= 0 && (this.logger.info(`Deleting expired history log: ${e.id}`), this.delete(e.topic, e.id));
      });
    } catch (e) {
      this.logger.warn(e);
    }
  }
  isInitialized() {
    if (!this.initialized) {
      const { message: e } = N("NOT_INITIALIZED", this.name);
      throw new Error(e);
    }
  }
};
var Mt2 = class extends E {
  constructor(e, t) {
    super(e, t), this.core = e, this.logger = t, this.expirations = /* @__PURE__ */ new Map(), this.events = new import_events6.EventEmitter(), this.name = vt2, this.version = It, this.cached = [], this.initialized = false, this.storagePrefix = x2, this.init = async () => {
      this.initialized || (this.logger.trace("Initialized"), await this.restore(), this.cached.forEach((i2) => this.expirations.set(i2.target, i2)), this.cached = [], this.registerEventListeners(), this.initialized = true);
    }, this.has = (i2) => {
      try {
        const s = this.formatTarget(i2);
        return typeof this.getExpiration(s) < "u";
      } catch {
        return false;
      }
    }, this.set = (i2, s) => {
      this.isInitialized();
      const n2 = this.formatTarget(i2), a2 = { target: n2, expiry: s };
      this.expirations.set(n2, a2), this.checkExpiry(n2, a2), this.events.emit(w2.created, { target: n2, expiration: a2 });
    }, this.get = (i2) => {
      this.isInitialized();
      const s = this.formatTarget(i2);
      return this.getExpiration(s);
    }, this.del = (i2) => {
      if (this.isInitialized(), this.has(i2)) {
        const s = this.formatTarget(i2), n2 = this.getExpiration(s);
        this.expirations.delete(s), this.events.emit(w2.deleted, { target: s, expiration: n2 });
      }
    }, this.on = (i2, s) => {
      this.events.on(i2, s);
    }, this.once = (i2, s) => {
      this.events.once(i2, s);
    }, this.off = (i2, s) => {
      this.events.off(i2, s);
    }, this.removeListener = (i2, s) => {
      this.events.removeListener(i2, s);
    }, this.logger = (0, import_logger.generateChildLogger)(t, this.name);
  }
  get context() {
    return (0, import_logger.getLoggerContext)(this.logger);
  }
  get storageKey() {
    return this.storagePrefix + this.version + "//" + this.name;
  }
  get length() {
    return this.expirations.size;
  }
  get keys() {
    return Array.from(this.expirations.keys());
  }
  get values() {
    return Array.from(this.expirations.values());
  }
  formatTarget(e) {
    if (typeof e == "string")
      return ct(e);
    if (typeof e == "number")
      return at(e);
    const { message: t } = N("UNKNOWN_TYPE", `Target type: ${typeof e}`);
    throw new Error(t);
  }
  async setExpirations(e) {
    await this.core.storage.setItem(this.storageKey, e);
  }
  async getExpirations() {
    return await this.core.storage.getItem(this.storageKey);
  }
  async persist() {
    await this.setExpirations(this.values), this.events.emit(w2.sync);
  }
  async restore() {
    try {
      const e = await this.getExpirations();
      if (typeof e > "u" || !e.length)
        return;
      if (this.expirations.size) {
        const { message: t } = N("RESTORE_WILL_OVERRIDE", this.name);
        throw this.logger.error(t), new Error(t);
      }
      this.cached = e, this.logger.debug(`Successfully Restored expirations for ${this.name}`), this.logger.trace({ type: "method", method: "restore", expirations: this.values });
    } catch (e) {
      this.logger.debug(`Failed to Restore expirations for ${this.name}`), this.logger.error(e);
    }
  }
  getExpiration(e) {
    const t = this.expirations.get(e);
    if (!t) {
      const { message: i2 } = N("NO_MATCHING_KEY", `${this.name}: ${e}`);
      throw this.logger.error(i2), new Error(i2);
    }
    return t;
  }
  checkExpiry(e, t) {
    const { expiry: i2 } = t;
    (0, import_time2.toMiliseconds)(i2) - Date.now() <= 0 && this.expire(e, t);
  }
  expire(e, t) {
    this.expirations.delete(e), this.events.emit(w2.expired, { target: e, expiration: t });
  }
  checkExpirations() {
    this.core.relayer.connected && this.expirations.forEach((e, t) => this.checkExpiry(t, e));
  }
  registerEventListeners() {
    this.core.heartbeat.on(import_heartbeat.HEARTBEAT_EVENTS.pulse, () => this.checkExpirations()), this.events.on(w2.created, (e) => {
      const t = w2.created;
      this.logger.info(`Emitting ${t}`), this.logger.debug({ type: "event", event: t, data: e }), this.persist();
    }), this.events.on(w2.expired, (e) => {
      const t = w2.expired;
      this.logger.info(`Emitting ${t}`), this.logger.debug({ type: "event", event: t, data: e }), this.persist();
    }), this.events.on(w2.deleted, (e) => {
      const t = w2.deleted;
      this.logger.info(`Emitting ${t}`), this.logger.debug({ type: "event", event: t, data: e }), this.persist();
    });
  }
  isInitialized() {
    if (!this.initialized) {
      const { message: e } = N("NOT_INITIALIZED", this.name);
      throw new Error(e);
    }
  }
};
var kt2 = class extends y {
  constructor(e, t) {
    super(e, t), this.projectId = e, this.logger = t, this.name = X2, this.initialized = false, this.queue = [], this.verifyDisabled = false, this.init = async (i2) => {
      if (this.verifyDisabled || H() || !q())
        return;
      const s = (i2 == null ? void 0 : i2.verifyUrl) || Q2;
      this.verifyUrl !== s && this.removeIframe(), this.verifyUrl = s;
      try {
        await this.createIframe();
      } catch (n2) {
        this.logger.warn(`Verify iframe failed to load: ${this.verifyUrl}`), this.logger.warn(n2);
      }
      if (!this.initialized) {
        this.removeIframe(), this.verifyUrl = ge;
        try {
          await this.createIframe();
        } catch (n2) {
          this.logger.error(`Verify iframe failed to load: ${this.verifyUrl}`), this.logger.error(n2), this.verifyDisabled = true;
        }
      }
    }, this.register = async (i2) => {
      this.initialized ? this.sendPost(i2.attestationId) : (this.addToQueue(i2.attestationId), await this.init());
    }, this.resolve = async (i2) => {
      if (this.isDevEnv)
        return "";
      const s = (i2 == null ? void 0 : i2.verifyUrl) || Q2;
      let n2 = "";
      try {
        n2 = await this.fetchAttestation(i2.attestationId, s);
      } catch (a2) {
        this.logger.warn(`failed to resolve attestation: ${i2.attestationId} from url: ${s}`), this.logger.warn(a2), n2 = await this.fetchAttestation(i2.attestationId, ge);
      }
      return n2;
    }, this.fetchAttestation = async (i2, s) => {
      var n2;
      this.logger.info(`resolving attestation: ${i2} from url: ${s}`);
      const a2 = this.startAbortTimer(import_time2.ONE_SECOND * 2), o = await fetch(`${s}/attestation/${i2}`, { signal: this.abortController.signal });
      return clearTimeout(a2), o.status === 200 ? (n2 = await o.json()) == null ? void 0 : n2.origin : "";
    }, this.addToQueue = (i2) => {
      this.queue.push(i2);
    }, this.processQueue = () => {
      this.queue.length !== 0 && (this.queue.forEach((i2) => this.sendPost(i2)), this.queue = []);
    }, this.sendPost = (i2) => {
      var s;
      try {
        if (!this.iframe)
          return;
        (s = this.iframe.contentWindow) == null || s.postMessage(i2, "*"), this.logger.info(`postMessage sent: ${i2} ${this.verifyUrl}`);
      } catch {
      }
    }, this.createIframe = async () => {
      let i2;
      const s = (n2) => {
        n2.data === "verify_ready" && (this.initialized = true, this.processQueue(), window.removeEventListener("message", s), i2());
      };
      await Promise.race([new Promise((n2) => {
        if (document.getElementById(X2))
          return n2();
        window.addEventListener("message", s);
        const a2 = document.createElement("iframe");
        a2.id = X2, a2.src = `${this.verifyUrl}/${this.projectId}`, a2.style.display = "none", document.body.append(a2), this.iframe = a2, i2 = n2;
      }), new Promise((n2, a2) => setTimeout(() => {
        window.removeEventListener("message", s), a2("verify iframe load timeout");
      }, (0, import_time2.toMiliseconds)(import_time2.FIVE_SECONDS)))]);
    }, this.removeIframe = () => {
      this.iframe && (this.iframe.remove(), this.iframe = void 0, this.initialized = false);
    }, this.logger = (0, import_logger.generateChildLogger)(t, this.name), this.verifyUrl = Q2, this.abortController = new AbortController(), this.isDevEnv = te() && process.env.IS_VITEST;
  }
  get context() {
    return (0, import_logger.getLoggerContext)(this.logger);
  }
  startAbortTimer(e) {
    return this.abortController = new AbortController(), setTimeout(() => this.abortController.abort(), (0, import_time2.toMiliseconds)(e));
  }
};
var Sr = Object.defineProperty;
var Kt2 = Object.getOwnPropertySymbols;
var Pr = Object.prototype.hasOwnProperty;
var Or = Object.prototype.propertyIsEnumerable;
var Bt2 = (r, e, t) => e in r ? Sr(r, e, { enumerable: true, configurable: true, writable: true, value: t }) : r[e] = t;
var Vt2 = (r, e) => {
  for (var t in e || (e = {}))
    Pr.call(e, t) && Bt2(r, t, e[t]);
  if (Kt2)
    for (var t of Kt2(e))
      Or.call(e, t) && Bt2(r, t, e[t]);
  return r;
};
var Z2 = class _Z extends n {
  constructor(e) {
    super(e), this.protocol = ce2, this.version = Je2, this.name = W2, this.events = new import_events6.EventEmitter(), this.initialized = false, this.on = (i2, s) => this.events.on(i2, s), this.once = (i2, s) => this.events.once(i2, s), this.off = (i2, s) => this.events.off(i2, s), this.removeListener = (i2, s) => this.events.removeListener(i2, s), this.projectId = e == null ? void 0 : e.projectId, this.relayUrl = (e == null ? void 0 : e.relayUrl) || le2;
    const t = typeof (e == null ? void 0 : e.logger) < "u" && typeof (e == null ? void 0 : e.logger) != "string" ? e.logger : (0, import_logger.pino)((0, import_logger.getDefaultLoggerOptions)({ level: (e == null ? void 0 : e.logger) || We2.logger }));
    this.logger = (0, import_logger.generateChildLogger)(t, this.name), this.heartbeat = new import_heartbeat.HeartBeat(), this.crypto = new Rt(this, this.logger, e == null ? void 0 : e.keychain), this.history = new $t2(this, this.logger), this.expirer = new Mt2(this, this.logger), this.storage = e != null && e.storage ? e.storage : new import_keyvaluestorage.default(Vt2(Vt2({}, Xe), e == null ? void 0 : e.storageOptions)), this.relayer = new At2({ core: this, logger: this.logger, relayUrl: this.relayUrl, projectId: this.projectId }), this.pairing = new Ft2(this, this.logger), this.verify = new kt2(this.projectId || "", this.logger);
  }
  static async init(e) {
    const t = new _Z(e);
    await t.initialize();
    const i2 = await t.crypto.getClientId();
    return await t.storage.setItem(pt2, i2), t;
  }
  get context() {
    return (0, import_logger.getLoggerContext)(this.logger);
  }
  async start() {
    this.initialized || await this.initialize();
  }
  async initialize() {
    this.logger.trace("Initialized");
    try {
      await this.crypto.init(), await this.history.init(), await this.expirer.init(), await this.relayer.init(), await this.heartbeat.init(), await this.pairing.init(), this.initialized = true, this.logger.info("Core Initialization Success");
    } catch (e) {
      throw this.logger.warn(`Core Initialization Failure at epoch ${Date.now()}`, e), this.logger.error(e.message), e;
    }
  }
};
var xr = Z2;

// node_modules/@taquito/beacon-wallet/node_modules/@walletconnect/sign-client/dist/index.es.js
var import_logger2 = __toESM(require_cjs3());
var import_events7 = __toESM(require_events());
var import_time3 = __toESM(require_cjs());
var J3 = "wc";
var X3 = 2;
var F2 = "client";
var G2 = `${J3}@${X3}:${F2}:`;
var M2 = { name: F2, logger: "error", controller: false, relayUrl: "wss://relay.walletconnect.com" };
var H3 = "WALLETCONNECT_DEEPLINK_CHOICE";
var ne = "proposal";
var oe2 = "Proposal expired";
var ae3 = "session";
var C2 = import_time3.SEVEN_DAYS;
var ce3 = "engine";
var V = { wc_sessionPropose: { req: { ttl: import_time3.FIVE_MINUTES, prompt: true, tag: 1100 }, res: { ttl: import_time3.FIVE_MINUTES, prompt: false, tag: 1101 } }, wc_sessionSettle: { req: { ttl: import_time3.FIVE_MINUTES, prompt: false, tag: 1102 }, res: { ttl: import_time3.FIVE_MINUTES, prompt: false, tag: 1103 } }, wc_sessionUpdate: { req: { ttl: import_time3.ONE_DAY, prompt: false, tag: 1104 }, res: { ttl: import_time3.ONE_DAY, prompt: false, tag: 1105 } }, wc_sessionExtend: { req: { ttl: import_time3.ONE_DAY, prompt: false, tag: 1106 }, res: { ttl: import_time3.ONE_DAY, prompt: false, tag: 1107 } }, wc_sessionRequest: { req: { ttl: import_time3.FIVE_MINUTES, prompt: true, tag: 1108 }, res: { ttl: import_time3.FIVE_MINUTES, prompt: false, tag: 1109 } }, wc_sessionEvent: { req: { ttl: import_time3.FIVE_MINUTES, prompt: true, tag: 1110 }, res: { ttl: import_time3.FIVE_MINUTES, prompt: false, tag: 1111 } }, wc_sessionDelete: { req: { ttl: import_time3.ONE_DAY, prompt: false, tag: 1112 }, res: { ttl: import_time3.ONE_DAY, prompt: false, tag: 1113 } }, wc_sessionPing: { req: { ttl: import_time3.THIRTY_SECONDS, prompt: false, tag: 1114 }, res: { ttl: import_time3.THIRTY_SECONDS, prompt: false, tag: 1115 } } };
var U3 = { min: import_time3.FIVE_MINUTES, max: import_time3.SEVEN_DAYS };
var E3 = { idle: "IDLE", active: "ACTIVE" };
var le3 = "request";
var pe2 = ["wc_sessionPropose", "wc_sessionRequest", "wc_authRequest"];
var rs2 = Object.defineProperty;
var ns2 = Object.defineProperties;
var os2 = Object.getOwnPropertyDescriptors;
var he3 = Object.getOwnPropertySymbols;
var as2 = Object.prototype.hasOwnProperty;
var cs2 = Object.prototype.propertyIsEnumerable;
var de3 = (m2, r, e) => r in m2 ? rs2(m2, r, { enumerable: true, configurable: true, writable: true, value: e }) : m2[r] = e;
var g3 = (m2, r) => {
  for (var e in r || (r = {}))
    as2.call(r, e) && de3(m2, e, r[e]);
  if (he3)
    for (var e of he3(r))
      cs2.call(r, e) && de3(m2, e, r[e]);
  return m2;
};
var b2 = (m2, r) => ns2(m2, os2(r));
var ls2 = class extends S {
  constructor(r) {
    super(r), this.name = ce3, this.events = new import_events7.default(), this.initialized = false, this.ignoredPayloadTypes = [_], this.requestQueue = { state: E3.idle, queue: [] }, this.sessionRequestQueue = { state: E3.idle, queue: [] }, this.requestQueueDelay = import_time3.ONE_SECOND, this.init = async () => {
      this.initialized || (await this.cleanup(), this.registerRelayerEvents(), this.registerExpirerEvents(), this.client.core.pairing.register({ methods: Object.keys(V) }), this.initialized = true, setTimeout(() => {
        this.sessionRequestQueue.queue = this.getPendingSessionRequests(), this.processSessionRequestQueue();
      }, (0, import_time3.toMiliseconds)(this.requestQueueDelay)));
    }, this.connect = async (e) => {
      await this.isInitialized();
      const s = b2(g3({}, e), { requiredNamespaces: e.requiredNamespaces || {}, optionalNamespaces: e.optionalNamespaces || {} });
      await this.isValidConnect(s);
      const { pairingTopic: t, requiredNamespaces: i2, optionalNamespaces: n2, sessionProperties: o, relays: a2 } = s;
      let l = t, p3, d2 = false;
      if (l && (d2 = this.client.core.pairing.pairings.get(l).active), !l || !d2) {
        const { topic: v, uri: S2 } = await this.client.core.pairing.create();
        l = v, p3 = S2;
      }
      const h3 = await this.client.core.crypto.generateKeyPair(), I = g3({ requiredNamespaces: i2, optionalNamespaces: n2, relays: a2 ?? [{ protocol: at2 }], proposer: { publicKey: h3, metadata: this.client.metadata } }, o && { sessionProperties: o }), { reject: w3, resolve: T, done: K3 } = st(import_time3.FIVE_MINUTES, oe2);
      if (this.events.once(ft("session_connect"), async ({ error: v, session: S2 }) => {
        if (v)
          w3(v);
        else if (S2) {
          S2.self.publicKey = h3;
          const W3 = b2(g3({}, S2), { requiredNamespaces: S2.requiredNamespaces, optionalNamespaces: S2.optionalNamespaces });
          await this.client.session.set(S2.topic, W3), await this.setExpiry(S2.topic, S2.expiry), l && await this.client.core.pairing.updateMetadata({ topic: l, metadata: S2.peer.metadata }), T(W3);
        }
      }), !l) {
        const { message: v } = N("NO_MATCHING_KEY", `connect() pairing topic: ${l}`);
        throw new Error(v);
      }
      const L3 = await this.sendRequest({ topic: l, method: "wc_sessionPropose", params: I }), ue3 = lt(import_time3.FIVE_MINUTES);
      return await this.setProposal(L3, g3({ id: L3, expiry: ue3 }, I)), { uri: p3, approval: K3 };
    }, this.pair = async (e) => (await this.isInitialized(), await this.client.core.pairing.pair(e)), this.approve = async (e) => {
      await this.isInitialized(), await this.isValidApprove(e);
      const { id: s, relayProtocol: t, namespaces: i2, sessionProperties: n2 } = e, o = this.client.proposal.get(s);
      let { pairingTopic: a2, proposer: l, requiredNamespaces: p3, optionalNamespaces: d2 } = o;
      a2 = a2 || "", B(p3) || (p3 = At(i2, "approve()"));
      const h3 = await this.client.core.crypto.generateKeyPair(), I = l.publicKey, w3 = await this.client.core.crypto.generateSharedKey(h3, I);
      a2 && s && (await this.client.core.pairing.updateMetadata({ topic: a2, metadata: l.metadata }), await this.sendResult({ id: s, topic: a2, result: { relay: { protocol: t ?? "irn" }, responderPublicKey: h3 } }), await this.client.proposal.delete(s, U("USER_DISCONNECTED")), await this.client.core.pairing.activate({ topic: a2 }));
      const T = g3({ relay: { protocol: t ?? "irn" }, namespaces: i2, requiredNamespaces: p3, optionalNamespaces: d2, pairingTopic: a2, controller: { publicKey: h3, metadata: this.client.metadata }, expiry: lt(C2) }, n2 && { sessionProperties: n2 });
      await this.client.core.relayer.subscribe(w3), await this.sendRequest({ topic: w3, method: "wc_sessionSettle", params: T, throwOnFailedPublish: true });
      const K3 = b2(g3({}, T), { topic: w3, pairingTopic: a2, acknowledged: false, self: T.controller, peer: { publicKey: l.publicKey, metadata: l.metadata }, controller: h3 });
      return await this.client.session.set(w3, K3), await this.setExpiry(w3, lt(C2)), { topic: w3, acknowledged: () => new Promise((L3) => setTimeout(() => L3(this.client.session.get(w3)), 500)) };
    }, this.reject = async (e) => {
      await this.isInitialized(), await this.isValidReject(e);
      const { id: s, reason: t } = e, { pairingTopic: i2 } = this.client.proposal.get(s);
      i2 && (await this.sendError(s, i2, t), await this.client.proposal.delete(s, U("USER_DISCONNECTED")));
    }, this.update = async (e) => {
      await this.isInitialized(), await this.isValidUpdate(e);
      const { topic: s, namespaces: t } = e, i2 = await this.sendRequest({ topic: s, method: "wc_sessionUpdate", params: { namespaces: t } }), { done: n2, resolve: o, reject: a2 } = st();
      return this.events.once(ft("session_update", i2), ({ error: l }) => {
        l ? a2(l) : o();
      }), await this.client.session.update(s, { namespaces: t }), { acknowledged: n2 };
    }, this.extend = async (e) => {
      await this.isInitialized(), await this.isValidExtend(e);
      const { topic: s } = e, t = await this.sendRequest({ topic: s, method: "wc_sessionExtend", params: {} }), { done: i2, resolve: n2, reject: o } = st();
      return this.events.once(ft("session_extend", t), ({ error: a2 }) => {
        a2 ? o(a2) : n2();
      }), await this.setExpiry(s, lt(C2)), { acknowledged: i2 };
    }, this.request = async (e) => {
      await this.isInitialized(), await this.isValidRequest(e);
      const { chainId: s, request: t, topic: i2, expiry: n2 } = e, o = payloadId(), { done: a2, resolve: l, reject: p3 } = st(n2);
      return this.events.once(ft("session_request", o), ({ error: d2, result: h3 }) => {
        d2 ? p3(d2) : l(h3);
      }), await Promise.all([new Promise(async (d2) => {
        await this.sendRequest({ clientRpcId: o, topic: i2, method: "wc_sessionRequest", params: { request: t, chainId: s }, expiry: n2, throwOnFailedPublish: true }).catch((h3) => p3(h3)), this.client.events.emit("session_request_sent", { topic: i2, request: t, chainId: s, id: o }), d2();
      }), new Promise(async (d2) => {
        const h3 = await this.client.core.storage.getItem(H3);
        pt({ id: o, topic: i2, wcDeepLink: h3 }), d2();
      }), a2()]).then((d2) => d2[2]);
    }, this.respond = async (e) => {
      await this.isInitialized(), await this.isValidRespond(e);
      const { topic: s, response: t } = e, { id: i2 } = t;
      isJsonRpcResult(t) ? await this.sendResult({ id: i2, topic: s, result: t.result, throwOnFailedPublish: true }) : isJsonRpcError(t) && await this.sendError(i2, s, t.error), this.cleanupAfterResponse(e);
    }, this.ping = async (e) => {
      await this.isInitialized(), await this.isValidPing(e);
      const { topic: s } = e;
      if (this.client.session.keys.includes(s)) {
        const t = await this.sendRequest({ topic: s, method: "wc_sessionPing", params: {} }), { done: i2, resolve: n2, reject: o } = st();
        this.events.once(ft("session_ping", t), ({ error: a2 }) => {
          a2 ? o(a2) : n2();
        }), await i2();
      } else
        this.client.core.pairing.pairings.keys.includes(s) && await this.client.core.pairing.ping({ topic: s });
    }, this.emit = async (e) => {
      await this.isInitialized(), await this.isValidEmit(e);
      const { topic: s, event: t, chainId: i2 } = e;
      await this.sendRequest({ topic: s, method: "wc_sessionEvent", params: { event: t, chainId: i2 } });
    }, this.disconnect = async (e) => {
      await this.isInitialized(), await this.isValidDisconnect(e);
      const { topic: s } = e;
      this.client.session.keys.includes(s) ? (await this.sendRequest({ topic: s, method: "wc_sessionDelete", params: U("USER_DISCONNECTED"), throwOnFailedPublish: true }), await this.deleteSession(s)) : await this.client.core.pairing.disconnect({ topic: s });
    }, this.find = (e) => (this.isInitialized(), this.client.session.getAll().filter((s) => $t(s, e))), this.getPendingSessionRequests = () => (this.isInitialized(), this.client.pendingRequest.getAll()), this.cleanupDuplicatePairings = async (e) => {
      if (e.pairingTopic)
        try {
          const s = this.client.core.pairing.pairings.get(e.pairingTopic), t = this.client.core.pairing.pairings.getAll().filter((i2) => {
            var n2, o;
            return ((n2 = i2.peerMetadata) == null ? void 0 : n2.url) && ((o = i2.peerMetadata) == null ? void 0 : o.url) === e.peer.metadata.url && i2.topic && i2.topic !== s.topic;
          });
          if (t.length === 0)
            return;
          this.client.logger.info(`Cleaning up ${t.length} duplicate pairing(s)`), await Promise.all(t.map((i2) => this.client.core.pairing.disconnect({ topic: i2.topic }))), this.client.logger.info("Duplicate pairings clean up finished");
        } catch (s) {
          this.client.logger.error(s);
        }
    }, this.deleteSession = async (e, s) => {
      const { self: t } = this.client.session.get(e);
      await this.client.core.relayer.unsubscribe(e), this.client.session.delete(e, U("USER_DISCONNECTED")), this.client.core.crypto.keychain.has(t.publicKey) && await this.client.core.crypto.deleteKeyPair(t.publicKey), this.client.core.crypto.keychain.has(e) && await this.client.core.crypto.deleteSymKey(e), s || this.client.core.expirer.del(e), this.client.core.storage.removeItem(H3).catch((i2) => this.client.logger.warn(i2));
    }, this.deleteProposal = async (e, s) => {
      await Promise.all([this.client.proposal.delete(e, U("USER_DISCONNECTED")), s ? Promise.resolve() : this.client.core.expirer.del(e)]);
    }, this.deletePendingSessionRequest = async (e, s, t = false) => {
      await Promise.all([this.client.pendingRequest.delete(e, s), t ? Promise.resolve() : this.client.core.expirer.del(e)]), this.sessionRequestQueue.queue = this.sessionRequestQueue.queue.filter((i2) => i2.id !== e), t && (this.sessionRequestQueue.state = E3.idle);
    }, this.setExpiry = async (e, s) => {
      this.client.session.keys.includes(e) && await this.client.session.update(e, { expiry: s }), this.client.core.expirer.set(e, s);
    }, this.setProposal = async (e, s) => {
      await this.client.proposal.set(e, s), this.client.core.expirer.set(e, s.expiry);
    }, this.setPendingSessionRequest = async (e) => {
      const s = V.wc_sessionRequest.req.ttl, { id: t, topic: i2, params: n2 } = e;
      await this.client.pendingRequest.set(t, { id: t, topic: i2, params: n2 }), s && this.client.core.expirer.set(t, lt(s));
    }, this.sendRequest = async (e) => {
      const { topic: s, method: t, params: i2, expiry: n2, relayRpcId: o, clientRpcId: a2, throwOnFailedPublish: l } = e, p3 = formatJsonRpcRequest(t, i2, a2);
      if (q() && pe2.includes(t)) {
        const I = Mn(JSON.stringify(p3));
        this.client.core.verify.register({ attestationId: I });
      }
      const d2 = await this.client.core.crypto.encode(s, p3), h3 = V[t].req;
      return n2 && (h3.ttl = n2), o && (h3.id = o), this.client.core.history.set(s, p3), l ? (h3.internal = b2(g3({}, h3.internal), { throwOnFailedPublish: true }), await this.client.core.relayer.publish(s, d2, h3)) : this.client.core.relayer.publish(s, d2, h3).catch((I) => this.client.logger.error(I)), p3.id;
    }, this.sendResult = async (e) => {
      const { id: s, topic: t, result: i2, throwOnFailedPublish: n2 } = e, o = formatJsonRpcResult(s, i2), a2 = await this.client.core.crypto.encode(t, o), l = await this.client.core.history.get(t, s), p3 = V[l.request.method].res;
      n2 ? (p3.internal = b2(g3({}, p3.internal), { throwOnFailedPublish: true }), await this.client.core.relayer.publish(t, a2, p3)) : this.client.core.relayer.publish(t, a2, p3).catch((d2) => this.client.logger.error(d2)), await this.client.core.history.resolve(o);
    }, this.sendError = async (e, s, t) => {
      const i2 = formatJsonRpcError(e, t), n2 = await this.client.core.crypto.encode(s, i2), o = await this.client.core.history.get(s, e), a2 = V[o.request.method].res;
      this.client.core.relayer.publish(s, n2, a2), await this.client.core.history.resolve(i2);
    }, this.cleanup = async () => {
      const e = [], s = [];
      this.client.session.getAll().forEach((t) => {
        dt(t.expiry) && e.push(t.topic);
      }), this.client.proposal.getAll().forEach((t) => {
        dt(t.expiry) && s.push(t.id);
      }), await Promise.all([...e.map((t) => this.deleteSession(t)), ...s.map((t) => this.deleteProposal(t))]);
    }, this.onRelayEventRequest = async (e) => {
      this.requestQueue.queue.push(e), await this.processRequestsQueue();
    }, this.processRequestsQueue = async () => {
      if (this.requestQueue.state === E3.active) {
        this.client.logger.info("Request queue already active, skipping...");
        return;
      }
      for (this.client.logger.info(`Request queue starting with ${this.requestQueue.queue.length} requests`); this.requestQueue.queue.length > 0; ) {
        this.requestQueue.state = E3.active;
        const e = this.requestQueue.queue.shift();
        if (e)
          try {
            this.processRequest(e), await new Promise((s) => setTimeout(s, 300));
          } catch (s) {
            this.client.logger.warn(s);
          }
      }
      this.requestQueue.state = E3.idle;
    }, this.processRequest = (e) => {
      const { topic: s, payload: t } = e, i2 = t.method;
      switch (i2) {
        case "wc_sessionPropose":
          return this.onSessionProposeRequest(s, t);
        case "wc_sessionSettle":
          return this.onSessionSettleRequest(s, t);
        case "wc_sessionUpdate":
          return this.onSessionUpdateRequest(s, t);
        case "wc_sessionExtend":
          return this.onSessionExtendRequest(s, t);
        case "wc_sessionPing":
          return this.onSessionPingRequest(s, t);
        case "wc_sessionDelete":
          return this.onSessionDeleteRequest(s, t);
        case "wc_sessionRequest":
          return this.onSessionRequest(s, t);
        case "wc_sessionEvent":
          return this.onSessionEventRequest(s, t);
        default:
          return this.client.logger.info(`Unsupported request method ${i2}`);
      }
    }, this.onRelayEventResponse = async (e) => {
      const { topic: s, payload: t } = e, i2 = (await this.client.core.history.get(s, t.id)).request.method;
      switch (i2) {
        case "wc_sessionPropose":
          return this.onSessionProposeResponse(s, t);
        case "wc_sessionSettle":
          return this.onSessionSettleResponse(s, t);
        case "wc_sessionUpdate":
          return this.onSessionUpdateResponse(s, t);
        case "wc_sessionExtend":
          return this.onSessionExtendResponse(s, t);
        case "wc_sessionPing":
          return this.onSessionPingResponse(s, t);
        case "wc_sessionRequest":
          return this.onSessionRequestResponse(s, t);
        default:
          return this.client.logger.info(`Unsupported response method ${i2}`);
      }
    }, this.onRelayEventUnknownPayload = (e) => {
      const { topic: s } = e, { message: t } = N("MISSING_OR_INVALID", `Decoded payload on topic ${s} is not identifiable as a JSON-RPC request or a response.`);
      throw new Error(t);
    }, this.onSessionProposeRequest = async (e, s) => {
      const { params: t, id: i2 } = s;
      try {
        this.isValidConnect(g3({}, s.params));
        const n2 = lt(import_time3.FIVE_MINUTES), o = g3({ id: i2, pairingTopic: e, expiry: n2 }, t);
        await this.setProposal(i2, o);
        const a2 = Mn(JSON.stringify(s)), l = await this.getVerifyContext(a2, o.proposer.metadata);
        this.client.events.emit("session_proposal", { id: i2, params: o, verifyContext: l });
      } catch (n2) {
        await this.sendError(i2, e, n2), this.client.logger.error(n2);
      }
    }, this.onSessionProposeResponse = async (e, s) => {
      const { id: t } = s;
      if (isJsonRpcResult(s)) {
        const { result: i2 } = s;
        this.client.logger.trace({ type: "method", method: "onSessionProposeResponse", result: i2 });
        const n2 = this.client.proposal.get(t);
        this.client.logger.trace({ type: "method", method: "onSessionProposeResponse", proposal: n2 });
        const o = n2.proposer.publicKey;
        this.client.logger.trace({ type: "method", method: "onSessionProposeResponse", selfPublicKey: o });
        const a2 = i2.responderPublicKey;
        this.client.logger.trace({ type: "method", method: "onSessionProposeResponse", peerPublicKey: a2 });
        const l = await this.client.core.crypto.generateSharedKey(o, a2);
        this.client.logger.trace({ type: "method", method: "onSessionProposeResponse", sessionTopic: l });
        const p3 = await this.client.core.relayer.subscribe(l);
        this.client.logger.trace({ type: "method", method: "onSessionProposeResponse", subscriptionId: p3 }), await this.client.core.pairing.activate({ topic: e });
      } else
        isJsonRpcError(s) && (await this.client.proposal.delete(t, U("USER_DISCONNECTED")), this.events.emit(ft("session_connect"), { error: s.error }));
    }, this.onSessionSettleRequest = async (e, s) => {
      const { id: t, params: i2 } = s;
      try {
        this.isValidSessionSettleRequest(i2);
        const { relay: n2, controller: o, expiry: a2, namespaces: l, requiredNamespaces: p3, optionalNamespaces: d2, sessionProperties: h3, pairingTopic: I } = s.params, w3 = g3({ topic: e, relay: n2, expiry: a2, namespaces: l, acknowledged: true, pairingTopic: I, requiredNamespaces: p3, optionalNamespaces: d2, controller: o.publicKey, self: { publicKey: "", metadata: this.client.metadata }, peer: { publicKey: o.publicKey, metadata: o.metadata } }, h3 && { sessionProperties: h3 });
        await this.sendResult({ id: s.id, topic: e, result: true }), this.events.emit(ft("session_connect"), { session: w3 }), this.cleanupDuplicatePairings(w3);
      } catch (n2) {
        await this.sendError(t, e, n2), this.client.logger.error(n2);
      }
    }, this.onSessionSettleResponse = async (e, s) => {
      const { id: t } = s;
      isJsonRpcResult(s) ? (await this.client.session.update(e, { acknowledged: true }), this.events.emit(ft("session_approve", t), {})) : isJsonRpcError(s) && (await this.client.session.delete(e, U("USER_DISCONNECTED")), this.events.emit(ft("session_approve", t), { error: s.error }));
    }, this.onSessionUpdateRequest = async (e, s) => {
      const { params: t, id: i2 } = s;
      try {
        const n2 = `${e}_session_update`, o = er.get(n2);
        if (o && this.isRequestOutOfSync(o, i2)) {
          this.client.logger.info(`Discarding out of sync request - ${i2}`);
          return;
        }
        this.isValidUpdate(g3({ topic: e }, t)), await this.client.session.update(e, { namespaces: t.namespaces }), await this.sendResult({ id: i2, topic: e, result: true }), this.client.events.emit("session_update", { id: i2, topic: e, params: t }), er.set(n2, i2);
      } catch (n2) {
        await this.sendError(i2, e, n2), this.client.logger.error(n2);
      }
    }, this.isRequestOutOfSync = (e, s) => parseInt(s.toString().slice(0, -3)) <= parseInt(e.toString().slice(0, -3)), this.onSessionUpdateResponse = (e, s) => {
      const { id: t } = s;
      isJsonRpcResult(s) ? this.events.emit(ft("session_update", t), {}) : isJsonRpcError(s) && this.events.emit(ft("session_update", t), { error: s.error });
    }, this.onSessionExtendRequest = async (e, s) => {
      const { id: t } = s;
      try {
        this.isValidExtend({ topic: e }), await this.setExpiry(e, lt(C2)), await this.sendResult({ id: t, topic: e, result: true }), this.client.events.emit("session_extend", { id: t, topic: e });
      } catch (i2) {
        await this.sendError(t, e, i2), this.client.logger.error(i2);
      }
    }, this.onSessionExtendResponse = (e, s) => {
      const { id: t } = s;
      isJsonRpcResult(s) ? this.events.emit(ft("session_extend", t), {}) : isJsonRpcError(s) && this.events.emit(ft("session_extend", t), { error: s.error });
    }, this.onSessionPingRequest = async (e, s) => {
      const { id: t } = s;
      try {
        this.isValidPing({ topic: e }), await this.sendResult({ id: t, topic: e, result: true }), this.client.events.emit("session_ping", { id: t, topic: e });
      } catch (i2) {
        await this.sendError(t, e, i2), this.client.logger.error(i2);
      }
    }, this.onSessionPingResponse = (e, s) => {
      const { id: t } = s;
      setTimeout(() => {
        isJsonRpcResult(s) ? this.events.emit(ft("session_ping", t), {}) : isJsonRpcError(s) && this.events.emit(ft("session_ping", t), { error: s.error });
      }, 500);
    }, this.onSessionDeleteRequest = async (e, s) => {
      const { id: t } = s;
      try {
        this.isValidDisconnect({ topic: e, reason: s.params }), await Promise.all([new Promise((i2) => {
          this.client.core.relayer.once(D2.publish, async () => {
            i2(await this.deleteSession(e));
          });
        }), this.sendResult({ id: t, topic: e, result: true })]), this.client.events.emit("session_delete", { id: t, topic: e });
      } catch (i2) {
        this.client.logger.error(i2);
      }
    }, this.onSessionRequest = async (e, s) => {
      const { id: t, params: i2 } = s;
      try {
        this.isValidRequest(g3({ topic: e }, i2)), await this.setPendingSessionRequest({ id: t, topic: e, params: i2 }), this.addSessionRequestToSessionRequestQueue({ id: t, topic: e, params: i2 }), await this.processSessionRequestQueue();
      } catch (n2) {
        await this.sendError(t, e, n2), this.client.logger.error(n2);
      }
    }, this.onSessionRequestResponse = (e, s) => {
      const { id: t } = s;
      isJsonRpcResult(s) ? this.events.emit(ft("session_request", t), { result: s.result }) : isJsonRpcError(s) && this.events.emit(ft("session_request", t), { error: s.error });
    }, this.onSessionEventRequest = async (e, s) => {
      const { id: t, params: i2 } = s;
      try {
        const n2 = `${e}_session_event_${i2.event.name}`, o = er.get(n2);
        if (o && this.isRequestOutOfSync(o, t)) {
          this.client.logger.info(`Discarding out of sync request - ${t}`);
          return;
        }
        this.isValidEmit(g3({ topic: e }, i2)), this.client.events.emit("session_event", { id: t, topic: e, params: i2 }), er.set(n2, t);
      } catch (n2) {
        await this.sendError(t, e, n2), this.client.logger.error(n2);
      }
    }, this.addSessionRequestToSessionRequestQueue = (e) => {
      this.sessionRequestQueue.queue.push(e);
    }, this.cleanupAfterResponse = (e) => {
      this.deletePendingSessionRequest(e.response.id, { message: "fulfilled", code: 0 }), setTimeout(() => {
        this.sessionRequestQueue.state = E3.idle, this.processSessionRequestQueue();
      }, (0, import_time3.toMiliseconds)(this.requestQueueDelay));
    }, this.processSessionRequestQueue = async () => {
      if (this.sessionRequestQueue.state === E3.active) {
        this.client.logger.info("session request queue is already active.");
        return;
      }
      const e = this.sessionRequestQueue.queue[0];
      if (!e) {
        this.client.logger.info("session request queue is empty.");
        return;
      }
      try {
        const { id: s, topic: t, params: i2 } = e, n2 = Mn(JSON.stringify(formatJsonRpcRequest("wc_sessionRequest", i2, s))), o = this.client.session.get(t), a2 = await this.getVerifyContext(n2, o.peer.metadata);
        this.sessionRequestQueue.state = E3.active, this.client.events.emit("session_request", { id: s, topic: t, params: i2, verifyContext: a2 });
      } catch (s) {
        this.client.logger.error(s);
      }
    }, this.isValidConnect = async (e) => {
      if (!xt(e)) {
        const { message: a2 } = N("MISSING_OR_INVALID", `connect() params: ${JSON.stringify(e)}`);
        throw new Error(a2);
      }
      const { pairingTopic: s, requiredNamespaces: t, optionalNamespaces: i2, sessionProperties: n2, relays: o } = e;
      if (w(s) || await this.isValidPairingTopic(s), !Kt(o, true)) {
        const { message: a2 } = N("MISSING_OR_INVALID", `connect() relays: ${o}`);
        throw new Error(a2);
      }
      !w(t) && B(t) !== 0 && this.validateNamespaces(t, "requiredNamespaces"), !w(i2) && B(i2) !== 0 && this.validateNamespaces(i2, "optionalNamespaces"), w(n2) || this.validateSessionProps(n2, "sessionProperties");
    }, this.validateNamespaces = (e, s) => {
      const t = Mt(e, "connect()", s);
      if (t)
        throw new Error(t.message);
    }, this.isValidApprove = async (e) => {
      if (!xt(e))
        throw new Error(N("MISSING_OR_INVALID", `approve() params: ${e}`).message);
      const { id: s, namespaces: t, relayProtocol: i2, sessionProperties: n2 } = e;
      await this.isValidProposalId(s);
      const o = this.client.proposal.get(s), a2 = cn(t, "approve()");
      if (a2)
        throw new Error(a2.message);
      const l = un(o.requiredNamespaces, t, "approve()");
      if (l)
        throw new Error(l.message);
      if (!h2(i2, true)) {
        const { message: p3 } = N("MISSING_OR_INVALID", `approve() relayProtocol: ${i2}`);
        throw new Error(p3);
      }
      w(n2) || this.validateSessionProps(n2, "sessionProperties");
    }, this.isValidReject = async (e) => {
      if (!xt(e)) {
        const { message: i2 } = N("MISSING_OR_INVALID", `reject() params: ${e}`);
        throw new Error(i2);
      }
      const { id: s, reason: t } = e;
      if (await this.isValidProposalId(s), !Ft(t)) {
        const { message: i2 } = N("MISSING_OR_INVALID", `reject() reason: ${JSON.stringify(t)}`);
        throw new Error(i2);
      }
    }, this.isValidSessionSettleRequest = (e) => {
      if (!xt(e)) {
        const { message: l } = N("MISSING_OR_INVALID", `onSessionSettleRequest() params: ${e}`);
        throw new Error(l);
      }
      const { relay: s, controller: t, namespaces: i2, expiry: n2 } = e;
      if (!an(s)) {
        const { message: l } = N("MISSING_OR_INVALID", "onSessionSettleRequest() relay protocol should be a string");
        throw new Error(l);
      }
      const o = Vt(t, "onSessionSettleRequest()");
      if (o)
        throw new Error(o.message);
      const a2 = cn(i2, "onSessionSettleRequest()");
      if (a2)
        throw new Error(a2.message);
      if (dt(n2)) {
        const { message: l } = N("EXPIRED", "onSessionSettleRequest()");
        throw new Error(l);
      }
    }, this.isValidUpdate = async (e) => {
      if (!xt(e)) {
        const { message: a2 } = N("MISSING_OR_INVALID", `update() params: ${e}`);
        throw new Error(a2);
      }
      const { topic: s, namespaces: t } = e;
      await this.isValidSessionTopic(s);
      const i2 = this.client.session.get(s), n2 = cn(t, "update()");
      if (n2)
        throw new Error(n2.message);
      const o = un(i2.requiredNamespaces, t, "update()");
      if (o)
        throw new Error(o.message);
    }, this.isValidExtend = async (e) => {
      if (!xt(e)) {
        const { message: t } = N("MISSING_OR_INVALID", `extend() params: ${e}`);
        throw new Error(t);
      }
      const { topic: s } = e;
      await this.isValidSessionTopic(s);
    }, this.isValidRequest = async (e) => {
      if (!xt(e)) {
        const { message: a2 } = N("MISSING_OR_INVALID", `request() params: ${e}`);
        throw new Error(a2);
      }
      const { topic: s, request: t, chainId: i2, expiry: n2 } = e;
      await this.isValidSessionTopic(s);
      const { namespaces: o } = this.client.session.get(s);
      if (!Gt(o, i2)) {
        const { message: a2 } = N("MISSING_OR_INVALID", `request() chainId: ${i2}`);
        throw new Error(a2);
      }
      if (!Ht(t)) {
        const { message: a2 } = N("MISSING_OR_INVALID", `request() ${JSON.stringify(t)}`);
        throw new Error(a2);
      }
      if (!Wt(o, i2, t.method)) {
        const { message: a2 } = N("MISSING_OR_INVALID", `request() method: ${t.method}`);
        throw new Error(a2);
      }
      if (n2 && !Qt(n2, U3)) {
        const { message: a2 } = N("MISSING_OR_INVALID", `request() expiry: ${n2}. Expiry must be a number (in seconds) between ${U3.min} and ${U3.max}`);
        throw new Error(a2);
      }
    }, this.isValidRespond = async (e) => {
      if (!xt(e)) {
        const { message: i2 } = N("MISSING_OR_INVALID", `respond() params: ${e}`);
        throw new Error(i2);
      }
      const { topic: s, response: t } = e;
      if (await this.isValidSessionTopic(s), !qt(t)) {
        const { message: i2 } = N("MISSING_OR_INVALID", `respond() response: ${JSON.stringify(t)}`);
        throw new Error(i2);
      }
    }, this.isValidPing = async (e) => {
      if (!xt(e)) {
        const { message: t } = N("MISSING_OR_INVALID", `ping() params: ${e}`);
        throw new Error(t);
      }
      const { topic: s } = e;
      await this.isValidSessionOrPairingTopic(s);
    }, this.isValidEmit = async (e) => {
      if (!xt(e)) {
        const { message: o } = N("MISSING_OR_INVALID", `emit() params: ${e}`);
        throw new Error(o);
      }
      const { topic: s, event: t, chainId: i2 } = e;
      await this.isValidSessionTopic(s);
      const { namespaces: n2 } = this.client.session.get(s);
      if (!Gt(n2, i2)) {
        const { message: o } = N("MISSING_OR_INVALID", `emit() chainId: ${i2}`);
        throw new Error(o);
      }
      if (!Bt(t)) {
        const { message: o } = N("MISSING_OR_INVALID", `emit() event: ${JSON.stringify(t)}`);
        throw new Error(o);
      }
      if (!zt(n2, i2, t.name)) {
        const { message: o } = N("MISSING_OR_INVALID", `emit() event: ${JSON.stringify(t)}`);
        throw new Error(o);
      }
    }, this.isValidDisconnect = async (e) => {
      if (!xt(e)) {
        const { message: t } = N("MISSING_OR_INVALID", `disconnect() params: ${e}`);
        throw new Error(t);
      }
      const { topic: s } = e;
      await this.isValidSessionOrPairingTopic(s);
    }, this.getVerifyContext = async (e, s) => {
      const t = { verified: { verifyUrl: s.verifyUrl || Q2, validation: "UNKNOWN", origin: s.url || "" } };
      try {
        const i2 = await this.client.core.verify.resolve({ attestationId: e, verifyUrl: s.verifyUrl });
        i2 && (t.verified.origin = i2, t.verified.validation = i2 === new URL(s.url).origin ? "VALID" : "INVALID");
      } catch (i2) {
        this.client.logger.error(i2);
      }
      return this.client.logger.info(`Verify context: ${JSON.stringify(t)}`), t;
    }, this.validateSessionProps = (e, s) => {
      Object.values(e).forEach((t) => {
        if (!h2(t, false)) {
          const { message: i2 } = N("MISSING_OR_INVALID", `${s} must be in Record<string, string> format. Received: ${JSON.stringify(t)}`);
          throw new Error(i2);
        }
      });
    };
  }
  async isInitialized() {
    if (!this.initialized) {
      const { message: r } = N("NOT_INITIALIZED", this.name);
      throw new Error(r);
    }
    await this.client.core.relayer.confirmOnlineStateOrThrow();
  }
  registerRelayerEvents() {
    this.client.core.relayer.on(D2.message, async (r) => {
      const { topic: e, message: s } = r;
      if (this.ignoredPayloadTypes.includes(this.client.core.crypto.getPayloadType(s)))
        return;
      const t = await this.client.core.crypto.decode(e, s);
      try {
        isJsonRpcRequest(t) ? (this.client.core.history.set(e, t), this.onRelayEventRequest({ topic: e, payload: t })) : isJsonRpcResponse(t) ? (await this.client.core.history.resolve(t), await this.onRelayEventResponse({ topic: e, payload: t }), this.client.core.history.delete(e, t.id)) : this.onRelayEventUnknownPayload({ topic: e, payload: t });
      } catch (i2) {
        this.client.logger.error(i2);
      }
    });
  }
  registerExpirerEvents() {
    this.client.core.expirer.on(w2.expired, async (r) => {
      const { topic: e, id: s } = ut(r.target);
      if (s && this.client.pendingRequest.keys.includes(s))
        return await this.deletePendingSessionRequest(s, N("EXPIRED"), true);
      e ? this.client.session.keys.includes(e) && (await this.deleteSession(e, true), this.client.events.emit("session_expire", { topic: e })) : s && (await this.deleteProposal(s, true), this.client.events.emit("proposal_expire", { id: s }));
    });
  }
  isValidPairingTopic(r) {
    if (!h2(r, false)) {
      const { message: e } = N("MISSING_OR_INVALID", `pairing topic should be a string: ${r}`);
      throw new Error(e);
    }
    if (!this.client.core.pairing.pairings.keys.includes(r)) {
      const { message: e } = N("NO_MATCHING_KEY", `pairing topic doesn't exist: ${r}`);
      throw new Error(e);
    }
    if (dt(this.client.core.pairing.pairings.get(r).expiry)) {
      const { message: e } = N("EXPIRED", `pairing topic: ${r}`);
      throw new Error(e);
    }
  }
  async isValidSessionTopic(r) {
    if (!h2(r, false)) {
      const { message: e } = N("MISSING_OR_INVALID", `session topic should be a string: ${r}`);
      throw new Error(e);
    }
    if (!this.client.session.keys.includes(r)) {
      const { message: e } = N("NO_MATCHING_KEY", `session topic doesn't exist: ${r}`);
      throw new Error(e);
    }
    if (dt(this.client.session.get(r).expiry)) {
      await this.deleteSession(r);
      const { message: e } = N("EXPIRED", `session topic: ${r}`);
      throw new Error(e);
    }
  }
  async isValidSessionOrPairingTopic(r) {
    if (this.client.session.keys.includes(r))
      await this.isValidSessionTopic(r);
    else if (this.client.core.pairing.pairings.keys.includes(r))
      this.isValidPairingTopic(r);
    else if (h2(r, false)) {
      const { message: e } = N("NO_MATCHING_KEY", `session or pairing topic doesn't exist: ${r}`);
      throw new Error(e);
    } else {
      const { message: e } = N("MISSING_OR_INVALID", `session or pairing topic should be a string: ${r}`);
      throw new Error(e);
    }
  }
  async isValidProposalId(r) {
    if (!Lt(r)) {
      const { message: e } = N("MISSING_OR_INVALID", `proposal id should be a number: ${r}`);
      throw new Error(e);
    }
    if (!this.client.proposal.keys.includes(r)) {
      const { message: e } = N("NO_MATCHING_KEY", `proposal id doesn't exist: ${r}`);
      throw new Error(e);
    }
    if (dt(this.client.proposal.get(r).expiry)) {
      await this.deleteProposal(r);
      const { message: e } = N("EXPIRED", `proposal id: ${r}`);
      throw new Error(e);
    }
  }
};
var ps2 = class extends Ut {
  constructor(r, e) {
    super(r, e, ne, G2), this.core = r, this.logger = e;
  }
};
var hs2 = class extends Ut {
  constructor(r, e) {
    super(r, e, ae3, G2), this.core = r, this.logger = e;
  }
};
var ds2 = class extends Ut {
  constructor(r, e) {
    super(r, e, le3, G2, (s) => s.id), this.core = r, this.logger = e;
  }
};
var Q3 = class _Q extends b {
  constructor(r) {
    super(r), this.protocol = J3, this.version = X3, this.name = M2.name, this.events = new import_events7.EventEmitter(), this.on = (s, t) => this.events.on(s, t), this.once = (s, t) => this.events.once(s, t), this.off = (s, t) => this.events.off(s, t), this.removeListener = (s, t) => this.events.removeListener(s, t), this.removeAllListeners = (s) => this.events.removeAllListeners(s), this.connect = async (s) => {
      try {
        return await this.engine.connect(s);
      } catch (t) {
        throw this.logger.error(t.message), t;
      }
    }, this.pair = async (s) => {
      try {
        return await this.engine.pair(s);
      } catch (t) {
        throw this.logger.error(t.message), t;
      }
    }, this.approve = async (s) => {
      try {
        return await this.engine.approve(s);
      } catch (t) {
        throw this.logger.error(t.message), t;
      }
    }, this.reject = async (s) => {
      try {
        return await this.engine.reject(s);
      } catch (t) {
        throw this.logger.error(t.message), t;
      }
    }, this.update = async (s) => {
      try {
        return await this.engine.update(s);
      } catch (t) {
        throw this.logger.error(t.message), t;
      }
    }, this.extend = async (s) => {
      try {
        return await this.engine.extend(s);
      } catch (t) {
        throw this.logger.error(t.message), t;
      }
    }, this.request = async (s) => {
      try {
        return await this.engine.request(s);
      } catch (t) {
        throw this.logger.error(t.message), t;
      }
    }, this.respond = async (s) => {
      try {
        return await this.engine.respond(s);
      } catch (t) {
        throw this.logger.error(t.message), t;
      }
    }, this.ping = async (s) => {
      try {
        return await this.engine.ping(s);
      } catch (t) {
        throw this.logger.error(t.message), t;
      }
    }, this.emit = async (s) => {
      try {
        return await this.engine.emit(s);
      } catch (t) {
        throw this.logger.error(t.message), t;
      }
    }, this.disconnect = async (s) => {
      try {
        return await this.engine.disconnect(s);
      } catch (t) {
        throw this.logger.error(t.message), t;
      }
    }, this.find = (s) => {
      try {
        return this.engine.find(s);
      } catch (t) {
        throw this.logger.error(t.message), t;
      }
    }, this.getPendingSessionRequests = () => {
      try {
        return this.engine.getPendingSessionRequests();
      } catch (s) {
        throw this.logger.error(s.message), s;
      }
    }, this.name = (r == null ? void 0 : r.name) || M2.name, this.metadata = (r == null ? void 0 : r.metadata) || zn();
    const e = typeof (r == null ? void 0 : r.logger) < "u" && typeof (r == null ? void 0 : r.logger) != "string" ? r.logger : (0, import_logger2.pino)((0, import_logger2.getDefaultLoggerOptions)({ level: (r == null ? void 0 : r.logger) || M2.logger }));
    this.core = (r == null ? void 0 : r.core) || new xr(r), this.logger = (0, import_logger2.generateChildLogger)(e, this.name), this.session = new hs2(this.core, this.logger), this.proposal = new ps2(this.core, this.logger), this.pendingRequest = new ds2(this.core, this.logger), this.engine = new ls2(this);
  }
  static async init(r) {
    const e = new _Q(r);
    return await e.initialize(), e;
  }
  get context() {
    return (0, import_logger2.getLoggerContext)(this.logger);
  }
  get pairing() {
    return this.core.pairing.pairings;
  }
  async initialize() {
    this.logger.trace("Initialized");
    try {
      await this.core.start(), await this.session.init(), await this.proposal.init(), await this.pendingRequest.init(), await this.engine.init(), this.core.verify.init({ verifyUrl: this.metadata.verifyUrl }), this.logger.info("SignClient Initialization Success");
    } catch (r) {
      throw this.logger.info("SignClient Initialization Failure"), this.logger.error(r.message), r;
    }
  }
};
var us2 = Q3;

// node_modules/@taquito/beacon-wallet/node_modules/@airgap/beacon-transport-walletconnect/dist/esm/error.js
var InvalidReceivedSessionNamespace = class extends Error {
  constructor(messageWc, codeWc, type, data) {
    super();
    this.messageWc = messageWc;
    this.codeWc = codeWc;
    this.data = data;
    this.name = "InvalidReceivedSessionNamespace";
    const baseMessage = `${codeWc}: ${messageWc}.`;
    this.message = data ? type === "incomplete" ? ` ${baseMessage} "${data}" is missing in the session namespace.` : ` ${baseMessage} "${data}" is invalid.` : baseMessage;
  }
};
var NotConnected = class extends Error {
  constructor() {
    super("Not connected, no active session");
    this.name = "NotConnected";
  }
};
var InvalidSession = class extends Error {
  constructor(message) {
    super(message);
    this.name = "InvalidSession";
  }
};
var MissingRequiredScope = class extends Error {
  constructor(requiredScopes) {
    super(`Required permission scope were not granted for "${requiredScopes}"`);
    this.requiredScopes = requiredScopes;
    this.name = "MissingRequiredScope";
  }
};
var ActiveNetworkUnspecified = class extends Error {
  constructor() {
    super('Please specify the active network using the "setActiveNetwork" method.');
    this.name = "ActiveNetworkUnspecified";
  }
};
var ActiveAccountUnspecified = class extends Error {
  constructor() {
    super('Please specify the active account using the "setActiveAccount" method.');
    this.name = "ActiveAccountUnspecified";
  }
};
var InvalidNetworkOrAccount = class extends Error {
  constructor(network, pkh) {
    super(`No permission. The combinaison "${network}" and "${pkh}" is not part of the active session.`);
    this.network = network;
    this.pkh = pkh;
    this.name = "InvalidNetworkOrAccount";
  }
};

// node_modules/@taquito/beacon-wallet/node_modules/@airgap/beacon-transport-walletconnect/dist/esm/communication-client/WalletConnectCommunicationClient.js
var __awaiter33 = function(thisArg, _arguments, P2, generator) {
  function adopt(value) {
    return value instanceof P2 ? value : new P2(function(resolve) {
      resolve(value);
    });
  }
  return new (P2 || (P2 = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var TEZOS_PLACEHOLDER = "tezos";
var NetworkType2;
(function(NetworkType3) {
  NetworkType3["MAINNET"] = "mainnet";
  NetworkType3["GHOSTNET"] = "ghostnet";
  NetworkType3["MONDAYNET"] = "mondaynet";
  NetworkType3["DAILYNET"] = "dailynet";
  NetworkType3["KATHMANDUNET"] = "kathmandunet";
  NetworkType3["LIMANET"] = "limanet";
})(NetworkType2 || (NetworkType2 = {}));
var PermissionScopeMethods;
(function(PermissionScopeMethods2) {
  PermissionScopeMethods2["GET_ACCOUNTS"] = "tezos_getAccounts";
  PermissionScopeMethods2["OPERATION_REQUEST"] = "tezos_send";
  PermissionScopeMethods2["SIGN"] = "tezos_sign";
})(PermissionScopeMethods || (PermissionScopeMethods = {}));
var PermissionScopeEvents;
(function(PermissionScopeEvents2) {
  PermissionScopeEvents2["CHAIN_CHANGED"] = "chainChanged";
  PermissionScopeEvents2["ACCOUNTS_CHANGED"] = "accountsChanged";
})(PermissionScopeEvents || (PermissionScopeEvents = {}));
var WalletConnectCommunicationClient = class _WalletConnectCommunicationClient extends CommunicationClient {
  constructor(wcOptions) {
    super();
    this.wcOptions = wcOptions;
    this.activeListeners = /* @__PURE__ */ new Map();
    this.channelOpeningListeners = /* @__PURE__ */ new Map();
  }
  static getInstance(wcOptions) {
    if (!_WalletConnectCommunicationClient.instance) {
      _WalletConnectCommunicationClient.instance = new _WalletConnectCommunicationClient(wcOptions);
    }
    return _WalletConnectCommunicationClient.instance;
  }
  listenForEncryptedMessage(senderPublicKey, messageCallback) {
    return __awaiter33(this, void 0, void 0, function* () {
      if (this.activeListeners.has(senderPublicKey)) {
        return;
      }
      const callbackFunction = (message, context2) => __awaiter33(this, void 0, void 0, function* () {
        messageCallback(message, context2);
      });
      this.activeListeners.set(senderPublicKey, callbackFunction);
    });
  }
  listenForChannelOpening(messageCallback) {
    return __awaiter33(this, void 0, void 0, function* () {
      const callbackFunction = (pairingResponse) => __awaiter33(this, void 0, void 0, function* () {
        messageCallback(pairingResponse);
      });
      this.channelOpeningListeners.set("channelOpening", callbackFunction);
    });
  }
  unsubscribeFromEncryptedMessages() {
    return __awaiter33(this, void 0, void 0, function* () {
    });
  }
  unsubscribeFromEncryptedMessage(_senderPublicKey) {
    return __awaiter33(this, void 0, void 0, function* () {
    });
  }
  sendMessage(_message, _peer) {
    return __awaiter33(this, void 0, void 0, function* () {
      const serializer = new Serializer();
      const message = yield serializer.deserialize(_message);
      this.currentMessageId = message.id;
      if ((message === null || message === void 0 ? void 0 : message.type) === BeaconMessageType.PermissionRequest) {
        this.requestPermissions();
      }
      if ((message === null || message === void 0 ? void 0 : message.type) === BeaconMessageType.OperationRequest) {
        this.sendOperations(message);
      }
      if ((message === null || message === void 0 ? void 0 : message.type) === BeaconMessageType.SignPayloadRequest) {
        this.signPayload(message);
      }
    });
  }
  requestPermissions() {
    var _a3, _b;
    return __awaiter33(this, void 0, void 0, function* () {
      console.log("#### Requesting permissions");
      const session = this.getSession();
      if (!this.getPermittedMethods().includes(PermissionScopeMethods.GET_ACCOUNTS)) {
        throw new MissingRequiredScope(PermissionScopeMethods.GET_ACCOUNTS);
      }
      const network = this.getActiveNetwork();
      console.log("#### Requesting public keys");
      const result = yield (_a3 = this.signClient) === null || _a3 === void 0 ? void 0 : _a3.request({
        topic: session.topic,
        chainId: `${TEZOS_PLACEHOLDER}:${network}`,
        request: {
          method: PermissionScopeMethods.GET_ACCOUNTS,
          params: {}
        }
      });
      console.log("##### GET ACCOUNTS", result);
      if (!result || result.length < 1) {
        throw new Error("No account shared by wallet");
      }
      if (result.some((account) => !account.pubkey)) {
        throw new Error("Public Key in `tezos_getAccounts` is empty!");
      }
      const permissionResponse = {
        type: BeaconMessageType.PermissionResponse,
        appMetadata: {
          senderId: session.peer.publicKey,
          name: session.peer.metadata.name,
          icon: session.peer.metadata.icons[0]
        },
        publicKey: (_b = result[0]) === null || _b === void 0 ? void 0 : _b.pubkey,
        network: { type: NetworkType2.MAINNET },
        scopes: [PermissionScope.SIGN, PermissionScope.OPERATION_REQUEST],
        id: this.currentMessageId
      };
      this.sendResponse(session, permissionResponse);
    });
  }
  /**
   * @description Once the session is establish, send payload to be approved and signed by the wallet.
   * @error MissingRequiredScope is thrown if permission to sign payload was not granted
   */
  signPayload(signPayloadRequest) {
    var _a3;
    return __awaiter33(this, void 0, void 0, function* () {
      const session = this.getSession();
      if (!this.getPermittedMethods().includes(PermissionScopeMethods.SIGN)) {
        throw new MissingRequiredScope(PermissionScopeMethods.SIGN);
      }
      const network = this.getActiveNetwork();
      const account = yield this.getPKH();
      this.validateNetworkAndAccount(network, account);
      (_a3 = this.signClient) === null || _a3 === void 0 ? void 0 : _a3.request({
        topic: session.topic,
        chainId: `${TEZOS_PLACEHOLDER}:${network}`,
        request: {
          method: PermissionScopeMethods.SIGN,
          params: {
            account,
            payload: signPayloadRequest.payload
          }
        }
      }).then((response) => {
        const signPayloadResponse = {
          type: BeaconMessageType.SignPayloadResponse,
          signingType: signPayloadRequest.signingType,
          signature: response === null || response === void 0 ? void 0 : response.signature,
          id: this.currentMessageId
        };
        this.sendResponse(session, signPayloadResponse);
      }).catch(() => __awaiter33(this, void 0, void 0, function* () {
        const errorResponse = {
          type: BeaconMessageType.Error,
          id: this.currentMessageId,
          errorType: BeaconErrorType.ABORTED_ERROR
        };
        this.sendResponse(session, errorResponse);
      }));
    });
  }
  /**
   * @description Once the session is established, send Tezos operations to be approved, signed and inject by the wallet.
   * @error MissingRequiredScope is thrown if permission to send operation was not granted
   */
  sendOperations(operationRequest) {
    var _a3;
    return __awaiter33(this, void 0, void 0, function* () {
      const session = this.getSession();
      if (!this.getPermittedMethods().includes(PermissionScopeMethods.OPERATION_REQUEST)) {
        throw new MissingRequiredScope(PermissionScopeMethods.OPERATION_REQUEST);
      }
      const network = this.getActiveNetwork();
      const account = yield this.getPKH();
      this.validateNetworkAndAccount(network, account);
      (_a3 = this.signClient) === null || _a3 === void 0 ? void 0 : _a3.request({
        topic: session.topic,
        chainId: `${TEZOS_PLACEHOLDER}:${network}`,
        request: {
          method: PermissionScopeMethods.OPERATION_REQUEST,
          params: {
            account,
            operations: operationRequest.operationDetails
          }
        }
      }).then((response) => {
        var _a4, _b, _c;
        const sendOperationResponse = {
          type: BeaconMessageType.OperationResponse,
          transactionHash: (_c = (_b = (_a4 = response.operationHash) !== null && _a4 !== void 0 ? _a4 : response.transactionHash) !== null && _b !== void 0 ? _b : response.hash) !== null && _c !== void 0 ? _c : "",
          id: this.currentMessageId
        };
        this.sendResponse(session, sendOperationResponse);
      }).catch(() => __awaiter33(this, void 0, void 0, function* () {
        const errorResponse = {
          type: BeaconMessageType.Error,
          id: this.currentMessageId,
          errorType: BeaconErrorType.ABORTED_ERROR
        };
        this.sendResponse(session, errorResponse);
      }));
    });
  }
  init(forceNewConnection = false) {
    var _a3;
    return __awaiter33(this, void 0, void 0, function* () {
      const connectParams = {
        permissionScope: {
          networks: [NetworkType2.MAINNET],
          events: [],
          methods: [
            PermissionScopeMethods.GET_ACCOUNTS,
            PermissionScopeMethods.OPERATION_REQUEST,
            PermissionScopeMethods.SIGN
          ]
        },
        pairingTopic: void 0
      };
      this.signClient = yield us2.init(this.wcOptions);
      let sessions = this.signClient.session.getAll();
      if (forceNewConnection) {
        for (let session of sessions) {
          yield this.signClient.disconnect({
            topic: session.topic,
            reason: {
              code: 0,
              message: "Force new connection"
            }
          });
        }
        this.clearState();
        sessions = this.signClient.session.getAll();
      }
      if (sessions && sessions.length > 0) {
        this.session = sessions[0];
        this.setDefaultAccountAndNetwork();
        return;
      }
      const { uri, approval } = yield this.signClient.connect({
        requiredNamespaces: {
          [TEZOS_PLACEHOLDER]: {
            chains: connectParams.permissionScope.networks.map((network) => `${TEZOS_PLACEHOLDER}:${network}`),
            methods: connectParams.permissionScope.methods,
            events: (_a3 = connectParams.permissionScope.events) !== null && _a3 !== void 0 ? _a3 : []
          }
        },
        pairingTopic: connectParams.pairingTopic
      });
      approval().then((session) => __awaiter33(this, void 0, void 0, function* () {
        var _b;
        this.session = (_b = this.session) !== null && _b !== void 0 ? _b : session;
        this.validateReceivedNamespace(connectParams.permissionScope, this.session.namespaces);
        this.setDefaultAccountAndNetwork();
        const pairingResponse = {
          id: this.session.peer.publicKey,
          type: "walletconnect-pairing-response",
          name: session.peer.metadata.name,
          publicKey: session.peer.publicKey,
          senderId: this.session.peer.publicKey,
          extensionId: this.session.peer.metadata.name,
          version: "3"
        };
        this.channelOpeningListeners.forEach((listener) => {
          listener(pairingResponse);
        });
      }));
      return uri;
    });
  }
  getPairingRequestInfo() {
    return __awaiter33(this, void 0, void 0, function* () {
      const uri = yield this.init(true);
      return {
        id: yield generateGUID(),
        type: "walletconnect-pairing-request",
        name: "WalletConnect",
        version: BEACON_VERSION,
        uri,
        senderId: yield generateGUID(),
        publicKey: yield generateGUID()
      };
    });
  }
  validateReceivedNamespace(scope, receivedNamespaces) {
    if (receivedNamespaces[TEZOS_PLACEHOLDER]) {
      this.validateMethods(scope.methods, receivedNamespaces[TEZOS_PLACEHOLDER].methods);
      if (scope.events) {
        this.validateEvents(scope.events, receivedNamespaces["tezos"].events);
      }
      this.validateAccounts(scope.networks, receivedNamespaces[TEZOS_PLACEHOLDER].accounts);
    } else {
      this.clearState();
      throw new InvalidReceivedSessionNamespace("All namespaces must be approved", U("USER_REJECTED").code, "incomplete", "tezos");
    }
  }
  validateMethods(requiredMethods, receivedMethods) {
    const missingMethods = [];
    requiredMethods.forEach((method) => {
      if (!receivedMethods.includes(method)) {
        missingMethods.push(method);
      }
    });
    if (missingMethods.length > 0) {
      this.clearState();
      throw new InvalidReceivedSessionNamespace("All methods must be approved", U("USER_REJECTED_METHODS").code, "incomplete", missingMethods);
    }
  }
  validateEvents(requiredEvents, receivedEvents) {
    const missingEvents = [];
    requiredEvents.forEach((method) => {
      if (!receivedEvents.includes(method)) {
        missingEvents.push(method);
      }
    });
    if (missingEvents.length > 0) {
      this.clearState();
      throw new InvalidReceivedSessionNamespace("All events must be approved", U("USER_REJECTED_EVENTS").code, "incomplete", missingEvents);
    }
  }
  validateAccounts(requiredNetwork, receivedAccounts) {
    if (receivedAccounts.length === 0) {
      this.clearState();
      throw new InvalidReceivedSessionNamespace("Accounts must not be empty", U("USER_REJECTED_CHAINS").code, "incomplete");
    }
    const receivedChains = [];
    const invalidChains = [];
    const missingChains = [];
    const invalidChainsNamespace = [];
    receivedAccounts.forEach((chain) => {
      const accountId = chain.split(":");
      if (accountId.length !== 3) {
        invalidChains.push(chain);
      }
      if (accountId[0] !== TEZOS_PLACEHOLDER) {
        invalidChainsNamespace.push(chain);
      }
      const network = accountId[1];
      if (!receivedChains.includes(network)) {
        receivedChains.push(network);
      }
    });
    if (invalidChains.length > 0) {
      this.clearState();
      throw new InvalidReceivedSessionNamespace("Accounts must be CAIP-10 compliant", U("USER_REJECTED_CHAINS").code, "invalid", invalidChains);
    }
    if (invalidChainsNamespace.length > 0) {
      this.clearState();
      throw new InvalidReceivedSessionNamespace("Accounts must be defined in matching namespace", U("UNSUPPORTED_ACCOUNTS").code, "invalid", invalidChainsNamespace);
    }
    requiredNetwork.forEach((network) => {
      if (!receivedChains.includes(network)) {
        missingChains.push(network);
      }
    });
    if (missingChains.length > 0) {
      this.clearState();
      throw new InvalidReceivedSessionNamespace("All chains must have at least one account", U("USER_REJECTED_CHAINS").code, "incomplete", missingChains);
    }
  }
  validateNetworkAndAccount(network, account) {
    if (!this.getTezosNamespace().accounts.includes(`${TEZOS_PLACEHOLDER}:${network}:${account}`)) {
      throw new InvalidNetworkOrAccount(network, account);
    }
  }
  /**
   * @description Access the active network
   * @error ActiveNetworkUnspecified thorwn when there are multiple Tezos netwroks in the session and none is set as the active one
   */
  getActiveNetwork() {
    if (!this.activeNetwork) {
      this.getSession();
      throw new ActiveNetworkUnspecified();
    }
    return this.activeNetwork;
  }
  setDefaultAccountAndNetwork() {
    const activeAccount = this.getAccounts();
    if (activeAccount.length === 1) {
      this.activeAccount = activeAccount[0];
    }
    const activeNetwork = this.getNetworks();
    if (activeNetwork.length === 1) {
      this.activeNetwork = activeNetwork[0];
    }
  }
  /**
   * @description Return all connected accounts from the active session
   * @error NotConnected if no active session
   */
  getAccounts() {
    return this.getTezosNamespace().accounts.map((account) => account.split(":")[2]);
  }
  /**
   * @description Return all networks from the namespace of the active session
   * @error NotConnected if no active session
   */
  getNetworks() {
    return this.getPermittedNetwork();
  }
  getTezosNamespace() {
    if (TEZOS_PLACEHOLDER in this.getSession().namespaces) {
      return this.getSession().namespaces[TEZOS_PLACEHOLDER];
    } else {
      throw new InvalidSession("Tezos not found in namespaces");
    }
  }
  getPermittedMethods() {
    return this.getTezosRequiredNamespace().methods;
  }
  getPermittedNetwork() {
    return this.getTezosRequiredNamespace().chains.map((chain) => chain.split(":")[1]);
  }
  getTezosRequiredNamespace() {
    return {
      chains: ["tezos:mainnet"],
      events: [],
      methods: ["tezos_getAccounts", "tezos_send", "tezos_sign"]
    };
  }
  sendResponse(session, partialResponse) {
    return __awaiter33(this, void 0, void 0, function* () {
      const response = Object.assign(Object.assign({}, partialResponse), { version: "2", senderId: session.peer.publicKey });
      const serializer = new Serializer();
      const serialized = yield serializer.serialize(response);
      this.activeListeners.forEach((listener) => {
        listener(serialized, {
          origin: Origin.WALLETCONNECT,
          id: this.currentMessageId
        });
      });
    });
  }
  currentSession() {
    return this.session;
  }
  getSession() {
    if (!this.session) {
      throw new NotConnected();
    }
    return this.session;
  }
  /**
   * @description Access the public key hash of the active account
   * @error ActiveAccountUnspecified thrown when there are multiple Tezos account in the session and none is set as the active one
   */
  getPKH() {
    return __awaiter33(this, void 0, void 0, function* () {
      if (!this.activeAccount) {
        this.getSession();
        throw new ActiveAccountUnspecified();
      }
      return this.activeAccount;
    });
  }
  clearState() {
    this.session = void 0;
    this.activeAccount = void 0;
    this.activeNetwork = void 0;
  }
};

// node_modules/@taquito/beacon-wallet/node_modules/@airgap/beacon-transport-walletconnect/dist/esm/WalletConnectTransport.js
var __awaiter34 = function(thisArg, _arguments, P2, generator) {
  function adopt(value) {
    return value instanceof P2 ? value : new P2(function(resolve) {
      resolve(value);
    });
  }
  return new (P2 || (P2 = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var WalletConnectTransport = class extends Transport {
  // public readonly type: TransportType = TransportType.WALLETCONNECT
  constructor(name, _keyPair, storage, storageKey, wcOptions) {
    super(name, WalletConnectCommunicationClient.getInstance(wcOptions), new PeerManager(storage, storageKey));
    this.wcOptions = wcOptions;
  }
  static isAvailable() {
    return __awaiter34(this, void 0, void 0, function* () {
      return Promise.resolve(true);
    });
  }
  connect() {
    const _super = Object.create(null, {
      connect: { get: () => super.connect }
    });
    return __awaiter34(this, void 0, void 0, function* () {
      if (this._isConnected !== TransportStatus.NOT_CONNECTED) {
        return;
      }
      this._isConnected = TransportStatus.CONNECTING;
      yield this.client.init();
      const knownPeers = yield this.getPeers();
      if (knownPeers.length > 0) {
        knownPeers.map((peer) => __awaiter34(this, void 0, void 0, function* () {
          return this.listen(peer.publicKey);
        }));
      }
      yield this.startOpenChannelListener();
      return _super.connect.call(this);
    });
  }
  getPeers() {
    return __awaiter34(this, void 0, void 0, function* () {
      const client = WalletConnectCommunicationClient.getInstance(this.wcOptions);
      const session = client.currentSession();
      if (!session) {
        return [];
      }
      return [
        {
          senderId: session.peer.publicKey,
          extensionId: session.peer.metadata.name,
          id: session.peer.publicKey,
          type: "walletconnect-pairing-response",
          name: "peer",
          publicKey: session.peer.publicKey,
          version: "first"
        }
      ];
    });
  }
  disconnect() {
    const _super = Object.create(null, {
      disconnect: { get: () => super.disconnect }
    });
    return __awaiter34(this, void 0, void 0, function* () {
      return _super.disconnect.call(this);
    });
  }
  startOpenChannelListener() {
    return __awaiter34(this, void 0, void 0, function* () {
    });
  }
  getPairingRequestInfo() {
    return __awaiter34(this, void 0, void 0, function* () {
      return this.client.getPairingRequestInfo();
    });
  }
  listen(publicKey) {
    return __awaiter34(this, void 0, void 0, function* () {
      yield this.client.listenForEncryptedMessage(publicKey, (message) => {
        const connectionContext = {
          origin: Origin.WALLETCONNECT,
          id: publicKey
        };
        this.notifyListeners(message, connectionContext).catch((error) => {
          throw error;
        });
      }).catch((error) => {
        throw error;
      });
    });
  }
};

// node_modules/@taquito/beacon-wallet/node_modules/@airgap/beacon-dapp/dist/esm/transports/DappWalletConnectTransport.js
var __awaiter35 = function(thisArg, _arguments, P2, generator) {
  function adopt(value) {
    return value instanceof P2 ? value : new P2(function(resolve) {
      resolve(value);
    });
  }
  return new (P2 || (P2 = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var logger14 = new Logger("DappWalletConnectTransport");
var DappWalletConnectTransport = class extends WalletConnectTransport {
  constructor(name, keyPair, storage, wcOptions) {
    super(name, keyPair, storage, StorageKey.TRANSPORT_WALLETCONNECT_PEERS_DAPP, wcOptions);
    this.client.listenForChannelOpening((peer) => __awaiter35(this, void 0, void 0, function* () {
      yield this.addPeer(peer);
      this._isConnected = TransportStatus.CONNECTED;
      if (this.newPeerListener) {
        this.newPeerListener(peer);
        this.newPeerListener = void 0;
      }
    }));
  }
  listenForNewPeer(newPeerListener) {
    return __awaiter35(this, void 0, void 0, function* () {
      this.newPeerListener = newPeerListener;
    });
  }
  stopListeningForNewPeers() {
    return __awaiter35(this, void 0, void 0, function* () {
      logger14.log("stopListeningForNewPeers");
      this.newPeerListener = void 0;
    });
  }
};

// node_modules/@taquito/beacon-wallet/node_modules/@airgap/beacon-dapp/dist/esm/dapp-client/DAppClient.js
var __awaiter36 = function(thisArg, _arguments, P2, generator) {
  function adopt(value) {
    return value instanceof P2 ? value : new P2(function(resolve) {
      resolve(value);
    });
  }
  return new (P2 || (P2 = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var logger15 = new Logger("DAppClient");
var DAppClient = class extends Client {
  constructor(config2) {
    var _a3, _b, _c, _d, _e3, _f, _g, _h;
    super(Object.assign({ storage: config2 && config2.storage ? config2.storage : new LocalStorage() }, config2));
    this.events = new BeaconEventHandler();
    this.openRequests = /* @__PURE__ */ new Map();
    this._activeAccount = new ExposedPromise();
    this._activePeer = new ExposedPromise();
    this.blockchains = /* @__PURE__ */ new Map();
    this.description = config2.description;
    this.wcProjectId = ((_a3 = config2.walletConnectOptions) === null || _a3 === void 0 ? void 0 : _a3.projectId) || "24469fd0a06df227b6e5f7dc7de0ff4f";
    this.wcRelayUrl = (_b = config2.walletConnectOptions) === null || _b === void 0 ? void 0 : _b.relayUrl;
    this.featuredWallets = config2.featuredWallets;
    this.events = new BeaconEventHandler(config2.eventHandlers, (_c = config2.disableDefaultEvents) !== null && _c !== void 0 ? _c : false);
    this.blockExplorer = (_d = config2.blockExplorer) !== null && _d !== void 0 ? _d : new TzktBlockExplorer();
    this.network = (_e3 = config2.network) !== null && _e3 !== void 0 ? _e3 : { type: (_f = config2.preferredNetwork) !== null && _f !== void 0 ? _f : NetworkType.MAINNET };
    setColorMode((_g = config2.colorMode) !== null && _g !== void 0 ? _g : ColorMode.LIGHT);
    this.disclaimerText = config2.disclaimerText;
    this.errorMessages = (_h = config2.errorMessages) !== null && _h !== void 0 ? _h : {};
    this.appMetadataManager = new AppMetadataManager(this.storage);
    this.activeAccountLoaded = this.storage.get(StorageKey.ACTIVE_ACCOUNT).then((activeAccountIdentifier) => __awaiter36(this, void 0, void 0, function* () {
      if (activeAccountIdentifier) {
        yield this.setActiveAccount(yield this.accountManager.getAccount(activeAccountIdentifier));
      } else {
        yield this.setActiveAccount(void 0);
      }
    })).catch((storageError) => __awaiter36(this, void 0, void 0, function* () {
      yield this.setActiveAccount(void 0);
      console.error(storageError);
    }));
    this.handleResponse = (message, connectionInfo) => __awaiter36(this, void 0, void 0, function* () {
      var _j, _k, _l;
      const openRequest = this.openRequests.get(message.id);
      console.log("### openRequest ###", openRequest);
      logger15.log("handleResponse", "Received message", message, connectionInfo);
      console.log("### message ###", JSON.stringify(message));
      console.log("### connectionInfo ###", connectionInfo);
      if (message.version === "3") {
        const typedMessage = message;
        if (openRequest && typedMessage.message.type === BeaconMessageType.Acknowledge) {
          this.analytics.track("event", "DAppClient", "Acknowledge received from Wallet");
          logger15.log(`acknowledge message received for ${message.id}`);
          console.timeLog(message.id, "acknowledge");
          this.events.emit(BeaconEvent.ACKNOWLEDGE_RECEIVED, {
            message: typedMessage.message,
            extraInfo: {},
            walletInfo: yield this.getWalletInfo()
          }).catch(console.error);
        } else if (openRequest) {
          const appMetadata = typedMessage.message.blockchainData.appMetadata;
          if (typedMessage.message.type === BeaconMessageType.PermissionResponse && appMetadata) {
            yield this.appMetadataManager.addAppMetadata(appMetadata);
          }
          console.timeLog(typedMessage.id, "response");
          console.timeEnd(typedMessage.id);
          if (typedMessage.message.type === BeaconMessageType.Error) {
            openRequest.reject(typedMessage.message);
          } else {
            openRequest.resolve({ message, connectionInfo });
          }
          this.openRequests.delete(typedMessage.id);
        } else {
          if (typedMessage.message.type === BeaconMessageType.Disconnect) {
            this.analytics.track("event", "DAppClient", "Disconnect received from Wallet");
            const relevantTransport = connectionInfo.origin === Origin.P2P ? this.p2pTransport : (_j = this.postMessageTransport) !== null && _j !== void 0 ? _j : yield this.transport;
            if (relevantTransport) {
              const peers = yield relevantTransport.getPeers();
              const peer = peers.find((peerEl) => peerEl.senderId === message.senderId);
              if (peer) {
                yield relevantTransport.removePeer(peer);
                yield this.removeAccountsForPeers([peer]);
                yield this.events.emit(BeaconEvent.CHANNEL_CLOSED);
              } else {
                logger15.error("handleDisconnect", "cannot find peer for sender ID", message.senderId);
              }
            }
          } else {
            logger15.error("handleResponse", "no request found for id ", message.id, message);
          }
        }
      } else {
        const typedMessage = message;
        if (openRequest && typedMessage.type === BeaconMessageType.Acknowledge) {
          logger15.log(`acknowledge message received for ${message.id}`);
          this.analytics.track("event", "DAppClient", "Acknowledge received from Wallet");
          console.timeLog(message.id, "acknowledge");
          this.events.emit(BeaconEvent.ACKNOWLEDGE_RECEIVED, {
            message: typedMessage,
            extraInfo: {},
            walletInfo: yield this.getWalletInfo()
          }).catch(console.error);
        } else if (openRequest) {
          if (typedMessage.type === BeaconMessageType.PermissionResponse && typedMessage.appMetadata) {
            yield this.appMetadataManager.addAppMetadata(typedMessage.appMetadata);
          }
          console.timeLog(typedMessage.id, "response");
          console.timeEnd(typedMessage.id);
          if (typedMessage.type === BeaconMessageType.Error || message.errorType) {
            openRequest.reject(typedMessage);
          } else {
            openRequest.resolve({ message, connectionInfo });
          }
          this.openRequests.delete(typedMessage.id);
        } else {
          if (typedMessage.type === BeaconMessageType.Disconnect || ((_k = message === null || message === void 0 ? void 0 : message.typedMessage) === null || _k === void 0 ? void 0 : _k.type) === BeaconMessageType.Disconnect) {
            this.analytics.track("event", "DAppClient", "Disconnect received from Wallet");
            const relevantTransport = connectionInfo.origin === Origin.P2P ? this.p2pTransport : (_l = this.postMessageTransport) !== null && _l !== void 0 ? _l : yield this.transport;
            if (relevantTransport) {
              const peers = yield relevantTransport.getPeers();
              const peer = peers.find((peerEl) => peerEl.senderId === message.senderId);
              if (peer) {
                yield relevantTransport.removePeer(peer);
                yield this.removeAccountsForPeers([peer]);
                yield this.events.emit(BeaconEvent.CHANNEL_CLOSED);
              } else {
                logger15.error("handleDisconnect", "cannot find peer for sender ID", message.senderId);
              }
            }
          } else {
            logger15.error("handleResponse", "no request found for id ", message.id, message);
          }
        }
      }
    });
  }
  initInternalTransports() {
    var _a3, _b;
    return __awaiter36(this, void 0, void 0, function* () {
      const keyPair = yield this.keyPair;
      if (this.postMessageTransport || this.p2pTransport || this.walletConnectTransport) {
        return;
      }
      this.postMessageTransport = new DappPostMessageTransport(this.name, keyPair, this.storage);
      yield this.addListener(this.postMessageTransport);
      this.p2pTransport = new DappP2PTransport(this.name, keyPair, this.storage, this.matrixNodes, this.iconUrl, this.appUrl);
      yield this.addListener(this.p2pTransport);
      const wcOptions = {
        projectId: this.wcProjectId,
        relayUrl: this.wcRelayUrl,
        metadata: {
          name: this.name,
          description: (_a3 = this.description) !== null && _a3 !== void 0 ? _a3 : "",
          url: (_b = this.appUrl) !== null && _b !== void 0 ? _b : "",
          icons: this.iconUrl ? [this.iconUrl] : []
        }
      };
      this.walletConnectTransport = new DappWalletConnectTransport(this.name, keyPair, this.storage, wcOptions);
      yield this.addListener(this.walletConnectTransport);
    });
  }
  init(transport) {
    const _super = Object.create(null, {
      init: { get: () => super.init }
    });
    return __awaiter36(this, void 0, void 0, function* () {
      if (this._initPromise) {
        return this._initPromise;
      }
      try {
        yield this.activeAccountLoaded;
      } catch (_a3) {
      }
      this._initPromise = new Promise((resolve) => __awaiter36(this, void 0, void 0, function* () {
        if (transport) {
          yield this.addListener(transport);
          resolve(yield _super.init.call(this, transport));
        } else if (this._transport.isSettled()) {
          yield (yield this.transport).connect();
          resolve(yield _super.init.call(this, yield this.transport));
        } else {
          const activeAccount = yield this.getActiveAccount();
          const stopListening = () => {
            if (this.postMessageTransport) {
              this.postMessageTransport.stopListeningForNewPeers().catch(console.error);
            }
            if (this.p2pTransport) {
              this.p2pTransport.stopListeningForNewPeers().catch(console.error);
            }
            if (this.walletConnectTransport) {
              this.walletConnectTransport.stopListeningForNewPeers().catch(console.error);
            }
          };
          yield this.initInternalTransports();
          if (!this.postMessageTransport || !this.p2pTransport || !this.walletConnectTransport) {
            return;
          }
          this.postMessageTransport.connect().then().catch(console.error);
          if (activeAccount && activeAccount.origin) {
            const origin = activeAccount.origin.type;
            if (origin === Origin.EXTENSION) {
              resolve(yield _super.init.call(this, this.postMessageTransport));
            } else if (origin === Origin.P2P) {
              resolve(yield _super.init.call(this, this.p2pTransport));
            } else if (origin === Origin.WALLETCONNECT) {
              resolve(yield _super.init.call(this, this.walletConnectTransport));
            }
          } else {
            const p2pTransport = this.p2pTransport;
            const postMessageTransport = this.postMessageTransport;
            const walletConnectTransport = this.walletConnectTransport;
            postMessageTransport.listenForNewPeer((peer) => {
              logger15.log("init", "postmessage transport peer connected", peer);
              this.analytics.track("event", "DAppClient", "Extension connected", {
                peerName: peer.name
              });
              this.events.emit(BeaconEvent.PAIR_SUCCESS, peer).catch((emitError) => console.warn(emitError));
              this.setActivePeer(peer).catch(console.error);
              this.setTransport(this.postMessageTransport).catch(console.error);
              stopListening();
              resolve(TransportType.POST_MESSAGE);
            }).catch(console.error);
            p2pTransport.listenForNewPeer((peer) => {
              logger15.log("init", "p2p transport peer connected", peer);
              this.analytics.track("event", "DAppClient", "Beacon Wallet connected", {
                peerName: peer.name
              });
              this.events.emit(BeaconEvent.PAIR_SUCCESS, peer).catch((emitError) => console.warn(emitError));
              this.setActivePeer(peer).catch(console.error);
              this.setTransport(this.p2pTransport).catch(console.error);
              stopListening();
              resolve(TransportType.P2P);
            }).catch(console.error);
            walletConnectTransport.listenForNewPeer((peer) => {
              logger15.log("init", "walletconnect transport peer connected", peer);
              this.analytics.track("event", "DAppClient", "WalletConnect Wallet connected", {
                peerName: peer.name
              });
              this.events.emit(BeaconEvent.PAIR_SUCCESS, peer).catch((emitError) => console.warn(emitError));
              this.setActivePeer(peer).catch(console.error);
              this.setTransport(this.walletConnectTransport).catch(console.error);
              stopListening();
              resolve(TransportType.WALLETCONNECT);
            }).catch(console.error);
            PostMessageTransport.getAvailableExtensions().then((extensions2) => __awaiter36(this, void 0, void 0, function* () {
              this.analytics.track("event", "DAppClient", "Extensions detected", { extensions: extensions2 });
            })).catch((error) => {
              this._initPromise = void 0;
              console.error(error);
            });
            this.events.emit(BeaconEvent.PAIR_INIT, {
              p2pPeerInfo: () => {
                p2pTransport.connect().then().catch(console.error);
                return p2pTransport.getPairingRequestInfo();
              },
              postmessagePeerInfo: () => postMessageTransport.getPairingRequestInfo(),
              walletConnectPeerInfo: () => walletConnectTransport.getPairingRequestInfo(),
              networkType: this.network.type,
              abortedHandler: () => {
                console.log("ABORTED");
                this._initPromise = void 0;
              },
              disclaimerText: this.disclaimerText,
              analytics: this.analytics,
              featuredWallets: this.featuredWallets
            }).catch((emitError) => console.warn(emitError));
          }
        }
      }));
      return this._initPromise;
    });
  }
  /**
   * Returns the active account
   */
  getActiveAccount() {
    return __awaiter36(this, void 0, void 0, function* () {
      return this._activeAccount.promise;
    });
  }
  /**
   * Sets the active account
   *
   * @param account The account that will be set as the active account
   */
  setActiveAccount(account) {
    return __awaiter36(this, void 0, void 0, function* () {
      if (this._activeAccount.isSettled()) {
        this._activeAccount = ExposedPromise.resolve(account);
      } else {
        this._activeAccount.resolve(account);
      }
      if (account) {
        const origin = account.origin.type;
        yield this.initInternalTransports();
        if (origin === Origin.EXTENSION) {
          yield this.setTransport(this.postMessageTransport);
        } else if (origin === Origin.P2P) {
          yield this.setTransport(this.p2pTransport);
        } else if (origin === Origin.WALLETCONNECT) {
          yield this.setTransport(this.walletConnectTransport);
        }
        const peer = yield this.getPeer(account);
        yield this.setActivePeer(peer);
      } else {
        yield this.setActivePeer(void 0);
        yield this.setTransport(void 0);
      }
      yield this.storage.set(StorageKey.ACTIVE_ACCOUNT, account ? account.accountIdentifier : void 0);
      yield this.events.emit(BeaconEvent.ACTIVE_ACCOUNT_SET, account);
      return;
    });
  }
  /**
   * Clear the active account
   */
  clearActiveAccount() {
    return this.setActiveAccount();
  }
  setColorMode(colorMode2) {
    return __awaiter36(this, void 0, void 0, function* () {
      return setColorMode(colorMode2);
    });
  }
  getColorMode() {
    return __awaiter36(this, void 0, void 0, function* () {
      return getColorMode();
    });
  }
  /**
   * @deprecated
   *
   * Use getOwnAppMetadata instead
   */
  getAppMetadata() {
    return __awaiter36(this, void 0, void 0, function* () {
      return this.getOwnAppMetadata();
    });
  }
  showPrepare() {
    return __awaiter36(this, void 0, void 0, function* () {
      const walletInfo = yield (() => __awaiter36(this, void 0, void 0, function* () {
        try {
          return yield this.getWalletInfo();
        } catch (_a3) {
          return void 0;
        }
      }))();
      yield this.events.emit(BeaconEvent.SHOW_PREPARE, { walletInfo });
    });
  }
  hideUI(elements) {
    return __awaiter36(this, void 0, void 0, function* () {
      yield this.events.emit(BeaconEvent.HIDE_UI, elements);
    });
  }
  /**
   * Will remove the account from the local storage and set a new active account if necessary.
   *
   * @param accountIdentifier ID of the account
   */
  removeAccount(accountIdentifier) {
    const _super = Object.create(null, {
      removeAccount: { get: () => super.removeAccount }
    });
    return __awaiter36(this, void 0, void 0, function* () {
      const removeAccountResult = _super.removeAccount.call(this, accountIdentifier);
      const activeAccount = yield this.getActiveAccount();
      if (activeAccount && activeAccount.accountIdentifier === accountIdentifier) {
        yield this.setActiveAccount(void 0);
      }
      return removeAccountResult;
    });
  }
  /**
   * Remove all accounts and set active account to undefined
   */
  removeAllAccounts() {
    const _super = Object.create(null, {
      removeAllAccounts: { get: () => super.removeAllAccounts }
    });
    return __awaiter36(this, void 0, void 0, function* () {
      yield _super.removeAllAccounts.call(this);
      yield this.setActiveAccount(void 0);
    });
  }
  /**
   * Removes a peer and all the accounts that have been connected through that peer
   *
   * @param peer Peer to be removed
   */
  removePeer(peer, sendDisconnectToPeer = false) {
    return __awaiter36(this, void 0, void 0, function* () {
      const transport = yield this.transport;
      const removePeerResult = transport.removePeer(peer);
      yield this.removeAccountsForPeers([peer]);
      if (sendDisconnectToPeer) {
        yield this.sendDisconnectToPeer(peer, transport);
      }
      return removePeerResult;
    });
  }
  /**
   * Remove all peers and all accounts that have been connected through those peers
   */
  removeAllPeers(sendDisconnectToPeers = false) {
    return __awaiter36(this, void 0, void 0, function* () {
      const transport = yield this.transport;
      const peers = yield transport.getPeers();
      const removePeerResult = transport.removeAllPeers();
      yield this.removeAccountsForPeers(peers);
      if (sendDisconnectToPeers) {
        const disconnectPromises = peers.map((peer) => this.sendDisconnectToPeer(peer, transport));
        yield Promise.all(disconnectPromises);
      }
      return removePeerResult;
    });
  }
  /**
   * Allows the user to subscribe to specific events that are fired in the SDK
   *
   * @param internalEvent The event to subscribe to
   * @param eventCallback The callback that will be called when the event occurs
   */
  subscribeToEvent(internalEvent, eventCallback) {
    return __awaiter36(this, void 0, void 0, function* () {
      yield this.events.on(internalEvent, eventCallback);
    });
  }
  /**
   * Check if we have permissions to send the specific message type to the active account.
   * If no active account is set, only permission requests are allowed.
   *
   * @param type The type of the message
   */
  checkPermissions(type) {
    return __awaiter36(this, void 0, void 0, function* () {
      if (type === BeaconMessageType.PermissionRequest) {
        return true;
      }
      const activeAccount = yield this.getActiveAccount();
      if (!activeAccount) {
        throw yield this.sendInternalError("No active account set!");
      }
      const permissions = activeAccount.scopes;
      switch (type) {
        case BeaconMessageType.OperationRequest:
          return permissions.includes(PermissionScope.OPERATION_REQUEST);
        case BeaconMessageType.SignPayloadRequest:
          return permissions.includes(PermissionScope.SIGN);
        case BeaconMessageType.BroadcastRequest:
          return true;
        default:
          return false;
      }
    });
  }
  sendNotification(title, message, payload, protocolIdentifier) {
    var _a3, _b, _c;
    return __awaiter36(this, void 0, void 0, function* () {
      const activeAccount = yield this.getActiveAccount();
      if (!activeAccount || activeAccount && !activeAccount.scopes.includes(PermissionScope.NOTIFICATION) && !activeAccount.notification) {
        throw new Error("notification permissions not given");
      }
      if (!((_a3 = activeAccount.notification) === null || _a3 === void 0 ? void 0 : _a3.token)) {
        throw new Error("No AccessToken");
      }
      const url = (_b = activeAccount.notification) === null || _b === void 0 ? void 0 : _b.apiUrl;
      if (!url) {
        throw new Error("No Push URL set");
      }
      return this.sendNotificationWithAccessToken({
        url,
        recipient: activeAccount.address,
        title,
        body: message,
        payload,
        protocolIdentifier,
        accessToken: (_c = activeAccount.notification) === null || _c === void 0 ? void 0 : _c.token
      });
    });
  }
  addBlockchain(chain) {
    this.blockchains.set(chain.identifier, chain);
    chain.getWalletLists().then((walletLists) => {
      setDesktopList(walletLists.desktopList);
      setExtensionList(walletLists.extensionList);
      setWebList(walletLists.webList);
      setiOSList(walletLists.iOSList);
    });
  }
  removeBlockchain(chainIdentifier) {
    this.blockchains.delete(chainIdentifier);
  }
  /** Generic messages */
  permissionRequest(input) {
    return __awaiter36(this, void 0, void 0, function* () {
      console.log("PERMISSION REQUEST");
      const blockchain = this.blockchains.get(input.blockchainIdentifier);
      if (!blockchain) {
        throw new Error(`Blockchain "${input.blockchainIdentifier}" not supported by dAppClient`);
      }
      const request = Object.assign(Object.assign({}, input), { type: BeaconMessageType.PermissionRequest, blockchainData: Object.assign(Object.assign({}, input.blockchainData), { appMetadata: yield this.getOwnAppMetadata() }) });
      console.log("REQUESTION PERMIMISSION V3", "xxx", request);
      const { message: response, connectionInfo } = yield this.makeRequestV3(request).catch((_requestError) => __awaiter36(this, void 0, void 0, function* () {
        throw new Error("TODO");
      }));
      console.log("RESPONSE V3", response, connectionInfo);
      const partialAccountInfos = yield blockchain.getAccountInfosFromPermissionResponse(response.message);
      const accountInfo = {
        accountIdentifier: partialAccountInfos[0].accountId,
        senderId: response.senderId,
        origin: {
          type: connectionInfo.origin,
          id: connectionInfo.id
        },
        address: partialAccountInfos[0].address,
        publicKey: partialAccountInfos[0].publicKey,
        scopes: response.message.blockchainData.scopes,
        connectedAt: (/* @__PURE__ */ new Date()).getTime(),
        chainData: response.message.blockchainData
      };
      yield this.accountManager.addAccount(accountInfo);
      yield this.setActiveAccount(accountInfo);
      yield blockchain.handleResponse({
        request,
        account: accountInfo,
        output: response,
        blockExplorer: this.blockExplorer,
        connectionContext: connectionInfo,
        walletInfo: yield this.getWalletInfo()
      });
      yield this.notifySuccess(request, {
        account: accountInfo,
        output: {
          address: partialAccountInfos[0].address,
          network: { type: NetworkType.MAINNET },
          scopes: [PermissionScope.OPERATION_REQUEST]
        },
        blockExplorer: this.blockExplorer,
        connectionContext: connectionInfo,
        walletInfo: yield this.getWalletInfo()
      });
      return response.message;
    });
  }
  request(input) {
    return __awaiter36(this, void 0, void 0, function* () {
      console.log("REQUEST", input);
      const blockchain = this.blockchains.get(input.blockchainIdentifier);
      if (!blockchain) {
        throw new Error(`Blockchain "${blockchain}" not supported by dAppClient`);
      }
      yield blockchain.validateRequest(input);
      const activeAccount = yield this.getActiveAccount();
      if (!activeAccount) {
        throw yield this.sendInternalError("No active account!");
      }
      const request = Object.assign(Object.assign({}, input), { type: BeaconMessageType.BlockchainRequest, accountId: activeAccount.accountIdentifier });
      const { message: response, connectionInfo } = yield this.makeRequestV3(request).catch((requestError) => __awaiter36(this, void 0, void 0, function* () {
        console.error(requestError);
        throw new Error("TODO");
      }));
      yield blockchain.handleResponse({
        request,
        account: activeAccount,
        output: response,
        blockExplorer: this.blockExplorer,
        connectionContext: connectionInfo,
        walletInfo: yield this.getWalletInfo()
      });
      return response.message;
    });
  }
  /**
   * Send a permission request to the DApp. This should be done as the first step. The wallet will respond
   * with an publicKey and permissions that were given. The account returned will be set as the "activeAccount"
   * and will be used for the following requests.
   *
   * @param input The message details we need to prepare the PermissionRequest message.
   */
  requestPermissions(input) {
    var _a3;
    return __awaiter36(this, void 0, void 0, function* () {
      if ((input === null || input === void 0 ? void 0 : input.network) !== void 0 && this.network.type !== ((_a3 = input === null || input === void 0 ? void 0 : input.network) === null || _a3 === void 0 ? void 0 : _a3.type)) {
        console.error("[BEACON] The network specified in the DAppClient constructor does not match the network set in the permission request. Please set the network in the constructor. Setting it during the Permission Request is deprecated.");
      }
      const request = {
        appMetadata: yield this.getOwnAppMetadata(),
        type: BeaconMessageType.PermissionRequest,
        network: this.network,
        scopes: input && input.scopes ? input.scopes : [PermissionScope.OPERATION_REQUEST, PermissionScope.SIGN]
      };
      this.analytics.track("event", "DAppClient", "Permission requested");
      const { message, connectionInfo } = yield this.makeRequest(request).catch((requestError) => __awaiter36(this, void 0, void 0, function* () {
        throw yield this.handleRequestError(request, requestError);
      }));
      const publicKey = yield prefixPublicKey(message.publicKey || message.pubkey || message.pubKey);
      const address = yield getAddressFromPublicKey(publicKey);
      console.log("######## MESSAGE #######");
      console.log(message);
      const walletKey = yield this.storage.get(StorageKey.LAST_SELECTED_WALLET);
      const accountInfo = {
        accountIdentifier: yield getAccountIdentifier(address, message.network),
        senderId: message.senderId,
        origin: {
          type: connectionInfo.origin,
          id: connectionInfo.id
        },
        walletKey,
        address,
        publicKey,
        network: message.network,
        scopes: message.scopes,
        threshold: message.threshold,
        notification: message.notification,
        connectedAt: (/* @__PURE__ */ new Date()).getTime()
      };
      console.log("######## ACCOUNT INFO #######");
      console.log(JSON.stringify(accountInfo));
      yield this.accountManager.addAccount(accountInfo);
      yield this.setActiveAccount(accountInfo);
      const output = Object.assign(Object.assign({}, message), {
        walletKey,
        address,
        accountInfo
      });
      yield this.notifySuccess(request, {
        account: accountInfo,
        output,
        blockExplorer: this.blockExplorer,
        connectionContext: connectionInfo,
        walletInfo: yield this.getWalletInfo()
      });
      this.analytics.track("event", "DAppClient", "Permission received", { address });
      return output;
    });
  }
  /**
   * This method will send a "SignPayloadRequest" to the wallet. This method is meant to be used to sign
   * arbitrary data (eg. a string). It will return the signature in the format of "edsig..."
   *
   * @param input The message details we need to prepare the SignPayloadRequest message.
   */
  requestSignPayload(input) {
    return __awaiter36(this, void 0, void 0, function* () {
      if (!input.payload) {
        throw yield this.sendInternalError("Payload must be provided");
      }
      const activeAccount = yield this.getActiveAccount();
      if (!activeAccount) {
        throw yield this.sendInternalError("No active account!");
      }
      const payload = input.payload;
      if (typeof payload !== "string") {
        throw new Error("Payload must be a string");
      }
      const signingType = (() => {
        switch (input.signingType) {
          case SigningType.OPERATION:
            if (!payload.startsWith("03")) {
              throw new Error('When using signing type "OPERATION", the payload must start with prefix "03"');
            }
            return SigningType.OPERATION;
          case SigningType.MICHELINE:
            if (!payload.startsWith("05")) {
              throw new Error('When using signing type "MICHELINE", the payload must start with prefix "05"');
            }
            return SigningType.MICHELINE;
          case SigningType.RAW:
          default:
            return SigningType.RAW;
        }
      })();
      this.analytics.track("event", "DAppClient", "Signature requested");
      const request = {
        type: BeaconMessageType.SignPayloadRequest,
        signingType,
        payload,
        sourceAddress: input.sourceAddress || activeAccount.address
      };
      const { message, connectionInfo } = yield this.makeRequest(request).catch((requestError) => __awaiter36(this, void 0, void 0, function* () {
        throw yield this.handleRequestError(request, requestError);
      }));
      yield this.notifySuccess(request, {
        account: activeAccount,
        output: message,
        connectionContext: connectionInfo,
        walletInfo: yield this.getWalletInfo()
      });
      this.analytics.track("event", "DAppClient", "Signature response");
      return message;
    });
  }
  /**
   * This method will send an "EncryptPayloadRequest" to the wallet. This method is meant to be used to encrypt or decrypt
   * arbitrary data (eg. a string). It will return the encrypted or decrypted payload
   *
   * @param input The message details we need to prepare the EncryptPayloadRequest message.
   */
  // TODO: ENCRYPTION
  // public async requestEncryptPayload(
  //   input: RequestEncryptPayloadInput
  // ): Promise<EncryptPayloadResponseOutput> {
  //   if (!input.payload) {
  //     throw await this.sendInternalError('Payload must be provided')
  //   }
  //   const activeAccount: AccountInfo | undefined = await this.getActiveAccount()
  //   if (!activeAccount) {
  //     throw await this.sendInternalError('No active account!')
  //   }
  //   const payload = input.payload
  //   if (typeof payload !== 'string') {
  //     throw new Error('Payload must be a string')
  //   }
  //   if (typeof input.encryptionCryptoOperation === 'undefined') {
  //     throw new Error('encryptionCryptoOperation must be defined')
  //   }
  //   if (typeof input.encryptionType === 'undefined') {
  //     throw new Error('encryptionType must be defined')
  //   }
  //   const request: EncryptPayloadRequestInput = {
  //     type: BeaconMessageType.EncryptPayloadRequest,
  //     cryptoOperation: input.encryptionCryptoOperation,
  //     encryptionType: input.encryptionType,
  //     payload,
  //     sourceAddress: input.sourceAddress || activeAccount.address
  //   }
  //   const { message, connectionInfo } = await this.makeRequest<
  //     EncryptPayloadRequest,
  //     EncryptPayloadResponse
  //   >(request).catch(async (requestError: ErrorResponse) => {
  //     throw await this.handleRequestError(request, requestError)
  //   })
  //   await this.notifySuccess(request, {
  //     account: activeAccount,
  //     output: message,
  //     connectionContext: connectionInfo,
  //     walletInfo: await this.getWalletInfo()
  //   })
  //   return message
  // }
  /**
   * This method sends an OperationRequest to the wallet. This method should be used for all kinds of operations,
   * eg. transaction or delegation. Not all properties have to be provided. Data like "counter" and fees will be
   * fetched and calculated by the wallet (but they can still be provided if required).
   *
   * @param input The message details we need to prepare the OperationRequest message.
   */
  requestOperation(input) {
    return __awaiter36(this, void 0, void 0, function* () {
      if (!input.operationDetails) {
        throw yield this.sendInternalError("Operation details must be provided");
      }
      const activeAccount = yield this.getActiveAccount();
      if (!activeAccount) {
        throw yield this.sendInternalError("No active account!");
      }
      const request = {
        type: BeaconMessageType.OperationRequest,
        network: activeAccount.network || this.network,
        operationDetails: input.operationDetails,
        sourceAddress: activeAccount.address || ""
      };
      this.analytics.track("event", "DAppClient", "Operation requested");
      const { message, connectionInfo } = yield this.makeRequest(request).catch((requestError) => __awaiter36(this, void 0, void 0, function* () {
        throw yield this.handleRequestError(request, requestError);
      }));
      yield this.notifySuccess(request, {
        account: activeAccount,
        output: message,
        blockExplorer: this.blockExplorer,
        connectionContext: connectionInfo,
        walletInfo: yield this.getWalletInfo()
      });
      this.analytics.track("event", "DAppClient", "Operation response");
      return message;
    });
  }
  /**
   * Sends a "BroadcastRequest" to the wallet. This method can be used to inject an already signed transaction
   * to the network.
   *
   * @param input The message details we need to prepare the BroadcastRequest message.
   */
  requestBroadcast(input) {
    var _a3;
    return __awaiter36(this, void 0, void 0, function* () {
      if (!input.signedTransaction) {
        throw yield this.sendInternalError("Signed transaction must be provided");
      }
      if (input.network !== void 0 && this.network.type !== ((_a3 = input.network) === null || _a3 === void 0 ? void 0 : _a3.type)) {
        console.error("[BEACON] The network specified in the DAppClient constructor does not match the network set in the broadcast request. Please set the network in the constructor. Setting it during the Broadcast Request is deprecated.");
      }
      const request = {
        type: BeaconMessageType.BroadcastRequest,
        network: this.network,
        signedTransaction: input.signedTransaction
      };
      this.analytics.track("event", "DAppClient", "Broadcast requested");
      const { message, connectionInfo } = yield this.makeRequest(request).catch((requestError) => __awaiter36(this, void 0, void 0, function* () {
        throw yield this.handleRequestError(request, requestError);
      }));
      yield this.notifySuccess(request, {
        network: this.network,
        output: message,
        blockExplorer: this.blockExplorer,
        connectionContext: connectionInfo,
        walletInfo: yield this.getWalletInfo()
      });
      this.analytics.track("event", "DAppClient", "Broadcast response");
      return message;
    });
  }
  setActivePeer(peer) {
    return __awaiter36(this, void 0, void 0, function* () {
      if (this._activePeer.isSettled()) {
        this._activePeer = ExposedPromise.resolve(peer);
      } else {
        this._activePeer.resolve(peer);
      }
      if (peer) {
        yield this.initInternalTransports();
        if (peer.type === "postmessage-pairing-response") {
          yield this.setTransport(this.postMessageTransport);
        } else if (peer.type === "p2p-pairing-response") {
          yield this.setTransport(this.p2pTransport);
        }
      }
      return;
    });
  }
  /**
   * A "setter" for when the transport needs to be changed.
   */
  setTransport(transport) {
    const _super = Object.create(null, {
      setTransport: { get: () => super.setTransport }
    });
    return __awaiter36(this, void 0, void 0, function* () {
      if (!transport) {
        this._initPromise = void 0;
      }
      const result = _super.setTransport.call(this, transport);
      yield this.events.emit(BeaconEvent.ACTIVE_TRANSPORT_SET, transport);
      return result;
    });
  }
  /**
   * This method will emit an internal error message.
   *
   * @param errorMessage The error message to send.
   */
  sendInternalError(errorMessage) {
    return __awaiter36(this, void 0, void 0, function* () {
      yield this.events.emit(BeaconEvent.INTERNAL_ERROR, { text: errorMessage });
      throw new Error(errorMessage);
    });
  }
  /**
   * This method will remove all accounts associated with a specific peer.
   *
   * @param peersToRemove An array of peers for which accounts should be removed
   */
  removeAccountsForPeers(peersToRemove) {
    return __awaiter36(this, void 0, void 0, function* () {
      const accounts = yield this.accountManager.getAccounts();
      const peerIdsToRemove = peersToRemove.map((peer) => peer.senderId);
      const accountsToRemove = accounts.filter((account) => peerIdsToRemove.includes(account.senderId));
      const accountIdentifiersToRemove = accountsToRemove.map((accountInfo) => accountInfo.accountIdentifier);
      yield this.accountManager.removeAccounts(accountIdentifiersToRemove);
      const activeAccount = yield this.getActiveAccount();
      if (activeAccount) {
        if (accountIdentifiersToRemove.includes(activeAccount.accountIdentifier)) {
          yield this.setActiveAccount(void 0);
        }
      }
    });
  }
  /**
   * This message handles errors that we receive from the wallet.
   *
   * @param request The request we sent
   * @param beaconError The error we received
   */
  handleRequestError(request, beaconError) {
    return __awaiter36(this, void 0, void 0, function* () {
      logger15.error("handleRequestError", "error response", beaconError);
      if (beaconError.errorType) {
        const buttons = [];
        if (beaconError.errorType === BeaconErrorType.NO_PRIVATE_KEY_FOUND_ERROR) {
          const actionCallback = () => __awaiter36(this, void 0, void 0, function* () {
            const operationRequest = request;
            let accountInfo;
            if (operationRequest.sourceAddress && operationRequest.network) {
              const accountIdentifier = yield getAccountIdentifier(operationRequest.sourceAddress, operationRequest.network);
              accountInfo = yield this.getAccount(accountIdentifier);
              if (accountInfo) {
                yield this.removeAccount(accountInfo.accountIdentifier);
              }
            }
          });
          buttons.push({ text: "Remove account", actionCallback });
        }
        const peer = yield this.getPeer();
        const activeAccount = yield this.getActiveAccount();
        if (request.type === BeaconMessageType.PermissionRequest && (yield this.getActiveAccount()) === void 0) {
          this._initPromise = void 0;
          this.postMessageTransport = void 0;
          this.p2pTransport = void 0;
          yield this.setTransport();
          yield this.setActivePeer();
        }
        this.events.emit(messageEvents[request.type].error, {
          errorResponse: beaconError,
          walletInfo: yield this.getWalletInfo(peer, activeAccount),
          errorMessages: this.errorMessages
        }, buttons).catch((emitError) => logger15.error("handleRequestError", emitError));
        throw BeaconError.getError(beaconError.errorType, beaconError.errorData);
      }
      throw beaconError;
    });
  }
  /**
   * This message will send an event when we receive a successful response to one of the requests we sent.
   *
   * @param request The request we sent
   * @param response The response we received
   */
  notifySuccess(request, response) {
    return __awaiter36(this, void 0, void 0, function* () {
      this.events.emit(messageEvents[request.type].success, response).catch((emitError) => console.warn(emitError));
    });
  }
  getWalletInfo(peer, account) {
    var _a3, _b;
    return __awaiter36(this, void 0, void 0, function* () {
      const selectedAccount = account ? account : yield this.getActiveAccount();
      const selectedPeer = peer ? peer : yield this.getPeer(selectedAccount);
      let walletInfo;
      if (selectedAccount) {
        walletInfo = yield this.appMetadataManager.getAppMetadata(selectedAccount.senderId);
      }
      const typedPeer = selectedPeer;
      if (!walletInfo) {
        walletInfo = {
          name: typedPeer === null || typedPeer === void 0 ? void 0 : typedPeer.name,
          icon: typedPeer === null || typedPeer === void 0 ? void 0 : typedPeer.icon
        };
      }
      const lowerCaseCompare = (str1, str2) => {
        if (str1 && str2) {
          return str1.toLowerCase() === str2.toLowerCase();
        }
        return false;
      };
      let selectedApp;
      let type;
      if (getiOSList().find((app) => lowerCaseCompare(app.name, walletInfo === null || walletInfo === void 0 ? void 0 : walletInfo.name))) {
        selectedApp = getiOSList().find((app) => lowerCaseCompare(app.name, walletInfo === null || walletInfo === void 0 ? void 0 : walletInfo.name));
        type = "mobile";
      } else if (getWebList().find((app) => lowerCaseCompare(app.name, walletInfo === null || walletInfo === void 0 ? void 0 : walletInfo.name))) {
        selectedApp = getWebList().find((app) => lowerCaseCompare(app.name, walletInfo === null || walletInfo === void 0 ? void 0 : walletInfo.name));
        type = "web";
      } else if (getDesktopList().find((app) => lowerCaseCompare(app.name, walletInfo === null || walletInfo === void 0 ? void 0 : walletInfo.name))) {
        selectedApp = getDesktopList().find((app) => lowerCaseCompare(app.name, walletInfo === null || walletInfo === void 0 ? void 0 : walletInfo.name));
        type = "desktop";
      } else if (getExtensionList().find((app) => lowerCaseCompare(app.name, walletInfo === null || walletInfo === void 0 ? void 0 : walletInfo.name))) {
        selectedApp = getExtensionList().find((app) => lowerCaseCompare(app.name, walletInfo === null || walletInfo === void 0 ? void 0 : walletInfo.name));
        type = "extension";
      }
      if (selectedApp) {
        let deeplink;
        if (selectedApp.hasOwnProperty("links")) {
          deeplink = selectedApp.links[(_a3 = selectedAccount === null || selectedAccount === void 0 ? void 0 : selectedAccount.network.type) !== null && _a3 !== void 0 ? _a3 : this.network.type];
        } else if (selectedApp.hasOwnProperty("deepLink")) {
          deeplink = selectedApp.deepLink;
        }
        return {
          name: walletInfo.name,
          icon: (_b = walletInfo.icon) !== null && _b !== void 0 ? _b : selectedApp.logo,
          deeplink,
          type
        };
      }
      return walletInfo;
    });
  }
  getPeer(account) {
    var _a3, _b, _c, _d, _e3, _f;
    return __awaiter36(this, void 0, void 0, function* () {
      let peer;
      if (account) {
        logger15.log("getPeer", "We have an account", account);
        const postMessagePeers = (_b = yield (_a3 = this.postMessageTransport) === null || _a3 === void 0 ? void 0 : _a3.getPeers()) !== null && _b !== void 0 ? _b : [];
        const p2pPeers = (_d = yield (_c = this.p2pTransport) === null || _c === void 0 ? void 0 : _c.getPeers()) !== null && _d !== void 0 ? _d : [];
        const walletConnectPeers = (_f = yield (_e3 = this.walletConnectTransport) === null || _e3 === void 0 ? void 0 : _e3.getPeers()) !== null && _f !== void 0 ? _f : [];
        const peers = [...postMessagePeers, ...p2pPeers, ...walletConnectPeers];
        logger15.log("getPeer", "Found peers", peers, account);
        peer = peers.find((peerEl) => peerEl.senderId === account.senderId);
        if (!peer) {
          peer = peers.find((peerEl) => peerEl.extensionId === account.origin.id);
        }
      } else {
        peer = yield this._activePeer.promise;
        logger15.log("getPeer", "Active peer", peer);
      }
      return peer;
    });
  }
  /**
   * This method handles sending of requests to the DApp. It makes sure that the DAppClient is initialized and connected
   * to the transport. After that rate limits and permissions will be checked, an ID is attached and the request is sent
   * to the DApp over the transport.
   *
   * @param requestInput The BeaconMessage to be sent to the wallet
   * @param account The account that the message will be sent to
   */
  makeRequest(requestInput) {
    var _a3;
    return __awaiter36(this, void 0, void 0, function* () {
      const messageId = yield generateGUID();
      console.time(messageId);
      logger15.log("makeRequest", "starting");
      yield this.init();
      console.timeLog(messageId, "init done");
      logger15.log("makeRequest", "after init");
      if (yield this.addRequestAndCheckIfRateLimited()) {
        this.events.emit(BeaconEvent.LOCAL_RATE_LIMIT_REACHED).catch((emitError) => console.warn(emitError));
        throw new Error("rate limit reached");
      }
      if (!(yield this.checkPermissions(requestInput.type))) {
        this.events.emit(BeaconEvent.NO_PERMISSIONS).catch((emitError) => console.warn(emitError));
        throw new Error("No permissions to send this request to wallet!");
      }
      if (!this.beaconId) {
        throw yield this.sendInternalError("BeaconID not defined");
      }
      const request = Object.assign({ id: messageId, version: "2", senderId: yield getSenderId(yield this.beaconId) }, requestInput);
      const exposed = new ExposedPromise();
      this.addOpenRequest(request.id, exposed);
      const payload = yield new Serializer().serialize(request);
      const account = yield this.getActiveAccount();
      const peer = yield this.getPeer(account);
      const walletInfo = yield this.getWalletInfo(peer, account);
      logger15.log("makeRequest", "sending message", request);
      console.timeLog(messageId, "sending");
      try {
        yield (yield this.transport).send(payload, peer);
      } catch (sendError) {
        this.events.emit(BeaconEvent.INTERNAL_ERROR, {
          text: "Unable to send message. If this problem persists, please reset the connection and pair your wallet again.",
          buttons: [
            {
              text: "Reset Connection",
              actionCallback: () => __awaiter36(this, void 0, void 0, function* () {
                yield closeToast();
                this.disconnect();
              })
            }
          ]
        });
        console.timeLog(messageId, "send error");
        throw sendError;
      }
      console.timeLog(messageId, "sent");
      this.events.emit(messageEvents[requestInput.type].sent, {
        walletInfo: Object.assign(Object.assign({}, walletInfo), { name: (_a3 = walletInfo.name) !== null && _a3 !== void 0 ? _a3 : "Wallet" }),
        extraInfo: {
          resetCallback: () => __awaiter36(this, void 0, void 0, function* () {
            this.disconnect();
          })
        }
      }).catch((emitError) => console.warn(emitError));
      return exposed.promise;
    });
  }
  /**
   * This method handles sending of requests to the DApp. It makes sure that the DAppClient is initialized and connected
   * to the transport. After that rate limits and permissions will be checked, an ID is attached and the request is sent
   * to the DApp over the transport.
   *
   * @param requestInput The BeaconMessage to be sent to the wallet
   * @param account The account that the message will be sent to
   */
  makeRequestV3(requestInput) {
    var _a3;
    return __awaiter36(this, void 0, void 0, function* () {
      const messageId = yield generateGUID();
      console.time(messageId);
      logger15.log("makeRequest", "starting");
      yield this.init();
      console.timeLog(messageId, "init done");
      logger15.log("makeRequest", "after init");
      if (yield this.addRequestAndCheckIfRateLimited()) {
        this.events.emit(BeaconEvent.LOCAL_RATE_LIMIT_REACHED).catch((emitError) => console.warn(emitError));
        throw new Error("rate limit reached");
      }
      if (!this.beaconId) {
        throw yield this.sendInternalError("BeaconID not defined");
      }
      const request = {
        id: messageId,
        version: "3",
        senderId: yield getSenderId(yield this.beaconId),
        message: requestInput
      };
      const exposed = new ExposedPromise();
      this.addOpenRequest(request.id, exposed);
      const payload = yield new Serializer().serialize(request);
      const account = yield this.getActiveAccount();
      const peer = yield this.getPeer(account);
      const walletInfo = yield this.getWalletInfo(peer, account);
      logger15.log("makeRequest", "sending message", request);
      console.timeLog(messageId, "sending");
      try {
        yield (yield this.transport).send(payload, peer);
      } catch (sendError) {
        this.events.emit(BeaconEvent.INTERNAL_ERROR, {
          text: "Unable to send message. If this problem persists, please reset the connection and pair your wallet again.",
          buttons: [
            {
              text: "Reset Connection",
              actionCallback: () => __awaiter36(this, void 0, void 0, function* () {
                yield closeToast();
                this.disconnect();
              })
            }
          ]
        });
        console.timeLog(messageId, "send error");
        throw sendError;
      }
      console.timeLog(messageId, "sent");
      const index = requestInput.type;
      this.events.emit(messageEvents[index].sent, {
        walletInfo: Object.assign(Object.assign({}, walletInfo), { name: (_a3 = walletInfo.name) !== null && _a3 !== void 0 ? _a3 : "Wallet" }),
        extraInfo: {
          resetCallback: () => __awaiter36(this, void 0, void 0, function* () {
            this.disconnect();
          })
        }
      }).catch((emitError) => console.warn(emitError));
      return exposed.promise;
    });
  }
  disconnect() {
    return __awaiter36(this, void 0, void 0, function* () {
      this.postMessageTransport = void 0;
      this.p2pTransport = void 0;
      this.walletConnectTransport = void 0;
      yield Promise.all([this.clearActiveAccount(), (yield this.transport).disconnect()]);
    });
  }
  /**
   * Adds a requests to the "openRequests" set so we know what messages have already been answered/handled.
   *
   * @param id The ID of the message
   * @param promise A promise that resolves once the response for that specific message is received
   */
  addOpenRequest(id, promise) {
    logger15.log("addOpenRequest", this.name, `adding request ${id} and waiting for answer`);
    this.openRequests.set(id, promise);
  }
  sendNotificationWithAccessToken(notification) {
    return __awaiter36(this, void 0, void 0, function* () {
      const { url, recipient, title, body, payload, protocolIdentifier, accessToken } = notification;
      const timestamp2 = (/* @__PURE__ */ new Date()).toISOString();
      const keypair = yield this.keyPair;
      const rawPublicKey = keypair.publicKey;
      const prefix2 = Buffer.from(new Uint8Array([13, 15, 37, 217]));
      const publicKey = bs58check5.encode(Buffer.concat([prefix2, Buffer.from(rawPublicKey)]));
      const constructedString = [
        "Tezos Signed Message: ",
        recipient,
        title,
        body,
        timestamp2,
        payload
      ].join(" ");
      const bytes = toHex(constructedString);
      const payloadBytes = "0501" + bytes.length.toString(16).padStart(8, "0") + bytes;
      const signature = yield signMessage(payloadBytes, {
        secretKey: Buffer.from(keypair.secretKey)
      });
      const notificationResponse = yield import_axios3.default.post(`${url}/send`, {
        recipient,
        title,
        body,
        timestamp: timestamp2,
        payload,
        accessToken,
        protocolIdentifier,
        sender: {
          name: this.name,
          publicKey,
          signature
        }
      });
      return notificationResponse.data;
    });
  }
};

// node_modules/@taquito/beacon-wallet/node_modules/@airgap/beacon-dapp/dist/esm/utils/get-instance.js
var _instance;
var getDAppClientInstance = (config2, reset) => {
  if (_instance && reset) {
    _instance.disconnect();
    _instance = void 0;
  }
  if (_instance) {
    return _instance;
  }
  if (!_instance) {
    _instance = new DAppClient(config2);
  }
  return _instance;
};

// node_modules/@taquito/core/dist/taquito-core.es6.js
var TaquitoError = class extends Error {
};
var ParameterValidationError = class extends TaquitoError {
};
var UnsupportedActionError = class extends TaquitoError {
};
var PermissionDeniedError = class extends TaquitoError {
};
var InvalidAddressError = class extends ParameterValidationError {
  constructor(address, errorDetail) {
    super();
    this.address = address;
    this.errorDetail = errorDetail;
    this.name = "InvalidAddressError";
    this.message = `Invalid address "${address}"`;
    this.message += errorDetail ? ` ${errorDetail}.` : ".";
  }
};
var InvalidBlockHashError = class extends ParameterValidationError {
  constructor(blockHash, errorDetail) {
    super();
    this.blockHash = blockHash;
    this.errorDetail = errorDetail;
    this.name = "InvalidBlockHashError";
    this.message = `Invalid block hash "${blockHash}"`;
    this.message += errorDetail ? ` ${errorDetail}.` : ".";
  }
};
var InvalidHexStringError = class extends ParameterValidationError {
  constructor(hexString, errorDetail) {
    super();
    this.hexString = hexString;
    this.errorDetail = errorDetail;
    this.name = "InvalidHexStringError";
    this.message = `Invalid hex string "${hexString}"`;
    this.message += errorDetail ? ` ${errorDetail}.` : ".";
  }
};
var InvalidMessageError = class extends ParameterValidationError {
  constructor(msg, errorDetail) {
    super();
    this.msg = msg;
    this.errorDetail = errorDetail;
    this.name = "InvalidMessageError";
    this.message = `Invalid message "${msg}"`;
    this.message += errorDetail ? ` ${errorDetail}.` : ".";
  }
};
var InvalidPublicKeyError = class extends ParameterValidationError {
  constructor(publicKey, errorDetail) {
    super();
    this.publicKey = publicKey;
    this.errorDetail = errorDetail;
    this.name = "InvalidPublicKeyError";
    this.message = `Invalid public key "${publicKey}"`;
    this.message += errorDetail ? ` ${errorDetail}.` : ".";
  }
};
var InvalidContractAddressError = class extends ParameterValidationError {
  constructor(contractAddress, errorDetail) {
    super();
    this.contractAddress = contractAddress;
    this.errorDetail = errorDetail;
    this.name = "InvalidContractAddressError";
    this.message = `Invalid contract address "${contractAddress}"`;
    this.message += errorDetail ? ` ${errorDetail}.` : ".";
  }
};
var InvalidKeyHashError = class extends ParameterValidationError {
  constructor(keyHash, errorDetail) {
    super();
    this.keyHash = keyHash;
    this.errorDetail = errorDetail;
    this.name = "InvalidKeyHashError";
    this.message = `Invalid public key hash "${keyHash}"`;
    this.message += errorDetail ? ` ${errorDetail}.` : ".";
  }
};
var InvalidOperationKindError = class extends ParameterValidationError {
  constructor(operationKind, errorDetail) {
    super();
    this.operationKind = operationKind;
    this.errorDetail = errorDetail;
    this.name = "InvalidOperationKindError";
    this.message = `Invalid operation kind "${operationKind}"`;
    this.message += errorDetail ? ` ${errorDetail}.` : ".";
  }
};

// node_modules/@taquito/beacon-wallet/dist/taquito-beacon-wallet.es6.js
var import_typedarray_to_buffer2 = __toESM(require_typedarray_to_buffer());

// node_modules/@taquito/http-utils/dist/taquito-http-utils.es6.js
var import_axios4 = __toESM(require_axios3());
var settle = require_settle();
var buildURL = require_buildURL();
var buildFullPath = require_buildFullPath();
var { isUndefined, isStandardBrowserEnv, isFormData } = require_utils();
var STATUS_CODE;
(function(STATUS_CODE2) {
  STATUS_CODE2[STATUS_CODE2["CONTINUE"] = 100] = "CONTINUE";
  STATUS_CODE2[STATUS_CODE2["SWITCHING_PROTOCOLS"] = 101] = "SWITCHING_PROTOCOLS";
  STATUS_CODE2[STATUS_CODE2["PROCESSING"] = 102] = "PROCESSING";
  STATUS_CODE2[STATUS_CODE2["OK"] = 200] = "OK";
  STATUS_CODE2[STATUS_CODE2["CREATED"] = 201] = "CREATED";
  STATUS_CODE2[STATUS_CODE2["ACCEPTED"] = 202] = "ACCEPTED";
  STATUS_CODE2[STATUS_CODE2["NON_AUTHORITATIVE_INFORMATION"] = 203] = "NON_AUTHORITATIVE_INFORMATION";
  STATUS_CODE2[STATUS_CODE2["NO_CONTENT"] = 204] = "NO_CONTENT";
  STATUS_CODE2[STATUS_CODE2["RESET_CONTENT"] = 205] = "RESET_CONTENT";
  STATUS_CODE2[STATUS_CODE2["PARTIAL_CONTENT"] = 206] = "PARTIAL_CONTENT";
  STATUS_CODE2[STATUS_CODE2["MULTI_STATUS"] = 207] = "MULTI_STATUS";
  STATUS_CODE2[STATUS_CODE2["ALREADY_REPORTED"] = 208] = "ALREADY_REPORTED";
  STATUS_CODE2[STATUS_CODE2["IM_USED"] = 226] = "IM_USED";
  STATUS_CODE2[STATUS_CODE2["MULTIPLE_CHOICES"] = 300] = "MULTIPLE_CHOICES";
  STATUS_CODE2[STATUS_CODE2["MOVED_PERMANENTLY"] = 301] = "MOVED_PERMANENTLY";
  STATUS_CODE2[STATUS_CODE2["FOUND"] = 302] = "FOUND";
  STATUS_CODE2[STATUS_CODE2["SEE_OTHER"] = 303] = "SEE_OTHER";
  STATUS_CODE2[STATUS_CODE2["NOT_MODIFIED"] = 304] = "NOT_MODIFIED";
  STATUS_CODE2[STATUS_CODE2["USE_PROXY"] = 305] = "USE_PROXY";
  STATUS_CODE2[STATUS_CODE2["SWITCH_PROXY"] = 306] = "SWITCH_PROXY";
  STATUS_CODE2[STATUS_CODE2["TEMPORARY_REDIRECT"] = 307] = "TEMPORARY_REDIRECT";
  STATUS_CODE2[STATUS_CODE2["PERMANENT_REDIRECT"] = 308] = "PERMANENT_REDIRECT";
  STATUS_CODE2[STATUS_CODE2["BAD_REQUEST"] = 400] = "BAD_REQUEST";
  STATUS_CODE2[STATUS_CODE2["UNAUTHORIZED"] = 401] = "UNAUTHORIZED";
  STATUS_CODE2[STATUS_CODE2["PAYMENT_REQUIRED"] = 402] = "PAYMENT_REQUIRED";
  STATUS_CODE2[STATUS_CODE2["FORBIDDEN"] = 403] = "FORBIDDEN";
  STATUS_CODE2[STATUS_CODE2["NOT_FOUND"] = 404] = "NOT_FOUND";
  STATUS_CODE2[STATUS_CODE2["METHOD_NOT_ALLOWED"] = 405] = "METHOD_NOT_ALLOWED";
  STATUS_CODE2[STATUS_CODE2["NOT_ACCEPTABLE"] = 406] = "NOT_ACCEPTABLE";
  STATUS_CODE2[STATUS_CODE2["PROXY_AUTHENTICATION_REQUIRED"] = 407] = "PROXY_AUTHENTICATION_REQUIRED";
  STATUS_CODE2[STATUS_CODE2["REQUEST_TIMEOUT"] = 408] = "REQUEST_TIMEOUT";
  STATUS_CODE2[STATUS_CODE2["CONFLICT"] = 409] = "CONFLICT";
  STATUS_CODE2[STATUS_CODE2["GONE"] = 410] = "GONE";
  STATUS_CODE2[STATUS_CODE2["LENGTH_REQUIRED"] = 411] = "LENGTH_REQUIRED";
  STATUS_CODE2[STATUS_CODE2["PRECONDITION_FAILED"] = 412] = "PRECONDITION_FAILED";
  STATUS_CODE2[STATUS_CODE2["PAYLOAD_TOO_LARGE"] = 413] = "PAYLOAD_TOO_LARGE";
  STATUS_CODE2[STATUS_CODE2["URI_TOO_LONG"] = 414] = "URI_TOO_LONG";
  STATUS_CODE2[STATUS_CODE2["UNSUPPORTED_MEDIA_TYPE"] = 415] = "UNSUPPORTED_MEDIA_TYPE";
  STATUS_CODE2[STATUS_CODE2["RANGE_NOT_SATISFIABLE"] = 416] = "RANGE_NOT_SATISFIABLE";
  STATUS_CODE2[STATUS_CODE2["EXPECTATION_FAILED"] = 417] = "EXPECTATION_FAILED";
  STATUS_CODE2[STATUS_CODE2["I_AM_A_TEAPOT"] = 418] = "I_AM_A_TEAPOT";
  STATUS_CODE2[STATUS_CODE2["MISDIRECTED_REQUEST"] = 421] = "MISDIRECTED_REQUEST";
  STATUS_CODE2[STATUS_CODE2["UNPROCESSABLE_ENTITY"] = 422] = "UNPROCESSABLE_ENTITY";
  STATUS_CODE2[STATUS_CODE2["LOCKED"] = 423] = "LOCKED";
  STATUS_CODE2[STATUS_CODE2["FAILED_DEPENDENCY"] = 424] = "FAILED_DEPENDENCY";
  STATUS_CODE2[STATUS_CODE2["UPGRADE_REQUIRED"] = 426] = "UPGRADE_REQUIRED";
  STATUS_CODE2[STATUS_CODE2["PRECONDITION_REQUIRED"] = 428] = "PRECONDITION_REQUIRED";
  STATUS_CODE2[STATUS_CODE2["TOO_MANY_REQUESTS"] = 429] = "TOO_MANY_REQUESTS";
  STATUS_CODE2[STATUS_CODE2["REQUEST_HEADER_FIELDS_TOO_LARGE"] = 431] = "REQUEST_HEADER_FIELDS_TOO_LARGE";
  STATUS_CODE2[STATUS_CODE2["UNAVAILABLE_FOR_LEGAL_REASONS"] = 451] = "UNAVAILABLE_FOR_LEGAL_REASONS";
  STATUS_CODE2[STATUS_CODE2["INTERNAL_SERVER_ERROR"] = 500] = "INTERNAL_SERVER_ERROR";
  STATUS_CODE2[STATUS_CODE2["NOT_IMPLEMENTED"] = 501] = "NOT_IMPLEMENTED";
  STATUS_CODE2[STATUS_CODE2["BAD_GATEWAY"] = 502] = "BAD_GATEWAY";
  STATUS_CODE2[STATUS_CODE2["SERVICE_UNAVAILABLE"] = 503] = "SERVICE_UNAVAILABLE";
  STATUS_CODE2[STATUS_CODE2["GATEWAY_TIMEOUT"] = 504] = "GATEWAY_TIMEOUT";
  STATUS_CODE2[STATUS_CODE2["HTTP_VERSION_NOT_SUPPORTED"] = 505] = "HTTP_VERSION_NOT_SUPPORTED";
  STATUS_CODE2[STATUS_CODE2["VARIANT_ALSO_NEGOTIATES"] = 506] = "VARIANT_ALSO_NEGOTIATES";
  STATUS_CODE2[STATUS_CODE2["INSUFFICIENT_STORAGE"] = 507] = "INSUFFICIENT_STORAGE";
  STATUS_CODE2[STATUS_CODE2["LOOP_DETECTED"] = 508] = "LOOP_DETECTED";
  STATUS_CODE2[STATUS_CODE2["NOT_EXTENDED"] = 510] = "NOT_EXTENDED";
  STATUS_CODE2[STATUS_CODE2["NETWORK_AUTHENTICATION_REQUIRED"] = 511] = "NETWORK_AUTHENTICATION_REQUIRED";
})(STATUS_CODE || (STATUS_CODE = {}));
var _a;
var isNode = typeof process !== "undefined" && !!((_a = process === null || process === void 0 ? void 0 : process.versions) === null || _a === void 0 ? void 0 : _a.node);
var ResponseType;
(function(ResponseType2) {
  ResponseType2["TEXT"] = "text";
  ResponseType2["JSON"] = "json";
})(ResponseType || (ResponseType = {}));

// node_modules/bignumber.js/bignumber.mjs
var isNumeric = /^-?(?:\d+(?:\.\d*)?|\.\d+)(?:e[+-]?\d+)?$/i;
var mathceil = Math.ceil;
var mathfloor = Math.floor;
var bignumberError = "[BigNumber Error] ";
var tooManyDigits = bignumberError + "Number primitive has more than 15 significant digits: ";
var BASE = 1e14;
var LOG_BASE = 14;
var MAX_SAFE_INTEGER = 9007199254740991;
var POWS_TEN = [1, 10, 100, 1e3, 1e4, 1e5, 1e6, 1e7, 1e8, 1e9, 1e10, 1e11, 1e12, 1e13];
var SQRT_BASE = 1e7;
var MAX = 1e9;
function clone(configObject) {
  var div, convertBase, parseNumeric, P2 = BigNumber2.prototype = { constructor: BigNumber2, toString: null, valueOf: null }, ONE = new BigNumber2(1), DECIMAL_PLACES = 20, ROUNDING_MODE = 4, TO_EXP_NEG = -7, TO_EXP_POS = 21, MIN_EXP = -1e7, MAX_EXP = 1e7, CRYPTO = false, MODULO_MODE = 1, POW_PRECISION = 0, FORMAT = {
    prefix: "",
    groupSize: 3,
    secondaryGroupSize: 0,
    groupSeparator: ",",
    decimalSeparator: ".",
    fractionGroupSize: 0,
    fractionGroupSeparator: "",
    // non-breaking space
    suffix: ""
  }, ALPHABET = "0123456789abcdefghijklmnopqrstuvwxyz", alphabetHasNormalDecimalDigits = true;
  function BigNumber2(v, b3) {
    var alphabet, c2, caseChanged, e, i2, isNum, len, str, x3 = this;
    if (!(x3 instanceof BigNumber2))
      return new BigNumber2(v, b3);
    if (b3 == null) {
      if (v && v._isBigNumber === true) {
        x3.s = v.s;
        if (!v.c || v.e > MAX_EXP) {
          x3.c = x3.e = null;
        } else if (v.e < MIN_EXP) {
          x3.c = [x3.e = 0];
        } else {
          x3.e = v.e;
          x3.c = v.c.slice();
        }
        return;
      }
      if ((isNum = typeof v == "number") && v * 0 == 0) {
        x3.s = 1 / v < 0 ? (v = -v, -1) : 1;
        if (v === ~~v) {
          for (e = 0, i2 = v; i2 >= 10; i2 /= 10, e++)
            ;
          if (e > MAX_EXP) {
            x3.c = x3.e = null;
          } else {
            x3.e = e;
            x3.c = [v];
          }
          return;
        }
        str = String(v);
      } else {
        if (!isNumeric.test(str = String(v)))
          return parseNumeric(x3, str, isNum);
        x3.s = str.charCodeAt(0) == 45 ? (str = str.slice(1), -1) : 1;
      }
      if ((e = str.indexOf(".")) > -1)
        str = str.replace(".", "");
      if ((i2 = str.search(/e/i)) > 0) {
        if (e < 0)
          e = i2;
        e += +str.slice(i2 + 1);
        str = str.substring(0, i2);
      } else if (e < 0) {
        e = str.length;
      }
    } else {
      intCheck(b3, 2, ALPHABET.length, "Base");
      if (b3 == 10 && alphabetHasNormalDecimalDigits) {
        x3 = new BigNumber2(v);
        return round(x3, DECIMAL_PLACES + x3.e + 1, ROUNDING_MODE);
      }
      str = String(v);
      if (isNum = typeof v == "number") {
        if (v * 0 != 0)
          return parseNumeric(x3, str, isNum, b3);
        x3.s = 1 / v < 0 ? (str = str.slice(1), -1) : 1;
        if (BigNumber2.DEBUG && str.replace(/^0\.0*|\./, "").length > 15) {
          throw Error(tooManyDigits + v);
        }
      } else {
        x3.s = str.charCodeAt(0) === 45 ? (str = str.slice(1), -1) : 1;
      }
      alphabet = ALPHABET.slice(0, b3);
      e = i2 = 0;
      for (len = str.length; i2 < len; i2++) {
        if (alphabet.indexOf(c2 = str.charAt(i2)) < 0) {
          if (c2 == ".") {
            if (i2 > e) {
              e = len;
              continue;
            }
          } else if (!caseChanged) {
            if (str == str.toUpperCase() && (str = str.toLowerCase()) || str == str.toLowerCase() && (str = str.toUpperCase())) {
              caseChanged = true;
              i2 = -1;
              e = 0;
              continue;
            }
          }
          return parseNumeric(x3, String(v), isNum, b3);
        }
      }
      isNum = false;
      str = convertBase(str, b3, 10, x3.s);
      if ((e = str.indexOf(".")) > -1)
        str = str.replace(".", "");
      else
        e = str.length;
    }
    for (i2 = 0; str.charCodeAt(i2) === 48; i2++)
      ;
    for (len = str.length; str.charCodeAt(--len) === 48; )
      ;
    if (str = str.slice(i2, ++len)) {
      len -= i2;
      if (isNum && BigNumber2.DEBUG && len > 15 && (v > MAX_SAFE_INTEGER || v !== mathfloor(v))) {
        throw Error(tooManyDigits + x3.s * v);
      }
      if ((e = e - i2 - 1) > MAX_EXP) {
        x3.c = x3.e = null;
      } else if (e < MIN_EXP) {
        x3.c = [x3.e = 0];
      } else {
        x3.e = e;
        x3.c = [];
        i2 = (e + 1) % LOG_BASE;
        if (e < 0)
          i2 += LOG_BASE;
        if (i2 < len) {
          if (i2)
            x3.c.push(+str.slice(0, i2));
          for (len -= LOG_BASE; i2 < len; ) {
            x3.c.push(+str.slice(i2, i2 += LOG_BASE));
          }
          i2 = LOG_BASE - (str = str.slice(i2)).length;
        } else {
          i2 -= len;
        }
        for (; i2--; str += "0")
          ;
        x3.c.push(+str);
      }
    } else {
      x3.c = [x3.e = 0];
    }
  }
  BigNumber2.clone = clone;
  BigNumber2.ROUND_UP = 0;
  BigNumber2.ROUND_DOWN = 1;
  BigNumber2.ROUND_CEIL = 2;
  BigNumber2.ROUND_FLOOR = 3;
  BigNumber2.ROUND_HALF_UP = 4;
  BigNumber2.ROUND_HALF_DOWN = 5;
  BigNumber2.ROUND_HALF_EVEN = 6;
  BigNumber2.ROUND_HALF_CEIL = 7;
  BigNumber2.ROUND_HALF_FLOOR = 8;
  BigNumber2.EUCLID = 9;
  BigNumber2.config = BigNumber2.set = function(obj) {
    var p3, v;
    if (obj != null) {
      if (typeof obj == "object") {
        if (obj.hasOwnProperty(p3 = "DECIMAL_PLACES")) {
          v = obj[p3];
          intCheck(v, 0, MAX, p3);
          DECIMAL_PLACES = v;
        }
        if (obj.hasOwnProperty(p3 = "ROUNDING_MODE")) {
          v = obj[p3];
          intCheck(v, 0, 8, p3);
          ROUNDING_MODE = v;
        }
        if (obj.hasOwnProperty(p3 = "EXPONENTIAL_AT")) {
          v = obj[p3];
          if (v && v.pop) {
            intCheck(v[0], -MAX, 0, p3);
            intCheck(v[1], 0, MAX, p3);
            TO_EXP_NEG = v[0];
            TO_EXP_POS = v[1];
          } else {
            intCheck(v, -MAX, MAX, p3);
            TO_EXP_NEG = -(TO_EXP_POS = v < 0 ? -v : v);
          }
        }
        if (obj.hasOwnProperty(p3 = "RANGE")) {
          v = obj[p3];
          if (v && v.pop) {
            intCheck(v[0], -MAX, -1, p3);
            intCheck(v[1], 1, MAX, p3);
            MIN_EXP = v[0];
            MAX_EXP = v[1];
          } else {
            intCheck(v, -MAX, MAX, p3);
            if (v) {
              MIN_EXP = -(MAX_EXP = v < 0 ? -v : v);
            } else {
              throw Error(bignumberError + p3 + " cannot be zero: " + v);
            }
          }
        }
        if (obj.hasOwnProperty(p3 = "CRYPTO")) {
          v = obj[p3];
          if (v === !!v) {
            if (v) {
              if (typeof crypto != "undefined" && crypto && (crypto.getRandomValues || crypto.randomBytes)) {
                CRYPTO = v;
              } else {
                CRYPTO = !v;
                throw Error(bignumberError + "crypto unavailable");
              }
            } else {
              CRYPTO = v;
            }
          } else {
            throw Error(bignumberError + p3 + " not true or false: " + v);
          }
        }
        if (obj.hasOwnProperty(p3 = "MODULO_MODE")) {
          v = obj[p3];
          intCheck(v, 0, 9, p3);
          MODULO_MODE = v;
        }
        if (obj.hasOwnProperty(p3 = "POW_PRECISION")) {
          v = obj[p3];
          intCheck(v, 0, MAX, p3);
          POW_PRECISION = v;
        }
        if (obj.hasOwnProperty(p3 = "FORMAT")) {
          v = obj[p3];
          if (typeof v == "object")
            FORMAT = v;
          else
            throw Error(bignumberError + p3 + " not an object: " + v);
        }
        if (obj.hasOwnProperty(p3 = "ALPHABET")) {
          v = obj[p3];
          if (typeof v == "string" && !/^.?$|[+\-.\s]|(.).*\1/.test(v)) {
            alphabetHasNormalDecimalDigits = v.slice(0, 10) == "0123456789";
            ALPHABET = v;
          } else {
            throw Error(bignumberError + p3 + " invalid: " + v);
          }
        }
      } else {
        throw Error(bignumberError + "Object expected: " + obj);
      }
    }
    return {
      DECIMAL_PLACES,
      ROUNDING_MODE,
      EXPONENTIAL_AT: [TO_EXP_NEG, TO_EXP_POS],
      RANGE: [MIN_EXP, MAX_EXP],
      CRYPTO,
      MODULO_MODE,
      POW_PRECISION,
      FORMAT,
      ALPHABET
    };
  };
  BigNumber2.isBigNumber = function(v) {
    if (!v || v._isBigNumber !== true)
      return false;
    if (!BigNumber2.DEBUG)
      return true;
    var i2, n2, c2 = v.c, e = v.e, s = v.s;
    out:
      if ({}.toString.call(c2) == "[object Array]") {
        if ((s === 1 || s === -1) && e >= -MAX && e <= MAX && e === mathfloor(e)) {
          if (c2[0] === 0) {
            if (e === 0 && c2.length === 1)
              return true;
            break out;
          }
          i2 = (e + 1) % LOG_BASE;
          if (i2 < 1)
            i2 += LOG_BASE;
          if (String(c2[0]).length == i2) {
            for (i2 = 0; i2 < c2.length; i2++) {
              n2 = c2[i2];
              if (n2 < 0 || n2 >= BASE || n2 !== mathfloor(n2))
                break out;
            }
            if (n2 !== 0)
              return true;
          }
        }
      } else if (c2 === null && e === null && (s === null || s === 1 || s === -1)) {
        return true;
      }
    throw Error(bignumberError + "Invalid BigNumber: " + v);
  };
  BigNumber2.maximum = BigNumber2.max = function() {
    return maxOrMin(arguments, -1);
  };
  BigNumber2.minimum = BigNumber2.min = function() {
    return maxOrMin(arguments, 1);
  };
  BigNumber2.random = function() {
    var pow2_53 = 9007199254740992;
    var random53bitInt = Math.random() * pow2_53 & 2097151 ? function() {
      return mathfloor(Math.random() * pow2_53);
    } : function() {
      return (Math.random() * 1073741824 | 0) * 8388608 + (Math.random() * 8388608 | 0);
    };
    return function(dp) {
      var a2, b3, e, k2, v, i2 = 0, c2 = [], rand = new BigNumber2(ONE);
      if (dp == null)
        dp = DECIMAL_PLACES;
      else
        intCheck(dp, 0, MAX);
      k2 = mathceil(dp / LOG_BASE);
      if (CRYPTO) {
        if (crypto.getRandomValues) {
          a2 = crypto.getRandomValues(new Uint32Array(k2 *= 2));
          for (; i2 < k2; ) {
            v = a2[i2] * 131072 + (a2[i2 + 1] >>> 11);
            if (v >= 9e15) {
              b3 = crypto.getRandomValues(new Uint32Array(2));
              a2[i2] = b3[0];
              a2[i2 + 1] = b3[1];
            } else {
              c2.push(v % 1e14);
              i2 += 2;
            }
          }
          i2 = k2 / 2;
        } else if (crypto.randomBytes) {
          a2 = crypto.randomBytes(k2 *= 7);
          for (; i2 < k2; ) {
            v = (a2[i2] & 31) * 281474976710656 + a2[i2 + 1] * 1099511627776 + a2[i2 + 2] * 4294967296 + a2[i2 + 3] * 16777216 + (a2[i2 + 4] << 16) + (a2[i2 + 5] << 8) + a2[i2 + 6];
            if (v >= 9e15) {
              crypto.randomBytes(7).copy(a2, i2);
            } else {
              c2.push(v % 1e14);
              i2 += 7;
            }
          }
          i2 = k2 / 7;
        } else {
          CRYPTO = false;
          throw Error(bignumberError + "crypto unavailable");
        }
      }
      if (!CRYPTO) {
        for (; i2 < k2; ) {
          v = random53bitInt();
          if (v < 9e15)
            c2[i2++] = v % 1e14;
        }
      }
      k2 = c2[--i2];
      dp %= LOG_BASE;
      if (k2 && dp) {
        v = POWS_TEN[LOG_BASE - dp];
        c2[i2] = mathfloor(k2 / v) * v;
      }
      for (; c2[i2] === 0; c2.pop(), i2--)
        ;
      if (i2 < 0) {
        c2 = [e = 0];
      } else {
        for (e = -1; c2[0] === 0; c2.splice(0, 1), e -= LOG_BASE)
          ;
        for (i2 = 1, v = c2[0]; v >= 10; v /= 10, i2++)
          ;
        if (i2 < LOG_BASE)
          e -= LOG_BASE - i2;
      }
      rand.e = e;
      rand.c = c2;
      return rand;
    };
  }();
  BigNumber2.sum = function() {
    var i2 = 1, args = arguments, sum = new BigNumber2(args[0]);
    for (; i2 < args.length; )
      sum = sum.plus(args[i2++]);
    return sum;
  };
  convertBase = function() {
    var decimal = "0123456789";
    function toBaseOut(str, baseIn, baseOut, alphabet) {
      var j2, arr = [0], arrL, i2 = 0, len = str.length;
      for (; i2 < len; ) {
        for (arrL = arr.length; arrL--; arr[arrL] *= baseIn)
          ;
        arr[0] += alphabet.indexOf(str.charAt(i2++));
        for (j2 = 0; j2 < arr.length; j2++) {
          if (arr[j2] > baseOut - 1) {
            if (arr[j2 + 1] == null)
              arr[j2 + 1] = 0;
            arr[j2 + 1] += arr[j2] / baseOut | 0;
            arr[j2] %= baseOut;
          }
        }
      }
      return arr.reverse();
    }
    return function(str, baseIn, baseOut, sign3, callerIsToString) {
      var alphabet, d2, e, k2, r, x3, xc, y3, i2 = str.indexOf("."), dp = DECIMAL_PLACES, rm = ROUNDING_MODE;
      if (i2 >= 0) {
        k2 = POW_PRECISION;
        POW_PRECISION = 0;
        str = str.replace(".", "");
        y3 = new BigNumber2(baseIn);
        x3 = y3.pow(str.length - i2);
        POW_PRECISION = k2;
        y3.c = toBaseOut(
          toFixedPoint(coeffToString(x3.c), x3.e, "0"),
          10,
          baseOut,
          decimal
        );
        y3.e = y3.c.length;
      }
      xc = toBaseOut(str, baseIn, baseOut, callerIsToString ? (alphabet = ALPHABET, decimal) : (alphabet = decimal, ALPHABET));
      e = k2 = xc.length;
      for (; xc[--k2] == 0; xc.pop())
        ;
      if (!xc[0])
        return alphabet.charAt(0);
      if (i2 < 0) {
        --e;
      } else {
        x3.c = xc;
        x3.e = e;
        x3.s = sign3;
        x3 = div(x3, y3, dp, rm, baseOut);
        xc = x3.c;
        r = x3.r;
        e = x3.e;
      }
      d2 = e + dp + 1;
      i2 = xc[d2];
      k2 = baseOut / 2;
      r = r || d2 < 0 || xc[d2 + 1] != null;
      r = rm < 4 ? (i2 != null || r) && (rm == 0 || rm == (x3.s < 0 ? 3 : 2)) : i2 > k2 || i2 == k2 && (rm == 4 || r || rm == 6 && xc[d2 - 1] & 1 || rm == (x3.s < 0 ? 8 : 7));
      if (d2 < 1 || !xc[0]) {
        str = r ? toFixedPoint(alphabet.charAt(1), -dp, alphabet.charAt(0)) : alphabet.charAt(0);
      } else {
        xc.length = d2;
        if (r) {
          for (--baseOut; ++xc[--d2] > baseOut; ) {
            xc[d2] = 0;
            if (!d2) {
              ++e;
              xc = [1].concat(xc);
            }
          }
        }
        for (k2 = xc.length; !xc[--k2]; )
          ;
        for (i2 = 0, str = ""; i2 <= k2; str += alphabet.charAt(xc[i2++]))
          ;
        str = toFixedPoint(str, e, alphabet.charAt(0));
      }
      return str;
    };
  }();
  div = function() {
    function multiply(x3, k2, base) {
      var m2, temp, xlo, xhi, carry = 0, i2 = x3.length, klo = k2 % SQRT_BASE, khi = k2 / SQRT_BASE | 0;
      for (x3 = x3.slice(); i2--; ) {
        xlo = x3[i2] % SQRT_BASE;
        xhi = x3[i2] / SQRT_BASE | 0;
        m2 = khi * xlo + xhi * klo;
        temp = klo * xlo + m2 % SQRT_BASE * SQRT_BASE + carry;
        carry = (temp / base | 0) + (m2 / SQRT_BASE | 0) + khi * xhi;
        x3[i2] = temp % base;
      }
      if (carry)
        x3 = [carry].concat(x3);
      return x3;
    }
    function compare2(a2, b3, aL, bL) {
      var i2, cmp;
      if (aL != bL) {
        cmp = aL > bL ? 1 : -1;
      } else {
        for (i2 = cmp = 0; i2 < aL; i2++) {
          if (a2[i2] != b3[i2]) {
            cmp = a2[i2] > b3[i2] ? 1 : -1;
            break;
          }
        }
      }
      return cmp;
    }
    function subtract(a2, b3, aL, base) {
      var i2 = 0;
      for (; aL--; ) {
        a2[aL] -= i2;
        i2 = a2[aL] < b3[aL] ? 1 : 0;
        a2[aL] = i2 * base + a2[aL] - b3[aL];
      }
      for (; !a2[0] && a2.length > 1; a2.splice(0, 1))
        ;
    }
    return function(x3, y3, dp, rm, base) {
      var cmp, e, i2, more, n2, prod, prodL, q3, qc, rem, remL, rem0, xi2, xL, yc0, yL, yz, s = x3.s == y3.s ? 1 : -1, xc = x3.c, yc = y3.c;
      if (!xc || !xc[0] || !yc || !yc[0]) {
        return new BigNumber2(
          // Return NaN if either NaN, or both Infinity or 0.
          !x3.s || !y3.s || (xc ? yc && xc[0] == yc[0] : !yc) ? NaN : (
            // Return 0 if x is 0 or y is Infinity, or return Infinity as y is 0.
            xc && xc[0] == 0 || !yc ? s * 0 : s / 0
          )
        );
      }
      q3 = new BigNumber2(s);
      qc = q3.c = [];
      e = x3.e - y3.e;
      s = dp + e + 1;
      if (!base) {
        base = BASE;
        e = bitFloor(x3.e / LOG_BASE) - bitFloor(y3.e / LOG_BASE);
        s = s / LOG_BASE | 0;
      }
      for (i2 = 0; yc[i2] == (xc[i2] || 0); i2++)
        ;
      if (yc[i2] > (xc[i2] || 0))
        e--;
      if (s < 0) {
        qc.push(1);
        more = true;
      } else {
        xL = xc.length;
        yL = yc.length;
        i2 = 0;
        s += 2;
        n2 = mathfloor(base / (yc[0] + 1));
        if (n2 > 1) {
          yc = multiply(yc, n2, base);
          xc = multiply(xc, n2, base);
          yL = yc.length;
          xL = xc.length;
        }
        xi2 = yL;
        rem = xc.slice(0, yL);
        remL = rem.length;
        for (; remL < yL; rem[remL++] = 0)
          ;
        yz = yc.slice();
        yz = [0].concat(yz);
        yc0 = yc[0];
        if (yc[1] >= base / 2)
          yc0++;
        do {
          n2 = 0;
          cmp = compare2(yc, rem, yL, remL);
          if (cmp < 0) {
            rem0 = rem[0];
            if (yL != remL)
              rem0 = rem0 * base + (rem[1] || 0);
            n2 = mathfloor(rem0 / yc0);
            if (n2 > 1) {
              if (n2 >= base)
                n2 = base - 1;
              prod = multiply(yc, n2, base);
              prodL = prod.length;
              remL = rem.length;
              while (compare2(prod, rem, prodL, remL) == 1) {
                n2--;
                subtract(prod, yL < prodL ? yz : yc, prodL, base);
                prodL = prod.length;
                cmp = 1;
              }
            } else {
              if (n2 == 0) {
                cmp = n2 = 1;
              }
              prod = yc.slice();
              prodL = prod.length;
            }
            if (prodL < remL)
              prod = [0].concat(prod);
            subtract(rem, prod, remL, base);
            remL = rem.length;
            if (cmp == -1) {
              while (compare2(yc, rem, yL, remL) < 1) {
                n2++;
                subtract(rem, yL < remL ? yz : yc, remL, base);
                remL = rem.length;
              }
            }
          } else if (cmp === 0) {
            n2++;
            rem = [0];
          }
          qc[i2++] = n2;
          if (rem[0]) {
            rem[remL++] = xc[xi2] || 0;
          } else {
            rem = [xc[xi2]];
            remL = 1;
          }
        } while ((xi2++ < xL || rem[0] != null) && s--);
        more = rem[0] != null;
        if (!qc[0])
          qc.splice(0, 1);
      }
      if (base == BASE) {
        for (i2 = 1, s = qc[0]; s >= 10; s /= 10, i2++)
          ;
        round(q3, dp + (q3.e = i2 + e * LOG_BASE - 1) + 1, rm, more);
      } else {
        q3.e = e;
        q3.r = +more;
      }
      return q3;
    };
  }();
  function format2(n2, i2, rm, id) {
    var c0, e, ne2, len, str;
    if (rm == null)
      rm = ROUNDING_MODE;
    else
      intCheck(rm, 0, 8);
    if (!n2.c)
      return n2.toString();
    c0 = n2.c[0];
    ne2 = n2.e;
    if (i2 == null) {
      str = coeffToString(n2.c);
      str = id == 1 || id == 2 && (ne2 <= TO_EXP_NEG || ne2 >= TO_EXP_POS) ? toExponential(str, ne2) : toFixedPoint(str, ne2, "0");
    } else {
      n2 = round(new BigNumber2(n2), i2, rm);
      e = n2.e;
      str = coeffToString(n2.c);
      len = str.length;
      if (id == 1 || id == 2 && (i2 <= e || e <= TO_EXP_NEG)) {
        for (; len < i2; str += "0", len++)
          ;
        str = toExponential(str, e);
      } else {
        i2 -= ne2;
        str = toFixedPoint(str, e, "0");
        if (e + 1 > len) {
          if (--i2 > 0)
            for (str += "."; i2--; str += "0")
              ;
        } else {
          i2 += e - len;
          if (i2 > 0) {
            if (e + 1 == len)
              str += ".";
            for (; i2--; str += "0")
              ;
          }
        }
      }
    }
    return n2.s < 0 && c0 ? "-" + str : str;
  }
  function maxOrMin(args, n2) {
    var k2, y3, i2 = 1, x3 = new BigNumber2(args[0]);
    for (; i2 < args.length; i2++) {
      y3 = new BigNumber2(args[i2]);
      if (!y3.s || (k2 = compare(x3, y3)) === n2 || k2 === 0 && x3.s === n2) {
        x3 = y3;
      }
    }
    return x3;
  }
  function normalise(n2, c2, e) {
    var i2 = 1, j2 = c2.length;
    for (; !c2[--j2]; c2.pop())
      ;
    for (j2 = c2[0]; j2 >= 10; j2 /= 10, i2++)
      ;
    if ((e = i2 + e * LOG_BASE - 1) > MAX_EXP) {
      n2.c = n2.e = null;
    } else if (e < MIN_EXP) {
      n2.c = [n2.e = 0];
    } else {
      n2.e = e;
      n2.c = c2;
    }
    return n2;
  }
  parseNumeric = function() {
    var basePrefix = /^(-?)0([xbo])(?=\w[\w.]*$)/i, dotAfter = /^([^.]+)\.$/, dotBefore = /^\.([^.]+)$/, isInfinityOrNaN = /^-?(Infinity|NaN)$/, whitespaceOrPlus = /^\s*\+(?=[\w.])|^\s+|\s+$/g;
    return function(x3, str, isNum, b3) {
      var base, s = isNum ? str : str.replace(whitespaceOrPlus, "");
      if (isInfinityOrNaN.test(s)) {
        x3.s = isNaN(s) ? null : s < 0 ? -1 : 1;
      } else {
        if (!isNum) {
          s = s.replace(basePrefix, function(m2, p1, p22) {
            base = (p22 = p22.toLowerCase()) == "x" ? 16 : p22 == "b" ? 2 : 8;
            return !b3 || b3 == base ? p1 : m2;
          });
          if (b3) {
            base = b3;
            s = s.replace(dotAfter, "$1").replace(dotBefore, "0.$1");
          }
          if (str != s)
            return new BigNumber2(s, base);
        }
        if (BigNumber2.DEBUG) {
          throw Error(bignumberError + "Not a" + (b3 ? " base " + b3 : "") + " number: " + str);
        }
        x3.s = null;
      }
      x3.c = x3.e = null;
    };
  }();
  function round(x3, sd, rm, r) {
    var d2, i2, j2, k2, n2, ni, rd, xc = x3.c, pows10 = POWS_TEN;
    if (xc) {
      out: {
        for (d2 = 1, k2 = xc[0]; k2 >= 10; k2 /= 10, d2++)
          ;
        i2 = sd - d2;
        if (i2 < 0) {
          i2 += LOG_BASE;
          j2 = sd;
          n2 = xc[ni = 0];
          rd = mathfloor(n2 / pows10[d2 - j2 - 1] % 10);
        } else {
          ni = mathceil((i2 + 1) / LOG_BASE);
          if (ni >= xc.length) {
            if (r) {
              for (; xc.length <= ni; xc.push(0))
                ;
              n2 = rd = 0;
              d2 = 1;
              i2 %= LOG_BASE;
              j2 = i2 - LOG_BASE + 1;
            } else {
              break out;
            }
          } else {
            n2 = k2 = xc[ni];
            for (d2 = 1; k2 >= 10; k2 /= 10, d2++)
              ;
            i2 %= LOG_BASE;
            j2 = i2 - LOG_BASE + d2;
            rd = j2 < 0 ? 0 : mathfloor(n2 / pows10[d2 - j2 - 1] % 10);
          }
        }
        r = r || sd < 0 || // Are there any non-zero digits after the rounding digit?
        // The expression  n % pows10[d - j - 1]  returns all digits of n to the right
        // of the digit at j, e.g. if n is 908714 and j is 2, the expression gives 714.
        xc[ni + 1] != null || (j2 < 0 ? n2 : n2 % pows10[d2 - j2 - 1]);
        r = rm < 4 ? (rd || r) && (rm == 0 || rm == (x3.s < 0 ? 3 : 2)) : rd > 5 || rd == 5 && (rm == 4 || r || rm == 6 && // Check whether the digit to the left of the rounding digit is odd.
        (i2 > 0 ? j2 > 0 ? n2 / pows10[d2 - j2] : 0 : xc[ni - 1]) % 10 & 1 || rm == (x3.s < 0 ? 8 : 7));
        if (sd < 1 || !xc[0]) {
          xc.length = 0;
          if (r) {
            sd -= x3.e + 1;
            xc[0] = pows10[(LOG_BASE - sd % LOG_BASE) % LOG_BASE];
            x3.e = -sd || 0;
          } else {
            xc[0] = x3.e = 0;
          }
          return x3;
        }
        if (i2 == 0) {
          xc.length = ni;
          k2 = 1;
          ni--;
        } else {
          xc.length = ni + 1;
          k2 = pows10[LOG_BASE - i2];
          xc[ni] = j2 > 0 ? mathfloor(n2 / pows10[d2 - j2] % pows10[j2]) * k2 : 0;
        }
        if (r) {
          for (; ; ) {
            if (ni == 0) {
              for (i2 = 1, j2 = xc[0]; j2 >= 10; j2 /= 10, i2++)
                ;
              j2 = xc[0] += k2;
              for (k2 = 1; j2 >= 10; j2 /= 10, k2++)
                ;
              if (i2 != k2) {
                x3.e++;
                if (xc[0] == BASE)
                  xc[0] = 1;
              }
              break;
            } else {
              xc[ni] += k2;
              if (xc[ni] != BASE)
                break;
              xc[ni--] = 0;
              k2 = 1;
            }
          }
        }
        for (i2 = xc.length; xc[--i2] === 0; xc.pop())
          ;
      }
      if (x3.e > MAX_EXP) {
        x3.c = x3.e = null;
      } else if (x3.e < MIN_EXP) {
        x3.c = [x3.e = 0];
      }
    }
    return x3;
  }
  function valueOf(n2) {
    var str, e = n2.e;
    if (e === null)
      return n2.toString();
    str = coeffToString(n2.c);
    str = e <= TO_EXP_NEG || e >= TO_EXP_POS ? toExponential(str, e) : toFixedPoint(str, e, "0");
    return n2.s < 0 ? "-" + str : str;
  }
  P2.absoluteValue = P2.abs = function() {
    var x3 = new BigNumber2(this);
    if (x3.s < 0)
      x3.s = 1;
    return x3;
  };
  P2.comparedTo = function(y3, b3) {
    return compare(this, new BigNumber2(y3, b3));
  };
  P2.decimalPlaces = P2.dp = function(dp, rm) {
    var c2, n2, v, x3 = this;
    if (dp != null) {
      intCheck(dp, 0, MAX);
      if (rm == null)
        rm = ROUNDING_MODE;
      else
        intCheck(rm, 0, 8);
      return round(new BigNumber2(x3), dp + x3.e + 1, rm);
    }
    if (!(c2 = x3.c))
      return null;
    n2 = ((v = c2.length - 1) - bitFloor(this.e / LOG_BASE)) * LOG_BASE;
    if (v = c2[v])
      for (; v % 10 == 0; v /= 10, n2--)
        ;
    if (n2 < 0)
      n2 = 0;
    return n2;
  };
  P2.dividedBy = P2.div = function(y3, b3) {
    return div(this, new BigNumber2(y3, b3), DECIMAL_PLACES, ROUNDING_MODE);
  };
  P2.dividedToIntegerBy = P2.idiv = function(y3, b3) {
    return div(this, new BigNumber2(y3, b3), 0, 1);
  };
  P2.exponentiatedBy = P2.pow = function(n2, m2) {
    var half, isModExp, i2, k2, more, nIsBig, nIsNeg, nIsOdd, y3, x3 = this;
    n2 = new BigNumber2(n2);
    if (n2.c && !n2.isInteger()) {
      throw Error(bignumberError + "Exponent not an integer: " + valueOf(n2));
    }
    if (m2 != null)
      m2 = new BigNumber2(m2);
    nIsBig = n2.e > 14;
    if (!x3.c || !x3.c[0] || x3.c[0] == 1 && !x3.e && x3.c.length == 1 || !n2.c || !n2.c[0]) {
      y3 = new BigNumber2(Math.pow(+valueOf(x3), nIsBig ? n2.s * (2 - isOdd(n2)) : +valueOf(n2)));
      return m2 ? y3.mod(m2) : y3;
    }
    nIsNeg = n2.s < 0;
    if (m2) {
      if (m2.c ? !m2.c[0] : !m2.s)
        return new BigNumber2(NaN);
      isModExp = !nIsNeg && x3.isInteger() && m2.isInteger();
      if (isModExp)
        x3 = x3.mod(m2);
    } else if (n2.e > 9 && (x3.e > 0 || x3.e < -1 || (x3.e == 0 ? x3.c[0] > 1 || nIsBig && x3.c[1] >= 24e7 : x3.c[0] < 8e13 || nIsBig && x3.c[0] <= 9999975e7))) {
      k2 = x3.s < 0 && isOdd(n2) ? -0 : 0;
      if (x3.e > -1)
        k2 = 1 / k2;
      return new BigNumber2(nIsNeg ? 1 / k2 : k2);
    } else if (POW_PRECISION) {
      k2 = mathceil(POW_PRECISION / LOG_BASE + 2);
    }
    if (nIsBig) {
      half = new BigNumber2(0.5);
      if (nIsNeg)
        n2.s = 1;
      nIsOdd = isOdd(n2);
    } else {
      i2 = Math.abs(+valueOf(n2));
      nIsOdd = i2 % 2;
    }
    y3 = new BigNumber2(ONE);
    for (; ; ) {
      if (nIsOdd) {
        y3 = y3.times(x3);
        if (!y3.c)
          break;
        if (k2) {
          if (y3.c.length > k2)
            y3.c.length = k2;
        } else if (isModExp) {
          y3 = y3.mod(m2);
        }
      }
      if (i2) {
        i2 = mathfloor(i2 / 2);
        if (i2 === 0)
          break;
        nIsOdd = i2 % 2;
      } else {
        n2 = n2.times(half);
        round(n2, n2.e + 1, 1);
        if (n2.e > 14) {
          nIsOdd = isOdd(n2);
        } else {
          i2 = +valueOf(n2);
          if (i2 === 0)
            break;
          nIsOdd = i2 % 2;
        }
      }
      x3 = x3.times(x3);
      if (k2) {
        if (x3.c && x3.c.length > k2)
          x3.c.length = k2;
      } else if (isModExp) {
        x3 = x3.mod(m2);
      }
    }
    if (isModExp)
      return y3;
    if (nIsNeg)
      y3 = ONE.div(y3);
    return m2 ? y3.mod(m2) : k2 ? round(y3, POW_PRECISION, ROUNDING_MODE, more) : y3;
  };
  P2.integerValue = function(rm) {
    var n2 = new BigNumber2(this);
    if (rm == null)
      rm = ROUNDING_MODE;
    else
      intCheck(rm, 0, 8);
    return round(n2, n2.e + 1, rm);
  };
  P2.isEqualTo = P2.eq = function(y3, b3) {
    return compare(this, new BigNumber2(y3, b3)) === 0;
  };
  P2.isFinite = function() {
    return !!this.c;
  };
  P2.isGreaterThan = P2.gt = function(y3, b3) {
    return compare(this, new BigNumber2(y3, b3)) > 0;
  };
  P2.isGreaterThanOrEqualTo = P2.gte = function(y3, b3) {
    return (b3 = compare(this, new BigNumber2(y3, b3))) === 1 || b3 === 0;
  };
  P2.isInteger = function() {
    return !!this.c && bitFloor(this.e / LOG_BASE) > this.c.length - 2;
  };
  P2.isLessThan = P2.lt = function(y3, b3) {
    return compare(this, new BigNumber2(y3, b3)) < 0;
  };
  P2.isLessThanOrEqualTo = P2.lte = function(y3, b3) {
    return (b3 = compare(this, new BigNumber2(y3, b3))) === -1 || b3 === 0;
  };
  P2.isNaN = function() {
    return !this.s;
  };
  P2.isNegative = function() {
    return this.s < 0;
  };
  P2.isPositive = function() {
    return this.s > 0;
  };
  P2.isZero = function() {
    return !!this.c && this.c[0] == 0;
  };
  P2.minus = function(y3, b3) {
    var i2, j2, t, xLTy, x3 = this, a2 = x3.s;
    y3 = new BigNumber2(y3, b3);
    b3 = y3.s;
    if (!a2 || !b3)
      return new BigNumber2(NaN);
    if (a2 != b3) {
      y3.s = -b3;
      return x3.plus(y3);
    }
    var xe = x3.e / LOG_BASE, ye3 = y3.e / LOG_BASE, xc = x3.c, yc = y3.c;
    if (!xe || !ye3) {
      if (!xc || !yc)
        return xc ? (y3.s = -b3, y3) : new BigNumber2(yc ? x3 : NaN);
      if (!xc[0] || !yc[0]) {
        return yc[0] ? (y3.s = -b3, y3) : new BigNumber2(xc[0] ? x3 : (
          // IEEE 754 (2008) 6.3: n - n = -0 when rounding to -Infinity
          ROUNDING_MODE == 3 ? -0 : 0
        ));
      }
    }
    xe = bitFloor(xe);
    ye3 = bitFloor(ye3);
    xc = xc.slice();
    if (a2 = xe - ye3) {
      if (xLTy = a2 < 0) {
        a2 = -a2;
        t = xc;
      } else {
        ye3 = xe;
        t = yc;
      }
      t.reverse();
      for (b3 = a2; b3--; t.push(0))
        ;
      t.reverse();
    } else {
      j2 = (xLTy = (a2 = xc.length) < (b3 = yc.length)) ? a2 : b3;
      for (a2 = b3 = 0; b3 < j2; b3++) {
        if (xc[b3] != yc[b3]) {
          xLTy = xc[b3] < yc[b3];
          break;
        }
      }
    }
    if (xLTy) {
      t = xc;
      xc = yc;
      yc = t;
      y3.s = -y3.s;
    }
    b3 = (j2 = yc.length) - (i2 = xc.length);
    if (b3 > 0)
      for (; b3--; xc[i2++] = 0)
        ;
    b3 = BASE - 1;
    for (; j2 > a2; ) {
      if (xc[--j2] < yc[j2]) {
        for (i2 = j2; i2 && !xc[--i2]; xc[i2] = b3)
          ;
        --xc[i2];
        xc[j2] += BASE;
      }
      xc[j2] -= yc[j2];
    }
    for (; xc[0] == 0; xc.splice(0, 1), --ye3)
      ;
    if (!xc[0]) {
      y3.s = ROUNDING_MODE == 3 ? -1 : 1;
      y3.c = [y3.e = 0];
      return y3;
    }
    return normalise(y3, xc, ye3);
  };
  P2.modulo = P2.mod = function(y3, b3) {
    var q3, s, x3 = this;
    y3 = new BigNumber2(y3, b3);
    if (!x3.c || !y3.s || y3.c && !y3.c[0]) {
      return new BigNumber2(NaN);
    } else if (!y3.c || x3.c && !x3.c[0]) {
      return new BigNumber2(x3);
    }
    if (MODULO_MODE == 9) {
      s = y3.s;
      y3.s = 1;
      q3 = div(x3, y3, 0, 3);
      y3.s = s;
      q3.s *= s;
    } else {
      q3 = div(x3, y3, 0, MODULO_MODE);
    }
    y3 = x3.minus(q3.times(y3));
    if (!y3.c[0] && MODULO_MODE == 1)
      y3.s = x3.s;
    return y3;
  };
  P2.multipliedBy = P2.times = function(y3, b3) {
    var c2, e, i2, j2, k2, m2, xcL, xlo, xhi, ycL, ylo, yhi, zc, base, sqrtBase, x3 = this, xc = x3.c, yc = (y3 = new BigNumber2(y3, b3)).c;
    if (!xc || !yc || !xc[0] || !yc[0]) {
      if (!x3.s || !y3.s || xc && !xc[0] && !yc || yc && !yc[0] && !xc) {
        y3.c = y3.e = y3.s = null;
      } else {
        y3.s *= x3.s;
        if (!xc || !yc) {
          y3.c = y3.e = null;
        } else {
          y3.c = [0];
          y3.e = 0;
        }
      }
      return y3;
    }
    e = bitFloor(x3.e / LOG_BASE) + bitFloor(y3.e / LOG_BASE);
    y3.s *= x3.s;
    xcL = xc.length;
    ycL = yc.length;
    if (xcL < ycL) {
      zc = xc;
      xc = yc;
      yc = zc;
      i2 = xcL;
      xcL = ycL;
      ycL = i2;
    }
    for (i2 = xcL + ycL, zc = []; i2--; zc.push(0))
      ;
    base = BASE;
    sqrtBase = SQRT_BASE;
    for (i2 = ycL; --i2 >= 0; ) {
      c2 = 0;
      ylo = yc[i2] % sqrtBase;
      yhi = yc[i2] / sqrtBase | 0;
      for (k2 = xcL, j2 = i2 + k2; j2 > i2; ) {
        xlo = xc[--k2] % sqrtBase;
        xhi = xc[k2] / sqrtBase | 0;
        m2 = yhi * xlo + xhi * ylo;
        xlo = ylo * xlo + m2 % sqrtBase * sqrtBase + zc[j2] + c2;
        c2 = (xlo / base | 0) + (m2 / sqrtBase | 0) + yhi * xhi;
        zc[j2--] = xlo % base;
      }
      zc[j2] = c2;
    }
    if (c2) {
      ++e;
    } else {
      zc.splice(0, 1);
    }
    return normalise(y3, zc, e);
  };
  P2.negated = function() {
    var x3 = new BigNumber2(this);
    x3.s = -x3.s || null;
    return x3;
  };
  P2.plus = function(y3, b3) {
    var t, x3 = this, a2 = x3.s;
    y3 = new BigNumber2(y3, b3);
    b3 = y3.s;
    if (!a2 || !b3)
      return new BigNumber2(NaN);
    if (a2 != b3) {
      y3.s = -b3;
      return x3.minus(y3);
    }
    var xe = x3.e / LOG_BASE, ye3 = y3.e / LOG_BASE, xc = x3.c, yc = y3.c;
    if (!xe || !ye3) {
      if (!xc || !yc)
        return new BigNumber2(a2 / 0);
      if (!xc[0] || !yc[0])
        return yc[0] ? y3 : new BigNumber2(xc[0] ? x3 : a2 * 0);
    }
    xe = bitFloor(xe);
    ye3 = bitFloor(ye3);
    xc = xc.slice();
    if (a2 = xe - ye3) {
      if (a2 > 0) {
        ye3 = xe;
        t = yc;
      } else {
        a2 = -a2;
        t = xc;
      }
      t.reverse();
      for (; a2--; t.push(0))
        ;
      t.reverse();
    }
    a2 = xc.length;
    b3 = yc.length;
    if (a2 - b3 < 0) {
      t = yc;
      yc = xc;
      xc = t;
      b3 = a2;
    }
    for (a2 = 0; b3; ) {
      a2 = (xc[--b3] = xc[b3] + yc[b3] + a2) / BASE | 0;
      xc[b3] = BASE === xc[b3] ? 0 : xc[b3] % BASE;
    }
    if (a2) {
      xc = [a2].concat(xc);
      ++ye3;
    }
    return normalise(y3, xc, ye3);
  };
  P2.precision = P2.sd = function(sd, rm) {
    var c2, n2, v, x3 = this;
    if (sd != null && sd !== !!sd) {
      intCheck(sd, 1, MAX);
      if (rm == null)
        rm = ROUNDING_MODE;
      else
        intCheck(rm, 0, 8);
      return round(new BigNumber2(x3), sd, rm);
    }
    if (!(c2 = x3.c))
      return null;
    v = c2.length - 1;
    n2 = v * LOG_BASE + 1;
    if (v = c2[v]) {
      for (; v % 10 == 0; v /= 10, n2--)
        ;
      for (v = c2[0]; v >= 10; v /= 10, n2++)
        ;
    }
    if (sd && x3.e + 1 > n2)
      n2 = x3.e + 1;
    return n2;
  };
  P2.shiftedBy = function(k2) {
    intCheck(k2, -MAX_SAFE_INTEGER, MAX_SAFE_INTEGER);
    return this.times("1e" + k2);
  };
  P2.squareRoot = P2.sqrt = function() {
    var m2, n2, r, rep, t, x3 = this, c2 = x3.c, s = x3.s, e = x3.e, dp = DECIMAL_PLACES + 4, half = new BigNumber2("0.5");
    if (s !== 1 || !c2 || !c2[0]) {
      return new BigNumber2(!s || s < 0 && (!c2 || c2[0]) ? NaN : c2 ? x3 : 1 / 0);
    }
    s = Math.sqrt(+valueOf(x3));
    if (s == 0 || s == 1 / 0) {
      n2 = coeffToString(c2);
      if ((n2.length + e) % 2 == 0)
        n2 += "0";
      s = Math.sqrt(+n2);
      e = bitFloor((e + 1) / 2) - (e < 0 || e % 2);
      if (s == 1 / 0) {
        n2 = "5e" + e;
      } else {
        n2 = s.toExponential();
        n2 = n2.slice(0, n2.indexOf("e") + 1) + e;
      }
      r = new BigNumber2(n2);
    } else {
      r = new BigNumber2(s + "");
    }
    if (r.c[0]) {
      e = r.e;
      s = e + dp;
      if (s < 3)
        s = 0;
      for (; ; ) {
        t = r;
        r = half.times(t.plus(div(x3, t, dp, 1)));
        if (coeffToString(t.c).slice(0, s) === (n2 = coeffToString(r.c)).slice(0, s)) {
          if (r.e < e)
            --s;
          n2 = n2.slice(s - 3, s + 1);
          if (n2 == "9999" || !rep && n2 == "4999") {
            if (!rep) {
              round(t, t.e + DECIMAL_PLACES + 2, 0);
              if (t.times(t).eq(x3)) {
                r = t;
                break;
              }
            }
            dp += 4;
            s += 4;
            rep = 1;
          } else {
            if (!+n2 || !+n2.slice(1) && n2.charAt(0) == "5") {
              round(r, r.e + DECIMAL_PLACES + 2, 1);
              m2 = !r.times(r).eq(x3);
            }
            break;
          }
        }
      }
    }
    return round(r, r.e + DECIMAL_PLACES + 1, ROUNDING_MODE, m2);
  };
  P2.toExponential = function(dp, rm) {
    if (dp != null) {
      intCheck(dp, 0, MAX);
      dp++;
    }
    return format2(this, dp, rm, 1);
  };
  P2.toFixed = function(dp, rm) {
    if (dp != null) {
      intCheck(dp, 0, MAX);
      dp = dp + this.e + 1;
    }
    return format2(this, dp, rm);
  };
  P2.toFormat = function(dp, rm, format3) {
    var str, x3 = this;
    if (format3 == null) {
      if (dp != null && rm && typeof rm == "object") {
        format3 = rm;
        rm = null;
      } else if (dp && typeof dp == "object") {
        format3 = dp;
        dp = rm = null;
      } else {
        format3 = FORMAT;
      }
    } else if (typeof format3 != "object") {
      throw Error(bignumberError + "Argument not an object: " + format3);
    }
    str = x3.toFixed(dp, rm);
    if (x3.c) {
      var i2, arr = str.split("."), g1 = +format3.groupSize, g22 = +format3.secondaryGroupSize, groupSeparator = format3.groupSeparator || "", intPart = arr[0], fractionPart = arr[1], isNeg = x3.s < 0, intDigits = isNeg ? intPart.slice(1) : intPart, len = intDigits.length;
      if (g22) {
        i2 = g1;
        g1 = g22;
        g22 = i2;
        len -= i2;
      }
      if (g1 > 0 && len > 0) {
        i2 = len % g1 || g1;
        intPart = intDigits.substr(0, i2);
        for (; i2 < len; i2 += g1)
          intPart += groupSeparator + intDigits.substr(i2, g1);
        if (g22 > 0)
          intPart += groupSeparator + intDigits.slice(i2);
        if (isNeg)
          intPart = "-" + intPart;
      }
      str = fractionPart ? intPart + (format3.decimalSeparator || "") + ((g22 = +format3.fractionGroupSize) ? fractionPart.replace(
        new RegExp("\\d{" + g22 + "}\\B", "g"),
        "$&" + (format3.fractionGroupSeparator || "")
      ) : fractionPart) : intPart;
    }
    return (format3.prefix || "") + str + (format3.suffix || "");
  };
  P2.toFraction = function(md) {
    var d2, d0, d1, d22, e, exp, n2, n0, n1, q3, r, s, x3 = this, xc = x3.c;
    if (md != null) {
      n2 = new BigNumber2(md);
      if (!n2.isInteger() && (n2.c || n2.s !== 1) || n2.lt(ONE)) {
        throw Error(bignumberError + "Argument " + (n2.isInteger() ? "out of range: " : "not an integer: ") + valueOf(n2));
      }
    }
    if (!xc)
      return new BigNumber2(x3);
    d2 = new BigNumber2(ONE);
    n1 = d0 = new BigNumber2(ONE);
    d1 = n0 = new BigNumber2(ONE);
    s = coeffToString(xc);
    e = d2.e = s.length - x3.e - 1;
    d2.c[0] = POWS_TEN[(exp = e % LOG_BASE) < 0 ? LOG_BASE + exp : exp];
    md = !md || n2.comparedTo(d2) > 0 ? e > 0 ? d2 : n1 : n2;
    exp = MAX_EXP;
    MAX_EXP = 1 / 0;
    n2 = new BigNumber2(s);
    n0.c[0] = 0;
    for (; ; ) {
      q3 = div(n2, d2, 0, 1);
      d22 = d0.plus(q3.times(d1));
      if (d22.comparedTo(md) == 1)
        break;
      d0 = d1;
      d1 = d22;
      n1 = n0.plus(q3.times(d22 = n1));
      n0 = d22;
      d2 = n2.minus(q3.times(d22 = d2));
      n2 = d22;
    }
    d22 = div(md.minus(d0), d1, 0, 1);
    n0 = n0.plus(d22.times(n1));
    d0 = d0.plus(d22.times(d1));
    n0.s = n1.s = x3.s;
    e = e * 2;
    r = div(n1, d1, e, ROUNDING_MODE).minus(x3).abs().comparedTo(
      div(n0, d0, e, ROUNDING_MODE).minus(x3).abs()
    ) < 1 ? [n1, d1] : [n0, d0];
    MAX_EXP = exp;
    return r;
  };
  P2.toNumber = function() {
    return +valueOf(this);
  };
  P2.toPrecision = function(sd, rm) {
    if (sd != null)
      intCheck(sd, 1, MAX);
    return format2(this, sd, rm, 2);
  };
  P2.toString = function(b3) {
    var str, n2 = this, s = n2.s, e = n2.e;
    if (e === null) {
      if (s) {
        str = "Infinity";
        if (s < 0)
          str = "-" + str;
      } else {
        str = "NaN";
      }
    } else {
      if (b3 == null) {
        str = e <= TO_EXP_NEG || e >= TO_EXP_POS ? toExponential(coeffToString(n2.c), e) : toFixedPoint(coeffToString(n2.c), e, "0");
      } else if (b3 === 10 && alphabetHasNormalDecimalDigits) {
        n2 = round(new BigNumber2(n2), DECIMAL_PLACES + e + 1, ROUNDING_MODE);
        str = toFixedPoint(coeffToString(n2.c), n2.e, "0");
      } else {
        intCheck(b3, 2, ALPHABET.length, "Base");
        str = convertBase(toFixedPoint(coeffToString(n2.c), e, "0"), 10, b3, s, true);
      }
      if (s < 0 && n2.c[0])
        str = "-" + str;
    }
    return str;
  };
  P2.valueOf = P2.toJSON = function() {
    return valueOf(this);
  };
  P2._isBigNumber = true;
  P2[Symbol.toStringTag] = "BigNumber";
  P2[Symbol.for("nodejs.util.inspect.custom")] = P2.valueOf;
  if (configObject != null)
    BigNumber2.set(configObject);
  return BigNumber2;
}
function bitFloor(n2) {
  var i2 = n2 | 0;
  return n2 > 0 || n2 === i2 ? i2 : i2 - 1;
}
function coeffToString(a2) {
  var s, z, i2 = 1, j2 = a2.length, r = a2[0] + "";
  for (; i2 < j2; ) {
    s = a2[i2++] + "";
    z = LOG_BASE - s.length;
    for (; z--; s = "0" + s)
      ;
    r += s;
  }
  for (j2 = r.length; r.charCodeAt(--j2) === 48; )
    ;
  return r.slice(0, j2 + 1 || 1);
}
function compare(x3, y3) {
  var a2, b3, xc = x3.c, yc = y3.c, i2 = x3.s, j2 = y3.s, k2 = x3.e, l = y3.e;
  if (!i2 || !j2)
    return null;
  a2 = xc && !xc[0];
  b3 = yc && !yc[0];
  if (a2 || b3)
    return a2 ? b3 ? 0 : -j2 : i2;
  if (i2 != j2)
    return i2;
  a2 = i2 < 0;
  b3 = k2 == l;
  if (!xc || !yc)
    return b3 ? 0 : !xc ^ a2 ? 1 : -1;
  if (!b3)
    return k2 > l ^ a2 ? 1 : -1;
  j2 = (k2 = xc.length) < (l = yc.length) ? k2 : l;
  for (i2 = 0; i2 < j2; i2++)
    if (xc[i2] != yc[i2])
      return xc[i2] > yc[i2] ^ a2 ? 1 : -1;
  return k2 == l ? 0 : k2 > l ^ a2 ? 1 : -1;
}
function intCheck(n2, min2, max2, name) {
  if (n2 < min2 || n2 > max2 || n2 !== mathfloor(n2)) {
    throw Error(bignumberError + (name || "Argument") + (typeof n2 == "number" ? n2 < min2 || n2 > max2 ? " out of range: " : " not an integer: " : " not a primitive number: ") + String(n2));
  }
}
function isOdd(n2) {
  var k2 = n2.c.length - 1;
  return bitFloor(n2.e / LOG_BASE) == k2 && n2.c[k2] % 2 != 0;
}
function toExponential(str, e) {
  return (str.length > 1 ? str.charAt(0) + "." + str.slice(1) : str) + (e < 0 ? "e" : "e+") + e;
}
function toFixedPoint(str, e, z) {
  var len, zs2;
  if (e < 0) {
    for (zs2 = z + "."; ++e; zs2 += z)
      ;
    str = zs2 + str;
  } else {
    len = str.length;
    if (++e > len) {
      for (zs2 = z, e -= len; --e; zs2 += z)
        ;
      str += zs2;
    } else if (e < len) {
      str = str.slice(0, e) + "." + str.slice(e);
    }
  }
  return str;
}
var BigNumber = clone();
var bignumber_default = BigNumber;

// node_modules/@taquito/utils/dist/taquito-utils.es6.js
var import_buffer = __toESM(require_buffer());
var import_ed255196 = __toESM(require_ed25519());
var import_blake2b6 = __toESM(require_blake2b());
var import_blakejs = __toESM(require_blakejs());
var import_bs58check = __toESM(require_bs58check());
var import_elliptic = __toESM(require_elliptic());
var import_typedarray_to_buffer = __toESM(require_typedarray_to_buffer());
var Prefix;
(function(Prefix2) {
  Prefix2["TZ1"] = "tz1";
  Prefix2["TZ2"] = "tz2";
  Prefix2["TZ3"] = "tz3";
  Prefix2["TZ4"] = "tz4";
  Prefix2["KT"] = "KT";
  Prefix2["KT1"] = "KT1";
  Prefix2["EDSK2"] = "edsk2";
  Prefix2["SPSK"] = "spsk";
  Prefix2["P2SK"] = "p2sk";
  Prefix2["EDPK"] = "edpk";
  Prefix2["SPPK"] = "sppk";
  Prefix2["P2PK"] = "p2pk";
  Prefix2["BLPK"] = "BLpk";
  Prefix2["EDESK"] = "edesk";
  Prefix2["SPESK"] = "spesk";
  Prefix2["P2ESK"] = "p2esk";
  Prefix2["EDSK"] = "edsk";
  Prefix2["EDSIG"] = "edsig";
  Prefix2["SPSIG"] = "spsig";
  Prefix2["P2SIG"] = "p2sig";
  Prefix2["SIG"] = "sig";
  Prefix2["NET"] = "Net";
  Prefix2["NCE"] = "nce";
  Prefix2["B"] = "B";
  Prefix2["O"] = "o";
  Prefix2["LO"] = "Lo";
  Prefix2["LLO"] = "LLo";
  Prefix2["P"] = "P";
  Prefix2["CO"] = "Co";
  Prefix2["ID"] = "id";
  Prefix2["EXPR"] = "expr";
  Prefix2["TZ"] = "TZ";
  Prefix2["VH"] = "vh";
  Prefix2["SASK"] = "sask";
  Prefix2["ZET1"] = "zet1";
  Prefix2["TXR1"] = "txr1";
  Prefix2["TXI"] = "txi";
  Prefix2["TXM"] = "txm";
  Prefix2["TXC"] = "txc";
  Prefix2["TXMR"] = "txmr";
  Prefix2["TXRL"] = "txM";
  Prefix2["TXW"] = "txw";
  Prefix2["SR1"] = "sr1";
  Prefix2["SRC1"] = "src1";
})(Prefix || (Prefix = {}));
var prefix = {
  [Prefix.TZ1]: new Uint8Array([6, 161, 159]),
  [Prefix.TZ2]: new Uint8Array([6, 161, 161]),
  [Prefix.TZ3]: new Uint8Array([6, 161, 164]),
  [Prefix.TZ4]: new Uint8Array([6, 161, 166]),
  [Prefix.KT]: new Uint8Array([2, 90, 121]),
  [Prefix.KT1]: new Uint8Array([2, 90, 121]),
  [Prefix.EDSK]: new Uint8Array([43, 246, 78, 7]),
  [Prefix.EDSK2]: new Uint8Array([13, 15, 58, 7]),
  [Prefix.SPSK]: new Uint8Array([17, 162, 224, 201]),
  [Prefix.P2SK]: new Uint8Array([16, 81, 238, 189]),
  [Prefix.EDPK]: new Uint8Array([13, 15, 37, 217]),
  [Prefix.SPPK]: new Uint8Array([3, 254, 226, 86]),
  [Prefix.P2PK]: new Uint8Array([3, 178, 139, 127]),
  [Prefix.BLPK]: new Uint8Array([6, 149, 135, 204]),
  [Prefix.EDESK]: new Uint8Array([7, 90, 60, 179, 41]),
  [Prefix.SPESK]: new Uint8Array([9, 237, 241, 174, 150]),
  [Prefix.P2ESK]: new Uint8Array([9, 48, 57, 115, 171]),
  [Prefix.EDSIG]: new Uint8Array([9, 245, 205, 134, 18]),
  [Prefix.SPSIG]: new Uint8Array([13, 115, 101, 19, 63]),
  [Prefix.P2SIG]: new Uint8Array([54, 240, 44, 52]),
  [Prefix.SIG]: new Uint8Array([4, 130, 43]),
  [Prefix.NET]: new Uint8Array([87, 82, 0]),
  [Prefix.NCE]: new Uint8Array([69, 220, 169]),
  [Prefix.B]: new Uint8Array([1, 52]),
  [Prefix.O]: new Uint8Array([5, 116]),
  [Prefix.LO]: new Uint8Array([133, 233]),
  [Prefix.LLO]: new Uint8Array([29, 159, 109]),
  [Prefix.P]: new Uint8Array([2, 170]),
  [Prefix.CO]: new Uint8Array([79, 179]),
  [Prefix.ID]: new Uint8Array([153, 103]),
  [Prefix.EXPR]: new Uint8Array([13, 44, 64, 27]),
  // Legacy prefix
  [Prefix.TZ]: new Uint8Array([2, 90, 121]),
  [Prefix.VH]: new Uint8Array([1, 106, 242]),
  [Prefix.SASK]: new Uint8Array([11, 237, 20, 92]),
  [Prefix.ZET1]: new Uint8Array([18, 71, 40, 223]),
  [Prefix.TXR1]: new Uint8Array([1, 128, 120, 31]),
  [Prefix.TXI]: new Uint8Array([79, 148, 196]),
  [Prefix.TXM]: new Uint8Array([79, 149, 30]),
  [Prefix.TXC]: new Uint8Array([79, 148, 17]),
  [Prefix.TXMR]: new Uint8Array([18, 7, 206, 87]),
  [Prefix.TXRL]: new Uint8Array([79, 146, 82]),
  [Prefix.TXW]: new Uint8Array([79, 150, 72]),
  [Prefix.SR1]: new Uint8Array([6, 124, 117]),
  [Prefix.SRC1]: new Uint8Array([17, 165, 134, 138])
};
var prefixLength = {
  [Prefix.TZ1]: 20,
  [Prefix.TZ2]: 20,
  [Prefix.TZ3]: 20,
  [Prefix.TZ4]: 20,
  [Prefix.KT]: 20,
  [Prefix.KT1]: 20,
  [Prefix.EDPK]: 32,
  [Prefix.SPPK]: 33,
  [Prefix.P2PK]: 33,
  //working with value in comment for base58.ml line 445 but not consistent with the three above
  [Prefix.BLPK]: 48,
  [Prefix.EDSIG]: 64,
  [Prefix.SPSIG]: 64,
  [Prefix.P2SIG]: 64,
  [Prefix.SIG]: 64,
  [Prefix.NET]: 4,
  [Prefix.B]: 32,
  [Prefix.P]: 32,
  [Prefix.O]: 32,
  [Prefix.VH]: 32,
  [Prefix.SASK]: 169,
  [Prefix.ZET1]: 43,
  [Prefix.TXR1]: 20,
  [Prefix.TXI]: 32,
  [Prefix.TXM]: 32,
  [Prefix.TXC]: 32,
  [Prefix.TXMR]: 32,
  [Prefix.TXRL]: 32,
  [Prefix.TXW]: 32,
  [Prefix.SR1]: 20,
  [Prefix.SRC1]: 32
};
var ValueConversionError = class extends UnsupportedActionError {
  constructor(value, desiredType) {
    super();
    this.value = value;
    this.desiredType = desiredType;
    this.name = "ValueConversionError";
    this.message = `Unable to convert ${value} to a ${desiredType}`;
  }
};
var ValidationResult;
(function(ValidationResult2) {
  ValidationResult2[ValidationResult2["NO_PREFIX_MATCHED"] = 0] = "NO_PREFIX_MATCHED";
  ValidationResult2[ValidationResult2["INVALID_CHECKSUM"] = 1] = "INVALID_CHECKSUM";
  ValidationResult2[ValidationResult2["INVALID_LENGTH"] = 2] = "INVALID_LENGTH";
  ValidationResult2[ValidationResult2["VALID"] = 3] = "VALID";
})(ValidationResult || (ValidationResult = {}));
function isValidPrefix(value) {
  if (typeof value !== "string") {
    return false;
  }
  return value in prefix;
}
function validatePrefixedValue(value, prefixes) {
  const match = new RegExp(`^(${prefixes.join("|")})`).exec(value);
  if (!match || match.length === 0) {
    return ValidationResult.NO_PREFIX_MATCHED;
  }
  const prefixKey = match[0];
  if (!isValidPrefix(prefixKey)) {
    return ValidationResult.NO_PREFIX_MATCHED;
  }
  if (value.includes("%")) {
    value = value.split("%")[0];
  }
  const kt1Regex = /^(KT1\w{33})$/;
  if (!kt1Regex.test(value) && prefixKey === "KT1") {
    return ValidationResult.INVALID_CHECKSUM;
  }
  let decoded = import_bs58check.default.decodeUnsafe(value);
  if (!decoded) {
    return ValidationResult.INVALID_CHECKSUM;
  }
  decoded = decoded.slice(prefix[prefixKey].length);
  if (decoded.length !== prefixLength[prefixKey]) {
    return ValidationResult.INVALID_LENGTH;
  }
  return ValidationResult.VALID;
}
var implicitPrefix = [Prefix.TZ1, Prefix.TZ2, Prefix.TZ3, Prefix.TZ4];
var contractPrefix = [Prefix.KT1, Prefix.TXR1];
var signaturePrefix = [Prefix.EDSIG, Prefix.P2SIG, Prefix.SPSIG, Prefix.SIG];
var pkPrefix = [Prefix.EDPK, Prefix.SPPK, Prefix.P2PK, Prefix.BLPK];
var operationPrefix = [Prefix.O];
var protocolPrefix = [Prefix.P];
var blockPrefix = [Prefix.B];
var smartRollupPrefix = [Prefix.SR1];
function validateAddress(value) {
  return validatePrefixedValue(value, [...implicitPrefix, ...contractPrefix, ...smartRollupPrefix]);
}
function validateChain(value) {
  return validatePrefixedValue(value, [Prefix.NET]);
}
function validateKeyHash(value) {
  return validatePrefixedValue(value, implicitPrefix);
}
function validateSignature(value) {
  return validatePrefixedValue(value, signaturePrefix);
}
function validatePublicKey(value) {
  return validatePrefixedValue(value, pkPrefix);
}
function validateBlock(value) {
  return validatePrefixedValue(value, blockPrefix);
}
function invalidDetail(validation) {
  switch (validation) {
    case ValidationResult.NO_PREFIX_MATCHED:
      return "with unsupported prefix";
    case ValidationResult.INVALID_CHECKSUM:
      return "failed checksum";
    case ValidationResult.INVALID_LENGTH:
      return "with incorrect length";
    default:
      return "";
  }
}
var TZ_DECIMALS = 6;
var MTZ_DECIMALS = 3;
function getDecimal(format2) {
  switch (format2) {
    case "tz":
      return TZ_DECIMALS;
    case "mtz":
      return MTZ_DECIMALS;
    case "mutez":
    default:
      return 0;
  }
}
function format(from2 = "mutez", to = "mutez", amount) {
  const bigNum = new bignumber_default(amount);
  if (bigNum.isNaN()) {
    return amount;
  }
  return bigNum.multipliedBy(Math.pow(10, getDecimal(from2))).dividedBy(Math.pow(10, getDecimal(to)));
}
function b58cencode(value, prefix2) {
  const payloadAr = typeof value === "string" ? Uint8Array.from(import_buffer.Buffer.from(value, "hex")) : value;
  const n2 = new Uint8Array(prefix2.length + payloadAr.length);
  n2.set(prefix2);
  n2.set(payloadAr, prefix2.length);
  return import_bs58check.default.encode(import_buffer.Buffer.from(n2.buffer));
}
var b58cdecode = (enc, prefixArg) => import_bs58check.default.decode(enc).slice(prefixArg.length);
function b58decode(payload) {
  const buf = import_bs58check.default.decode(payload);
  const prefixMap = {
    [prefix.tz1.toString()]: "0000",
    [prefix.tz2.toString()]: "0001",
    [prefix.tz3.toString()]: "0002"
  };
  const rollupPrefMap = {
    [prefix.txr1.toString()]: "02"
  };
  const pref = prefixMap[new Uint8Array(buf.slice(0, 3)).toString()];
  const rollupPref = rollupPrefMap[new Uint8Array(buf.slice(0, 4)).toString()];
  if (pref) {
    const hex = buf2hex(buf.slice(3));
    return pref + hex;
  } else if (rollupPref) {
    const hex = buf2hex(buf.slice(4));
    return rollupPref + hex + "00";
  } else {
    return "01" + buf2hex(buf.slice(3, 42)) + "00";
  }
}
function b58decodeL2Address(payload) {
  const buf = import_bs58check.default.decode(payload);
  return buf2hex(buf.slice(3, 42));
}
function encodePubKey(value) {
  if (value.substring(0, 2) === "00") {
    const pref = {
      "0000": prefix.tz1,
      "0001": prefix.tz2,
      "0002": prefix.tz3
    };
    return b58cencode(value.substring(4), pref[value.substring(0, 4)]);
  } else if (value.substring(0, 2) === "02") {
    return b58cencode(value.substring(2, value.length - 2), prefix.txr1);
  }
  return b58cencode(value.substring(2, 42), prefix.KT);
}
function encodeL2Address(value) {
  return b58cencode(value, prefix.tz4);
}
function encodeKey(value) {
  if (value[0] === "0") {
    const pref = {
      "00": new Uint8Array([13, 15, 37, 217]),
      "01": new Uint8Array([3, 254, 226, 86]),
      "02": new Uint8Array([3, 178, 139, 127])
    };
    return b58cencode(value.substring(2), pref[value.substring(0, 2)]);
  }
}
function encodeKeyHash(value) {
  if (value[0] === "0") {
    const pref = {
      "00": new Uint8Array([6, 161, 159]),
      "01": new Uint8Array([6, 161, 161]),
      "02": new Uint8Array([6, 161, 164])
    };
    return b58cencode(value.substring(2), pref[value.substring(0, 2)]);
  }
}
var hex2buf = (hex) => {
  if (hex.length % 2 !== 0) {
    throw new InvalidHexStringError(hex, `: Expecting even number of characters`);
  }
  const hexDigits = stripHexPrefix(hex);
  if (!hexDigits.match(/^([\da-f]{2})*$/gi)) {
    throw new InvalidHexStringError(hex, `: Only characters 0-9, a-f and A-F are expected. Optionally, it can be prefixed with '0x'`);
  }
  const out = new Uint8Array(hexDigits.length / 2);
  let j2 = 0;
  for (let i2 = 0; i2 < hexDigits.length; i2 += 2) {
    const v = parseInt(hexDigits.slice(i2, i2 + 2), 16);
    if (Number.isNaN(v)) {
      throw new ValueConversionError(hex, "Uint8Array");
    }
    out[j2++] = v;
  }
  return out;
};
var mergebuf = (b1, b22) => {
  const r = new Uint8Array(b1.length + b22.length);
  r.set(b1);
  r.set(b22, b1.length);
  return r;
};
var buf2hex = (buffer2) => {
  const byteArray = new Uint8Array(buffer2);
  const hexParts = [];
  byteArray.forEach((byte) => {
    const hex = byte.toString(16);
    const paddedHex = `00${hex}`.slice(-2);
    hexParts.push(paddedHex);
  });
  return hexParts.join("");
};
function stripHexPrefix(hex) {
  return hex.startsWith("0x") ? hex.slice(2) : hex;
}

// node_modules/@taquito/rpc/dist/taquito-rpc.es6.js
var RPCMethodName;
(function(RPCMethodName2) {
  RPCMethodName2["GET_BAKING_RIGHTS"] = "getBakingRights";
  RPCMethodName2["GET_BALLOTS"] = "getBallots";
  RPCMethodName2["GET_BALLOT_LIST"] = "getBallotList";
  RPCMethodName2["GET_BIG_MAP_KEY"] = "getBigMapKey";
  RPCMethodName2["GET_BIG_MAP_EXPR"] = "getBigMapExpr";
  RPCMethodName2["GET_BLOCK_HASH"] = "getBlockHash";
  RPCMethodName2["GET_BLOCK"] = "getBlock";
  RPCMethodName2["GET_BLOCK_HEADER"] = "getBlockHeader";
  RPCMethodName2["GET_BLOCK_METADATA"] = "getBlockMetadata";
  RPCMethodName2["GET_BALANCE"] = "getBalance";
  RPCMethodName2["GET_CHAIN_ID"] = "getChainId";
  RPCMethodName2["GET_CONSTANTS"] = "getConstants";
  RPCMethodName2["GET_CONTRACT"] = "getContract";
  RPCMethodName2["GET_CURRENT_PERIOD"] = "getCurrentPeriod";
  RPCMethodName2["GET_CURRENT_PROPOSAL"] = "getCurrentProposal";
  RPCMethodName2["GET_CURRENT_QUORUM"] = "getCurrentQuorum";
  RPCMethodName2["GET_DELEGATE"] = "getDelegate";
  RPCMethodName2["GET_DELEGATES"] = "getDelegates";
  RPCMethodName2["GET_VOTING_INFO"] = "getVotingInfo";
  RPCMethodName2["GET_ENDORSING_RIGHTS"] = "getEndorsingRights";
  RPCMethodName2["GET_ENTRYPOINTS"] = "getEntrypoints";
  RPCMethodName2["GET_LIVE_BLOCKS"] = "getLiveBlocks";
  RPCMethodName2["GET_MANAGER_KEY"] = "getManagerKey";
  RPCMethodName2["GET_NORMALIZED_SCRIPT"] = "getNormalizedScript";
  RPCMethodName2["GET_PROPOSALS"] = "getProposals";
  RPCMethodName2["GET_PROTOCOLS"] = "getProtocols";
  RPCMethodName2["GET_SAPLING_DIFF_BY_CONTRACT"] = "getSaplingDiffByContract";
  RPCMethodName2["GET_SAPLING_DIFF_BY_ID"] = "getSaplingDiffById";
  RPCMethodName2["GET_SCRIPT"] = "getScript";
  RPCMethodName2["GET_STORAGE"] = "getStorage";
  RPCMethodName2["GET_SUCCESSOR_PERIOD"] = "getSuccessorPeriod";
  RPCMethodName2["GET_TX_ROLLUP_INBOX"] = "getTxRollupInbox";
  RPCMethodName2["GET_TX_ROLLUP_STATE"] = "getTxRollupState";
  RPCMethodName2["GET_VOTES_LISTINGS"] = "getVotesListings";
  RPCMethodName2["PACK_DATA"] = "packData";
  RPCMethodName2["GET_STORAGE_USED_SPACE"] = "getStorageUsedSpace";
  RPCMethodName2["GET_STORAGE_PAID_SPACE"] = "getStoragePaidSpace";
  RPCMethodName2["GET_TICKET_BALANCE"] = "getTicketBalance";
  RPCMethodName2["GET_ALL_TICKET_BALANCES"] = "getAllTicketBalances";
  RPCMethodName2["GET_PENDING_OPERATIONS"] = "getPendingOperations";
  RPCMethodName2["GET_ORIGINATION_PROOF"] = "getOriginationProof";
})(RPCMethodName || (RPCMethodName = {}));
var OPERATION_METADATA;
(function(OPERATION_METADATA2) {
  OPERATION_METADATA2["TOO_LARGE"] = "too large";
})(OPERATION_METADATA || (OPERATION_METADATA = {}));
var METADATA_BALANCE_UPDATES_CATEGORY;
(function(METADATA_BALANCE_UPDATES_CATEGORY2) {
  METADATA_BALANCE_UPDATES_CATEGORY2["BAKING_REWARDS"] = "baking rewards";
  METADATA_BALANCE_UPDATES_CATEGORY2["REWARDS"] = "rewards";
  METADATA_BALANCE_UPDATES_CATEGORY2["FEES"] = "fees";
  METADATA_BALANCE_UPDATES_CATEGORY2["DEPOSITS"] = "deposits";
  METADATA_BALANCE_UPDATES_CATEGORY2["LEGACY_REWARDS"] = "legacy_rewards";
  METADATA_BALANCE_UPDATES_CATEGORY2["LEGACY_FEES"] = "legacy_fees";
  METADATA_BALANCE_UPDATES_CATEGORY2["LEGACY_DEPOSITS"] = "legacy_deposits";
  METADATA_BALANCE_UPDATES_CATEGORY2["BLOCK_FEES"] = "block fees";
  METADATA_BALANCE_UPDATES_CATEGORY2["NONCE_REVELATION_REWARDS"] = "nonce revelation rewards";
  METADATA_BALANCE_UPDATES_CATEGORY2["DOUBLE_SIGNING_EVIDENCE_REWARDS"] = "double signing evidence rewards";
  METADATA_BALANCE_UPDATES_CATEGORY2["ENDORSING_REWARDS"] = "endorsing rewards";
  METADATA_BALANCE_UPDATES_CATEGORY2["BAKING_BONUSES"] = "baking bonuses";
  METADATA_BALANCE_UPDATES_CATEGORY2["STORAGE_FEES"] = "storage fees";
  METADATA_BALANCE_UPDATES_CATEGORY2["PUNISHMENTS"] = "punishments";
  METADATA_BALANCE_UPDATES_CATEGORY2["LOST_ENDORSING_REWARDS"] = "lost endorsing rewards";
  METADATA_BALANCE_UPDATES_CATEGORY2["SUBSIDY"] = "subsidy";
  METADATA_BALANCE_UPDATES_CATEGORY2["BURNED"] = "burned";
  METADATA_BALANCE_UPDATES_CATEGORY2["COMMITMENT"] = "commitment";
  METADATA_BALANCE_UPDATES_CATEGORY2["BOOTSTRAP"] = "bootstrap";
  METADATA_BALANCE_UPDATES_CATEGORY2["INVOICE"] = "invoice";
  METADATA_BALANCE_UPDATES_CATEGORY2["MINTED"] = "minted";
  METADATA_BALANCE_UPDATES_CATEGORY2["TX_ROLLUP_REJECTION_REWARDS"] = "tx_rollup_rejection_rewards";
  METADATA_BALANCE_UPDATES_CATEGORY2["TX_ROLLUP_REJECTION_PUNISHMENTS"] = "tx_rollup_rejection_punishments";
  METADATA_BALANCE_UPDATES_CATEGORY2["BONDS"] = "bonds";
})(METADATA_BALANCE_UPDATES_CATEGORY || (METADATA_BALANCE_UPDATES_CATEGORY = {}));
var PvmKind;
(function(PvmKind2) {
  PvmKind2["WASM2"] = "wasm_2_0_0";
  PvmKind2["ARITH"] = "arith";
})(PvmKind || (PvmKind = {}));
var SmartRollupRefutationOptions;
(function(SmartRollupRefutationOptions2) {
  SmartRollupRefutationOptions2["START"] = "start";
  SmartRollupRefutationOptions2["MOVE"] = "move";
})(SmartRollupRefutationOptions || (SmartRollupRefutationOptions = {}));
var SmartRollupInputProofKind;
(function(SmartRollupInputProofKind2) {
  SmartRollupInputProofKind2["INBOX_PROOF"] = "inbox_proof";
  SmartRollupInputProofKind2["REVEAL_PROOF"] = "reveal_proof";
  SmartRollupInputProofKind2["FIRST_INPUT"] = "first_input";
})(SmartRollupInputProofKind || (SmartRollupInputProofKind = {}));
var SmartRollupRefuteRevealProofKind;
(function(SmartRollupRefuteRevealProofKind2) {
  SmartRollupRefuteRevealProofKind2["RAW_DATA_PROOF"] = "raw_data_proof";
  SmartRollupRefuteRevealProofKind2["METADATA_PROOF"] = "metadata_proof";
  SmartRollupRefuteRevealProofKind2["DAL_PAGE_PROOF"] = "dal_page_proof";
})(SmartRollupRefuteRevealProofKind || (SmartRollupRefuteRevealProofKind = {}));
var SmartRollupRefuteGameStatusOptions;
(function(SmartRollupRefuteGameStatusOptions2) {
  SmartRollupRefuteGameStatusOptions2["ONGOING"] = "ongoing";
  SmartRollupRefuteGameStatusOptions2["ENDED"] = "ended";
})(SmartRollupRefuteGameStatusOptions || (SmartRollupRefuteGameStatusOptions = {}));
var SmartRollupRefuteGameEndedPlayerOutcomes;
(function(SmartRollupRefuteGameEndedPlayerOutcomes2) {
  SmartRollupRefuteGameEndedPlayerOutcomes2["LOSER"] = "loser";
  SmartRollupRefuteGameEndedPlayerOutcomes2["DRAW"] = "draw";
})(SmartRollupRefuteGameEndedPlayerOutcomes || (SmartRollupRefuteGameEndedPlayerOutcomes = {}));
var SmartRollupRefuteGameEndedReason;
(function(SmartRollupRefuteGameEndedReason2) {
  SmartRollupRefuteGameEndedReason2["CONFLICT_RESOLVED"] = "conflict_resolved";
  SmartRollupRefuteGameEndedReason2["TIMEOUT"] = "timeout";
})(SmartRollupRefuteGameEndedReason || (SmartRollupRefuteGameEndedReason = {}));
var OpKind;
(function(OpKind2) {
  OpKind2["ORIGINATION"] = "origination";
  OpKind2["DELEGATION"] = "delegation";
  OpKind2["REVEAL"] = "reveal";
  OpKind2["TRANSACTION"] = "transaction";
  OpKind2["ACTIVATION"] = "activate_account";
  OpKind2["ENDORSEMENT"] = "endorsement";
  OpKind2["PREENDORSEMENT"] = "preendorsement";
  OpKind2["SET_DEPOSITS_LIMIT"] = "set_deposits_limit";
  OpKind2["DOUBLE_PREENDORSEMENT_EVIDENCE"] = "double_preendorsement_evidence";
  OpKind2["ENDORSEMENT_WITH_SLOT"] = "endorsement_with_slot";
  OpKind2["SEED_NONCE_REVELATION"] = "seed_nonce_revelation";
  OpKind2["DOUBLE_ENDORSEMENT_EVIDENCE"] = "double_endorsement_evidence";
  OpKind2["DOUBLE_BAKING_EVIDENCE"] = "double_baking_evidence";
  OpKind2["PROPOSALS"] = "proposals";
  OpKind2["BALLOT"] = "ballot";
  OpKind2["FAILING_NOOP"] = "failing_noop";
  OpKind2["REGISTER_GLOBAL_CONSTANT"] = "register_global_constant";
  OpKind2["TX_ROLLUP_ORIGINATION"] = "tx_rollup_origination";
  OpKind2["TX_ROLLUP_SUBMIT_BATCH"] = "tx_rollup_submit_batch";
  OpKind2["TX_ROLLUP_COMMIT"] = "tx_rollup_commit";
  OpKind2["TX_ROLLUP_RETURN_BOND"] = "tx_rollup_return_bond";
  OpKind2["TX_ROLLUP_FINALIZE_COMMITMENT"] = "tx_rollup_finalize_commitment";
  OpKind2["TX_ROLLUP_REMOVE_COMMITMENT"] = "tx_rollup_remove_commitment";
  OpKind2["TX_ROLLUP_REJECTION"] = "tx_rollup_rejection";
  OpKind2["TX_ROLLUP_DISPATCH_TICKETS"] = "tx_rollup_dispatch_tickets";
  OpKind2["TRANSFER_TICKET"] = "transfer_ticket";
  OpKind2["INCREASE_PAID_STORAGE"] = "increase_paid_storage";
  OpKind2["UPDATE_CONSENSUS_KEY"] = "update_consensus_key";
  OpKind2["DRAIN_DELEGATE"] = "drain_delegate";
  OpKind2["VDF_REVELATION"] = "vdf_revelation";
  OpKind2["EVENT"] = "event";
  OpKind2["TICKET_UPDATES"] = "ticket_updates";
  OpKind2["SMART_ROLLUP_ORIGINATE"] = "smart_rollup_originate";
  OpKind2["SMART_ROLLUP_ADD_MESSAGES"] = "smart_rollup_add_messages";
  OpKind2["SMART_ROLLUP_EXECUTE_OUTBOX_MESSAGE"] = "smart_rollup_execute_outbox_message";
  OpKind2["SMART_ROLLUP_PUBLISH"] = "smart_rollup_publish";
  OpKind2["SMART_ROLLUP_CEMENT"] = "smart_rollup_cement";
  OpKind2["SMART_ROLLUP_RECOVER_BOND"] = "smart_rollup_recover_bond";
  OpKind2["SMART_ROLLUP_REFUTE"] = "smart_rollup_refute";
  OpKind2["SMART_ROLLUP_TIMEOUT"] = "smart_rollup_timeout";
})(OpKind || (OpKind = {}));

// node_modules/rxjs/node_modules/tslib/tslib.es6.mjs
var extendStatics = function(d2, b3) {
  extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d3, b4) {
    d3.__proto__ = b4;
  } || function(d3, b4) {
    for (var p3 in b4)
      if (Object.prototype.hasOwnProperty.call(b4, p3))
        d3[p3] = b4[p3];
  };
  return extendStatics(d2, b3);
};
function __extends(d2, b3) {
  if (typeof b3 !== "function" && b3 !== null)
    throw new TypeError("Class extends value " + String(b3) + " is not a constructor or null");
  extendStatics(d2, b3);
  function __() {
    this.constructor = d2;
  }
  d2.prototype = b3 === null ? Object.create(b3) : (__.prototype = b3.prototype, new __());
}
function __awaiter37(thisArg, _arguments, P2, generator) {
  function adopt(value) {
    return value instanceof P2 ? value : new P2(function(resolve) {
      resolve(value);
    });
  }
  return new (P2 || (P2 = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
}
function __generator(thisArg, body) {
  var _2 = { label: 0, sent: function() {
    if (t[0] & 1)
      throw t[1];
    return t[1];
  }, trys: [], ops: [] }, f2, y3, t, g4;
  return g4 = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g4[Symbol.iterator] = function() {
    return this;
  }), g4;
  function verb(n2) {
    return function(v) {
      return step([n2, v]);
    };
  }
  function step(op) {
    if (f2)
      throw new TypeError("Generator is already executing.");
    while (g4 && (g4 = 0, op[0] && (_2 = 0)), _2)
      try {
        if (f2 = 1, y3 && (t = op[0] & 2 ? y3["return"] : op[0] ? y3["throw"] || ((t = y3["return"]) && t.call(y3), 0) : y3.next) && !(t = t.call(y3, op[1])).done)
          return t;
        if (y3 = 0, t)
          op = [op[0] & 2, t.value];
        switch (op[0]) {
          case 0:
          case 1:
            t = op;
            break;
          case 4:
            _2.label++;
            return { value: op[1], done: false };
          case 5:
            _2.label++;
            y3 = op[1];
            op = [0];
            continue;
          case 7:
            op = _2.ops.pop();
            _2.trys.pop();
            continue;
          default:
            if (!(t = _2.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
              _2 = 0;
              continue;
            }
            if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
              _2.label = op[1];
              break;
            }
            if (op[0] === 6 && _2.label < t[1]) {
              _2.label = t[1];
              t = op;
              break;
            }
            if (t && _2.label < t[2]) {
              _2.label = t[2];
              _2.ops.push(op);
              break;
            }
            if (t[2])
              _2.ops.pop();
            _2.trys.pop();
            continue;
        }
        op = body.call(thisArg, _2);
      } catch (e) {
        op = [6, e];
        y3 = 0;
      } finally {
        f2 = t = 0;
      }
    if (op[0] & 5)
      throw op[1];
    return { value: op[0] ? op[1] : void 0, done: true };
  }
}
function __values(o) {
  var s = typeof Symbol === "function" && Symbol.iterator, m2 = s && o[s], i2 = 0;
  if (m2)
    return m2.call(o);
  if (o && typeof o.length === "number")
    return {
      next: function() {
        if (o && i2 >= o.length)
          o = void 0;
        return { value: o && o[i2++], done: !o };
      }
    };
  throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
}
function __read(o, n2) {
  var m2 = typeof Symbol === "function" && o[Symbol.iterator];
  if (!m2)
    return o;
  var i2 = m2.call(o), r, ar2 = [], e;
  try {
    while ((n2 === void 0 || n2-- > 0) && !(r = i2.next()).done)
      ar2.push(r.value);
  } catch (error) {
    e = { error };
  } finally {
    try {
      if (r && !r.done && (m2 = i2["return"]))
        m2.call(i2);
    } finally {
      if (e)
        throw e.error;
    }
  }
  return ar2;
}
function __spreadArray(to, from2, pack) {
  if (pack || arguments.length === 2)
    for (var i2 = 0, l = from2.length, ar2; i2 < l; i2++) {
      if (ar2 || !(i2 in from2)) {
        if (!ar2)
          ar2 = Array.prototype.slice.call(from2, 0, i2);
        ar2[i2] = from2[i2];
      }
    }
  return to.concat(ar2 || Array.prototype.slice.call(from2));
}
function __await(v) {
  return this instanceof __await ? (this.v = v, this) : new __await(v);
}
function __asyncGenerator(thisArg, _arguments, generator) {
  if (!Symbol.asyncIterator)
    throw new TypeError("Symbol.asyncIterator is not defined.");
  var g4 = generator.apply(thisArg, _arguments || []), i2, q3 = [];
  return i2 = {}, verb("next"), verb("throw"), verb("return"), i2[Symbol.asyncIterator] = function() {
    return this;
  }, i2;
  function verb(n2) {
    if (g4[n2])
      i2[n2] = function(v) {
        return new Promise(function(a2, b3) {
          q3.push([n2, v, a2, b3]) > 1 || resume(n2, v);
        });
      };
  }
  function resume(n2, v) {
    try {
      step(g4[n2](v));
    } catch (e) {
      settle2(q3[0][3], e);
    }
  }
  function step(r) {
    r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle2(q3[0][2], r);
  }
  function fulfill(value) {
    resume("next", value);
  }
  function reject(value) {
    resume("throw", value);
  }
  function settle2(f2, v) {
    if (f2(v), q3.shift(), q3.length)
      resume(q3[0][0], q3[0][1]);
  }
}
function __asyncValues(o) {
  if (!Symbol.asyncIterator)
    throw new TypeError("Symbol.asyncIterator is not defined.");
  var m2 = o[Symbol.asyncIterator], i2;
  return m2 ? m2.call(o) : (o = typeof __values === "function" ? __values(o) : o[Symbol.iterator](), i2 = {}, verb("next"), verb("throw"), verb("return"), i2[Symbol.asyncIterator] = function() {
    return this;
  }, i2);
  function verb(n2) {
    i2[n2] = o[n2] && function(v) {
      return new Promise(function(resolve, reject) {
        v = o[n2](v), settle2(resolve, reject, v.done, v.value);
      });
    };
  }
  function settle2(resolve, reject, d2, v) {
    Promise.resolve(v).then(function(v2) {
      resolve({ value: v2, done: d2 });
    }, reject);
  }
}

// node_modules/rxjs/dist/esm5/internal/util/isFunction.js
function isFunction(value) {
  return typeof value === "function";
}

// node_modules/rxjs/dist/esm5/internal/util/createErrorClass.js
function createErrorClass(createImpl) {
  var _super = function(instance) {
    Error.call(instance);
    instance.stack = new Error().stack;
  };
  var ctorFunc = createImpl(_super);
  ctorFunc.prototype = Object.create(Error.prototype);
  ctorFunc.prototype.constructor = ctorFunc;
  return ctorFunc;
}

// node_modules/rxjs/dist/esm5/internal/util/UnsubscriptionError.js
var UnsubscriptionError = createErrorClass(function(_super) {
  return function UnsubscriptionErrorImpl(errors) {
    _super(this);
    this.message = errors ? errors.length + " errors occurred during unsubscription:\n" + errors.map(function(err, i2) {
      return i2 + 1 + ") " + err.toString();
    }).join("\n  ") : "";
    this.name = "UnsubscriptionError";
    this.errors = errors;
  };
});

// node_modules/rxjs/dist/esm5/internal/util/arrRemove.js
function arrRemove(arr, item) {
  if (arr) {
    var index = arr.indexOf(item);
    0 <= index && arr.splice(index, 1);
  }
}

// node_modules/rxjs/dist/esm5/internal/Subscription.js
var Subscription = function() {
  function Subscription2(initialTeardown) {
    this.initialTeardown = initialTeardown;
    this.closed = false;
    this._parentage = null;
    this._finalizers = null;
  }
  Subscription2.prototype.unsubscribe = function() {
    var e_1, _a3, e_2, _b;
    var errors;
    if (!this.closed) {
      this.closed = true;
      var _parentage = this._parentage;
      if (_parentage) {
        this._parentage = null;
        if (Array.isArray(_parentage)) {
          try {
            for (var _parentage_1 = __values(_parentage), _parentage_1_1 = _parentage_1.next(); !_parentage_1_1.done; _parentage_1_1 = _parentage_1.next()) {
              var parent_1 = _parentage_1_1.value;
              parent_1.remove(this);
            }
          } catch (e_1_1) {
            e_1 = { error: e_1_1 };
          } finally {
            try {
              if (_parentage_1_1 && !_parentage_1_1.done && (_a3 = _parentage_1.return))
                _a3.call(_parentage_1);
            } finally {
              if (e_1)
                throw e_1.error;
            }
          }
        } else {
          _parentage.remove(this);
        }
      }
      var initialFinalizer = this.initialTeardown;
      if (isFunction(initialFinalizer)) {
        try {
          initialFinalizer();
        } catch (e) {
          errors = e instanceof UnsubscriptionError ? e.errors : [e];
        }
      }
      var _finalizers = this._finalizers;
      if (_finalizers) {
        this._finalizers = null;
        try {
          for (var _finalizers_1 = __values(_finalizers), _finalizers_1_1 = _finalizers_1.next(); !_finalizers_1_1.done; _finalizers_1_1 = _finalizers_1.next()) {
            var finalizer = _finalizers_1_1.value;
            try {
              execFinalizer(finalizer);
            } catch (err) {
              errors = errors !== null && errors !== void 0 ? errors : [];
              if (err instanceof UnsubscriptionError) {
                errors = __spreadArray(__spreadArray([], __read(errors)), __read(err.errors));
              } else {
                errors.push(err);
              }
            }
          }
        } catch (e_2_1) {
          e_2 = { error: e_2_1 };
        } finally {
          try {
            if (_finalizers_1_1 && !_finalizers_1_1.done && (_b = _finalizers_1.return))
              _b.call(_finalizers_1);
          } finally {
            if (e_2)
              throw e_2.error;
          }
        }
      }
      if (errors) {
        throw new UnsubscriptionError(errors);
      }
    }
  };
  Subscription2.prototype.add = function(teardown) {
    var _a3;
    if (teardown && teardown !== this) {
      if (this.closed) {
        execFinalizer(teardown);
      } else {
        if (teardown instanceof Subscription2) {
          if (teardown.closed || teardown._hasParent(this)) {
            return;
          }
          teardown._addParent(this);
        }
        (this._finalizers = (_a3 = this._finalizers) !== null && _a3 !== void 0 ? _a3 : []).push(teardown);
      }
    }
  };
  Subscription2.prototype._hasParent = function(parent) {
    var _parentage = this._parentage;
    return _parentage === parent || Array.isArray(_parentage) && _parentage.includes(parent);
  };
  Subscription2.prototype._addParent = function(parent) {
    var _parentage = this._parentage;
    this._parentage = Array.isArray(_parentage) ? (_parentage.push(parent), _parentage) : _parentage ? [_parentage, parent] : parent;
  };
  Subscription2.prototype._removeParent = function(parent) {
    var _parentage = this._parentage;
    if (_parentage === parent) {
      this._parentage = null;
    } else if (Array.isArray(_parentage)) {
      arrRemove(_parentage, parent);
    }
  };
  Subscription2.prototype.remove = function(teardown) {
    var _finalizers = this._finalizers;
    _finalizers && arrRemove(_finalizers, teardown);
    if (teardown instanceof Subscription2) {
      teardown._removeParent(this);
    }
  };
  Subscription2.EMPTY = function() {
    var empty2 = new Subscription2();
    empty2.closed = true;
    return empty2;
  }();
  return Subscription2;
}();
var EMPTY_SUBSCRIPTION = Subscription.EMPTY;
function isSubscription(value) {
  return value instanceof Subscription || value && "closed" in value && isFunction(value.remove) && isFunction(value.add) && isFunction(value.unsubscribe);
}
function execFinalizer(finalizer) {
  if (isFunction(finalizer)) {
    finalizer();
  } else {
    finalizer.unsubscribe();
  }
}

// node_modules/rxjs/dist/esm5/internal/config.js
var config = {
  onUnhandledError: null,
  onStoppedNotification: null,
  Promise: void 0,
  useDeprecatedSynchronousErrorHandling: false,
  useDeprecatedNextContext: false
};

// node_modules/rxjs/dist/esm5/internal/scheduler/timeoutProvider.js
var timeoutProvider = {
  setTimeout: function(handler, timeout2) {
    var args = [];
    for (var _i = 2; _i < arguments.length; _i++) {
      args[_i - 2] = arguments[_i];
    }
    var delegate = timeoutProvider.delegate;
    if (delegate === null || delegate === void 0 ? void 0 : delegate.setTimeout) {
      return delegate.setTimeout.apply(delegate, __spreadArray([handler, timeout2], __read(args)));
    }
    return setTimeout.apply(void 0, __spreadArray([handler, timeout2], __read(args)));
  },
  clearTimeout: function(handle) {
    var delegate = timeoutProvider.delegate;
    return ((delegate === null || delegate === void 0 ? void 0 : delegate.clearTimeout) || clearTimeout)(handle);
  },
  delegate: void 0
};

// node_modules/rxjs/dist/esm5/internal/util/reportUnhandledError.js
function reportUnhandledError(err) {
  timeoutProvider.setTimeout(function() {
    var onUnhandledError = config.onUnhandledError;
    if (onUnhandledError) {
      onUnhandledError(err);
    } else {
      throw err;
    }
  });
}

// node_modules/rxjs/dist/esm5/internal/util/noop.js
function noop() {
}

// node_modules/rxjs/dist/esm5/internal/NotificationFactories.js
var COMPLETE_NOTIFICATION = function() {
  return createNotification("C", void 0, void 0);
}();
function errorNotification(error) {
  return createNotification("E", void 0, error);
}
function nextNotification(value) {
  return createNotification("N", value, void 0);
}
function createNotification(kind, value, error) {
  return {
    kind,
    value,
    error
  };
}

// node_modules/rxjs/dist/esm5/internal/util/errorContext.js
var context = null;
function errorContext(cb) {
  if (config.useDeprecatedSynchronousErrorHandling) {
    var isRoot = !context;
    if (isRoot) {
      context = { errorThrown: false, error: null };
    }
    cb();
    if (isRoot) {
      var _a3 = context, errorThrown = _a3.errorThrown, error = _a3.error;
      context = null;
      if (errorThrown) {
        throw error;
      }
    }
  } else {
    cb();
  }
}
function captureError(err) {
  if (config.useDeprecatedSynchronousErrorHandling && context) {
    context.errorThrown = true;
    context.error = err;
  }
}

// node_modules/rxjs/dist/esm5/internal/Subscriber.js
var Subscriber = function(_super) {
  __extends(Subscriber2, _super);
  function Subscriber2(destination) {
    var _this = _super.call(this) || this;
    _this.isStopped = false;
    if (destination) {
      _this.destination = destination;
      if (isSubscription(destination)) {
        destination.add(_this);
      }
    } else {
      _this.destination = EMPTY_OBSERVER;
    }
    return _this;
  }
  Subscriber2.create = function(next, error, complete) {
    return new SafeSubscriber(next, error, complete);
  };
  Subscriber2.prototype.next = function(value) {
    if (this.isStopped) {
      handleStoppedNotification(nextNotification(value), this);
    } else {
      this._next(value);
    }
  };
  Subscriber2.prototype.error = function(err) {
    if (this.isStopped) {
      handleStoppedNotification(errorNotification(err), this);
    } else {
      this.isStopped = true;
      this._error(err);
    }
  };
  Subscriber2.prototype.complete = function() {
    if (this.isStopped) {
      handleStoppedNotification(COMPLETE_NOTIFICATION, this);
    } else {
      this.isStopped = true;
      this._complete();
    }
  };
  Subscriber2.prototype.unsubscribe = function() {
    if (!this.closed) {
      this.isStopped = true;
      _super.prototype.unsubscribe.call(this);
      this.destination = null;
    }
  };
  Subscriber2.prototype._next = function(value) {
    this.destination.next(value);
  };
  Subscriber2.prototype._error = function(err) {
    try {
      this.destination.error(err);
    } finally {
      this.unsubscribe();
    }
  };
  Subscriber2.prototype._complete = function() {
    try {
      this.destination.complete();
    } finally {
      this.unsubscribe();
    }
  };
  return Subscriber2;
}(Subscription);
var _bind = Function.prototype.bind;
function bind(fn2, thisArg) {
  return _bind.call(fn2, thisArg);
}
var ConsumerObserver = function() {
  function ConsumerObserver2(partialObserver) {
    this.partialObserver = partialObserver;
  }
  ConsumerObserver2.prototype.next = function(value) {
    var partialObserver = this.partialObserver;
    if (partialObserver.next) {
      try {
        partialObserver.next(value);
      } catch (error) {
        handleUnhandledError(error);
      }
    }
  };
  ConsumerObserver2.prototype.error = function(err) {
    var partialObserver = this.partialObserver;
    if (partialObserver.error) {
      try {
        partialObserver.error(err);
      } catch (error) {
        handleUnhandledError(error);
      }
    } else {
      handleUnhandledError(err);
    }
  };
  ConsumerObserver2.prototype.complete = function() {
    var partialObserver = this.partialObserver;
    if (partialObserver.complete) {
      try {
        partialObserver.complete();
      } catch (error) {
        handleUnhandledError(error);
      }
    }
  };
  return ConsumerObserver2;
}();
var SafeSubscriber = function(_super) {
  __extends(SafeSubscriber2, _super);
  function SafeSubscriber2(observerOrNext, error, complete) {
    var _this = _super.call(this) || this;
    var partialObserver;
    if (isFunction(observerOrNext) || !observerOrNext) {
      partialObserver = {
        next: observerOrNext !== null && observerOrNext !== void 0 ? observerOrNext : void 0,
        error: error !== null && error !== void 0 ? error : void 0,
        complete: complete !== null && complete !== void 0 ? complete : void 0
      };
    } else {
      var context_1;
      if (_this && config.useDeprecatedNextContext) {
        context_1 = Object.create(observerOrNext);
        context_1.unsubscribe = function() {
          return _this.unsubscribe();
        };
        partialObserver = {
          next: observerOrNext.next && bind(observerOrNext.next, context_1),
          error: observerOrNext.error && bind(observerOrNext.error, context_1),
          complete: observerOrNext.complete && bind(observerOrNext.complete, context_1)
        };
      } else {
        partialObserver = observerOrNext;
      }
    }
    _this.destination = new ConsumerObserver(partialObserver);
    return _this;
  }
  return SafeSubscriber2;
}(Subscriber);
function handleUnhandledError(error) {
  if (config.useDeprecatedSynchronousErrorHandling) {
    captureError(error);
  } else {
    reportUnhandledError(error);
  }
}
function defaultErrorHandler(err) {
  throw err;
}
function handleStoppedNotification(notification, subscriber) {
  var onStoppedNotification = config.onStoppedNotification;
  onStoppedNotification && timeoutProvider.setTimeout(function() {
    return onStoppedNotification(notification, subscriber);
  });
}
var EMPTY_OBSERVER = {
  closed: true,
  next: noop,
  error: defaultErrorHandler,
  complete: noop
};

// node_modules/rxjs/dist/esm5/internal/symbol/observable.js
var observable = function() {
  return typeof Symbol === "function" && Symbol.observable || "@@observable";
}();

// node_modules/rxjs/dist/esm5/internal/util/identity.js
function identity(x3) {
  return x3;
}

// node_modules/rxjs/dist/esm5/internal/util/pipe.js
function pipeFromArray(fns) {
  if (fns.length === 0) {
    return identity;
  }
  if (fns.length === 1) {
    return fns[0];
  }
  return function piped(input) {
    return fns.reduce(function(prev, fn2) {
      return fn2(prev);
    }, input);
  };
}

// node_modules/rxjs/dist/esm5/internal/Observable.js
var Observable = function() {
  function Observable2(subscribe) {
    if (subscribe) {
      this._subscribe = subscribe;
    }
  }
  Observable2.prototype.lift = function(operator) {
    var observable2 = new Observable2();
    observable2.source = this;
    observable2.operator = operator;
    return observable2;
  };
  Observable2.prototype.subscribe = function(observerOrNext, error, complete) {
    var _this = this;
    var subscriber = isSubscriber(observerOrNext) ? observerOrNext : new SafeSubscriber(observerOrNext, error, complete);
    errorContext(function() {
      var _a3 = _this, operator = _a3.operator, source = _a3.source;
      subscriber.add(operator ? operator.call(subscriber, source) : source ? _this._subscribe(subscriber) : _this._trySubscribe(subscriber));
    });
    return subscriber;
  };
  Observable2.prototype._trySubscribe = function(sink) {
    try {
      return this._subscribe(sink);
    } catch (err) {
      sink.error(err);
    }
  };
  Observable2.prototype.forEach = function(next, promiseCtor) {
    var _this = this;
    promiseCtor = getPromiseCtor(promiseCtor);
    return new promiseCtor(function(resolve, reject) {
      var subscriber = new SafeSubscriber({
        next: function(value) {
          try {
            next(value);
          } catch (err) {
            reject(err);
            subscriber.unsubscribe();
          }
        },
        error: reject,
        complete: resolve
      });
      _this.subscribe(subscriber);
    });
  };
  Observable2.prototype._subscribe = function(subscriber) {
    var _a3;
    return (_a3 = this.source) === null || _a3 === void 0 ? void 0 : _a3.subscribe(subscriber);
  };
  Observable2.prototype[observable] = function() {
    return this;
  };
  Observable2.prototype.pipe = function() {
    var operations = [];
    for (var _i = 0; _i < arguments.length; _i++) {
      operations[_i] = arguments[_i];
    }
    return pipeFromArray(operations)(this);
  };
  Observable2.prototype.toPromise = function(promiseCtor) {
    var _this = this;
    promiseCtor = getPromiseCtor(promiseCtor);
    return new promiseCtor(function(resolve, reject) {
      var value;
      _this.subscribe(function(x3) {
        return value = x3;
      }, function(err) {
        return reject(err);
      }, function() {
        return resolve(value);
      });
    });
  };
  Observable2.create = function(subscribe) {
    return new Observable2(subscribe);
  };
  return Observable2;
}();
function getPromiseCtor(promiseCtor) {
  var _a3;
  return (_a3 = promiseCtor !== null && promiseCtor !== void 0 ? promiseCtor : config.Promise) !== null && _a3 !== void 0 ? _a3 : Promise;
}
function isObserver(value) {
  return value && isFunction(value.next) && isFunction(value.error) && isFunction(value.complete);
}
function isSubscriber(value) {
  return value && value instanceof Subscriber || isObserver(value) && isSubscription(value);
}

// node_modules/rxjs/dist/esm5/internal/util/lift.js
function hasLift(source) {
  return isFunction(source === null || source === void 0 ? void 0 : source.lift);
}
function operate(init) {
  return function(source) {
    if (hasLift(source)) {
      return source.lift(function(liftedSource) {
        try {
          return init(liftedSource, this);
        } catch (err) {
          this.error(err);
        }
      });
    }
    throw new TypeError("Unable to lift unknown Observable type");
  };
}

// node_modules/rxjs/dist/esm5/internal/operators/OperatorSubscriber.js
function createOperatorSubscriber(destination, onNext, onComplete, onError, onFinalize) {
  return new OperatorSubscriber(destination, onNext, onComplete, onError, onFinalize);
}
var OperatorSubscriber = function(_super) {
  __extends(OperatorSubscriber2, _super);
  function OperatorSubscriber2(destination, onNext, onComplete, onError, onFinalize, shouldUnsubscribe) {
    var _this = _super.call(this, destination) || this;
    _this.onFinalize = onFinalize;
    _this.shouldUnsubscribe = shouldUnsubscribe;
    _this._next = onNext ? function(value) {
      try {
        onNext(value);
      } catch (err) {
        destination.error(err);
      }
    } : _super.prototype._next;
    _this._error = onError ? function(err) {
      try {
        onError(err);
      } catch (err2) {
        destination.error(err2);
      } finally {
        this.unsubscribe();
      }
    } : _super.prototype._error;
    _this._complete = onComplete ? function() {
      try {
        onComplete();
      } catch (err) {
        destination.error(err);
      } finally {
        this.unsubscribe();
      }
    } : _super.prototype._complete;
    return _this;
  }
  OperatorSubscriber2.prototype.unsubscribe = function() {
    var _a3;
    if (!this.shouldUnsubscribe || this.shouldUnsubscribe()) {
      var closed_1 = this.closed;
      _super.prototype.unsubscribe.call(this);
      !closed_1 && ((_a3 = this.onFinalize) === null || _a3 === void 0 ? void 0 : _a3.call(this));
    }
  };
  return OperatorSubscriber2;
}(Subscriber);

// node_modules/rxjs/dist/esm5/internal/operators/refCount.js
function refCount() {
  return operate(function(source, subscriber) {
    var connection = null;
    source._refCount++;
    var refCounter = createOperatorSubscriber(subscriber, void 0, void 0, void 0, function() {
      if (!source || source._refCount <= 0 || 0 < --source._refCount) {
        connection = null;
        return;
      }
      var sharedConnection = source._connection;
      var conn = connection;
      connection = null;
      if (sharedConnection && (!conn || sharedConnection === conn)) {
        sharedConnection.unsubscribe();
      }
      subscriber.unsubscribe();
    });
    source.subscribe(refCounter);
    if (!refCounter.closed) {
      connection = source.connect();
    }
  });
}

// node_modules/rxjs/dist/esm5/internal/observable/ConnectableObservable.js
var ConnectableObservable = function(_super) {
  __extends(ConnectableObservable2, _super);
  function ConnectableObservable2(source, subjectFactory) {
    var _this = _super.call(this) || this;
    _this.source = source;
    _this.subjectFactory = subjectFactory;
    _this._subject = null;
    _this._refCount = 0;
    _this._connection = null;
    if (hasLift(source)) {
      _this.lift = source.lift;
    }
    return _this;
  }
  ConnectableObservable2.prototype._subscribe = function(subscriber) {
    return this.getSubject().subscribe(subscriber);
  };
  ConnectableObservable2.prototype.getSubject = function() {
    var subject = this._subject;
    if (!subject || subject.isStopped) {
      this._subject = this.subjectFactory();
    }
    return this._subject;
  };
  ConnectableObservable2.prototype._teardown = function() {
    this._refCount = 0;
    var _connection = this._connection;
    this._subject = this._connection = null;
    _connection === null || _connection === void 0 ? void 0 : _connection.unsubscribe();
  };
  ConnectableObservable2.prototype.connect = function() {
    var _this = this;
    var connection = this._connection;
    if (!connection) {
      connection = this._connection = new Subscription();
      var subject_1 = this.getSubject();
      connection.add(this.source.subscribe(createOperatorSubscriber(subject_1, void 0, function() {
        _this._teardown();
        subject_1.complete();
      }, function(err) {
        _this._teardown();
        subject_1.error(err);
      }, function() {
        return _this._teardown();
      })));
      if (connection.closed) {
        this._connection = null;
        connection = Subscription.EMPTY;
      }
    }
    return connection;
  };
  ConnectableObservable2.prototype.refCount = function() {
    return refCount()(this);
  };
  return ConnectableObservable2;
}(Observable);

// node_modules/rxjs/dist/esm5/internal/scheduler/performanceTimestampProvider.js
var performanceTimestampProvider = {
  now: function() {
    return (performanceTimestampProvider.delegate || performance).now();
  },
  delegate: void 0
};

// node_modules/rxjs/dist/esm5/internal/scheduler/animationFrameProvider.js
var animationFrameProvider = {
  schedule: function(callback) {
    var request = requestAnimationFrame;
    var cancel = cancelAnimationFrame;
    var delegate = animationFrameProvider.delegate;
    if (delegate) {
      request = delegate.requestAnimationFrame;
      cancel = delegate.cancelAnimationFrame;
    }
    var handle = request(function(timestamp2) {
      cancel = void 0;
      callback(timestamp2);
    });
    return new Subscription(function() {
      return cancel === null || cancel === void 0 ? void 0 : cancel(handle);
    });
  },
  requestAnimationFrame: function() {
    var args = [];
    for (var _i = 0; _i < arguments.length; _i++) {
      args[_i] = arguments[_i];
    }
    var delegate = animationFrameProvider.delegate;
    return ((delegate === null || delegate === void 0 ? void 0 : delegate.requestAnimationFrame) || requestAnimationFrame).apply(void 0, __spreadArray([], __read(args)));
  },
  cancelAnimationFrame: function() {
    var args = [];
    for (var _i = 0; _i < arguments.length; _i++) {
      args[_i] = arguments[_i];
    }
    var delegate = animationFrameProvider.delegate;
    return ((delegate === null || delegate === void 0 ? void 0 : delegate.cancelAnimationFrame) || cancelAnimationFrame).apply(void 0, __spreadArray([], __read(args)));
  },
  delegate: void 0
};

// node_modules/rxjs/dist/esm5/internal/observable/dom/animationFrames.js
function animationFramesFactory(timestampProvider) {
  return new Observable(function(subscriber) {
    var provider = timestampProvider || performanceTimestampProvider;
    var start = provider.now();
    var id = 0;
    var run = function() {
      if (!subscriber.closed) {
        id = animationFrameProvider.requestAnimationFrame(function(timestamp2) {
          id = 0;
          var now = provider.now();
          subscriber.next({
            timestamp: timestampProvider ? now : timestamp2,
            elapsed: now - start
          });
          run();
        });
      }
    };
    run();
    return function() {
      if (id) {
        animationFrameProvider.cancelAnimationFrame(id);
      }
    };
  });
}
var DEFAULT_ANIMATION_FRAMES = animationFramesFactory();

// node_modules/rxjs/dist/esm5/internal/util/ObjectUnsubscribedError.js
var ObjectUnsubscribedError = createErrorClass(function(_super) {
  return function ObjectUnsubscribedErrorImpl() {
    _super(this);
    this.name = "ObjectUnsubscribedError";
    this.message = "object unsubscribed";
  };
});

// node_modules/rxjs/dist/esm5/internal/Subject.js
var Subject = function(_super) {
  __extends(Subject2, _super);
  function Subject2() {
    var _this = _super.call(this) || this;
    _this.closed = false;
    _this.currentObservers = null;
    _this.observers = [];
    _this.isStopped = false;
    _this.hasError = false;
    _this.thrownError = null;
    return _this;
  }
  Subject2.prototype.lift = function(operator) {
    var subject = new AnonymousSubject(this, this);
    subject.operator = operator;
    return subject;
  };
  Subject2.prototype._throwIfClosed = function() {
    if (this.closed) {
      throw new ObjectUnsubscribedError();
    }
  };
  Subject2.prototype.next = function(value) {
    var _this = this;
    errorContext(function() {
      var e_1, _a3;
      _this._throwIfClosed();
      if (!_this.isStopped) {
        if (!_this.currentObservers) {
          _this.currentObservers = Array.from(_this.observers);
        }
        try {
          for (var _b = __values(_this.currentObservers), _c = _b.next(); !_c.done; _c = _b.next()) {
            var observer = _c.value;
            observer.next(value);
          }
        } catch (e_1_1) {
          e_1 = { error: e_1_1 };
        } finally {
          try {
            if (_c && !_c.done && (_a3 = _b.return))
              _a3.call(_b);
          } finally {
            if (e_1)
              throw e_1.error;
          }
        }
      }
    });
  };
  Subject2.prototype.error = function(err) {
    var _this = this;
    errorContext(function() {
      _this._throwIfClosed();
      if (!_this.isStopped) {
        _this.hasError = _this.isStopped = true;
        _this.thrownError = err;
        var observers = _this.observers;
        while (observers.length) {
          observers.shift().error(err);
        }
      }
    });
  };
  Subject2.prototype.complete = function() {
    var _this = this;
    errorContext(function() {
      _this._throwIfClosed();
      if (!_this.isStopped) {
        _this.isStopped = true;
        var observers = _this.observers;
        while (observers.length) {
          observers.shift().complete();
        }
      }
    });
  };
  Subject2.prototype.unsubscribe = function() {
    this.isStopped = this.closed = true;
    this.observers = this.currentObservers = null;
  };
  Object.defineProperty(Subject2.prototype, "observed", {
    get: function() {
      var _a3;
      return ((_a3 = this.observers) === null || _a3 === void 0 ? void 0 : _a3.length) > 0;
    },
    enumerable: false,
    configurable: true
  });
  Subject2.prototype._trySubscribe = function(subscriber) {
    this._throwIfClosed();
    return _super.prototype._trySubscribe.call(this, subscriber);
  };
  Subject2.prototype._subscribe = function(subscriber) {
    this._throwIfClosed();
    this._checkFinalizedStatuses(subscriber);
    return this._innerSubscribe(subscriber);
  };
  Subject2.prototype._innerSubscribe = function(subscriber) {
    var _this = this;
    var _a3 = this, hasError = _a3.hasError, isStopped = _a3.isStopped, observers = _a3.observers;
    if (hasError || isStopped) {
      return EMPTY_SUBSCRIPTION;
    }
    this.currentObservers = null;
    observers.push(subscriber);
    return new Subscription(function() {
      _this.currentObservers = null;
      arrRemove(observers, subscriber);
    });
  };
  Subject2.prototype._checkFinalizedStatuses = function(subscriber) {
    var _a3 = this, hasError = _a3.hasError, thrownError = _a3.thrownError, isStopped = _a3.isStopped;
    if (hasError) {
      subscriber.error(thrownError);
    } else if (isStopped) {
      subscriber.complete();
    }
  };
  Subject2.prototype.asObservable = function() {
    var observable2 = new Observable();
    observable2.source = this;
    return observable2;
  };
  Subject2.create = function(destination, source) {
    return new AnonymousSubject(destination, source);
  };
  return Subject2;
}(Observable);
var AnonymousSubject = function(_super) {
  __extends(AnonymousSubject2, _super);
  function AnonymousSubject2(destination, source) {
    var _this = _super.call(this) || this;
    _this.destination = destination;
    _this.source = source;
    return _this;
  }
  AnonymousSubject2.prototype.next = function(value) {
    var _a3, _b;
    (_b = (_a3 = this.destination) === null || _a3 === void 0 ? void 0 : _a3.next) === null || _b === void 0 ? void 0 : _b.call(_a3, value);
  };
  AnonymousSubject2.prototype.error = function(err) {
    var _a3, _b;
    (_b = (_a3 = this.destination) === null || _a3 === void 0 ? void 0 : _a3.error) === null || _b === void 0 ? void 0 : _b.call(_a3, err);
  };
  AnonymousSubject2.prototype.complete = function() {
    var _a3, _b;
    (_b = (_a3 = this.destination) === null || _a3 === void 0 ? void 0 : _a3.complete) === null || _b === void 0 ? void 0 : _b.call(_a3);
  };
  AnonymousSubject2.prototype._subscribe = function(subscriber) {
    var _a3, _b;
    return (_b = (_a3 = this.source) === null || _a3 === void 0 ? void 0 : _a3.subscribe(subscriber)) !== null && _b !== void 0 ? _b : EMPTY_SUBSCRIPTION;
  };
  return AnonymousSubject2;
}(Subject);

// node_modules/rxjs/dist/esm5/internal/BehaviorSubject.js
var BehaviorSubject = function(_super) {
  __extends(BehaviorSubject2, _super);
  function BehaviorSubject2(_value) {
    var _this = _super.call(this) || this;
    _this._value = _value;
    return _this;
  }
  Object.defineProperty(BehaviorSubject2.prototype, "value", {
    get: function() {
      return this.getValue();
    },
    enumerable: false,
    configurable: true
  });
  BehaviorSubject2.prototype._subscribe = function(subscriber) {
    var subscription = _super.prototype._subscribe.call(this, subscriber);
    !subscription.closed && subscriber.next(this._value);
    return subscription;
  };
  BehaviorSubject2.prototype.getValue = function() {
    var _a3 = this, hasError = _a3.hasError, thrownError = _a3.thrownError, _value = _a3._value;
    if (hasError) {
      throw thrownError;
    }
    this._throwIfClosed();
    return _value;
  };
  BehaviorSubject2.prototype.next = function(value) {
    _super.prototype.next.call(this, this._value = value);
  };
  return BehaviorSubject2;
}(Subject);

// node_modules/rxjs/dist/esm5/internal/scheduler/dateTimestampProvider.js
var dateTimestampProvider = {
  now: function() {
    return (dateTimestampProvider.delegate || Date).now();
  },
  delegate: void 0
};

// node_modules/rxjs/dist/esm5/internal/ReplaySubject.js
var ReplaySubject = function(_super) {
  __extends(ReplaySubject2, _super);
  function ReplaySubject2(_bufferSize, _windowTime, _timestampProvider) {
    if (_bufferSize === void 0) {
      _bufferSize = Infinity;
    }
    if (_windowTime === void 0) {
      _windowTime = Infinity;
    }
    if (_timestampProvider === void 0) {
      _timestampProvider = dateTimestampProvider;
    }
    var _this = _super.call(this) || this;
    _this._bufferSize = _bufferSize;
    _this._windowTime = _windowTime;
    _this._timestampProvider = _timestampProvider;
    _this._buffer = [];
    _this._infiniteTimeWindow = true;
    _this._infiniteTimeWindow = _windowTime === Infinity;
    _this._bufferSize = Math.max(1, _bufferSize);
    _this._windowTime = Math.max(1, _windowTime);
    return _this;
  }
  ReplaySubject2.prototype.next = function(value) {
    var _a3 = this, isStopped = _a3.isStopped, _buffer = _a3._buffer, _infiniteTimeWindow = _a3._infiniteTimeWindow, _timestampProvider = _a3._timestampProvider, _windowTime = _a3._windowTime;
    if (!isStopped) {
      _buffer.push(value);
      !_infiniteTimeWindow && _buffer.push(_timestampProvider.now() + _windowTime);
    }
    this._trimBuffer();
    _super.prototype.next.call(this, value);
  };
  ReplaySubject2.prototype._subscribe = function(subscriber) {
    this._throwIfClosed();
    this._trimBuffer();
    var subscription = this._innerSubscribe(subscriber);
    var _a3 = this, _infiniteTimeWindow = _a3._infiniteTimeWindow, _buffer = _a3._buffer;
    var copy = _buffer.slice();
    for (var i2 = 0; i2 < copy.length && !subscriber.closed; i2 += _infiniteTimeWindow ? 1 : 2) {
      subscriber.next(copy[i2]);
    }
    this._checkFinalizedStatuses(subscriber);
    return subscription;
  };
  ReplaySubject2.prototype._trimBuffer = function() {
    var _a3 = this, _bufferSize = _a3._bufferSize, _timestampProvider = _a3._timestampProvider, _buffer = _a3._buffer, _infiniteTimeWindow = _a3._infiniteTimeWindow;
    var adjustedBufferSize = (_infiniteTimeWindow ? 1 : 2) * _bufferSize;
    _bufferSize < Infinity && adjustedBufferSize < _buffer.length && _buffer.splice(0, _buffer.length - adjustedBufferSize);
    if (!_infiniteTimeWindow) {
      var now = _timestampProvider.now();
      var last3 = 0;
      for (var i2 = 1; i2 < _buffer.length && _buffer[i2] <= now; i2 += 2) {
        last3 = i2;
      }
      last3 && _buffer.splice(0, last3 + 1);
    }
  };
  return ReplaySubject2;
}(Subject);

// node_modules/rxjs/dist/esm5/internal/AsyncSubject.js
var AsyncSubject = function(_super) {
  __extends(AsyncSubject2, _super);
  function AsyncSubject2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this._value = null;
    _this._hasValue = false;
    _this._isComplete = false;
    return _this;
  }
  AsyncSubject2.prototype._checkFinalizedStatuses = function(subscriber) {
    var _a3 = this, hasError = _a3.hasError, _hasValue = _a3._hasValue, _value = _a3._value, thrownError = _a3.thrownError, isStopped = _a3.isStopped, _isComplete = _a3._isComplete;
    if (hasError) {
      subscriber.error(thrownError);
    } else if (isStopped || _isComplete) {
      _hasValue && subscriber.next(_value);
      subscriber.complete();
    }
  };
  AsyncSubject2.prototype.next = function(value) {
    if (!this.isStopped) {
      this._value = value;
      this._hasValue = true;
    }
  };
  AsyncSubject2.prototype.complete = function() {
    var _a3 = this, _hasValue = _a3._hasValue, _value = _a3._value, _isComplete = _a3._isComplete;
    if (!_isComplete) {
      this._isComplete = true;
      _hasValue && _super.prototype.next.call(this, _value);
      _super.prototype.complete.call(this);
    }
  };
  return AsyncSubject2;
}(Subject);

// node_modules/rxjs/dist/esm5/internal/scheduler/Action.js
var Action = function(_super) {
  __extends(Action2, _super);
  function Action2(scheduler, work) {
    return _super.call(this) || this;
  }
  Action2.prototype.schedule = function(state, delay2) {
    if (delay2 === void 0) {
      delay2 = 0;
    }
    return this;
  };
  return Action2;
}(Subscription);

// node_modules/rxjs/dist/esm5/internal/scheduler/intervalProvider.js
var intervalProvider = {
  setInterval: function(handler, timeout2) {
    var args = [];
    for (var _i = 2; _i < arguments.length; _i++) {
      args[_i - 2] = arguments[_i];
    }
    var delegate = intervalProvider.delegate;
    if (delegate === null || delegate === void 0 ? void 0 : delegate.setInterval) {
      return delegate.setInterval.apply(delegate, __spreadArray([handler, timeout2], __read(args)));
    }
    return setInterval.apply(void 0, __spreadArray([handler, timeout2], __read(args)));
  },
  clearInterval: function(handle) {
    var delegate = intervalProvider.delegate;
    return ((delegate === null || delegate === void 0 ? void 0 : delegate.clearInterval) || clearInterval)(handle);
  },
  delegate: void 0
};

// node_modules/rxjs/dist/esm5/internal/scheduler/AsyncAction.js
var AsyncAction = function(_super) {
  __extends(AsyncAction2, _super);
  function AsyncAction2(scheduler, work) {
    var _this = _super.call(this, scheduler, work) || this;
    _this.scheduler = scheduler;
    _this.work = work;
    _this.pending = false;
    return _this;
  }
  AsyncAction2.prototype.schedule = function(state, delay2) {
    var _a3;
    if (delay2 === void 0) {
      delay2 = 0;
    }
    if (this.closed) {
      return this;
    }
    this.state = state;
    var id = this.id;
    var scheduler = this.scheduler;
    if (id != null) {
      this.id = this.recycleAsyncId(scheduler, id, delay2);
    }
    this.pending = true;
    this.delay = delay2;
    this.id = (_a3 = this.id) !== null && _a3 !== void 0 ? _a3 : this.requestAsyncId(scheduler, this.id, delay2);
    return this;
  };
  AsyncAction2.prototype.requestAsyncId = function(scheduler, _id, delay2) {
    if (delay2 === void 0) {
      delay2 = 0;
    }
    return intervalProvider.setInterval(scheduler.flush.bind(scheduler, this), delay2);
  };
  AsyncAction2.prototype.recycleAsyncId = function(_scheduler, id, delay2) {
    if (delay2 === void 0) {
      delay2 = 0;
    }
    if (delay2 != null && this.delay === delay2 && this.pending === false) {
      return id;
    }
    if (id != null) {
      intervalProvider.clearInterval(id);
    }
    return void 0;
  };
  AsyncAction2.prototype.execute = function(state, delay2) {
    if (this.closed) {
      return new Error("executing a cancelled action");
    }
    this.pending = false;
    var error = this._execute(state, delay2);
    if (error) {
      return error;
    } else if (this.pending === false && this.id != null) {
      this.id = this.recycleAsyncId(this.scheduler, this.id, null);
    }
  };
  AsyncAction2.prototype._execute = function(state, _delay) {
    var errored = false;
    var errorValue;
    try {
      this.work(state);
    } catch (e) {
      errored = true;
      errorValue = e ? e : new Error("Scheduled action threw falsy error");
    }
    if (errored) {
      this.unsubscribe();
      return errorValue;
    }
  };
  AsyncAction2.prototype.unsubscribe = function() {
    if (!this.closed) {
      var _a3 = this, id = _a3.id, scheduler = _a3.scheduler;
      var actions = scheduler.actions;
      this.work = this.state = this.scheduler = null;
      this.pending = false;
      arrRemove(actions, this);
      if (id != null) {
        this.id = this.recycleAsyncId(scheduler, id, null);
      }
      this.delay = null;
      _super.prototype.unsubscribe.call(this);
    }
  };
  return AsyncAction2;
}(Action);

// node_modules/rxjs/dist/esm5/internal/util/Immediate.js
var nextHandle = 1;
var resolved;
var activeHandles = {};
function findAndClearHandle(handle) {
  if (handle in activeHandles) {
    delete activeHandles[handle];
    return true;
  }
  return false;
}
var Immediate = {
  setImmediate: function(cb) {
    var handle = nextHandle++;
    activeHandles[handle] = true;
    if (!resolved) {
      resolved = Promise.resolve();
    }
    resolved.then(function() {
      return findAndClearHandle(handle) && cb();
    });
    return handle;
  },
  clearImmediate: function(handle) {
    findAndClearHandle(handle);
  }
};

// node_modules/rxjs/dist/esm5/internal/scheduler/immediateProvider.js
var setImmediate = Immediate.setImmediate;
var clearImmediate = Immediate.clearImmediate;
var immediateProvider = {
  setImmediate: function() {
    var args = [];
    for (var _i = 0; _i < arguments.length; _i++) {
      args[_i] = arguments[_i];
    }
    var delegate = immediateProvider.delegate;
    return ((delegate === null || delegate === void 0 ? void 0 : delegate.setImmediate) || setImmediate).apply(void 0, __spreadArray([], __read(args)));
  },
  clearImmediate: function(handle) {
    var delegate = immediateProvider.delegate;
    return ((delegate === null || delegate === void 0 ? void 0 : delegate.clearImmediate) || clearImmediate)(handle);
  },
  delegate: void 0
};

// node_modules/rxjs/dist/esm5/internal/scheduler/AsapAction.js
var AsapAction = function(_super) {
  __extends(AsapAction2, _super);
  function AsapAction2(scheduler, work) {
    var _this = _super.call(this, scheduler, work) || this;
    _this.scheduler = scheduler;
    _this.work = work;
    return _this;
  }
  AsapAction2.prototype.requestAsyncId = function(scheduler, id, delay2) {
    if (delay2 === void 0) {
      delay2 = 0;
    }
    if (delay2 !== null && delay2 > 0) {
      return _super.prototype.requestAsyncId.call(this, scheduler, id, delay2);
    }
    scheduler.actions.push(this);
    return scheduler._scheduled || (scheduler._scheduled = immediateProvider.setImmediate(scheduler.flush.bind(scheduler, void 0)));
  };
  AsapAction2.prototype.recycleAsyncId = function(scheduler, id, delay2) {
    var _a3;
    if (delay2 === void 0) {
      delay2 = 0;
    }
    if (delay2 != null ? delay2 > 0 : this.delay > 0) {
      return _super.prototype.recycleAsyncId.call(this, scheduler, id, delay2);
    }
    var actions = scheduler.actions;
    if (id != null && ((_a3 = actions[actions.length - 1]) === null || _a3 === void 0 ? void 0 : _a3.id) !== id) {
      immediateProvider.clearImmediate(id);
      if (scheduler._scheduled === id) {
        scheduler._scheduled = void 0;
      }
    }
    return void 0;
  };
  return AsapAction2;
}(AsyncAction);

// node_modules/rxjs/dist/esm5/internal/Scheduler.js
var Scheduler = function() {
  function Scheduler2(schedulerActionCtor, now) {
    if (now === void 0) {
      now = Scheduler2.now;
    }
    this.schedulerActionCtor = schedulerActionCtor;
    this.now = now;
  }
  Scheduler2.prototype.schedule = function(work, delay2, state) {
    if (delay2 === void 0) {
      delay2 = 0;
    }
    return new this.schedulerActionCtor(this, work).schedule(state, delay2);
  };
  Scheduler2.now = dateTimestampProvider.now;
  return Scheduler2;
}();

// node_modules/rxjs/dist/esm5/internal/scheduler/AsyncScheduler.js
var AsyncScheduler = function(_super) {
  __extends(AsyncScheduler2, _super);
  function AsyncScheduler2(SchedulerAction, now) {
    if (now === void 0) {
      now = Scheduler.now;
    }
    var _this = _super.call(this, SchedulerAction, now) || this;
    _this.actions = [];
    _this._active = false;
    return _this;
  }
  AsyncScheduler2.prototype.flush = function(action) {
    var actions = this.actions;
    if (this._active) {
      actions.push(action);
      return;
    }
    var error;
    this._active = true;
    do {
      if (error = action.execute(action.state, action.delay)) {
        break;
      }
    } while (action = actions.shift());
    this._active = false;
    if (error) {
      while (action = actions.shift()) {
        action.unsubscribe();
      }
      throw error;
    }
  };
  return AsyncScheduler2;
}(Scheduler);

// node_modules/rxjs/dist/esm5/internal/scheduler/AsapScheduler.js
var AsapScheduler = function(_super) {
  __extends(AsapScheduler2, _super);
  function AsapScheduler2() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  AsapScheduler2.prototype.flush = function(action) {
    this._active = true;
    var flushId = this._scheduled;
    this._scheduled = void 0;
    var actions = this.actions;
    var error;
    action = action || actions.shift();
    do {
      if (error = action.execute(action.state, action.delay)) {
        break;
      }
    } while ((action = actions[0]) && action.id === flushId && actions.shift());
    this._active = false;
    if (error) {
      while ((action = actions[0]) && action.id === flushId && actions.shift()) {
        action.unsubscribe();
      }
      throw error;
    }
  };
  return AsapScheduler2;
}(AsyncScheduler);

// node_modules/rxjs/dist/esm5/internal/scheduler/asap.js
var asapScheduler = new AsapScheduler(AsapAction);

// node_modules/rxjs/dist/esm5/internal/scheduler/async.js
var asyncScheduler = new AsyncScheduler(AsyncAction);
var async = asyncScheduler;

// node_modules/rxjs/dist/esm5/internal/scheduler/QueueAction.js
var QueueAction = function(_super) {
  __extends(QueueAction2, _super);
  function QueueAction2(scheduler, work) {
    var _this = _super.call(this, scheduler, work) || this;
    _this.scheduler = scheduler;
    _this.work = work;
    return _this;
  }
  QueueAction2.prototype.schedule = function(state, delay2) {
    if (delay2 === void 0) {
      delay2 = 0;
    }
    if (delay2 > 0) {
      return _super.prototype.schedule.call(this, state, delay2);
    }
    this.delay = delay2;
    this.state = state;
    this.scheduler.flush(this);
    return this;
  };
  QueueAction2.prototype.execute = function(state, delay2) {
    return delay2 > 0 || this.closed ? _super.prototype.execute.call(this, state, delay2) : this._execute(state, delay2);
  };
  QueueAction2.prototype.requestAsyncId = function(scheduler, id, delay2) {
    if (delay2 === void 0) {
      delay2 = 0;
    }
    if (delay2 != null && delay2 > 0 || delay2 == null && this.delay > 0) {
      return _super.prototype.requestAsyncId.call(this, scheduler, id, delay2);
    }
    scheduler.flush(this);
    return 0;
  };
  return QueueAction2;
}(AsyncAction);

// node_modules/rxjs/dist/esm5/internal/scheduler/QueueScheduler.js
var QueueScheduler = function(_super) {
  __extends(QueueScheduler2, _super);
  function QueueScheduler2() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  return QueueScheduler2;
}(AsyncScheduler);

// node_modules/rxjs/dist/esm5/internal/scheduler/queue.js
var queueScheduler = new QueueScheduler(QueueAction);

// node_modules/rxjs/dist/esm5/internal/scheduler/AnimationFrameAction.js
var AnimationFrameAction = function(_super) {
  __extends(AnimationFrameAction2, _super);
  function AnimationFrameAction2(scheduler, work) {
    var _this = _super.call(this, scheduler, work) || this;
    _this.scheduler = scheduler;
    _this.work = work;
    return _this;
  }
  AnimationFrameAction2.prototype.requestAsyncId = function(scheduler, id, delay2) {
    if (delay2 === void 0) {
      delay2 = 0;
    }
    if (delay2 !== null && delay2 > 0) {
      return _super.prototype.requestAsyncId.call(this, scheduler, id, delay2);
    }
    scheduler.actions.push(this);
    return scheduler._scheduled || (scheduler._scheduled = animationFrameProvider.requestAnimationFrame(function() {
      return scheduler.flush(void 0);
    }));
  };
  AnimationFrameAction2.prototype.recycleAsyncId = function(scheduler, id, delay2) {
    var _a3;
    if (delay2 === void 0) {
      delay2 = 0;
    }
    if (delay2 != null ? delay2 > 0 : this.delay > 0) {
      return _super.prototype.recycleAsyncId.call(this, scheduler, id, delay2);
    }
    var actions = scheduler.actions;
    if (id != null && ((_a3 = actions[actions.length - 1]) === null || _a3 === void 0 ? void 0 : _a3.id) !== id) {
      animationFrameProvider.cancelAnimationFrame(id);
      scheduler._scheduled = void 0;
    }
    return void 0;
  };
  return AnimationFrameAction2;
}(AsyncAction);

// node_modules/rxjs/dist/esm5/internal/scheduler/AnimationFrameScheduler.js
var AnimationFrameScheduler = function(_super) {
  __extends(AnimationFrameScheduler2, _super);
  function AnimationFrameScheduler2() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  AnimationFrameScheduler2.prototype.flush = function(action) {
    this._active = true;
    var flushId = this._scheduled;
    this._scheduled = void 0;
    var actions = this.actions;
    var error;
    action = action || actions.shift();
    do {
      if (error = action.execute(action.state, action.delay)) {
        break;
      }
    } while ((action = actions[0]) && action.id === flushId && actions.shift());
    this._active = false;
    if (error) {
      while ((action = actions[0]) && action.id === flushId && actions.shift()) {
        action.unsubscribe();
      }
      throw error;
    }
  };
  return AnimationFrameScheduler2;
}(AsyncScheduler);

// node_modules/rxjs/dist/esm5/internal/scheduler/animationFrame.js
var animationFrameScheduler = new AnimationFrameScheduler(AnimationFrameAction);

// node_modules/rxjs/dist/esm5/internal/scheduler/VirtualTimeScheduler.js
var VirtualTimeScheduler = function(_super) {
  __extends(VirtualTimeScheduler2, _super);
  function VirtualTimeScheduler2(schedulerActionCtor, maxFrames) {
    if (schedulerActionCtor === void 0) {
      schedulerActionCtor = VirtualAction;
    }
    if (maxFrames === void 0) {
      maxFrames = Infinity;
    }
    var _this = _super.call(this, schedulerActionCtor, function() {
      return _this.frame;
    }) || this;
    _this.maxFrames = maxFrames;
    _this.frame = 0;
    _this.index = -1;
    return _this;
  }
  VirtualTimeScheduler2.prototype.flush = function() {
    var _a3 = this, actions = _a3.actions, maxFrames = _a3.maxFrames;
    var error;
    var action;
    while ((action = actions[0]) && action.delay <= maxFrames) {
      actions.shift();
      this.frame = action.delay;
      if (error = action.execute(action.state, action.delay)) {
        break;
      }
    }
    if (error) {
      while (action = actions.shift()) {
        action.unsubscribe();
      }
      throw error;
    }
  };
  VirtualTimeScheduler2.frameTimeFactor = 10;
  return VirtualTimeScheduler2;
}(AsyncScheduler);
var VirtualAction = function(_super) {
  __extends(VirtualAction2, _super);
  function VirtualAction2(scheduler, work, index) {
    if (index === void 0) {
      index = scheduler.index += 1;
    }
    var _this = _super.call(this, scheduler, work) || this;
    _this.scheduler = scheduler;
    _this.work = work;
    _this.index = index;
    _this.active = true;
    _this.index = scheduler.index = index;
    return _this;
  }
  VirtualAction2.prototype.schedule = function(state, delay2) {
    if (delay2 === void 0) {
      delay2 = 0;
    }
    if (Number.isFinite(delay2)) {
      if (!this.id) {
        return _super.prototype.schedule.call(this, state, delay2);
      }
      this.active = false;
      var action = new VirtualAction2(this.scheduler, this.work);
      this.add(action);
      return action.schedule(state, delay2);
    } else {
      return Subscription.EMPTY;
    }
  };
  VirtualAction2.prototype.requestAsyncId = function(scheduler, id, delay2) {
    if (delay2 === void 0) {
      delay2 = 0;
    }
    this.delay = scheduler.frame + delay2;
    var actions = scheduler.actions;
    actions.push(this);
    actions.sort(VirtualAction2.sortActions);
    return 1;
  };
  VirtualAction2.prototype.recycleAsyncId = function(scheduler, id, delay2) {
    if (delay2 === void 0) {
      delay2 = 0;
    }
    return void 0;
  };
  VirtualAction2.prototype._execute = function(state, delay2) {
    if (this.active === true) {
      return _super.prototype._execute.call(this, state, delay2);
    }
  };
  VirtualAction2.sortActions = function(a2, b3) {
    if (a2.delay === b3.delay) {
      if (a2.index === b3.index) {
        return 0;
      } else if (a2.index > b3.index) {
        return 1;
      } else {
        return -1;
      }
    } else if (a2.delay > b3.delay) {
      return 1;
    } else {
      return -1;
    }
  };
  return VirtualAction2;
}(AsyncAction);

// node_modules/rxjs/dist/esm5/internal/observable/empty.js
var EMPTY = new Observable(function(subscriber) {
  return subscriber.complete();
});

// node_modules/rxjs/dist/esm5/internal/util/isScheduler.js
function isScheduler(value) {
  return value && isFunction(value.schedule);
}

// node_modules/rxjs/dist/esm5/internal/util/args.js
function last(arr) {
  return arr[arr.length - 1];
}
function popScheduler(args) {
  return isScheduler(last(args)) ? args.pop() : void 0;
}

// node_modules/rxjs/dist/esm5/internal/util/isArrayLike.js
var isArrayLike = function(x3) {
  return x3 && typeof x3.length === "number" && typeof x3 !== "function";
};

// node_modules/rxjs/dist/esm5/internal/util/isPromise.js
function isPromise(value) {
  return isFunction(value === null || value === void 0 ? void 0 : value.then);
}

// node_modules/rxjs/dist/esm5/internal/util/isInteropObservable.js
function isInteropObservable(input) {
  return isFunction(input[observable]);
}

// node_modules/rxjs/dist/esm5/internal/util/isAsyncIterable.js
function isAsyncIterable(obj) {
  return Symbol.asyncIterator && isFunction(obj === null || obj === void 0 ? void 0 : obj[Symbol.asyncIterator]);
}

// node_modules/rxjs/dist/esm5/internal/util/throwUnobservableError.js
function createInvalidObservableTypeError(input) {
  return new TypeError("You provided " + (input !== null && typeof input === "object" ? "an invalid object" : "'" + input + "'") + " where a stream was expected. You can provide an Observable, Promise, ReadableStream, Array, AsyncIterable, or Iterable.");
}

// node_modules/rxjs/dist/esm5/internal/symbol/iterator.js
function getSymbolIterator() {
  if (typeof Symbol !== "function" || !Symbol.iterator) {
    return "@@iterator";
  }
  return Symbol.iterator;
}
var iterator = getSymbolIterator();

// node_modules/rxjs/dist/esm5/internal/util/isIterable.js
function isIterable(input) {
  return isFunction(input === null || input === void 0 ? void 0 : input[iterator]);
}

// node_modules/rxjs/dist/esm5/internal/util/isReadableStreamLike.js
function readableStreamLikeToAsyncGenerator(readableStream) {
  return __asyncGenerator(this, arguments, function readableStreamLikeToAsyncGenerator_1() {
    var reader, _a3, value, done;
    return __generator(this, function(_b) {
      switch (_b.label) {
        case 0:
          reader = readableStream.getReader();
          _b.label = 1;
        case 1:
          _b.trys.push([1, , 9, 10]);
          _b.label = 2;
        case 2:
          if (false)
            return [3, 8];
          return [4, __await(reader.read())];
        case 3:
          _a3 = _b.sent(), value = _a3.value, done = _a3.done;
          if (!done)
            return [3, 5];
          return [4, __await(void 0)];
        case 4:
          return [2, _b.sent()];
        case 5:
          return [4, __await(value)];
        case 6:
          return [4, _b.sent()];
        case 7:
          _b.sent();
          return [3, 2];
        case 8:
          return [3, 10];
        case 9:
          reader.releaseLock();
          return [7];
        case 10:
          return [2];
      }
    });
  });
}
function isReadableStreamLike(obj) {
  return isFunction(obj === null || obj === void 0 ? void 0 : obj.getReader);
}

// node_modules/rxjs/dist/esm5/internal/observable/innerFrom.js
function innerFrom(input) {
  if (input instanceof Observable) {
    return input;
  }
  if (input != null) {
    if (isInteropObservable(input)) {
      return fromInteropObservable(input);
    }
    if (isArrayLike(input)) {
      return fromArrayLike(input);
    }
    if (isPromise(input)) {
      return fromPromise(input);
    }
    if (isAsyncIterable(input)) {
      return fromAsyncIterable(input);
    }
    if (isIterable(input)) {
      return fromIterable(input);
    }
    if (isReadableStreamLike(input)) {
      return fromReadableStreamLike(input);
    }
  }
  throw createInvalidObservableTypeError(input);
}
function fromInteropObservable(obj) {
  return new Observable(function(subscriber) {
    var obs = obj[observable]();
    if (isFunction(obs.subscribe)) {
      return obs.subscribe(subscriber);
    }
    throw new TypeError("Provided object does not correctly implement Symbol.observable");
  });
}
function fromArrayLike(array) {
  return new Observable(function(subscriber) {
    for (var i2 = 0; i2 < array.length && !subscriber.closed; i2++) {
      subscriber.next(array[i2]);
    }
    subscriber.complete();
  });
}
function fromPromise(promise) {
  return new Observable(function(subscriber) {
    promise.then(function(value) {
      if (!subscriber.closed) {
        subscriber.next(value);
        subscriber.complete();
      }
    }, function(err) {
      return subscriber.error(err);
    }).then(null, reportUnhandledError);
  });
}
function fromIterable(iterable) {
  return new Observable(function(subscriber) {
    var e_1, _a3;
    try {
      for (var iterable_1 = __values(iterable), iterable_1_1 = iterable_1.next(); !iterable_1_1.done; iterable_1_1 = iterable_1.next()) {
        var value = iterable_1_1.value;
        subscriber.next(value);
        if (subscriber.closed) {
          return;
        }
      }
    } catch (e_1_1) {
      e_1 = { error: e_1_1 };
    } finally {
      try {
        if (iterable_1_1 && !iterable_1_1.done && (_a3 = iterable_1.return))
          _a3.call(iterable_1);
      } finally {
        if (e_1)
          throw e_1.error;
      }
    }
    subscriber.complete();
  });
}
function fromAsyncIterable(asyncIterable) {
  return new Observable(function(subscriber) {
    process2(asyncIterable, subscriber).catch(function(err) {
      return subscriber.error(err);
    });
  });
}
function fromReadableStreamLike(readableStream) {
  return fromAsyncIterable(readableStreamLikeToAsyncGenerator(readableStream));
}
function process2(asyncIterable, subscriber) {
  var asyncIterable_1, asyncIterable_1_1;
  var e_2, _a3;
  return __awaiter37(this, void 0, void 0, function() {
    var value, e_2_1;
    return __generator(this, function(_b) {
      switch (_b.label) {
        case 0:
          _b.trys.push([0, 5, 6, 11]);
          asyncIterable_1 = __asyncValues(asyncIterable);
          _b.label = 1;
        case 1:
          return [4, asyncIterable_1.next()];
        case 2:
          if (!(asyncIterable_1_1 = _b.sent(), !asyncIterable_1_1.done))
            return [3, 4];
          value = asyncIterable_1_1.value;
          subscriber.next(value);
          if (subscriber.closed) {
            return [2];
          }
          _b.label = 3;
        case 3:
          return [3, 1];
        case 4:
          return [3, 11];
        case 5:
          e_2_1 = _b.sent();
          e_2 = { error: e_2_1 };
          return [3, 11];
        case 6:
          _b.trys.push([6, , 9, 10]);
          if (!(asyncIterable_1_1 && !asyncIterable_1_1.done && (_a3 = asyncIterable_1.return)))
            return [3, 8];
          return [4, _a3.call(asyncIterable_1)];
        case 7:
          _b.sent();
          _b.label = 8;
        case 8:
          return [3, 10];
        case 9:
          if (e_2)
            throw e_2.error;
          return [7];
        case 10:
          return [7];
        case 11:
          subscriber.complete();
          return [2];
      }
    });
  });
}

// node_modules/rxjs/dist/esm5/internal/util/executeSchedule.js
function executeSchedule(parentSubscription, scheduler, work, delay2, repeat2) {
  if (delay2 === void 0) {
    delay2 = 0;
  }
  if (repeat2 === void 0) {
    repeat2 = false;
  }
  var scheduleSubscription = scheduler.schedule(function() {
    work();
    if (repeat2) {
      parentSubscription.add(this.schedule(null, delay2));
    } else {
      this.unsubscribe();
    }
  }, delay2);
  parentSubscription.add(scheduleSubscription);
  if (!repeat2) {
    return scheduleSubscription;
  }
}

// node_modules/rxjs/dist/esm5/internal/operators/observeOn.js
function observeOn(scheduler, delay2) {
  if (delay2 === void 0) {
    delay2 = 0;
  }
  return operate(function(source, subscriber) {
    source.subscribe(createOperatorSubscriber(subscriber, function(value) {
      return executeSchedule(subscriber, scheduler, function() {
        return subscriber.next(value);
      }, delay2);
    }, function() {
      return executeSchedule(subscriber, scheduler, function() {
        return subscriber.complete();
      }, delay2);
    }, function(err) {
      return executeSchedule(subscriber, scheduler, function() {
        return subscriber.error(err);
      }, delay2);
    }));
  });
}

// node_modules/rxjs/dist/esm5/internal/operators/subscribeOn.js
function subscribeOn(scheduler, delay2) {
  if (delay2 === void 0) {
    delay2 = 0;
  }
  return operate(function(source, subscriber) {
    subscriber.add(scheduler.schedule(function() {
      return source.subscribe(subscriber);
    }, delay2));
  });
}

// node_modules/rxjs/dist/esm5/internal/scheduled/scheduleObservable.js
function scheduleObservable(input, scheduler) {
  return innerFrom(input).pipe(subscribeOn(scheduler), observeOn(scheduler));
}

// node_modules/rxjs/dist/esm5/internal/scheduled/schedulePromise.js
function schedulePromise(input, scheduler) {
  return innerFrom(input).pipe(subscribeOn(scheduler), observeOn(scheduler));
}

// node_modules/rxjs/dist/esm5/internal/scheduled/scheduleArray.js
function scheduleArray(input, scheduler) {
  return new Observable(function(subscriber) {
    var i2 = 0;
    return scheduler.schedule(function() {
      if (i2 === input.length) {
        subscriber.complete();
      } else {
        subscriber.next(input[i2++]);
        if (!subscriber.closed) {
          this.schedule();
        }
      }
    });
  });
}

// node_modules/rxjs/dist/esm5/internal/scheduled/scheduleIterable.js
function scheduleIterable(input, scheduler) {
  return new Observable(function(subscriber) {
    var iterator2;
    executeSchedule(subscriber, scheduler, function() {
      iterator2 = input[iterator]();
      executeSchedule(subscriber, scheduler, function() {
        var _a3;
        var value;
        var done;
        try {
          _a3 = iterator2.next(), value = _a3.value, done = _a3.done;
        } catch (err) {
          subscriber.error(err);
          return;
        }
        if (done) {
          subscriber.complete();
        } else {
          subscriber.next(value);
        }
      }, 0, true);
    });
    return function() {
      return isFunction(iterator2 === null || iterator2 === void 0 ? void 0 : iterator2.return) && iterator2.return();
    };
  });
}

// node_modules/rxjs/dist/esm5/internal/scheduled/scheduleAsyncIterable.js
function scheduleAsyncIterable(input, scheduler) {
  if (!input) {
    throw new Error("Iterable cannot be null");
  }
  return new Observable(function(subscriber) {
    executeSchedule(subscriber, scheduler, function() {
      var iterator2 = input[Symbol.asyncIterator]();
      executeSchedule(subscriber, scheduler, function() {
        iterator2.next().then(function(result) {
          if (result.done) {
            subscriber.complete();
          } else {
            subscriber.next(result.value);
          }
        });
      }, 0, true);
    });
  });
}

// node_modules/rxjs/dist/esm5/internal/scheduled/scheduleReadableStreamLike.js
function scheduleReadableStreamLike(input, scheduler) {
  return scheduleAsyncIterable(readableStreamLikeToAsyncGenerator(input), scheduler);
}

// node_modules/rxjs/dist/esm5/internal/scheduled/scheduled.js
function scheduled(input, scheduler) {
  if (input != null) {
    if (isInteropObservable(input)) {
      return scheduleObservable(input, scheduler);
    }
    if (isArrayLike(input)) {
      return scheduleArray(input, scheduler);
    }
    if (isPromise(input)) {
      return schedulePromise(input, scheduler);
    }
    if (isAsyncIterable(input)) {
      return scheduleAsyncIterable(input, scheduler);
    }
    if (isIterable(input)) {
      return scheduleIterable(input, scheduler);
    }
    if (isReadableStreamLike(input)) {
      return scheduleReadableStreamLike(input, scheduler);
    }
  }
  throw createInvalidObservableTypeError(input);
}

// node_modules/rxjs/dist/esm5/internal/observable/from.js
function from(input, scheduler) {
  return scheduler ? scheduled(input, scheduler) : innerFrom(input);
}

// node_modules/rxjs/dist/esm5/internal/observable/of.js
function of() {
  var args = [];
  for (var _i = 0; _i < arguments.length; _i++) {
    args[_i] = arguments[_i];
  }
  var scheduler = popScheduler(args);
  return from(args, scheduler);
}

// node_modules/rxjs/dist/esm5/internal/observable/throwError.js
function throwError(errorOrErrorFactory, scheduler) {
  var errorFactory = isFunction(errorOrErrorFactory) ? errorOrErrorFactory : function() {
    return errorOrErrorFactory;
  };
  var init = function(subscriber) {
    return subscriber.error(errorFactory());
  };
  return new Observable(scheduler ? function(subscriber) {
    return scheduler.schedule(init, 0, subscriber);
  } : init);
}

// node_modules/rxjs/dist/esm5/internal/Notification.js
var NotificationKind;
(function(NotificationKind2) {
  NotificationKind2["NEXT"] = "N";
  NotificationKind2["ERROR"] = "E";
  NotificationKind2["COMPLETE"] = "C";
})(NotificationKind || (NotificationKind = {}));
var Notification = function() {
  function Notification2(kind, value, error) {
    this.kind = kind;
    this.value = value;
    this.error = error;
    this.hasValue = kind === "N";
  }
  Notification2.prototype.observe = function(observer) {
    return observeNotification(this, observer);
  };
  Notification2.prototype.do = function(nextHandler, errorHandler, completeHandler) {
    var _a3 = this, kind = _a3.kind, value = _a3.value, error = _a3.error;
    return kind === "N" ? nextHandler === null || nextHandler === void 0 ? void 0 : nextHandler(value) : kind === "E" ? errorHandler === null || errorHandler === void 0 ? void 0 : errorHandler(error) : completeHandler === null || completeHandler === void 0 ? void 0 : completeHandler();
  };
  Notification2.prototype.accept = function(nextOrObserver, error, complete) {
    var _a3;
    return isFunction((_a3 = nextOrObserver) === null || _a3 === void 0 ? void 0 : _a3.next) ? this.observe(nextOrObserver) : this.do(nextOrObserver, error, complete);
  };
  Notification2.prototype.toObservable = function() {
    var _a3 = this, kind = _a3.kind, value = _a3.value, error = _a3.error;
    var result = kind === "N" ? of(value) : kind === "E" ? throwError(function() {
      return error;
    }) : kind === "C" ? EMPTY : 0;
    if (!result) {
      throw new TypeError("Unexpected notification kind " + kind);
    }
    return result;
  };
  Notification2.createNext = function(value) {
    return new Notification2("N", value);
  };
  Notification2.createError = function(err) {
    return new Notification2("E", void 0, err);
  };
  Notification2.createComplete = function() {
    return Notification2.completeNotification;
  };
  Notification2.completeNotification = new Notification2("C");
  return Notification2;
}();
function observeNotification(notification, observer) {
  var _a3, _b, _c;
  var _d = notification, kind = _d.kind, value = _d.value, error = _d.error;
  if (typeof kind !== "string") {
    throw new TypeError('Invalid notification, missing "kind"');
  }
  kind === "N" ? (_a3 = observer.next) === null || _a3 === void 0 ? void 0 : _a3.call(observer, value) : kind === "E" ? (_b = observer.error) === null || _b === void 0 ? void 0 : _b.call(observer, error) : (_c = observer.complete) === null || _c === void 0 ? void 0 : _c.call(observer);
}

// node_modules/rxjs/dist/esm5/internal/util/EmptyError.js
var EmptyError = createErrorClass(function(_super) {
  return function EmptyErrorImpl() {
    _super(this);
    this.name = "EmptyError";
    this.message = "no elements in sequence";
  };
});

// node_modules/rxjs/dist/esm5/internal/util/ArgumentOutOfRangeError.js
var ArgumentOutOfRangeError = createErrorClass(function(_super) {
  return function ArgumentOutOfRangeErrorImpl() {
    _super(this);
    this.name = "ArgumentOutOfRangeError";
    this.message = "argument out of range";
  };
});

// node_modules/rxjs/dist/esm5/internal/util/NotFoundError.js
var NotFoundError = createErrorClass(function(_super) {
  return function NotFoundErrorImpl(message) {
    _super(this);
    this.name = "NotFoundError";
    this.message = message;
  };
});

// node_modules/rxjs/dist/esm5/internal/util/SequenceError.js
var SequenceError = createErrorClass(function(_super) {
  return function SequenceErrorImpl(message) {
    _super(this);
    this.name = "SequenceError";
    this.message = message;
  };
});

// node_modules/rxjs/dist/esm5/internal/util/isDate.js
function isValidDate(value) {
  return value instanceof Date && !isNaN(value);
}

// node_modules/rxjs/dist/esm5/internal/operators/timeout.js
var TimeoutError = createErrorClass(function(_super) {
  return function TimeoutErrorImpl(info) {
    if (info === void 0) {
      info = null;
    }
    _super(this);
    this.message = "Timeout has occurred";
    this.name = "TimeoutError";
    this.info = info;
  };
});

// node_modules/rxjs/dist/esm5/internal/util/mapOneOrManyArgs.js
var isArray = Array.isArray;

// node_modules/rxjs/dist/esm5/internal/util/argsArgArrayOrObject.js
var isArray2 = Array.isArray;
var objectProto = Object.prototype;

// node_modules/rxjs/dist/esm5/internal/observable/timer.js
function timer(dueTime, intervalOrScheduler, scheduler) {
  if (dueTime === void 0) {
    dueTime = 0;
  }
  if (scheduler === void 0) {
    scheduler = async;
  }
  var intervalDuration = -1;
  if (intervalOrScheduler != null) {
    if (isScheduler(intervalOrScheduler)) {
      scheduler = intervalOrScheduler;
    } else {
      intervalDuration = intervalOrScheduler;
    }
  }
  return new Observable(function(subscriber) {
    var due = isValidDate(dueTime) ? +dueTime - scheduler.now() : dueTime;
    if (due < 0) {
      due = 0;
    }
    var n2 = 0;
    return scheduler.schedule(function() {
      if (!subscriber.closed) {
        subscriber.next(n2++);
        if (0 <= intervalDuration) {
          this.schedule(void 0, intervalDuration);
        } else {
          subscriber.complete();
        }
      }
    }, due);
  });
}

// node_modules/rxjs/dist/esm5/internal/observable/never.js
var NEVER = new Observable(noop);

// node_modules/rxjs/dist/esm5/internal/util/argsOrArgArray.js
var isArray3 = Array.isArray;

// node_modules/rxjs/dist/esm5/internal/operators/retry.js
function retry(configOrCount) {
  if (configOrCount === void 0) {
    configOrCount = Infinity;
  }
  var config2;
  if (configOrCount && typeof configOrCount === "object") {
    config2 = configOrCount;
  } else {
    config2 = {
      count: configOrCount
    };
  }
  var _a3 = config2.count, count2 = _a3 === void 0 ? Infinity : _a3, delay2 = config2.delay, _b = config2.resetOnSuccess, resetOnSuccess = _b === void 0 ? false : _b;
  return count2 <= 0 ? identity : operate(function(source, subscriber) {
    var soFar = 0;
    var innerSub;
    var subscribeForRetry = function() {
      var syncUnsub = false;
      innerSub = source.subscribe(createOperatorSubscriber(subscriber, function(value) {
        if (resetOnSuccess) {
          soFar = 0;
        }
        subscriber.next(value);
      }, void 0, function(err) {
        if (soFar++ < count2) {
          var resub_1 = function() {
            if (innerSub) {
              innerSub.unsubscribe();
              innerSub = null;
              subscribeForRetry();
            } else {
              syncUnsub = true;
            }
          };
          if (delay2 != null) {
            var notifier = typeof delay2 === "number" ? timer(delay2) : innerFrom(delay2(err, soFar));
            var notifierSubscriber_1 = createOperatorSubscriber(subscriber, function() {
              notifierSubscriber_1.unsubscribe();
              resub_1();
            }, function() {
              subscriber.complete();
            });
            notifier.subscribe(notifierSubscriber_1);
          } else {
            resub_1();
          }
        } else {
          subscriber.error(err);
        }
      }));
      if (syncUnsub) {
        innerSub.unsubscribe();
        innerSub = null;
        subscribeForRetry();
      }
    };
    subscribeForRetry();
  });
}

// node_modules/rxjs/dist/esm5/internal/operators/timeInterval.js
var TimeInterval = function() {
  function TimeInterval2(value, interval2) {
    this.value = value;
    this.interval = interval2;
  }
  return TimeInterval2;
}();

// node_modules/@taquito/michelson-encoder/dist/taquito-michelson-encoder.es6.js
var import_fast_json_stable_stringify = __toESM(require_fast_json_stable_stringify());
var _a$1;
var InvalidMapTypeError = class extends TaquitoError {
  constructor(mapType, reason) {
    super();
    this.mapType = mapType;
    this.reason = reason;
    this.message = `The map type '${JSON.stringify(mapType)}' is invalid. Reason: ${reason}.`;
    this.name = "InvalidMapTypeError";
  }
};
var michelsonMapTypeSymbol = Symbol.for("taquito-michelson-map-type-symbol");
function validateMapType(value) {
  if (!("prim" in value)) {
    throw new InvalidMapTypeError(value, `Missing 'prim' field`);
  }
  if (!["map", "big_map"].includes(value.prim)) {
    throw new InvalidMapTypeError(value, `The prim field should be 'map' or 'big_map'`);
  }
  if (!("args" in value)) {
    throw new InvalidMapTypeError(value, `Missing 'args' field`);
  }
  if (!Array.isArray(value.args)) {
    throw new InvalidMapTypeError(value, `The 'args' field should be an array`);
  }
  if (value.args.length !== 2) {
    throw new InvalidMapTypeError(value, `The 'args' field should have 2 elements`);
  }
}
var MapTypecheckError = class extends TaquitoError {
  constructor(value, type, objectType, reason) {
    super();
    this.value = value;
    this.type = type;
    this.reason = reason;
    this.name = "MapTypecheckError";
    this.message = `The ${objectType} provided: ${JSON.stringify(value)} is not compatible with the expected michelson type: ${JSON.stringify(type)}. Reason: ${JSON.stringify(reason)}.`;
    this.name = "MapTypecheckError";
  }
};
var MichelsonMap = class _MichelsonMap {
  /**
   * @param mapType If specified key and value will be type-checked before being added to the map
   *
   * @example new MichelsonMap({ prim: "map", args: [{prim: "string"}, {prim: "int"}]})
   */
  constructor(mapType) {
    this.valueMap = /* @__PURE__ */ new Map();
    this.keyMap = /* @__PURE__ */ new Map();
    this[_a$1] = true;
    if (mapType) {
      this.setType(mapType);
    }
  }
  // Used to check if an object is a michelson map.
  // Using instanceof was not working for project that had multiple instance of taquito dependencies
  // as the class constructor is different
  static isMichelsonMap(obj) {
    return obj && obj[michelsonMapTypeSymbol] === true;
  }
  setType(mapType) {
    validateMapType(mapType);
    this.keySchema = new Schema(mapType.args[0]);
    this.valueSchema = new Schema(mapType.args[1]);
  }
  removeType() {
    this.keySchema = void 0;
    this.valueSchema = void 0;
  }
  static fromLiteral(obj, mapType) {
    const map2 = new _MichelsonMap(mapType);
    Object.keys(obj).forEach((key) => {
      map2.set(key, obj[key]);
    });
    return map2;
  }
  typecheckKey(key) {
    if (!this.keySchema) {
      return;
    }
    this.keySchema.Typecheck(key);
  }
  typecheckValue(value) {
    if (!this.valueSchema) {
      return;
    }
    this.valueSchema.Typecheck(value);
  }
  /**
   * @throws {@link MapTypecheckError} when the argument passed does not match the expected schema for value
   */
  assertTypecheckValue(value) {
    try {
      this.typecheckValue(value);
    } catch (e) {
      throw new MapTypecheckError(value, this.valueSchema, "value", e);
    }
  }
  /**
   * @throws {@link MapTypecheckError} when the argument passed does not match the expected schema for key
   */
  assertTypecheckKey(key) {
    try {
      this.typecheckKey(key);
    } catch (e) {
      throw new MapTypecheckError(key, this.keySchema, "key", e);
    }
  }
  serializeDeterministically(key) {
    return (0, import_fast_json_stable_stringify.default)(key);
  }
  *keys() {
    for (const [key] of this.entries()) {
      yield key;
    }
  }
  *values() {
    for (const [, value] of this.entries()) {
      yield value;
    }
  }
  *entries() {
    for (const key of this.valueMap.keys()) {
      yield [this.keyMap.get(key), this.valueMap.get(key)];
    }
  }
  get(key) {
    this.assertTypecheckKey(key);
    const strKey = this.serializeDeterministically(key);
    return this.valueMap.get(strKey);
  }
  /**
   *
   * @description Set a key and a value in the MichelsonMap. If the key already exists, override the current value.
   *
   * @example map.set("myKey", "myValue") // Using a string as key
   *
   * @example map.set({0: "test", 1: "test1"}, "myValue") // Using a pair as key
   *
   * @warn The same key can be represented in multiple ways, depending on the type of the key. This duplicate key situation will cause a runtime error (duplicate key) when sending the map data to the Tezos RPC node.
   *
   * For example, consider a contract with a map whose key is of type boolean.  If you set the following values in MichelsonMap: map.set(false, "myValue") and map.set(null, "myValue").
   *
   * You will get two unique entries in the MichelsonMap. These values will both be evaluated as falsy by the MichelsonEncoder and ultimately rejected by the Tezos RPC.
   */
  set(key, value) {
    this.assertTypecheckKey(key);
    this.assertTypecheckValue(value);
    const strKey = this.serializeDeterministically(key);
    this.keyMap.set(strKey, key);
    this.valueMap.set(strKey, value);
  }
  delete(key) {
    this.assertTypecheckKey(key);
    this.keyMap.delete(this.serializeDeterministically(key));
    this.valueMap.delete(this.serializeDeterministically(key));
  }
  has(key) {
    this.assertTypecheckKey(key);
    const strKey = this.serializeDeterministically(key);
    return this.keyMap.has(strKey) && this.valueMap.has(strKey);
  }
  clear() {
    this.keyMap.clear();
    this.valueMap.clear();
  }
  get size() {
    return this.keyMap.size;
  }
  forEach(cb) {
    for (const [key, value] of this.entries()) {
      cb(value, key, this);
    }
  }
};
_a$1 = michelsonMapTypeSymbol;
var TokenValidationError = class extends TaquitoError {
  constructor(value, token, baseMessage) {
    super();
    this.value = value;
    this.token = token;
    this.name = "TokenValidationError";
    const annot = this.token.annot();
    const annotText = annot ? `[${annot}] ` : "";
    this.message = `${annotText}${baseMessage}`;
  }
};
var Token = class {
  constructor(val, idx, fac) {
    this.val = val;
    this.idx = idx;
    this.fac = fac;
    this.createToken = this.fac;
  }
  typeWithoutAnnotations() {
    const handleMichelsonExpression = (val) => {
      if (typeof val === "object") {
        if (Array.isArray(val)) {
          const array = val;
          return array.map((item) => handleMichelsonExpression(item));
        }
        const extended = val;
        if (extended.args) {
          return {
            prim: extended.prim,
            args: extended.args.map((x3) => handleMichelsonExpression(x3))
          };
        } else {
          return {
            prim: extended.prim
          };
        }
      }
      return val;
    };
    const handleMichelsonExtended = (val) => {
      if (val.args) {
        return {
          prim: val.prim,
          args: val.args.map((x3) => handleMichelsonExpression(x3))
        };
      } else {
        return {
          prim: val.prim
        };
      }
    };
    return handleMichelsonExtended(this.val);
  }
  annot() {
    return (Array.isArray(this.val.annots) && this.val.annots.length > 0 ? this.val.annots[0] : String(this.idx)).replace(/(%|:)(_Liq_entry_)?/, "");
  }
  hasAnnotations() {
    return Array.isArray(this.val.annots) && this.val.annots.length;
  }
  get tokenVal() {
    return this.val;
  }
  ExtractSignature() {
    return [[this.ExtractSchema()]];
  }
};
var ComparableToken = class extends Token {
  compare(o1, o2) {
    if (o1 === o2) {
      return 0;
    }
    return o1 < o2 ? -1 : 1;
  }
};
var BigMapValidationError = class extends TokenValidationError {
  constructor(value, token, message) {
    super(value, token, message);
    this.value = value;
    this.token = token;
    this.name = "BigMapValidationError";
  }
};
var BigMapToken = class _BigMapToken extends Token {
  constructor(val, idx, fac) {
    super(val, idx, fac);
    this.val = val;
    this.idx = idx;
    this.fac = fac;
  }
  get ValueSchema() {
    return this.createToken(this.val.args[1], 0);
  }
  get KeySchema() {
    return this.createToken(this.val.args[0], 0);
  }
  /**
   * @deprecated ExtractSchema has been deprecated in favor of generateSchema
   *
   */
  ExtractSchema() {
    return {
      big_map: {
        key: this.KeySchema.ExtractSchema(),
        value: this.ValueSchema.ExtractSchema()
      }
    };
  }
  generateSchema() {
    return {
      __michelsonType: _BigMapToken.prim,
      schema: {
        key: this.KeySchema.generateSchema(),
        value: this.ValueSchema.generateSchema()
      }
    };
  }
  /**
   * @throws {@link BigMapValidationError}
   */
  validate(value) {
    if (!MichelsonMap.isMichelsonMap(value)) {
      throw new BigMapValidationError(value, this, `Value ${JSON.stringify(value)} is not a MichelsonMap`);
    }
  }
  objLitToMichelsonMap(val) {
    if (val instanceof MichelsonMap)
      return val;
    if (typeof val === "object") {
      if (Object.keys(val).length === 0) {
        return new MichelsonMap();
      } else {
        return MichelsonMap.fromLiteral(val);
      }
    }
    return val;
  }
  /**
   * @throws {@link BigMapValidationError}
   */
  Encode(args) {
    const val = this.objLitToMichelsonMap(args.pop());
    this.validate(val);
    return Array.from(val.keys()).sort((a2, b3) => this.KeySchema.compare(a2, b3)).map((key) => {
      return {
        prim: "Elt",
        args: [this.KeySchema.EncodeObject(key), this.ValueSchema.EncodeObject(val.get(key))]
      };
    });
  }
  /**
   * @throws {@link BigMapValidationError}
   */
  EncodeObject(args, semantic) {
    const val = this.objLitToMichelsonMap(args);
    this.validate(val);
    if (semantic && semantic[_BigMapToken.prim]) {
      return semantic[_BigMapToken.prim](val, this.val);
    }
    return Array.from(val.keys()).sort((a2, b3) => this.KeySchema.compare(a2, b3)).map((key) => {
      return {
        prim: "Elt",
        args: [this.KeySchema.EncodeObject(key), this.ValueSchema.EncodeObject(val.get(key))]
      };
    });
  }
  /**
   * @throws {@link InvalidMapTypeError} when the argument passed to val is an array but not a valid map type
   * @throws {@link BigMapValidationError} when the value is invalid
   */
  Execute(val, semantic) {
    if (semantic && semantic[_BigMapToken.prim]) {
      return semantic[_BigMapToken.prim](val, this.val);
    }
    if (Array.isArray(val)) {
      const map2 = new MichelsonMap(this.val);
      val.forEach((current) => {
        map2.set(this.KeySchema.ToKey(current.args[0]), this.ValueSchema.Execute(current.args[1]));
      });
      return map2;
    } else if ("int" in val) {
      return val.int;
    } else {
      throw new BigMapValidationError(val, this, `Big map is expecting either an array (Athens) or an object with an int property (Babylon). Got ${JSON.stringify(val)}`);
    }
  }
  findAndReturnTokens(tokenToFind, tokens2) {
    if (_BigMapToken.prim === tokenToFind) {
      tokens2.push(this);
    }
    this.KeySchema.findAndReturnTokens(tokenToFind, tokens2);
    this.ValueSchema.findAndReturnTokens(tokenToFind, tokens2);
    return tokens2;
  }
};
BigMapToken.prim = "big_map";
var OrValidationError = class extends TokenValidationError {
  constructor(value, token, message) {
    super(value, token, message);
    this.value = value;
    this.token = token;
    this.name = "OrValidationError";
  }
};
var OrToken = class _OrToken extends ComparableToken {
  constructor(val, idx, fac) {
    super(val, idx, fac);
    this.val = val;
    this.idx = idx;
    this.fac = fac;
  }
  Encode(args) {
    const label = args[args.length - 1];
    const leftToken = this.createToken(this.val.args[0], this.idx);
    let keyCount = 1;
    if (leftToken instanceof _OrToken) {
      keyCount = Object.keys(leftToken.ExtractSchema()).length;
    }
    const rightToken = this.createToken(this.val.args[1], this.idx + keyCount);
    if (String(leftToken.annot()) === String(label) && !(leftToken instanceof _OrToken)) {
      args.pop();
      return { prim: "Left", args: [leftToken.Encode(args)] };
    } else if (String(rightToken.annot()) === String(label) && !(rightToken instanceof _OrToken)) {
      args.pop();
      return { prim: "Right", args: [rightToken.Encode(args)] };
    } else {
      if (leftToken instanceof _OrToken) {
        const val = leftToken.Encode(args);
        if (val) {
          return { prim: "Left", args: [val] };
        }
      }
      if (rightToken instanceof _OrToken) {
        const val = rightToken.Encode(args);
        if (val) {
          return { prim: "Right", args: [val] };
        }
      }
      return null;
    }
  }
  ExtractSignature() {
    const leftToken = this.createToken(this.val.args[0], this.idx);
    let keyCount = 1;
    if (leftToken instanceof _OrToken) {
      keyCount = Object.keys(leftToken.ExtractSchema()).length;
    }
    const rightToken = this.createToken(this.val.args[1], this.idx + keyCount);
    const newSig = [];
    if (leftToken instanceof _OrToken) {
      newSig.push(...leftToken.ExtractSignature());
    } else {
      for (const sig of leftToken.ExtractSignature()) {
        newSig.push([leftToken.annot(), ...sig]);
      }
    }
    if (rightToken instanceof _OrToken) {
      newSig.push(...rightToken.ExtractSignature());
    } else {
      for (const sig of rightToken.ExtractSignature()) {
        newSig.push([rightToken.annot(), ...sig]);
      }
    }
    return newSig;
  }
  /**
   * @throws {@link OrValidationError}
   */
  EncodeObject(args, semantic) {
    this.validateJavascriptObject(args);
    const label = Object.keys(args)[0];
    const leftToken = this.createToken(this.val.args[0], this.idx);
    let keyCount = 1;
    if (leftToken instanceof _OrToken) {
      keyCount = Object.keys(leftToken.ExtractSchema()).length;
    }
    const rightToken = this.createToken(this.val.args[1], this.idx + keyCount);
    if (String(leftToken.annot()) === String(label) && !(leftToken instanceof _OrToken)) {
      return { prim: "Left", args: [leftToken.EncodeObject(args[label], semantic)] };
    } else if (String(rightToken.annot()) === String(label) && !(rightToken instanceof _OrToken)) {
      return { prim: "Right", args: [rightToken.EncodeObject(args[label], semantic)] };
    } else {
      if (leftToken instanceof _OrToken) {
        const val = leftToken.EncodeObject(args, semantic);
        if (val) {
          return { prim: "Left", args: [val] };
        }
      }
      if (rightToken instanceof _OrToken) {
        const val = rightToken.EncodeObject(args, semantic);
        if (val) {
          return { prim: "Right", args: [val] };
        }
      }
      return null;
    }
  }
  /**
   * @throws {@link OrValidationError}
   */
  validateJavascriptObject(args) {
    if (typeof args !== "object" || Array.isArray(args) || args === null || Object.keys(args).length !== 1) {
      throw new OrValidationError(args, this, `EncodeObject expects an object with a single key but got: ${JSON.stringify(args)}`);
    }
  }
  /**
   * @throws {@link OrValidationError}
   */
  Execute(val, semantics) {
    const leftToken = this.createToken(this.val.args[0], this.idx);
    let keyCount = 1;
    if (leftToken instanceof _OrToken) {
      keyCount = Object.keys(leftToken.ExtractSchema()).length;
    }
    const rightToken = this.createToken(this.val.args[1], this.idx + keyCount);
    if (val.prim === "Right") {
      if (rightToken instanceof _OrToken) {
        return rightToken.Execute(val.args[0], semantics);
      } else {
        return {
          [rightToken.annot()]: rightToken.Execute(val.args[0], semantics)
        };
      }
    } else if (val.prim === "Left") {
      if (leftToken instanceof _OrToken) {
        return leftToken.Execute(val.args[0], semantics);
      }
      return {
        [leftToken.annot()]: leftToken.Execute(val.args[0], semantics)
      };
    } else {
      throw new OrValidationError(val, this, `Was expecting Left or Right prim but got: ${JSON.stringify(val.prim)}`);
    }
  }
  traversal(getLeftValue, getRightValue, concat5) {
    const leftToken = this.createToken(this.val.args[0], this.idx);
    let keyCount = 1;
    let leftValue;
    if (leftToken instanceof _OrToken) {
      leftValue = getLeftValue(leftToken);
      keyCount = Object.keys(leftToken.ExtractSchema()).length;
    } else {
      leftValue = { [leftToken.annot()]: getLeftValue(leftToken) };
    }
    const rightToken = this.createToken(this.val.args[1], this.idx + keyCount);
    let rightValue;
    if (rightToken instanceof _OrToken) {
      rightValue = getRightValue(rightToken);
    } else {
      rightValue = { [rightToken.annot()]: getRightValue(rightToken) };
    }
    const res = concat5(leftValue, rightValue);
    return res;
  }
  /**
   * @deprecated ExtractSchema has been deprecated in favor of generateSchema
   *
   */
  ExtractSchema() {
    return this.traversal((leftToken) => leftToken.ExtractSchema(), (rightToken) => rightToken.ExtractSchema(), (leftValue, rightValue) => Object.assign(Object.assign({}, leftValue), rightValue));
  }
  generateSchema() {
    return {
      __michelsonType: _OrToken.prim,
      schema: this.traversal((leftToken) => {
        if (leftToken instanceof _OrToken) {
          return leftToken.generateSchema().schema;
        } else {
          return leftToken.generateSchema();
        }
      }, (rightToken) => {
        if (rightToken instanceof _OrToken) {
          return rightToken.generateSchema().schema;
        } else {
          return rightToken.generateSchema();
        }
      }, (leftValue, rightValue) => Object.assign(Object.assign({}, leftValue), rightValue))
    };
  }
  findToken(label) {
    const leftToken = this.createToken(this.val.args[0], this.idx);
    let keyCount = 1;
    if (leftToken instanceof _OrToken) {
      keyCount = Object.keys(leftToken.ExtractSchema()).length;
    }
    const rightToken = this.createToken(this.val.args[1], this.idx + keyCount);
    if (String(leftToken.annot()) === String(label) && !(leftToken instanceof _OrToken) && leftToken instanceof ComparableToken) {
      return leftToken;
    } else if (String(rightToken.annot()) === String(label) && !(rightToken instanceof _OrToken) && rightToken instanceof ComparableToken) {
      return rightToken;
    } else {
      if (leftToken instanceof _OrToken) {
        const tok = leftToken.findToken(label);
        if (tok) {
          return tok;
        }
      }
      if (rightToken instanceof _OrToken) {
        const tok = rightToken.findToken(label);
        if (tok) {
          return tok;
        }
      }
      return null;
    }
  }
  compare(val1, val2) {
    const labelVal1 = Object.keys(val1)[0];
    const labelVal2 = Object.keys(val2)[0];
    if (labelVal1 === labelVal2) {
      const token = this.findToken(labelVal1);
      if (token instanceof ComparableToken) {
        return token.compare(val1[labelVal1], val2[labelVal1]);
      }
    } else {
      const encoded1 = JSON.stringify(this.EncodeObject(val1));
      const encoded2 = JSON.stringify(this.EncodeObject(val2));
      return encoded1 < encoded2 ? -1 : 1;
    }
  }
  ToKey(val) {
    return this.Execute(val);
  }
  ToBigMapKey(val) {
    return {
      key: this.EncodeObject(val),
      type: this.typeWithoutAnnotations()
    };
  }
  findAndReturnTokens(tokenToFind, tokens2) {
    if (_OrToken.prim === tokenToFind) {
      tokens2.push(this);
    }
    this.traversal((leftToken) => leftToken.findAndReturnTokens(tokenToFind, tokens2), (rightToken) => rightToken.findAndReturnTokens(tokenToFind, tokens2), (leftValue, rightValue) => Object.assign(Object.assign({}, leftValue), rightValue));
    return tokens2;
  }
};
OrToken.prim = "or";
var TokenArgumentValidationError = class extends TaquitoError {
  constructor(message) {
    super(message);
    this.message = message;
    this.name = "TokenArgumentValidationError";
  }
};
var TokenComparisonError = class extends TaquitoError {
  constructor(val1, val2) {
    super();
    this.val1 = val1;
    this.val2 = val2;
    this.name = "TokenComparisonError";
    this.message = `Tokens ${JSON.stringify(val1)} and ${JSON.stringify(val2)} are not comparable`;
  }
};
function collapse$1(val, prim = PairToken.prim) {
  if (Array.isArray(val)) {
    return collapse$1({
      prim,
      args: val
    }, prim);
  }
  if (val.args === void 0) {
    throw new TokenArgumentValidationError(`The value ${JSON.stringify(val)} is an invalid PairToken with no arguments, a pair must have two or more arguments.`);
  }
  if (val.args.length > 2) {
    return [
      val.args[0],
      {
        prim,
        args: val.args.slice(1)
      }
    ];
  }
  return [val.args[0], val.args[1]];
}
var PairToken = class _PairToken extends ComparableToken {
  constructor(val, idx, fac) {
    super(Array.isArray(val) ? {
      prim: _PairToken.prim,
      args: val
    } : val.prim ? val : {
      prim: _PairToken.prim,
      args: val
    }, idx, fac);
  }
  args() {
    return collapse$1(this.val);
  }
  tokens() {
    let cnt = 0;
    return this.args().map((a2) => {
      const tok = this.createToken(a2, this.idx + cnt);
      if (tok instanceof _PairToken) {
        cnt += Object.keys(tok.ExtractSchema()).length;
      } else {
        cnt++;
      }
      return tok;
    });
  }
  Encode(args) {
    return {
      prim: "Pair",
      args: this.tokens().map((t) => t.Encode(args))
    };
  }
  ExtractSignature() {
    const args = this.args();
    const leftToken = this.createToken(args[0], this.idx);
    let keyCount = 1;
    if (leftToken instanceof OrToken) {
      keyCount = Object.keys(leftToken.ExtractSchema()).length;
    }
    const rightToken = this.createToken(args[1], this.idx + keyCount);
    const newSig = [];
    for (const leftSig of leftToken.ExtractSignature()) {
      for (const rightSig of rightToken.ExtractSignature()) {
        newSig.push([...leftSig, ...rightSig]);
      }
    }
    return newSig;
  }
  ToBigMapKey(val) {
    return {
      key: this.EncodeObject(val),
      type: this.typeWithoutAnnotations()
    };
  }
  ToKey(val) {
    return this.Execute(val);
  }
  EncodeObject(args, semantic) {
    const [leftToken, rightToken] = this.tokens();
    let leftValue;
    if (leftToken instanceof _PairToken && !leftToken.hasAnnotations()) {
      leftValue = args;
    } else {
      leftValue = args[leftToken.annot()];
    }
    let rightValue;
    if (rightToken instanceof _PairToken && !rightToken.hasAnnotations()) {
      rightValue = args;
    } else {
      rightValue = args[rightToken.annot()];
    }
    return {
      prim: "Pair",
      args: [
        leftToken.EncodeObject(leftValue, semantic),
        rightToken.EncodeObject(rightValue, semantic)
      ]
    };
  }
  traversal(getLeftValue, getRightValue) {
    const args = this.args();
    const leftToken = this.createToken(args[0], this.idx);
    let keyCount = 1;
    let leftValue;
    if (leftToken instanceof _PairToken && !leftToken.hasAnnotations()) {
      leftValue = getLeftValue(leftToken);
      if (leftToken instanceof _PairToken) {
        keyCount = Object.keys(leftToken.ExtractSchema()).length;
      }
    } else {
      leftValue = { [leftToken.annot()]: getLeftValue(leftToken) };
    }
    const rightToken = this.createToken(args[1], this.idx + keyCount);
    let rightValue;
    if (rightToken instanceof _PairToken && !rightToken.hasAnnotations()) {
      rightValue = getRightValue(rightToken);
    } else {
      rightValue = { [rightToken.annot()]: getRightValue(rightToken) };
    }
    const res = Object.assign(Object.assign({}, leftValue), rightValue);
    return res;
  }
  Execute(val, semantics) {
    const args = collapse$1(val, "Pair");
    return this.traversal((leftToken) => leftToken.Execute(args[0], semantics), (rightToken) => rightToken.Execute(args[1], semantics));
  }
  /**
   * @deprecated ExtractSchema has been deprecated in favor of generateSchema
   *
   */
  ExtractSchema() {
    return this.traversal((leftToken) => leftToken.ExtractSchema(), (rightToken) => rightToken.ExtractSchema());
  }
  generateSchema() {
    return {
      __michelsonType: _PairToken.prim,
      schema: this.traversal((leftToken) => {
        if (leftToken instanceof _PairToken && !leftToken.hasAnnotations()) {
          return leftToken.generateSchema().schema;
        } else {
          return leftToken.generateSchema();
        }
      }, (rightToken) => {
        if (rightToken instanceof _PairToken && !rightToken.hasAnnotations()) {
          return rightToken.generateSchema().schema;
        } else {
          return rightToken.generateSchema();
        }
      })
    };
  }
  /**
   * @throws {@link TokenComparisonError}
   */
  compare(val1, val2) {
    const [leftToken, rightToken] = this.tokens();
    const getValue = (token, args) => {
      if (token instanceof _PairToken && !token.hasAnnotations()) {
        return args;
      } else {
        return args[token.annot()];
      }
    };
    if (leftToken instanceof ComparableToken && rightToken instanceof ComparableToken) {
      const result = leftToken.compare(getValue(leftToken, val1), getValue(leftToken, val2));
      if (result === 0) {
        return rightToken.compare(getValue(rightToken, val1), getValue(rightToken, val2));
      }
      return result;
    }
    throw new TokenComparisonError(val1, val2);
  }
  findAndReturnTokens(tokenToFind, tokens2) {
    if (_PairToken.prim === tokenToFind) {
      tokens2.push(this);
    }
    this.tokens().map((t) => t.findAndReturnTokens(tokenToFind, tokens2));
    return tokens2;
  }
};
PairToken.prim = "pair";
var NatValidationError = class extends TokenValidationError {
  constructor(value, token, message) {
    super(value, token, message);
    this.value = value;
    this.token = token;
    this.name = "NatValidationError";
  }
};
var NatToken = class _NatToken extends ComparableToken {
  constructor(val, idx, fac) {
    super(val, idx, fac);
    this.val = val;
    this.idx = idx;
    this.fac = fac;
  }
  Execute(val) {
    return new bignumber_default(val[Object.keys(val)[0]]);
  }
  /**
   * @throws {@link NatValidationError}
   */
  Encode(args) {
    const val = args.pop();
    this.validate(val);
    return { int: new bignumber_default(val).toFixed() };
  }
  /**
   * @throws {@link NatValidationError}
   */
  validate(val) {
    const bigNumber = new bignumber_default(val);
    if (bigNumber.isNaN()) {
      throw new NatValidationError(val, this, `Value is not a number: ${JSON.stringify(val)}`);
    }
    if (bigNumber.isNegative()) {
      throw new NatValidationError(val, this, `Value cannot be negative: ${JSON.stringify(val)}`);
    }
  }
  /**
   * @throws {@link NatValidationError}
   */
  EncodeObject(val, semantic) {
    this.validate(val);
    if (semantic && semantic[_NatToken.prim]) {
      return semantic[_NatToken.prim](val);
    }
    return { int: new bignumber_default(val).toFixed() };
  }
  /**
   * @deprecated ExtractSchema has been deprecated in favor of generateSchema
   *
   */
  ExtractSchema() {
    return _NatToken.prim;
  }
  generateSchema() {
    return {
      __michelsonType: _NatToken.prim,
      schema: _NatToken.prim
    };
  }
  ToBigMapKey(val) {
    return {
      key: { int: String(val) },
      type: { prim: _NatToken.prim }
    };
  }
  ToKey({ int }) {
    return new bignumber_default(int);
  }
  compare(nat1, nat2) {
    const o1 = Number(nat1);
    const o2 = Number(nat2);
    if (o1 === o2) {
      return 0;
    }
    return o1 < o2 ? -1 : 1;
  }
  findAndReturnTokens(tokenToFind, tokens2) {
    if (_NatToken.prim === tokenToFind) {
      tokens2.push(this);
    }
    return tokens2;
  }
};
NatToken.prim = "nat";
var StringToken = class _StringToken extends ComparableToken {
  constructor(val, idx, fac) {
    super(val, idx, fac);
    this.val = val;
    this.idx = idx;
    this.fac = fac;
  }
  Execute(val) {
    return val[Object.keys(val)[0]];
  }
  /**
   * @deprecated ExtractSchema has been deprecated in favor of generateSchema
   *
   */
  ExtractSchema() {
    return _StringToken.prim;
  }
  generateSchema() {
    return {
      __michelsonType: _StringToken.prim,
      schema: _StringToken.prim
    };
  }
  Encode(args) {
    const val = args.pop();
    return { string: val };
  }
  EncodeObject(val, semantic) {
    if (semantic && semantic[_StringToken.prim]) {
      return semantic[_StringToken.prim](val);
    }
    return { string: val };
  }
  ToKey({ string }) {
    return string;
  }
  ToBigMapKey(val) {
    return {
      key: { string: val },
      type: { prim: _StringToken.prim }
    };
  }
  findAndReturnTokens(tokenToFind, tokens2) {
    if (_StringToken.prim === tokenToFind) {
      tokens2.push(this);
    }
    return tokens2;
  }
};
StringToken.prim = "string";
var AddressValidationError = class extends TokenValidationError {
  constructor(value, token, message) {
    super(value, token, message);
    this.value = value;
    this.token = token;
    this.name = "AddressValidationError";
  }
};
var AddressToken = class _AddressToken extends ComparableToken {
  constructor(val, idx, fac) {
    super(val, idx, fac);
    this.val = val;
    this.idx = idx;
    this.fac = fac;
  }
  ToBigMapKey(val) {
    const decoded = b58decode(val);
    return {
      key: { bytes: decoded },
      type: { prim: "bytes" }
    };
  }
  /**
   * @throws {@link AddressValidationError}
   */
  validate(value) {
    if (validateAddress(value) !== ValidationResult.VALID) {
      throw new AddressValidationError(value, this, `Address is not valid: ${JSON.stringify(value)}`);
    }
  }
  /**
   * @throws {@link AddressValidationError}
   */
  Encode(args) {
    const val = args.pop();
    this.validate(val);
    return { string: val };
  }
  /**
   * @throws {@link AddressValidationError}
   */
  EncodeObject(val, semantic) {
    this.validate(val);
    if (semantic && semantic[_AddressToken.prim]) {
      return semantic[_AddressToken.prim](val);
    }
    return { string: val };
  }
  /**
   * @throws {@link AddressValidationError}
   */
  Execute(val) {
    if (val.string) {
      return val.string;
    }
    if (!val.bytes) {
      throw new AddressValidationError(val, this, `cannot be missing both string and bytes: ${JSON.stringify(val)}`);
    }
    return encodePubKey(val.bytes);
  }
  /**
   * @deprecated ExtractSchema has been deprecated in favor of generateSchema
   *
   */
  ExtractSchema() {
    return _AddressToken.prim;
  }
  generateSchema() {
    return {
      __michelsonType: _AddressToken.prim,
      schema: _AddressToken.prim
    };
  }
  /**
   * @throws {@link AddressValidationError}
   */
  ToKey({ bytes, string }) {
    if (string) {
      return string;
    }
    if (!bytes) {
      throw new AddressValidationError({ bytes, string }, this, `cannot be missing both string and bytes ${JSON.stringify({ string, bytes })}`);
    }
    return encodePubKey(bytes);
  }
  compare(address1, address2) {
    const isImplicit = (address) => {
      return address.startsWith("tz");
    };
    const implicit1 = isImplicit(address1);
    const implicit2 = isImplicit(address2);
    if (implicit1 && !implicit2) {
      return -1;
    } else if (implicit2 && !implicit1) {
      return 1;
    }
    return super.compare(address1, address2);
  }
  findAndReturnTokens(tokenToFind, tokens2) {
    if (_AddressToken.prim === tokenToFind) {
      tokens2.push(this);
    }
    return tokens2;
  }
};
AddressToken.prim = "address";
var MapValidationError = class extends TokenValidationError {
  constructor(value, token, message) {
    super(value, token, message);
    this.value = value;
    this.token = token;
    this.name = "MapValidationError";
  }
};
var MapToken = class _MapToken extends Token {
  constructor(val, idx, fac) {
    super(val, idx, fac);
    this.val = val;
    this.idx = idx;
    this.fac = fac;
  }
  get ValueSchema() {
    return this.createToken(this.val.args[1], 0);
  }
  get KeySchema() {
    return this.createToken(this.val.args[0], 0);
  }
  /**
   * @throws {@link MapValidationError}
   */
  validate(value) {
    if (!MichelsonMap.isMichelsonMap(value)) {
      throw new MapValidationError(value, this, `Value ${JSON.stringify(value)} is not a valid MichelsonMap`);
    }
  }
  Execute(val, semantics) {
    const map2 = new MichelsonMap(this.val);
    val.forEach((current) => {
      map2.set(this.KeySchema.ToKey(current.args[0]), this.ValueSchema.Execute(current.args[1], semantics));
    });
    return map2;
  }
  objLitToMichelsonMap(val) {
    if (val instanceof MichelsonMap)
      return val;
    if (typeof val === "object") {
      if (Object.keys(val).length === 0) {
        return new MichelsonMap();
      } else {
        return MichelsonMap.fromLiteral(val);
      }
    }
    return val;
  }
  /**
   * @throws {@link MapValidationError}
   */
  Encode(args) {
    const val = this.objLitToMichelsonMap(args.pop());
    this.validate(val);
    return Array.from(val.keys()).sort((a2, b3) => this.KeySchema.compare(a2, b3)).map((key) => {
      return {
        prim: "Elt",
        args: [this.KeySchema.EncodeObject(key), this.ValueSchema.EncodeObject(val.get(key))]
      };
    });
  }
  /**
   * @throws {@link MapValidationError}
   */
  EncodeObject(args, semantic) {
    const val = this.objLitToMichelsonMap(args);
    this.validate(val);
    if (semantic && semantic[_MapToken.prim]) {
      return semantic[_MapToken.prim](val);
    }
    return Array.from(val.keys()).sort((a2, b3) => this.KeySchema.compare(a2, b3)).map((key) => {
      return {
        prim: "Elt",
        args: [this.KeySchema.EncodeObject(key), this.ValueSchema.EncodeObject(val.get(key))]
      };
    });
  }
  /**
   * @deprecated ExtractSchema has been deprecated in favor of generateSchema
   *
   */
  ExtractSchema() {
    return {
      map: {
        key: this.KeySchema.ExtractSchema(),
        value: this.ValueSchema.ExtractSchema()
      }
    };
  }
  generateSchema() {
    return {
      __michelsonType: _MapToken.prim,
      schema: {
        key: this.KeySchema.generateSchema(),
        value: this.ValueSchema.generateSchema()
      }
    };
  }
  findAndReturnTokens(tokenToFind, tokens2) {
    if (_MapToken.prim === tokenToFind) {
      tokens2.push(this);
    }
    this.KeySchema.findAndReturnTokens(tokenToFind, tokens2);
    this.ValueSchema.findAndReturnTokens(tokenToFind, tokens2);
    return tokens2;
  }
};
MapToken.prim = "map";
var BoolToken = class _BoolToken extends ComparableToken {
  constructor(val, idx, fac) {
    super(val, idx, fac);
    this.val = val;
    this.idx = idx;
    this.fac = fac;
  }
  Execute(val) {
    return String(val.prim).toLowerCase() === "true" ? true : false;
  }
  Encode(args) {
    const val = args.pop();
    return { prim: val ? "True" : "False" };
  }
  EncodeObject(val, semantic) {
    if (semantic && semantic[_BoolToken.prim]) {
      return semantic[_BoolToken.prim](val);
    }
    return { prim: val ? "True" : "False" };
  }
  /**
   * @deprecated ExtractSchema has been deprecated in favor of generateSchema
   *
   */
  ExtractSchema() {
    return _BoolToken.prim;
  }
  generateSchema() {
    return {
      __michelsonType: _BoolToken.prim,
      schema: _BoolToken.prim
    };
  }
  ToBigMapKey(val) {
    return {
      key: this.EncodeObject(val),
      type: { prim: _BoolToken.prim }
    };
  }
  ToKey(val) {
    return this.EncodeObject(val);
  }
  compare(val1, val2) {
    if (val1 && val2 || !val1 && !val2) {
      return 0;
    } else if (val1) {
      return 1;
    } else {
      return -1;
    }
  }
  findAndReturnTokens(tokenToFind, tokens2) {
    if (_BoolToken.prim === tokenToFind) {
      tokens2.push(this);
    }
    return tokens2;
  }
};
BoolToken.prim = "bool";
var TxRollupL2AddressValidationError = class extends TokenValidationError {
  constructor(value, token, message) {
    super(value, token, message);
    this.value = value;
    this.token = token;
    this.name = "TxRollupL2AddressValidationError";
  }
};
var TxRollupL2AddressToken = class _TxRollupL2AddressToken extends ComparableToken {
  constructor(val, idx, fac) {
    super(val, idx, fac);
    this.val = val;
    this.idx = idx;
    this.fac = fac;
  }
  ToBigMapKey(val) {
    const decoded = b58decodeL2Address(val);
    return {
      key: { bytes: decoded },
      type: { prim: "bytes" }
    };
  }
  /**
   * @throws {@link TxRollupL2AddressValidationError}
   */
  validate(value) {
    if (validateAddress(value) !== ValidationResult.VALID) {
      throw new TxRollupL2AddressValidationError(value, this, `tx_rollup_l2_address is not valid: ${JSON.stringify(value)}`);
    }
  }
  /**
   * @throws {@link TxRollupL2AddressValidationError}
   */
  Encode(args) {
    const val = args.pop();
    if (!val) {
      throw new TxRollupL2AddressValidationError(val, this, `arg missing to encode: this -> "${JSON.stringify(val)}"`);
    }
    this.validate(val);
    return { string: val };
  }
  /**
   * @throws {@link TxRollupL2AddressValidationError}
   */
  EncodeObject(val, semantic) {
    this.validate(val);
    if (semantic && semantic[_TxRollupL2AddressToken.prim]) {
      return semantic[_TxRollupL2AddressToken.prim](val);
    }
    return { string: val };
  }
  /**
   * @throws {@link TxRollupL2AddressValidationError}
   */
  Execute(val) {
    if (val.string) {
      return val.string;
    }
    if (!val.bytes) {
      throw new TxRollupL2AddressValidationError(val, this, `value cannot be missing string and byte value. must have one ${JSON.stringify(val)}`);
    }
    return encodeL2Address(val.bytes);
  }
  ExtractSchema() {
    return _TxRollupL2AddressToken.prim;
  }
  generateSchema() {
    return {
      __michelsonType: _TxRollupL2AddressToken.prim,
      schema: _TxRollupL2AddressToken.prim
    };
  }
  /**
   * @throws {@link TxRollupL2AddressValidationError}
   */
  ToKey({ bytes, string }) {
    if (string) {
      return string;
    }
    if (!bytes) {
      throw new TxRollupL2AddressValidationError(bytes, this, `value cannot be missing string and byte value. must have one: bytes = ${JSON.stringify(bytes)}`);
    }
    return encodeL2Address(bytes);
  }
  findAndReturnTokens(tokenToFind, tokens2) {
    if (_TxRollupL2AddressToken.prim === tokenToFind) {
      tokens2.push(this);
    }
    return tokens2;
  }
};
TxRollupL2AddressToken.prim = "tx_rollup_l2_address";
var ContractValidationError = class extends TokenValidationError {
  constructor(value, token, message) {
    super(value, token, message);
    this.value = value;
    this.token = token;
    this.name = "ContractValidationError";
  }
};
var ContractToken = class _ContractToken extends Token {
  constructor(val, idx, fac) {
    super(val, idx, fac);
    this.val = val;
    this.idx = idx;
    this.fac = fac;
  }
  /**
   * @throws {@link ContractValidationError}
   */
  validate(value) {
    if (validateAddress(value) !== ValidationResult.VALID) {
      throw new ContractValidationError(value, this, `Value ${JSON.stringify(value)} is not a valid contract address.`);
    }
    return null;
  }
  /**
   * @throws {@link ContractValidationError}
   */
  Execute(val) {
    if (val.string) {
      return val.string;
    }
    if (!val.bytes) {
      throw new ContractValidationError(val, this, `Value ${JSON.stringify(val)} is not a valid contract address. must contain bytes or string.`);
    }
    return encodePubKey(val.bytes);
  }
  /**
   * @throws {@link ContractValidationError}
   */
  Encode(args) {
    const val = args.pop();
    this.validate(val);
    return { string: val };
  }
  /**
   * @throws {@link ContractValidationError}
   */
  EncodeObject(val, semantic) {
    this.validate(val);
    if (semantic && semantic[_ContractToken.prim]) {
      return semantic[_ContractToken.prim](val);
    }
    return { string: val };
  }
  /**
   * @deprecated ExtractSchema has been deprecated in favor of generateSchema
   *
   */
  ExtractSchema() {
    return _ContractToken.prim;
  }
  generateSchema() {
    const valueSchema = this.createToken(this.val.args[0], 0);
    return {
      __michelsonType: _ContractToken.prim,
      schema: {
        parameter: this.val.args[0] ? valueSchema.generateSchema() : {}
      }
    };
  }
  findAndReturnTokens(tokenToFind, tokens2) {
    if (_ContractToken.prim === tokenToFind) {
      tokens2.push(this);
    }
    return tokens2;
  }
};
ContractToken.prim = "contract";
var ListValidationError = class extends TokenValidationError {
  constructor(value, token, message) {
    super(value, token, message);
    this.value = value;
    this.token = token;
    this.name = "ListValidationError";
  }
};
var ListToken = class _ListToken extends Token {
  constructor(val, idx, fac) {
    super(val, idx, fac);
    this.val = val;
    this.idx = idx;
    this.fac = fac;
  }
  get valueSchema() {
    return this.createToken(this.val.args[0], this.idx);
  }
  /**
   * @throws {@link ListValidationError}
   */
  validate(value) {
    if (!Array.isArray(value)) {
      throw new ListValidationError(value, this, `Value ${JSON.stringify(value)} is not a valid array`);
    }
  }
  /**
   * @throws {@link ListValidationError}
   */
  Encode(args) {
    const val = args.pop();
    this.validate(val);
    const schema = this.createToken(this.val.args[0], 0);
    return val.reduce((prev, current) => {
      return [...prev, schema.EncodeObject(current)];
    }, []);
  }
  /**
   * @throws {@link ListValidationError}
   */
  Execute(val, semantics) {
    const schema = this.createToken(this.val.args[0], 0);
    this.validate(val);
    return val.reduce((prev, current) => {
      return [...prev, schema.Execute(current, semantics)];
    }, []);
  }
  /**
   * @throws {@link ListValidationError}
   */
  EncodeObject(args, semantic) {
    const schema = this.createToken(this.val.args[0], 0);
    this.validate(args);
    if (semantic && semantic[_ListToken.prim]) {
      return semantic[_ListToken.prim](args);
    }
    return args.reduce((prev, current) => {
      return [...prev, schema.EncodeObject(current)];
    }, []);
  }
  /**
   * @deprecated ExtractSchema has been deprecated in favor of generateSchema
   *
   */
  ExtractSchema() {
    return {
      [_ListToken.prim]: this.valueSchema.ExtractSchema()
    };
  }
  generateSchema() {
    return {
      __michelsonType: _ListToken.prim,
      schema: this.valueSchema.generateSchema()
    };
  }
  findAndReturnTokens(tokenToFind, tokens2) {
    if (_ListToken.prim === tokenToFind) {
      tokens2.push(this);
    }
    this.createToken(this.val.args[0], this.idx).findAndReturnTokens(tokenToFind, tokens2);
    return tokens2;
  }
};
ListToken.prim = "list";
var MutezValidationError = class extends TokenValidationError {
  constructor(value, token, message) {
    super(value, token, message);
    this.value = value;
    this.token = token;
    this.name = "MutezValidationError";
  }
};
var MutezToken = class _MutezToken extends ComparableToken {
  constructor(val, idx, fac) {
    super(val, idx, fac);
    this.val = val;
    this.idx = idx;
    this.fac = fac;
  }
  Execute(val) {
    return new bignumber_default(val[Object.keys(val)[0]]);
  }
  /**
   * @deprecated ExtractSchema has been deprecated in favor of generateSchema
   *
   */
  ExtractSchema() {
    return _MutezToken.prim;
  }
  generateSchema() {
    return {
      __michelsonType: _MutezToken.prim,
      schema: _MutezToken.prim
    };
  }
  /**
   * @throws {@link MutezValidationError}
   */
  validate(val) {
    const bigNumber = new bignumber_default(val);
    if (bigNumber.isNaN()) {
      throw new MutezValidationError(val, this, `Value is not a number: ${val}`);
    }
  }
  /**
   * @throws {@link MutezValidationError}
   */
  Encode(args) {
    const val = args.pop();
    this.validate(val);
    return { int: String(val).toString() };
  }
  /**
   * @throws {@link MutezValidationError}
   */
  EncodeObject(val, semantic) {
    this.validate(val);
    if (semantic && semantic[_MutezToken.prim]) {
      return semantic[_MutezToken.prim](val);
    }
    return { int: String(val).toString() };
  }
  ToBigMapKey(val) {
    return {
      key: { int: String(val) },
      type: { prim: _MutezToken.prim }
    };
  }
  ToKey({ int }) {
    return int;
  }
  compare(mutez1, mutez2) {
    const o1 = Number(mutez1);
    const o2 = Number(mutez2);
    if (o1 === o2) {
      return 0;
    }
    return o1 < o2 ? -1 : 1;
  }
  findAndReturnTokens(tokenToFind, tokens2) {
    if (_MutezToken.prim === tokenToFind) {
      tokens2.push(this);
    }
    return tokens2;
  }
};
MutezToken.prim = "mutez";
var BytesValidationError = class extends TokenValidationError {
  constructor(value, token, message) {
    super(value, token, message);
    this.value = value;
    this.token = token;
    this.name = "BytesValidationError";
  }
};
var BytesToken = class _BytesToken extends ComparableToken {
  constructor(val, idx, fac) {
    super(val, idx, fac);
    this.val = val;
    this.idx = idx;
    this.fac = fac;
  }
  ToBigMapKey(val) {
    return {
      key: { bytes: val },
      type: { prim: _BytesToken.prim }
    };
  }
  /**
   * @throws {@link BytesValidationError}
   */
  validate(val) {
    if (typeof val === "string" && /^[0-9a-fA-F]*$/.test(val) && val.length % 2 === 0) {
      return;
    }
    throw new BytesValidationError(val, this, `Invalid bytes: ${val}`);
  }
  convertUint8ArrayToHexString(val) {
    return val.constructor === Uint8Array ? Buffer.from(val).toString("hex") : val;
  }
  /**
   * @throws {@link BytesValidationError}
   */
  Encode(args) {
    let val = args.pop();
    val = stripHexPrefix(this.convertUint8ArrayToHexString(val));
    this.validate(val);
    return { bytes: String(val).toString() };
  }
  /**
   * @throws {@link BytesValidationError}
   */
  EncodeObject(val, semantic) {
    val = this.convertUint8ArrayToHexString(val);
    if (typeof val === "string") {
      val = stripHexPrefix(val);
    }
    this.validate(val);
    if (semantic && semantic[_BytesToken.prim]) {
      return semantic[_BytesToken.prim](val);
    }
    return { bytes: String(val).toString() };
  }
  Execute(val) {
    return val.bytes;
  }
  /**
   * @deprecated ExtractSchema has been deprecated in favor of generateSchema
   *
   */
  ExtractSchema() {
    return _BytesToken.prim;
  }
  generateSchema() {
    return {
      __michelsonType: _BytesToken.prim,
      schema: _BytesToken.prim
    };
  }
  ToKey({ bytes, string }) {
    if (string) {
      return string;
    }
    return bytes;
  }
  findAndReturnTokens(tokenToFind, tokens2) {
    if (_BytesToken.prim === tokenToFind) {
      tokens2.push(this);
    }
    return tokens2;
  }
};
BytesToken.prim = "bytes";
var OptionToken = class _OptionToken extends ComparableToken {
  constructor(val, idx, fac) {
    super(val, idx, fac);
    this.val = val;
    this.idx = idx;
    this.fac = fac;
  }
  subToken() {
    return this.createToken(this.val.args[0], this.idx);
  }
  schema() {
    return this.createToken(this.val.args[0], 0);
  }
  annot() {
    return Array.isArray(this.val.annots) ? super.annot() : this.createToken(this.val.args[0], this.idx).annot();
  }
  Encode(args) {
    const value = args;
    if (value === void 0 || value === null) {
      return { prim: "None" };
    } else if (Array.isArray(value) && (value[value.length - 1] === void 0 || value[value.length - 1] === null)) {
      value.pop();
      return { prim: "None" };
    }
    return { prim: "Some", args: [this.schema().Encode(args)] };
  }
  EncodeObject(args, semantic) {
    let value = args;
    if (value === void 0 || value === null) {
      return { prim: "None" };
    }
    value = typeof value === "object" && "Some" in value ? value["Some"] : value;
    return { prim: "Some", args: [this.schema().EncodeObject(value, semantic)] };
  }
  Execute(val, semantics) {
    if (val.prim === "None") {
      return null;
    }
    return { Some: this.schema().Execute(val.args[0], semantics) };
  }
  /**
   * @deprecated ExtractSchema has been deprecated in favor of generateSchema
   *
   */
  ExtractSchema() {
    return { Some: this.schema().ExtractSchema() };
  }
  generateSchema() {
    return {
      __michelsonType: _OptionToken.prim,
      schema: this.schema().generateSchema()
    };
  }
  ExtractSignature() {
    return [...this.schema().ExtractSignature()];
  }
  get KeySchema() {
    return this.schema();
  }
  compare(val1, val2) {
    if (!val1) {
      return -1;
    } else if (!val2) {
      return 1;
    }
    return this.KeySchema.compare(val1, val2);
  }
  ToKey(val) {
    return this.Execute(val);
  }
  ToBigMapKey(val) {
    return {
      key: this.EncodeObject(val),
      type: this.typeWithoutAnnotations()
    };
  }
  findAndReturnTokens(tokenToFind, tokens2) {
    if (_OptionToken.prim === tokenToFind) {
      tokens2.push(this);
    }
    this.subToken().findAndReturnTokens(tokenToFind, tokens2);
    return tokens2;
  }
};
OptionToken.prim = "option";
var TimestampToken = class _TimestampToken extends ComparableToken {
  constructor(val, idx, fac) {
    super(val, idx, fac);
    this.val = val;
    this.idx = idx;
    this.fac = fac;
  }
  Execute(val) {
    if (val.string && /^\d+$/.test(val.string)) {
      return new Date(Number(val.string) * 1e3).toISOString();
    } else if (val.string) {
      return new Date(val.string).toISOString();
    } else if (val.int) {
      return new Date(Number(val.int) * 1e3).toISOString();
    }
  }
  Encode(args) {
    const val = args.pop();
    if (typeof val === "number") {
      return { int: String(val) };
    } else {
      return { string: val };
    }
  }
  EncodeObject(val, semantic) {
    if (semantic && semantic[_TimestampToken.prim]) {
      return semantic[_TimestampToken.prim](val);
    }
    if (typeof val === "number") {
      return { int: String(val) };
    } else {
      return { string: val };
    }
  }
  /**
   * @deprecated ExtractSchema has been deprecated in favor of generateSchema
   *
   */
  ExtractSchema() {
    return _TimestampToken.prim;
  }
  generateSchema() {
    return {
      __michelsonType: _TimestampToken.prim,
      schema: _TimestampToken.prim
    };
  }
  ToKey({ string }) {
    return string;
  }
  ToBigMapKey(val) {
    return {
      key: { string: val },
      type: { prim: _TimestampToken.prim }
    };
  }
  findAndReturnTokens(tokenToFind, tokens2) {
    if (_TimestampToken.prim === tokenToFind) {
      tokens2.push(this);
    }
    return tokens2;
  }
};
TimestampToken.prim = "timestamp";
var IntValidationError = class extends TokenValidationError {
  constructor(value, token, message) {
    super(value, token, message);
    this.value = value;
    this.token = token;
    this.name = "IntValidationError";
  }
};
var IntToken = class _IntToken extends ComparableToken {
  constructor(val, idx, fac) {
    super(val, idx, fac);
    this.val = val;
    this.idx = idx;
    this.fac = fac;
  }
  Execute(val) {
    return new bignumber_default(val[Object.keys(val)[0]]);
  }
  /**
   * @deprecated ExtractSchema has been deprecated in favor of generateSchema
   *
   */
  ExtractSchema() {
    return _IntToken.prim;
  }
  generateSchema() {
    return {
      __michelsonType: _IntToken.prim,
      schema: _IntToken.prim
    };
  }
  /**
   * @throws {@link IntValidationError}
   */
  validate(val) {
    const bigNumber = new bignumber_default(val);
    if (bigNumber.isNaN()) {
      throw new IntValidationError(val, this, `Value is not a number: ${JSON.stringify(val)}`);
    }
  }
  /**
   * @throws {@link IntValidationError}
   */
  Encode(args) {
    const val = args.pop();
    this.validate(val);
    return { int: new bignumber_default(val).toFixed() };
  }
  /**
   * @throws {@link IntValidationError}
   */
  EncodeObject(val, semantic) {
    this.validate(val);
    if (semantic && semantic[_IntToken.prim]) {
      return semantic[_IntToken.prim](val);
    }
    return { int: new bignumber_default(val).toFixed() };
  }
  ToBigMapKey(val) {
    return {
      key: { int: String(val) },
      type: { prim: _IntToken.prim }
    };
  }
  ToKey({ int }) {
    return int;
  }
  compare(int1, int2) {
    const o1 = Number(int1);
    const o2 = Number(int2);
    if (o1 === o2) {
      return 0;
    }
    return o1 < o2 ? -1 : 1;
  }
  findAndReturnTokens(tokenToFind, tokens2) {
    if (_IntToken.prim === tokenToFind) {
      tokens2.push(this);
    }
    return tokens2;
  }
};
IntToken.prim = "int";
var UnitToken = class _UnitToken extends ComparableToken {
  constructor(val, idx, fac) {
    super(val, idx, fac);
    this.val = val;
    this.idx = idx;
    this.fac = fac;
  }
  Encode(args) {
    args.pop();
    return { prim: "Unit" };
  }
  EncodeObject(val, semantic) {
    if (semantic && semantic[_UnitToken.prim]) {
      return semantic[_UnitToken.prim](val);
    }
    return { prim: "Unit" };
  }
  Execute(_val) {
    return UnitValue;
  }
  /**
   * @deprecated ExtractSchema has been deprecated in favor of generateSchema
   *
   */
  ExtractSchema() {
    return _UnitToken.prim;
  }
  generateSchema() {
    return {
      __michelsonType: _UnitToken.prim,
      schema: _UnitToken.prim
    };
  }
  compare(_val1, _val2) {
    return 0;
  }
  ToKey(_val) {
    return UnitValue;
  }
  ToBigMapKey(_val) {
    return {
      key: { prim: "Unit" },
      type: { prim: _UnitToken.prim }
    };
  }
  findAndReturnTokens(tokenToFind, tokens2) {
    if (_UnitToken.prim === tokenToFind) {
      tokens2.push(this);
    }
    return tokens2;
  }
};
UnitToken.prim = "unit";
var publicKeyPrefixLength = 4;
var KeyValidationError = class extends TokenValidationError {
  constructor(value, token, message) {
    super(value, token, message);
    this.value = value;
    this.token = token;
    this.name = "KeyValidationError";
  }
};
var KeyToken = class _KeyToken extends ComparableToken {
  constructor(val, idx, fac) {
    super(val, idx, fac);
    this.val = val;
    this.idx = idx;
    this.fac = fac;
  }
  Execute(val) {
    if (val.string) {
      return val.string;
    }
    return encodeKey(val.bytes);
  }
  /**
   * @throws {@link KeyValidationError}
   */
  validate(value) {
    if (validatePublicKey(value) !== ValidationResult.VALID) {
      throw new KeyValidationError(value, this, "Key is not valid");
    }
  }
  /**
   * @throws {@link KeyValidationError}
   */
  Encode(args) {
    const val = args.pop();
    this.validate(val);
    return { string: val };
  }
  /**
   * @throws {@link KeyValidationError}
   */
  EncodeObject(val, semantic) {
    this.validate(val);
    if (semantic && semantic[_KeyToken.prim]) {
      return semantic[_KeyToken.prim](val);
    }
    return { string: val };
  }
  /**
   * @deprecated ExtractSchema has been deprecated in favor of generateSchema
   *
   */
  ExtractSchema() {
    return _KeyToken.prim;
  }
  generateSchema() {
    return {
      __michelsonType: _KeyToken.prim,
      schema: _KeyToken.prim
    };
  }
  ToKey(val) {
    return this.Execute(val);
  }
  ToBigMapKey(val) {
    return {
      key: { string: val },
      type: { prim: _KeyToken.prim }
    };
  }
  compare(key1, key2) {
    const keyPrefix1 = this.getPrefix(key1);
    const keyPrefix2 = this.getPrefix(key2);
    if (keyPrefix1 === Prefix.EDPK && keyPrefix2 !== Prefix.EDPK) {
      return -1;
    } else if (keyPrefix1 === Prefix.SPPK && keyPrefix2 !== Prefix.SPPK) {
      return keyPrefix2 === Prefix.EDPK ? 1 : -1;
    } else if (keyPrefix1 === Prefix.P2PK) {
      if (keyPrefix2 !== Prefix.P2PK) {
        return 1;
      }
      const keyBytes1 = this.getP256PublicKeyComparableBytes(key1);
      const keyBytes2 = this.getP256PublicKeyComparableBytes(key2);
      return Buffer.compare(keyBytes1, keyBytes2);
    }
    return super.compare(key1, key2);
  }
  getPrefix(val) {
    return val.substring(0, publicKeyPrefixLength);
  }
  getP256PublicKeyComparableBytes(p2pk) {
    return b58cdecode(p2pk, prefix[Prefix.P2PK]).slice(1);
  }
  findAndReturnTokens(tokenToFind, tokens2) {
    if (_KeyToken.prim === tokenToFind) {
      tokens2.push(this);
    }
    return tokens2;
  }
};
KeyToken.prim = "key";
var KeyHashValidationError = class extends TokenValidationError {
  constructor(value, token, message) {
    super(value, token, message);
    this.value = value;
    this.token = token;
    this.name = "KeyHashValidationError";
  }
};
var KeyHashToken = class _KeyHashToken extends ComparableToken {
  constructor(val, idx, fac) {
    super(val, idx, fac);
    this.val = val;
    this.idx = idx;
    this.fac = fac;
  }
  Execute(val) {
    if (val.string) {
      return val.string;
    }
    return encodeKeyHash(val.bytes);
  }
  /**
   * @throws {@link KeyHashValidationError}
   */
  validate(value) {
    if (validateKeyHash(value) !== ValidationResult.VALID) {
      throw new KeyHashValidationError(value, this, `KeyHash is not valid: ${JSON.stringify(value)}`);
    }
  }
  /**
   * @throws {@link KeyHashValidationError}
   */
  Encode(args) {
    const val = args.pop();
    this.validate(val);
    return { string: val };
  }
  /**
   * @throws {@link KeyHashValidationError}
   */
  EncodeObject(val, semantic) {
    this.validate(val);
    if (semantic && semantic[_KeyHashToken.prim]) {
      return semantic[_KeyHashToken.prim](val);
    }
    return { string: val };
  }
  /**
   * @deprecated ExtractSchema has been deprecated in favor of generateSchema
   *
   */
  ExtractSchema() {
    return _KeyHashToken.prim;
  }
  generateSchema() {
    return {
      __michelsonType: _KeyHashToken.prim,
      schema: _KeyHashToken.prim
    };
  }
  ToKey({ string, bytes }) {
    if (string) {
      return string;
    }
    return encodeKeyHash(bytes);
  }
  ToBigMapKey(val) {
    return {
      key: { string: val },
      type: { prim: _KeyHashToken.prim }
    };
  }
  findAndReturnTokens(tokenToFind, tokens2) {
    if (_KeyHashToken.prim === tokenToFind) {
      tokens2.push(this);
    }
    return tokens2;
  }
};
KeyHashToken.prim = "key_hash";
var SignatureValidationError = class extends TokenValidationError {
  constructor(value, token, message) {
    super(value, token, message);
    this.value = value;
    this.token = token;
    this.name = "SignatureValidationError";
  }
};
var SignatureToken = class _SignatureToken extends ComparableToken {
  constructor(val, idx, fac) {
    super(val, idx, fac);
    this.val = val;
    this.idx = idx;
    this.fac = fac;
  }
  Execute(val) {
    if (val.string) {
      return val.string;
    }
    return val.bytes;
  }
  /**
   * @throws {@link SignatureValidationError}
   */
  validate(value) {
    if (validateSignature(value) !== ValidationResult.VALID) {
      throw new SignatureValidationError(value, this, "Signature is not valid");
    }
  }
  /**
   * @throws {@link SignatureValidationError}
   */
  Encode(args) {
    const val = args.pop();
    this.validate(val);
    return { string: val };
  }
  /**
   * @throws {@link SignatureValidationError}
   */
  EncodeObject(val, semantic) {
    this.validate(val);
    if (semantic && semantic[_SignatureToken.prim]) {
      return semantic[_SignatureToken.prim](val);
    }
    return { string: val };
  }
  /**
   * @deprecated ExtractSchema has been deprecated in favor of generateSchema
   *
   */
  ExtractSchema() {
    return _SignatureToken.prim;
  }
  generateSchema() {
    return {
      __michelsonType: _SignatureToken.prim,
      schema: _SignatureToken.prim
    };
  }
  ToKey(val) {
    return this.Execute(val);
  }
  ToBigMapKey(val) {
    return {
      key: { string: val },
      type: { prim: _SignatureToken.prim }
    };
  }
  findAndReturnTokens(tokenToFind, tokens2) {
    if (_SignatureToken.prim === tokenToFind) {
      tokens2.push(this);
    }
    return tokens2;
  }
};
SignatureToken.prim = "signature";
var LambdaToken = class _LambdaToken extends Token {
  constructor(val, idx, fac) {
    super(val, idx, fac);
    this.val = val;
    this.idx = idx;
    this.fac = fac;
  }
  get paramSchema() {
    return this.createToken(this.val.args[0], this.idx);
  }
  get returnSchema() {
    return this.createToken(this.val.args[1], this.idx + 1);
  }
  Execute(val) {
    if (val.string) {
      return val.string;
    } else {
      return val;
    }
  }
  Encode(args) {
    const val = args.pop();
    return val;
  }
  EncodeObject(val, semantic) {
    if (semantic && semantic[_LambdaToken.prim]) {
      return semantic[_LambdaToken.prim](val);
    }
    return val;
  }
  /**
   * @deprecated ExtractSchema has been deprecated in favor of generateSchema
   *
   */
  ExtractSchema() {
    return {
      [_LambdaToken.prim]: {
        parameters: this.paramSchema.ExtractSchema(),
        returns: this.returnSchema.ExtractSchema()
      }
    };
  }
  generateSchema() {
    return {
      __michelsonType: _LambdaToken.prim,
      schema: {
        parameters: this.paramSchema.generateSchema(),
        returns: this.returnSchema.generateSchema()
      }
    };
  }
  findAndReturnTokens(tokenToFind, tokens2) {
    if (_LambdaToken.prim === tokenToFind) {
      tokens2.push(this);
    }
    this.createToken(this.val.args[0], this.idx).findAndReturnTokens(tokenToFind, tokens2);
    this.createToken(this.val.args[1], this.idx).findAndReturnTokens(tokenToFind, tokens2);
    return tokens2;
  }
};
LambdaToken.prim = "lambda";
var OperationToken = class _OperationToken extends Token {
  constructor(val, idx, fac) {
    super(val, idx, fac);
    this.val = val;
    this.idx = idx;
    this.fac = fac;
  }
  Execute(val) {
    return val.string;
  }
  Encode(...args) {
    const val = args.pop();
    return { string: val };
  }
  EncodeObject(val, semantic) {
    if (semantic && semantic[_OperationToken.prim]) {
      return semantic[_OperationToken.prim](val);
    }
    return { string: val };
  }
  /**
   * @deprecated ExtractSchema has been deprecated in favor of generateSchema
   *
   */
  ExtractSchema() {
    return _OperationToken.prim;
  }
  generateSchema() {
    return {
      __michelsonType: _OperationToken.prim,
      schema: _OperationToken.prim
    };
  }
  findAndReturnTokens(tokenToFind, tokens2) {
    if (_OperationToken.prim === tokenToFind) {
      tokens2.push(this);
    }
    return tokens2;
  }
};
OperationToken.prim = "operation";
var SetValidationError = class extends TokenValidationError {
  constructor(value, token, message) {
    super(value, token, message);
    this.value = value;
    this.token = token;
    this.name = "SetValidationError";
  }
};
var SetToken = class _SetToken extends Token {
  constructor(val, idx, fac) {
    super(val, idx, fac);
    this.val = val;
    this.idx = idx;
    this.fac = fac;
  }
  get KeySchema() {
    return this.createToken(this.val.args[0], 0);
  }
  /**
   * @throws {@link SetValidationError}
   */
  validate(value) {
    if (!Array.isArray(value)) {
      throw new SetValidationError(value, this, `Value ${JSON.stringify(value)} is not an array`);
    }
  }
  /**
   * @throws {@link SetValidationError}
   */
  Encode(args) {
    const val = args.pop();
    this.validate(val);
    return val.sort((a2, b3) => this.KeySchema.compare(a2, b3)).reduce((prev, current) => {
      return [...prev, this.KeySchema.EncodeObject(current)];
    }, []);
  }
  Execute(val, semantics) {
    return val.reduce((prev, current) => {
      return [...prev, this.KeySchema.Execute(current, semantics)];
    }, []);
  }
  /**
   * @throws {@link SetValidationError}
   */
  EncodeObject(args, semantic) {
    this.validate(args);
    if (semantic && semantic[_SetToken.prim]) {
      return semantic[_SetToken.prim](args);
    }
    return args.sort((a2, b3) => this.KeySchema.compare(a2, b3)).reduce((prev, current) => {
      return [...prev, this.KeySchema.EncodeObject(current)];
    }, []);
  }
  /**
   * @deprecated ExtractSchema has been deprecated in favor of generateSchema
   *
   */
  ExtractSchema() {
    return _SetToken.prim;
  }
  generateSchema() {
    return {
      __michelsonType: _SetToken.prim,
      schema: this.KeySchema.generateSchema()
    };
  }
  findAndReturnTokens(tokenToFind, tokens2) {
    if (_SetToken.prim === tokenToFind) {
      tokens2.push(this);
    }
    this.KeySchema.findAndReturnTokens(tokenToFind, tokens2);
    return tokens2;
  }
};
SetToken.prim = "set";
var ChainIDValidationError = class extends TokenValidationError {
  constructor(value, token, message) {
    super(value, token, message);
    this.value = value;
    this.token = token;
    this.name = "ChainIDValidationError";
  }
};
var ChainIDToken = class _ChainIDToken extends ComparableToken {
  constructor(val, idx, fac) {
    super(val, idx, fac);
    this.val = val;
    this.idx = idx;
    this.fac = fac;
  }
  /**
   * @throws {@link ChainIDValidationError}
   */
  validate(value) {
    if (validateChain(value) !== ValidationResult.VALID) {
      throw new ChainIDValidationError(value, this, `Value ${JSON.stringify(value)} is not a valid ChainID`);
    }
  }
  Execute(val) {
    return val[Object.keys(val)[0]];
  }
  /**
   * @deprecated ExtractSchema has been deprecated in favor of generateSchema
   *
   */
  ExtractSchema() {
    return _ChainIDToken.prim;
  }
  generateSchema() {
    return {
      __michelsonType: _ChainIDToken.prim,
      schema: _ChainIDToken.prim
    };
  }
  /**
   * @throws {@link ChainIDValidationError}
   */
  Encode(args) {
    const val = args.pop();
    this.validate(val);
    return { string: val };
  }
  /**
   * @throws {@link ChainIDValidationError}
   */
  EncodeObject(val, semantic) {
    this.validate(val);
    if (semantic && semantic[_ChainIDToken.prim]) {
      return semantic[_ChainIDToken.prim](val);
    }
    return { string: val };
  }
  ToKey({ string }) {
    return string;
  }
  ToBigMapKey(val) {
    return {
      key: { string: val },
      type: { prim: _ChainIDToken.prim }
    };
  }
  findAndReturnTokens(tokenToFind, tokens2) {
    if (_ChainIDToken.prim === tokenToFind) {
      tokens2.push(this);
    }
    return tokens2;
  }
};
ChainIDToken.prim = "chain_id";
var EncodeTicketError = class extends TaquitoError {
  constructor() {
    super();
    this.name = "TicketEncodeError";
    this.message = "Tickets cannot be sent to the blockchain; they are created on-chain";
  }
};
var ticketerType$1 = { prim: "contract" };
var amountType$1 = { prim: "int" };
var TicketToken = class _TicketToken extends Token {
  constructor(val, idx, fac) {
    super(val, idx, fac);
    this.val = val;
    this.idx = idx;
    this.fac = fac;
  }
  get valueToken() {
    return this.createToken(this.val.args[0], this.idx);
  }
  /**
   * @throws {@link EncodeTicketError}
   */
  Encode(_args) {
    throw new EncodeTicketError();
  }
  /**
   * @throws {@link EncodeTicketError}
   */
  EncodeObject(args, semantic) {
    if (semantic && semantic[_TicketToken.prim]) {
      return semantic[_TicketToken.prim](args, this.val);
    }
    throw new EncodeTicketError();
  }
  Execute(val, semantics) {
    if (semantics && semantics[_TicketToken.prim]) {
      return semantics[_TicketToken.prim](val, this.val);
    }
    const ticketer = this.createToken(ticketerType$1, this.idx);
    const value = this.valueToken;
    const amount = this.createToken(amountType$1, this.idx);
    if (void 0 === val.args[2] && void 0 !== val.args[1].args) {
      return {
        ticketer: ticketer.Execute(val.args[0], semantics),
        value: value.Execute(val.args[1].args[0], semantics),
        amount: amount.Execute(val.args[1].args[1], semantics)
      };
    }
    return {
      ticketer: ticketer.Execute(val.args[0], semantics),
      value: value.Execute(val.args[1], semantics),
      amount: amount.Execute(val.args[2], semantics)
    };
  }
  /**
   * @deprecated ExtractSchema has been deprecated in favor of generateSchema
   *
   */
  ExtractSchema() {
    return {
      ticketer: ContractToken.prim,
      value: this.valueToken.ExtractSchema(),
      amount: IntToken.prim
    };
  }
  generateSchema() {
    return {
      __michelsonType: _TicketToken.prim,
      schema: {
        value: this.valueToken.generateSchema(),
        ticketer: {
          __michelsonType: ContractToken.prim,
          schema: ContractToken.prim
        },
        amount: {
          __michelsonType: IntToken.prim,
          schema: IntToken.prim
        }
      }
    };
  }
  findAndReturnTokens(tokenToFind, tokens2) {
    if (_TicketToken.prim === tokenToFind) {
      tokens2.push(this);
    }
    this.valueToken.findAndReturnTokens(tokenToFind, tokens2);
    return tokens2;
  }
};
TicketToken.prim = "ticket";
var EncodeTicketDeprecatedError = class extends TaquitoError {
  constructor() {
    super();
    this.name = "TicketDeprecatedEncodeError";
    this.message = "Ticket_deprecated cannot be sent to the blockchain; they are created on-chain";
  }
};
var ticketerType = { prim: "contract" };
var amountType = { prim: "int" };
var TicketDeprecatedToken = class _TicketDeprecatedToken extends Token {
  constructor(val, idx, fac) {
    super(val, idx, fac);
    this.val = val;
    this.idx = idx;
    this.fac = fac;
  }
  get valueToken() {
    return this.createToken(this.val.args[0], this.idx);
  }
  /**
   * @throws {@link EncodeTicketDeprecatedError}
   */
  Encode(_args) {
    throw new EncodeTicketDeprecatedError();
  }
  /**
   * @throws {@link EncodeTicketDeprecatedError}
   */
  EncodeObject(args, semantic) {
    if (semantic && semantic[_TicketDeprecatedToken.prim]) {
      return semantic[_TicketDeprecatedToken.prim](args, this.val);
    }
    throw new EncodeTicketDeprecatedError();
  }
  Execute(val, semantics) {
    if (semantics && semantics[_TicketDeprecatedToken.prim]) {
      return semantics[_TicketDeprecatedToken.prim](val, this.val);
    }
    const ticketer = this.createToken(ticketerType, this.idx);
    const value = this.valueToken;
    const amount = this.createToken(amountType, this.idx);
    if (void 0 === val.args[2] && void 0 !== val.args[1].args) {
      return {
        ticketer: ticketer.Execute(val.args[0], semantics),
        value: value.Execute(val.args[1].args[0], semantics),
        amount: amount.Execute(val.args[1].args[1], semantics)
      };
    }
    return {
      ticketer: ticketer.Execute(val.args[0], semantics),
      value: value.Execute(val.args[1], semantics),
      amount: amount.Execute(val.args[2], semantics)
    };
  }
  /**
   * @deprecated ExtractSchema has been deprecated in favor of generateSchema
   *
   */
  ExtractSchema() {
    return {
      ticketer: ContractToken.prim,
      value: this.valueToken.ExtractSchema(),
      amount: IntToken.prim
    };
  }
  generateSchema() {
    return {
      __michelsonType: _TicketDeprecatedToken.prim,
      schema: {
        value: this.valueToken.generateSchema(),
        ticketer: {
          __michelsonType: ContractToken.prim,
          schema: ContractToken.prim
        },
        amount: {
          __michelsonType: IntToken.prim,
          schema: IntToken.prim
        }
      }
    };
  }
  findAndReturnTokens(tokenToFind, tokens2) {
    if (_TicketDeprecatedToken.prim === tokenToFind) {
      tokens2.push(this);
    }
    this.valueToken.findAndReturnTokens(tokenToFind, tokens2);
    return tokens2;
  }
};
TicketDeprecatedToken.prim = "ticket_deprecated";
var NeverTokenError = class extends TokenValidationError {
  constructor(value, token, message) {
    super(value, token, message);
    this.value = value;
    this.token = token;
    this.name = "NeverTokenError";
  }
};
var NeverToken = class _NeverToken extends Token {
  constructor(val, idx, fac) {
    super(val, idx, fac);
    this.val = val;
    this.idx = idx;
    this.fac = fac;
  }
  /**
   * @throws {@link NeverTokenError}
   */
  Encode(args) {
    const val = args.pop();
    throw new NeverTokenError(val, this, `Assigning a value to the type never is forbidden. Trying to assign ${JSON.stringify(val)}.`);
  }
  /**
   * @throws {@link NeverTokenError}
   */
  EncodeObject(val, semantic) {
    if (semantic && semantic[_NeverToken.prim]) {
      return semantic[_NeverToken.prim](val);
    }
    throw new NeverTokenError(val, this, `Assigning a value to the type never is forbidden. Trying to assign ${JSON.stringify(val)}.`);
  }
  /**
   * @throws {@link NeverTokenError}
   */
  Execute(val) {
    throw new NeverTokenError(val, this, `There is no literal value for the type never. Trying to execute ${JSON.stringify(val)}.`);
  }
  /**
   * @deprecated ExtractSchema has been deprecated in favor of generateSchema
   *
   */
  ExtractSchema() {
    return _NeverToken.prim;
  }
  generateSchema() {
    return {
      __michelsonType: _NeverToken.prim,
      schema: _NeverToken.prim
    };
  }
  findAndReturnTokens(tokenToFind, tokens2) {
    if (_NeverToken.prim === tokenToFind) {
      tokens2.push(this);
    }
    return tokens2;
  }
};
NeverToken.prim = "never";
var SaplingStateValidationError = class extends TokenValidationError {
  constructor(value, token, message) {
    super(value, token, message);
    this.value = value;
    this.token = token;
    this.name = "SaplingStateValidationError";
  }
};
var SaplingStateToken = class _SaplingStateToken extends Token {
  constructor(val, idx, fac) {
    super(val, idx, fac);
    this.val = val;
    this.idx = idx;
    this.fac = fac;
  }
  isValid(val) {
    return typeof val === "object" && Object.keys(val).length === 0;
  }
  /**
   * @throws {@link SaplingStateValidationError}
   */
  Execute(val, semantic) {
    if (semantic && semantic[_SaplingStateToken.prim]) {
      return semantic[_SaplingStateToken.prim](val, this.val);
    }
    if ("int" in val) {
      return val.int;
    } else {
      throw new SaplingStateValidationError(val, this, `Sapling state is expecting an object with an int property. Got ${JSON.stringify(val)}`);
    }
  }
  /**
   * @throws {@link SaplingStateValidationError}
   */
  Encode(args) {
    const val = args.pop();
    if (this.isValid(val)) {
      return [];
    } else {
      throw new SaplingStateValidationError(val, this, `Invalid sapling_state. Received: ${JSON.stringify(val)} while expecting: {}`);
    }
  }
  /**
   * @throws {@link SaplingStateValidationError}
   */
  EncodeObject(val, semantic) {
    if (semantic && semantic[_SaplingStateToken.prim]) {
      return semantic[_SaplingStateToken.prim](val);
    }
    if (this.isValid(val)) {
      return [];
    } else {
      throw new SaplingStateValidationError(val, this, `Invalid sapling_state. Received: ${JSON.stringify(val)} while expecting: {}`);
    }
  }
  /**
   * @deprecated ExtractSchema has been deprecated in favor of generateSchema
   *
   */
  ExtractSchema() {
    return {
      [_SaplingStateToken.prim]: {
        "memo-size": Number(this.val.args[0]["int"])
      }
    };
  }
  generateSchema() {
    return {
      __michelsonType: _SaplingStateToken.prim,
      schema: {
        memoSize: this.val.args[0]["int"]
      }
    };
  }
  findAndReturnTokens(tokenToFind, tokens2) {
    if (_SaplingStateToken.prim === tokenToFind) {
      tokens2.push(this);
    }
    return tokens2;
  }
};
SaplingStateToken.prim = "sapling_state";
var SaplingTransactionValidationError = class extends TokenValidationError {
  constructor(value, token, message) {
    super(value, token, message);
    this.value = value;
    this.token = token;
    this.name = "SaplingTransactionValidationError";
  }
};
var SaplingTransactionToken = class _SaplingTransactionToken extends Token {
  constructor(val, idx, fac) {
    super(val, idx, fac);
    this.val = val;
    this.idx = idx;
    this.fac = fac;
  }
  /**
   * @throws {@link SaplingTransactionValidationError}
   */
  Execute(_val) {
    throw new SaplingTransactionValidationError(_val, this, `There is no literal value for the sapling_transaction type. Got: ${JSON.stringify(_val)}.`);
  }
  /**
   * @throws {@link SaplingTransactionValidationError}
   */
  validateBytes(val) {
    const bytes = /^(0x|0X)?([0-9a-fA-F]*$)/.exec(val);
    if (bytes && bytes[2].length % 2 === 0) {
      return bytes[2];
    } else {
      throw new SaplingTransactionValidationError(val, this, `Invalid bytes: ${JSON.stringify(val)}`);
    }
  }
  convertUint8ArrayToHexString(val) {
    return val.constructor === Uint8Array ? Buffer.from(val).toString("hex") : val;
  }
  Encode(args) {
    let val = args.pop();
    val = this.validateBytes(this.convertUint8ArrayToHexString(val));
    return { bytes: String(val).toString() };
  }
  EncodeObject(val, semantic) {
    val = this.validateBytes(this.convertUint8ArrayToHexString(val));
    if (semantic && semantic[_SaplingTransactionToken.prim]) {
      return semantic[_SaplingTransactionToken.prim](val);
    }
    return { bytes: String(val).toString() };
  }
  /**
   * @deprecated ExtractSchema has been deprecated in favor of generateSchema
   *
   */
  ExtractSchema() {
    return {
      [_SaplingTransactionToken.prim]: {
        "memo-size": Number(this.val.args[0]["int"])
      }
    };
  }
  generateSchema() {
    return {
      __michelsonType: _SaplingTransactionToken.prim,
      schema: {
        memoSize: this.val.args[0]["int"]
      }
    };
  }
  findAndReturnTokens(tokenToFind, tokens2) {
    if (_SaplingTransactionToken.prim === tokenToFind) {
      tokens2.push(this);
    }
    return tokens2;
  }
};
SaplingTransactionToken.prim = "sapling_transaction";
var SaplingTransactionDeprecatedValidationError = class extends TokenValidationError {
  constructor(value, token, message) {
    super(value, token, message);
    this.value = value;
    this.token = token;
    this.name = "SaplingTransactionDeprecatedValidationError";
  }
};
var SaplingTransactionDeprecatedToken = class _SaplingTransactionDeprecatedToken extends Token {
  constructor(val, idx, fac) {
    super(val, idx, fac);
    this.val = val;
    this.idx = idx;
    this.fac = fac;
  }
  /**
   * @throws {@link SaplingTransactionDeprecatedValidationError}
   */
  Execute(_val) {
    throw new SaplingTransactionDeprecatedValidationError(_val, this, `There is no literal value for the sapling_transaction_deprecated type. Got: ${JSON.stringify(_val)}.`);
  }
  /**
   * @throws {@link SaplingTransactionDeprecatedValidationError}
   */
  validateBytes(val) {
    const bytes = /^(0x|0X)?([0-9a-fA-F]*$)/.exec(val);
    if (bytes && bytes[2].length % 2 === 0) {
      return bytes[2];
    } else {
      throw new SaplingTransactionDeprecatedValidationError(val, this, `Invalid bytes: ${JSON.stringify(val)}`);
    }
  }
  convertUint8ArrayToHexString(val) {
    return val.constructor === Uint8Array ? Buffer.from(val).toString("hex") : val;
  }
  Encode(args) {
    let val = args.pop();
    val = this.validateBytes(this.convertUint8ArrayToHexString(val));
    return { bytes: String(val).toString() };
  }
  EncodeObject(val, semantic) {
    val = this.validateBytes(this.convertUint8ArrayToHexString(val));
    if (semantic && semantic[_SaplingTransactionDeprecatedToken.prim]) {
      return semantic[_SaplingTransactionDeprecatedToken.prim](val);
    }
    return { bytes: String(val).toString() };
  }
  /**
   * @deprecated ExtractSchema has been deprecated in favor of generateSchema
   *
   */
  ExtractSchema() {
    return {
      [_SaplingTransactionDeprecatedToken.prim]: {
        "memo-size": Number(this.val.args[0]["int"])
      }
    };
  }
  generateSchema() {
    return {
      __michelsonType: _SaplingTransactionDeprecatedToken.prim,
      schema: {
        memoSize: this.val.args[0]["int"]
      }
    };
  }
  findAndReturnTokens(tokenToFind, tokens2) {
    if (_SaplingTransactionDeprecatedToken.prim === tokenToFind) {
      tokens2.push(this);
    }
    return tokens2;
  }
};
SaplingTransactionDeprecatedToken.prim = "sapling_transaction_deprecated";
var Bls12381frValidationError = class extends TokenValidationError {
  constructor(value, token, message) {
    super(value, token, message);
    this.value = value;
    this.token = token;
    this.name = "Bls12381frValidationError";
  }
};
var Bls12381frToken = class _Bls12381frToken extends Token {
  constructor(val, idx, fac) {
    super(val, idx, fac);
    this.val = val;
    this.idx = idx;
    this.fac = fac;
  }
  /**
   * @throws {@link Bls12381frValidationError}
   */
  validate(val) {
    if (/^[0-9a-fA-F]*$/.test(val) && val.length % 2 === 0) {
      return;
    }
    throw new Bls12381frValidationError(val, this, `Invalid bytes: ${JSON.stringify(val)}`);
  }
  convertUint8ArrayToHexString(val) {
    return val.constructor === Uint8Array ? Buffer.from(val).toString("hex") : val;
  }
  /**
   * @throws {@link Bls12381frValidationError}
   */
  Encode(args) {
    let val = args.pop();
    if (typeof val === "number") {
      return { int: val.toString() };
    } else {
      val = this.convertUint8ArrayToHexString(val);
      this.validate(val);
      return { bytes: val };
    }
  }
  /**
   * @throws {@link Bls12381frValidationError}
   */
  EncodeObject(val, semantic) {
    if (semantic && semantic[_Bls12381frToken.prim]) {
      return semantic[_Bls12381frToken.prim](val);
    }
    if (typeof val === "number") {
      return { int: val.toString() };
    } else {
      val = this.convertUint8ArrayToHexString(val);
      this.validate(val);
      return { bytes: val };
    }
  }
  Execute(val) {
    return val.bytes;
  }
  /**
   * @deprecated ExtractSchema has been deprecated in favor of generateSchema
   *
   */
  ExtractSchema() {
    return _Bls12381frToken.prim;
  }
  generateSchema() {
    return {
      __michelsonType: _Bls12381frToken.prim,
      schema: _Bls12381frToken.prim
    };
  }
  findAndReturnTokens(tokenToFind, tokens2) {
    if (_Bls12381frToken.prim === tokenToFind) {
      tokens2.push(this);
    }
    return tokens2;
  }
};
Bls12381frToken.prim = "bls12_381_fr";
var Bls12381g1ValidationError = class extends TokenValidationError {
  constructor(value, token, message) {
    super(value, token, message);
    this.value = value;
    this.token = token;
    this.name = "Bls12381g1ValidationError";
  }
};
var Bls12381g1Token = class _Bls12381g1Token extends Token {
  constructor(val, idx, fac) {
    super(val, idx, fac);
    this.val = val;
    this.idx = idx;
    this.fac = fac;
  }
  /**
   * @throws {@link Bls12381g1ValidationError}
   */
  validate(val) {
    if (/^[0-9a-fA-F]*$/.test(val) && val.length % 2 === 0) {
      return;
    }
    throw new Bls12381g1ValidationError(val, this, `Invalid bytes: ${JSON.stringify(val)}`);
  }
  convertUint8ArrayToHexString(val) {
    return val.constructor === Uint8Array ? Buffer.from(val).toString("hex") : val;
  }
  /**
   * @throws {@link Bls12381g1ValidationError}
   */
  Encode(args) {
    let val = args.pop();
    val = this.convertUint8ArrayToHexString(val);
    this.validate(val);
    return { bytes: val };
  }
  /**
   * @throws {@link Bls12381g1ValidationError}
   */
  EncodeObject(val, semantic) {
    val = this.convertUint8ArrayToHexString(val);
    this.validate(val);
    if (semantic && semantic[_Bls12381g1Token.prim]) {
      return semantic[_Bls12381g1Token.prim](val);
    }
    return { bytes: val };
  }
  Execute(val) {
    return val.bytes;
  }
  /**
   * @deprecated ExtractSchema has been deprecated in favor of generateSchema
   *
   */
  ExtractSchema() {
    return _Bls12381g1Token.prim;
  }
  generateSchema() {
    return {
      __michelsonType: _Bls12381g1Token.prim,
      schema: _Bls12381g1Token.prim
    };
  }
  findAndReturnTokens(tokenToFind, tokens2) {
    if (_Bls12381g1Token.prim === tokenToFind) {
      tokens2.push(this);
    }
    return tokens2;
  }
};
Bls12381g1Token.prim = "bls12_381_g1";
var Bls12381g2ValidationError = class extends TokenValidationError {
  constructor(value, token, message) {
    super(value, token, message);
    this.value = value;
    this.token = token;
    this.name = "Bls12381g2ValidationError";
  }
};
var Bls12381g2Token = class _Bls12381g2Token extends Token {
  constructor(val, idx, fac) {
    super(val, idx, fac);
    this.val = val;
    this.idx = idx;
    this.fac = fac;
  }
  /**
   * @throws {@link Bls12381g2ValidationError}
   */
  validate(val) {
    if (/^[0-9a-fA-F]*$/.test(val) && val.length % 2 === 0) {
      return;
    }
    throw new Bls12381g2ValidationError(val, this, `Invalid bytes: ${JSON.stringify(val)}`);
  }
  convertUint8ArrayToHexString(val) {
    return val.constructor === Uint8Array ? Buffer.from(val).toString("hex") : val;
  }
  /**
   * @throws {@link Bls12381g2ValidationError}
   */
  Encode(args) {
    let val = args.pop();
    val = this.convertUint8ArrayToHexString(val);
    this.validate(val);
    return { bytes: val };
  }
  /**
   * @throws {@link Bls12381g2ValidationError}
   */
  EncodeObject(val, semantic) {
    val = this.convertUint8ArrayToHexString(val);
    this.validate(val);
    if (semantic && semantic[_Bls12381g2Token.prim]) {
      return semantic[_Bls12381g2Token.prim](val);
    }
    return { bytes: val };
  }
  Execute(val) {
    return val.bytes;
  }
  /**
   * @deprecated ExtractSchema has been deprecated in favor of generateSchema
   *
   */
  ExtractSchema() {
    return _Bls12381g2Token.prim;
  }
  generateSchema() {
    return {
      __michelsonType: _Bls12381g2Token.prim,
      schema: _Bls12381g2Token.prim
    };
  }
  findAndReturnTokens(tokenToFind, tokens2) {
    if (_Bls12381g2Token.prim === tokenToFind) {
      tokens2.push(this);
    }
    return tokens2;
  }
};
Bls12381g2Token.prim = "bls12_381_g2";
var ChestValidationError = class extends TokenValidationError {
  constructor(value, token, message) {
    super(value, token, message);
    this.value = value;
    this.token = token;
    this.name = "ChestValidationError";
  }
};
var ChestToken = class _ChestToken extends Token {
  constructor(val, idx, fac) {
    super(val, idx, fac);
    this.val = val;
    this.idx = idx;
    this.fac = fac;
  }
  /**
   * @throws {@link ChestKeyValidationError}
   */
  validate(val) {
    if (/^[0-9a-fA-F]*$/.test(val) && val.length % 2 == 0) {
      return;
    }
    throw new ChestValidationError(val, this, `Invalid bytes: ${JSON.stringify(val)}`);
  }
  convertUint8ArrayToHexString(val) {
    return val.constructor === Uint8Array ? Buffer.from(val).toString("hex") : val;
  }
  /**
   * @throws {@link ChestKeyValidationError}
   */
  Encode(args) {
    let val = args.pop();
    val = this.convertUint8ArrayToHexString(val);
    this.validate(val);
    return { bytes: val };
  }
  /**
   * @throws {@link ChestKeyValidationError}
   */
  EncodeObject(val, semantic) {
    val = this.convertUint8ArrayToHexString(val);
    this.validate(val);
    if (semantic && semantic[_ChestToken.prim]) {
      return semantic[_ChestToken.prim](val);
    }
    return { bytes: val };
  }
  Execute(val) {
    return val.bytes;
  }
  /**
   * @deprecated ExtractSchema has been deprecated in favor of generateSchema
   *
   */
  ExtractSchema() {
    return _ChestToken.prim;
  }
  generateSchema() {
    return {
      __michelsonType: _ChestToken.prim,
      schema: _ChestToken.prim
    };
  }
  findAndReturnTokens(tokenToFind, tokens2) {
    if (_ChestToken.prim === tokenToFind) {
      tokens2.push(this);
    }
    return tokens2;
  }
};
ChestToken.prim = "chest";
var ChestKeyValidationError = class extends TokenValidationError {
  constructor(value, token, message) {
    super(value, token, message);
    this.value = value;
    this.token = token;
    this.name = "ChestKeyValidationError";
  }
};
var ChestKeyToken = class _ChestKeyToken extends Token {
  constructor(val, idx, fac) {
    super(val, idx, fac);
    this.val = val;
    this.idx = idx;
    this.fac = fac;
  }
  /**
   * @throws {@link ChestKeyValidationError}
   */
  validate(val) {
    if (/^[0-9a-fA-F]*$/.test(val) && val.length % 2 === 0) {
      return;
    }
    throw new ChestKeyValidationError(val, this, `Invalid bytes: ${JSON.stringify(val)}`);
  }
  convertUint8ArrayToHexString(val) {
    return val.constructor === Uint8Array ? Buffer.from(val).toString("hex") : val;
  }
  /**
   * @throws {@link ChestKeyValidationError}
   */
  Encode(args) {
    let val = args.pop();
    val = this.convertUint8ArrayToHexString(val);
    this.validate(val);
    return { bytes: val };
  }
  /**
   * @throws {@link ChestKeyValidationError}
   */
  EncodeObject(val, semantic) {
    val = this.convertUint8ArrayToHexString(val);
    this.validate(val);
    if (semantic && semantic[_ChestKeyToken.prim]) {
      return semantic[_ChestKeyToken.prim](val);
    }
    return { bytes: val };
  }
  Execute(val) {
    return val.bytes;
  }
  /**
   * @deprecated ExtractSchema has been deprecated in favor of generateSchema
   *
   */
  ExtractSchema() {
    return _ChestKeyToken.prim;
  }
  generateSchema() {
    return {
      __michelsonType: _ChestKeyToken.prim,
      schema: _ChestKeyToken.prim
    };
  }
  findAndReturnTokens(tokenToFind, tokens2) {
    if (_ChestKeyToken.prim === tokenToFind) {
      tokens2.push(this);
    }
    return tokens2;
  }
};
ChestKeyToken.prim = "chest_key";
var GlobalConstantEncodingError = class extends TokenValidationError {
  constructor(value, token, message) {
    super(value, token, message);
    this.value = value;
    this.token = token;
    this.name = "GlobalConstantEncodingError";
  }
};
var GlobalConstantDecodingError = class extends TokenValidationError {
  constructor(value, token, message) {
    super(value, token, message);
    this.value = value;
    this.token = token;
    this.name = "GlobalConstantDecodingError";
  }
};
var GlobalConstantToken = class _GlobalConstantToken extends Token {
  constructor(val, idx, fac) {
    super(val, idx, fac);
    this.val = val;
    this.idx = idx;
    this.fac = fac;
  }
  /**
   * @throws {@link GlobalConstantDecodingError}
   */
  Execute(val, semantic) {
    if (semantic && semantic[_GlobalConstantToken.prim]) {
      return semantic[_GlobalConstantToken.prim](val, this.val);
    } else {
      throw new GlobalConstantDecodingError(val, this, `Unable to decode a value represented by a global constants. Please provide an expanded script to the Michelson-Encoder or semantics for the decoding. The following global constant hash was encountered: ${this.val.args[0]["string"]}.`);
    }
  }
  /**
   * @throws {@link GlobalConstantEncodingError}
   */
  Encode(args) {
    throw new GlobalConstantEncodingError(args, this, `Unable to encode a script containing global constants. Please provide an expanded script to the Michelson-Encoder. The following global constant hash was encountered: ${this.val.args[0]["string"]}.`);
  }
  /**
   * @throws {@link GlobalConstantEncodingError}
   */
  EncodeObject(val, semantic) {
    if (semantic && semantic[_GlobalConstantToken.prim]) {
      return semantic[_GlobalConstantToken.prim](val);
    }
    throw new GlobalConstantEncodingError(val, this, `Unable to encode a script containing global constants. Please provide an expanded script to the Michelson-Encoder. The following global constant hash was encountered: ${this.val.args[0]["string"]}.`);
  }
  /**
   * @deprecated ExtractSchema has been deprecated in favor of generateSchema
   *
   */
  ExtractSchema() {
    return _GlobalConstantToken.prim;
  }
  generateSchema() {
    return {
      __michelsonType: _GlobalConstantToken.prim,
      schema: {
        hash: this.val.args[0]["string"]
      }
    };
  }
  findAndReturnTokens(tokenToFind, tokens2) {
    if (_GlobalConstantToken.prim === tokenToFind) {
      tokens2.push(this);
    }
    return tokens2;
  }
};
GlobalConstantToken.prim = "constant";
var tokens = [
  PairToken,
  NatToken,
  StringToken,
  BigMapToken,
  AddressToken,
  TxRollupL2AddressToken,
  MapToken,
  BoolToken,
  OrToken,
  ContractToken,
  ListToken,
  MutezToken,
  BytesToken,
  OptionToken,
  TimestampToken,
  IntToken,
  UnitToken,
  KeyToken,
  KeyHashToken,
  SignatureToken,
  LambdaToken,
  OperationToken,
  SetToken,
  ChainIDToken,
  TicketToken,
  TicketDeprecatedToken,
  NeverToken,
  SaplingStateToken,
  SaplingTransactionToken,
  SaplingTransactionDeprecatedToken,
  Bls12381frToken,
  Bls12381g1Token,
  Bls12381g2Token,
  ChestToken,
  ChestKeyToken,
  GlobalConstantToken
];
var InvalidTokenError = class extends TaquitoError {
  constructor(message, data) {
    super(message);
    this.message = message;
    this.data = data;
    this.name = "Invalid token error";
  }
};
function createToken(val, idx) {
  if (Array.isArray(val)) {
    return new PairToken(val, idx, createToken);
  }
  const t = tokens.find((x3) => x3.prim === val.prim);
  if (!t) {
    throw new InvalidTokenError(`Malformed data: ${JSON.stringify(val)}. Expected a value with a valid prim property`, val);
  }
  return new t(val, idx, createToken);
}
var InvalidRpcResponseError = class extends TaquitoError {
  constructor(script, reason) {
    super();
    this.script = script;
    this.reason = reason;
    this.name = "InvalidRpcResponseError";
    let message = `Invalid RPC response passed as argument(s).`;
    if (reason) {
      message += ` Reason: ${reason}.`;
    }
    message += ` Received: ${JSON.stringify(script)}`;
    this.message = message;
  }
};
var InvalidBigMapSchemaError = class extends TaquitoError {
  constructor(message) {
    super(message);
    this.message = message;
    this.name = "InvalidBigMapSchemaError";
  }
};
var InvalidBigMapDiffError = class extends TaquitoError {
  constructor(message, value) {
    super(message);
    this.message = message;
    this.value = value;
    this.name = "InvalidBigMapDiffError";
  }
};
var BigMapEncodingError = class extends TaquitoError {
  constructor(obj, details, schema, value) {
    super();
    this.details = details;
    this.schema = schema;
    this.value = value;
    this.name = "BigMapEncodingError";
    this.message = `Unable to encode the big map ${obj}. Schema is: ${JSON.stringify(schema)}. The ${obj} is: ${JSON.stringify(value)}. Error details: ${details}`;
  }
};
var StorageEncodingError = class extends TaquitoError {
  constructor(obj, details, schema, value, semantics) {
    super();
    this.details = details;
    this.schema = schema;
    this.value = value;
    this.semantics = semantics;
    this.name = "StorageEncodingError";
    this.message = `Unable to encode ${obj}. The schema is: ${JSON.stringify(schema)}, the value is: ${JSON.stringify(value)}.${semantics ? `And the semantic is: ${JSON.stringify(semantics)}` : ""}. Error details: ${details}`;
  }
};
var MissingArgumentError = class extends TaquitoError {
  constructor(message) {
    super(message);
    this.message = message;
    this.name = "MissingArgumentError";
  }
};
var _a2;
var schemaTypeSymbol = Symbol.for("taquito-schema-type-symbol");
function collapse(val, prim = PairToken.prim) {
  var _b, _c;
  if (Array.isArray(val)) {
    return collapse({
      prim,
      args: val
    }, prim);
  }
  const extended = val;
  if (extended.prim === prim && extended.args && extended.args.length > 2) {
    return Object.assign(Object.assign({}, extended), { args: [
      (_b = extended.args) === null || _b === void 0 ? void 0 : _b[0],
      {
        prim,
        args: (_c = extended.args) === null || _c === void 0 ? void 0 : _c.slice(1)
      }
    ] });
  }
  return extended;
}
function deepEqual(a2, b3) {
  if (a2 === void 0 || b3 === void 0) {
    return a2 === b3;
  }
  const ac = collapse(a2);
  const bc = collapse(b3);
  return ac.prim === bc.prim && (ac.args === void 0 && bc.args === void 0 || ac.args !== void 0 && bc.args !== void 0 && ac.args.length === bc.args.length && ac.args.every((v, i2) => {
    var _b, _c;
    return deepEqual(v, (_c = (_b = bc.args) === null || _b === void 0 ? void 0 : _b[i2]) !== null && _c !== void 0 ? _c : {});
  })) && (ac.annots === void 0 && bc.annots === void 0 || ac.annots !== void 0 && bc.annots !== void 0 && ac.annots.length === bc.annots.length && ac.annots.every((v, i2) => {
    var _b;
    return v === ((_b = bc.annots) === null || _b === void 0 ? void 0 : _b[i2]);
  }));
}
var Schema = class _Schema {
  constructor(val) {
    this.val = val;
    this[_a2] = true;
    this.root = createToken(val, 0);
    if (this.root instanceof BigMapToken) {
      this.bigMap = this.root;
    } else if (this.isExpressionExtended(val) && val.prim === "pair") {
      const exp = val.args[0];
      if (this.isExpressionExtended(exp) && exp.prim === "big_map") {
        this.bigMap = new BigMapToken(exp, 0, createToken);
      }
    }
  }
  static isSchema(obj) {
    return obj && obj[schemaTypeSymbol] === true;
  }
  /**
   * @throws {@link InvalidRpcResponseError}
   */
  static fromRPCResponse(val) {
    if (!val) {
      throw new InvalidRpcResponseError(val, "the RPC response is empty");
    }
    if (!val.script) {
      throw new InvalidRpcResponseError(val, "the RPC response has no script");
    }
    if (!Array.isArray(val.script.code)) {
      throw new InvalidRpcResponseError(val, "The response.script.code should be an array");
    }
    let code = val.script.code;
    while (code.length === 1 && Array.isArray(code[0])) {
      code = code[0];
    }
    const storage = code.find((x3) => "prim" in x3 && x3.prim === "storage");
    if (!storage || !Array.isArray(storage.args)) {
      throw new InvalidRpcResponseError(val, 'The response.script.code has an element of type {prim: "storage"}, but its args is not an array');
    }
    return new _Schema(storage.args[0]);
  }
  isExpressionExtended(val) {
    return "prim" in val && Array.isArray(val.args);
  }
  removeTopLevelAnnotation(obj) {
    if (this.root instanceof PairToken || this.root instanceof OrToken) {
      if (this.root.hasAnnotations() && typeof obj === "object" && Object.keys(obj).length === 1) {
        return obj[Object.keys(obj)[0]];
      }
    }
    return obj;
  }
  Execute(val, semantics) {
    const storage = this.root.Execute(val, semantics);
    return this.removeTopLevelAnnotation(storage);
  }
  Typecheck(val) {
    if (this.root instanceof BigMapToken && Number.isInteger(Number(val))) {
      return;
    }
    if (this.root instanceof TicketToken && val.ticketer && val.value && val.amount) {
      return;
    }
    if (this.root instanceof TicketDeprecatedToken && val.ticketer && val.value && val.amount) {
      return;
    }
    if (this.root instanceof MapToken && this.root.ValueSchema instanceof BigMapToken) {
      return;
    }
    this.root.EncodeObject(val);
  }
  /**
   * @throws {@link InvalidBigMapSchemaError}
   * @throws {@link InvalidBigMapDiffError}
   */
  ExecuteOnBigMapDiff(diff, semantics) {
    if (!this.bigMap) {
      throw new InvalidBigMapSchemaError("Big map schema is undefined");
    }
    if (!Array.isArray(diff)) {
      throw new InvalidBigMapDiffError(`Big map diff must be an array, got: ${JSON.stringify(diff)}`, diff);
    }
    const eltFormat = diff.map(({ key, value }) => ({ args: [key, value] }));
    return this.bigMap.Execute(eltFormat, semantics);
  }
  /**
   * @throws {@link InvalidBigMapSchemaError}
   */
  ExecuteOnBigMapValue(key, semantics) {
    if (!this.bigMap) {
      throw new InvalidBigMapSchemaError("Big map schema is undefined");
    }
    return this.bigMap.ValueSchema.Execute(key, semantics);
  }
  /**
   * @throws {@link InvalidBigMapSchemaError}
   * @throws {@link BigMapEncodingError}
   */
  EncodeBigMapKey(key) {
    if (!this.bigMap) {
      throw new InvalidBigMapSchemaError("Big map schema is undefined");
    }
    try {
      return this.bigMap.KeySchema.ToBigMapKey(key);
    } catch (ex) {
      throw new BigMapEncodingError("key", ex, this.bigMap.KeySchema, key);
    }
  }
  /**
   * @throws {@link TokenValidationError}
   * @throws {@link StorageEncodingError}
   */
  Encode(value, semantics) {
    try {
      return this.root.EncodeObject(value, semantics);
    } catch (ex) {
      if (ex instanceof TokenValidationError) {
        throw ex;
      }
      throw new StorageEncodingError("storage object", ex, this.root, value, semantics);
    }
  }
  /**
   * @deprecated ExtractSchema has been deprecated in favor of generateSchema
   *
   */
  ExtractSchema() {
    return this.removeTopLevelAnnotation(this.root.ExtractSchema());
  }
  /**
   * @description Produce a representation of the storage schema.
   * Note: Provide guidance on how to write the storage object for the origination operation with Taquito.
   */
  generateSchema() {
    return this.removeTopLevelAnnotation(this.root.generateSchema());
  }
  /**
   * @deprecated
   * @throws {@link InvalidBigMapSchemaError}
   */
  ComputeState(tx, state) {
    if (!this.bigMap) {
      throw new InvalidBigMapSchemaError("Big map schema is undefined");
    }
    const bigMap = tx.reduce((prev, current) => {
      return Object.assign(Object.assign({}, prev), this.ExecuteOnBigMapDiff(current.contents[0].metadata.operation_result.big_map_diff));
    }, {});
    return Object.assign(Object.assign({}, this.Execute(state)), { [this.bigMap.annot()]: bigMap });
  }
  /**
   * @description Look up in top-level pairs of the storage to find a value matching the specified type
   *
   * @returns The first value found that match the type or `undefined` if no value is found
   *
   * @param storage storage to parse to find the value
   * @param valueType type of value to look for
   *
   */
  FindFirstInTopLevelPair(storage, valueType) {
    return this.findValue(this.root["val"], storage, valueType);
  }
  // TODO check these type casts
  /**
   * @throws {@link MissingArgumentError}
   */
  findValue(schema, storage, valueToFind) {
    if (deepEqual(valueToFind, schema)) {
      return storage;
    }
    if (Array.isArray(schema) || schema.prim === "pair") {
      const sch = collapse(schema);
      const strg = collapse(storage, "Pair");
      if (sch.args === void 0 || strg.args === void 0) {
        throw new MissingArgumentError("Tokens have no arguments");
      }
      if (sch.args[0])
        return (
          // unsafe
          this.findValue(sch.args[0], strg.args[0], valueToFind) || this.findValue(sch.args[1], strg.args[1], valueToFind)
        );
    }
  }
  /**
   * @description Look up the schema to find any occurrence of a particular token.
   *
   * @returns an array of tokens of the specified kind or an empty array if no token was found
   *
   * @param tokenToFind string representing the prim property of the token to find
   *
   * @example
   * ```
   * Useful to find all global constants in a script, an array of GlobalConstantToken is returned:
   *
   * const schema = new Schema(script);
   * const allGlobalConstantTokens = schema.findToken('constant');
   * ```
   *
   */
  findToken(tokenToFind) {
    const tokens2 = [];
    return this.root.findAndReturnTokens(tokenToFind, tokens2);
  }
};
_a2 = schemaTypeSymbol;
var UnitValue = Symbol();

// node_modules/@taquito/michel-codec/dist/taquito-michel-codec.es6.js
var sourceReference = Symbol("source_reference");
var ScanError = class extends TaquitoError {
  constructor(src, idx, message) {
    super();
    this.src = src;
    this.idx = idx;
    this.message = message;
    this.name = "ScanError";
  }
};
var Literal;
(function(Literal2) {
  Literal2[Literal2["Comment"] = 0] = "Comment";
  Literal2[Literal2["Number"] = 1] = "Number";
  Literal2[Literal2["String"] = 2] = "String";
  Literal2[Literal2["Bytes"] = 3] = "Bytes";
  Literal2[Literal2["Ident"] = 4] = "Ident";
})(Literal || (Literal = {}));
var isSpace = new RegExp("\\s");
var isIdentStart = new RegExp("[:@%_A-Za-z]");
var isIdent = new RegExp("[@%_\\.A-Za-z0-9]");
var isDigit = new RegExp("[0-9]");
var isHex = new RegExp("[0-9a-fA-F]");
function* scan2(src, scanComments = false) {
  let i2 = 0;
  while (i2 < src.length) {
    while (i2 < src.length && isSpace.test(src[i2])) {
      i2++;
    }
    if (i2 === src.length) {
      return;
    }
    const s = src[i2];
    const start = i2;
    if (isIdentStart.test(s)) {
      i2++;
      while (i2 < src.length && isIdent.test(src[i2])) {
        i2++;
      }
      yield { t: Literal.Ident, v: src.slice(start, i2), first: start, last: i2 };
    } else if (src.length - i2 > 1 && src.substring(i2, i2 + 2) === "0x") {
      i2 += 2;
      while (i2 < src.length && isHex.test(src[i2])) {
        i2++;
      }
      if ((i2 - start & 1) !== 0) {
        throw new ScanError(src, i2, "Bytes literal length is expected to be power of two");
      }
      yield { t: Literal.Bytes, v: src.slice(start, i2), first: start, last: i2 };
    } else if (isDigit.test(s) || s === "-") {
      if (s === "-") {
        i2++;
      }
      const ii = i2;
      while (i2 < src.length && isDigit.test(src[i2])) {
        i2++;
      }
      if (ii === i2) {
        throw new ScanError(src, i2, "Number literal is too short");
      }
      yield { t: Literal.Number, v: src.slice(start, i2), first: start, last: i2 };
    } else if (s === '"') {
      i2++;
      let esc = false;
      for (; i2 < src.length && (esc || src[i2] !== '"'); i2++) {
        if (!esc && src[i2] === "\\") {
          esc = true;
        } else {
          esc = false;
        }
      }
      if (i2 === src.length) {
        throw new ScanError(src, i2, "Unterminated string literal");
      }
      i2++;
      yield { t: Literal.String, v: src.slice(start, i2), first: start, last: i2 };
    } else if (s === "#") {
      i2++;
      while (i2 < src.length && src[i2] !== "\n") {
        i2++;
      }
      if (scanComments) {
        yield { t: Literal.Comment, v: src.slice(start, i2), first: start, last: i2 };
      }
    } else if (src.length - i2 > 1 && src.substring(i2, i2 + 2) === "/*") {
      i2 += 2;
      while (i2 < src.length && !(src.length - i2 > 1 && src.substring(i2, i2 + 2) === "*/")) {
        i2++;
      }
      if (i2 === src.length) {
        throw new ScanError(src, i2, "Unterminated C style comment");
      }
      i2 += 2;
      if (scanComments) {
        yield { t: Literal.Comment, v: src.slice(start, i2), first: start, last: i2 };
      }
    } else if (s === "(" || s === ")" || s === "{" || s === "}" || s === ";") {
      i2++;
      yield { t: s, v: s, first: start, last: i2 };
    } else {
      throw new ScanError(src, i2, `Invalid character at offset ${i2}: \`${s}'`);
    }
  }
}
var refContract = Symbol("ref_contract");
var Protocol;
(function(Protocol2) {
  Protocol2["Ps9mPmXa"] = "Ps9mPmXaRzmzk35gbAYNCAw6UXdE2qoABTHbN2oEEc1qM7CwT9P";
  Protocol2["PtCJ7pwo"] = "PtCJ7pwoxe8JasnHY8YonnLYjcVHmhiARPJvqcC6VfHT5s8k8sY";
  Protocol2["PsYLVpVv"] = "PsYLVpVvgbLhAhoqAkMFUo6gudkJ9weNXhUYCiLDzcUpFpkk8Wt";
  Protocol2["PsddFKi3"] = "PsddFKi32cMJ2qPjf43Qv5GDWLDPZb3T3bF6fLKiF5HtvHNU7aP";
  Protocol2["Pt24m4xi"] = "Pt24m4xiPbLDhVgVfABUjirbmda3yohdN82Sp9FeuAXJ4eV9otd";
  Protocol2["PsBABY5H"] = "PsBABY5HQTSkA4297zNHfsZNKtxULfL18y95qb3m53QJiXGmrbU";
  Protocol2["PsBabyM1"] = "PsBabyM1eUXZseaJdmXFApDSBqj8YBfwELoxZHHW77EMcAbbwAS";
  Protocol2["PsCARTHA"] = "PsCARTHAGazKbHtnKfLzQg3kms52kSRpgnDY982a9oYsSXRLQEb";
  Protocol2["PsDELPH1"] = "PsDELPH1Kxsxt8f9eWbxQeRxkjfbxoqM52jvs5Y5fBxWWh4ifpo";
  Protocol2["PtEdoTez"] = "PtEdoTezd3RHSC31mpxxo1npxFjoWWcFgQtxapi51Z8TLu6v6Uq";
  Protocol2["PtEdo2Zk"] = "PtEdo2ZkT9oKpimTah6x2embF25oss54njMuPzkJTEi5RqfdZFA";
  Protocol2["PsFLoren"] = "PsFLorenaUUuikDWvMDr6fGBRG8kt3e3D3fHoXK1j1BFRxeSH4i";
  Protocol2["PsFLorena"] = "PsFLorenaUUuikDWvMDr6fGBRG8kt3e3D3fHoXK1j1BFRxeSH4i";
  Protocol2["PtGRANAD"] = "PtGRANADsDU8R9daYKAgWnQYAJ64omN1o3KMGVCykShA97vQbvV";
  Protocol2["PtGRANADs"] = "PtGRANADsDU8R9daYKAgWnQYAJ64omN1o3KMGVCykShA97vQbvV";
  Protocol2["PtHangzH"] = "PtHangzHogokSuiMHemCuowEavgYTP8J5qQ9fQS793MHYFpCY3r";
  Protocol2["PtHangz2"] = "PtHangz2aRngywmSRGGvrcTyMbbdpWdpFKuS4uMWxg2RaH9i1qx";
  Protocol2["PsiThaCa"] = "PsiThaCaT47Zboaw71QWScM8sXeMM7bbQFncK9FLqYc6EKdpjVP";
  Protocol2["Psithaca2"] = "Psithaca2MLRFYargivpo7YvUr7wUDqyxrdhC5CQq78mRvimz6A";
  Protocol2["PtJakarta"] = "PtJakartaiDz69SfDDLXJSiuZqTSeSKRDbKVZC8MNzJnvRjvnGw";
  Protocol2["PtJakart2"] = "PtJakart2xVj7pYXJBXrqHgd82rdkLey5ZeeGwDgPp9rhQUbSqY";
  Protocol2["PtKathman"] = "PtKathmankSpLLDALzWw7CGD2j2MtyveTwboEYokqUCP4a1LxMg";
  Protocol2["PtLimaPtL"] = "PtLimaPtLMwfNinJi9rCfDPWea8dFgTZ1MeJ9f1m2SRic6ayiwW";
  Protocol2["PtMumbaii"] = "PtMumbaiiFFEGbew1rRjzSPyzRbA51Tm3RVZL5suHPxSZYDhCEc";
  Protocol2["PtMumbai2"] = "PtMumbai2TmsJHNGRkD8v8YDbtao7BLUC3wjASn1inAKLFCjaH1";
  Protocol2["PtNairobi"] = "PtNairobiyssHuh87hEhfVBGCVrK3WnS8Z2FT4ymB5tAa4r1nQf";
  Protocol2["ProtoALpha"] = "ProtoALphaALphaALphaALphaALphaALphaALphaALphaDdp3zK";
})(Protocol || (Protocol = {}));
var DefaultProtocol = Protocol.Psithaca2;
var protoLevel = {
  Ps9mPmXaRzmzk35gbAYNCAw6UXdE2qoABTHbN2oEEc1qM7CwT9P: 0,
  PtCJ7pwoxe8JasnHY8YonnLYjcVHmhiARPJvqcC6VfHT5s8k8sY: 1,
  PsYLVpVvgbLhAhoqAkMFUo6gudkJ9weNXhUYCiLDzcUpFpkk8Wt: 2,
  PsddFKi32cMJ2qPjf43Qv5GDWLDPZb3T3bF6fLKiF5HtvHNU7aP: 3,
  Pt24m4xiPbLDhVgVfABUjirbmda3yohdN82Sp9FeuAXJ4eV9otd: 4,
  PsBABY5HQTSkA4297zNHfsZNKtxULfL18y95qb3m53QJiXGmrbU: 5,
  PsBabyM1eUXZseaJdmXFApDSBqj8YBfwELoxZHHW77EMcAbbwAS: 5,
  PsCARTHAGazKbHtnKfLzQg3kms52kSRpgnDY982a9oYsSXRLQEb: 6,
  PsDELPH1Kxsxt8f9eWbxQeRxkjfbxoqM52jvs5Y5fBxWWh4ifpo: 7,
  PtEdoTezd3RHSC31mpxxo1npxFjoWWcFgQtxapi51Z8TLu6v6Uq: 8,
  PtEdo2ZkT9oKpimTah6x2embF25oss54njMuPzkJTEi5RqfdZFA: 8,
  PsFLorenaUUuikDWvMDr6fGBRG8kt3e3D3fHoXK1j1BFRxeSH4i: 9,
  PtGRANADsDU8R9daYKAgWnQYAJ64omN1o3KMGVCykShA97vQbvV: 10,
  PtHangzHogokSuiMHemCuowEavgYTP8J5qQ9fQS793MHYFpCY3r: 11,
  PtHangz2aRngywmSRGGvrcTyMbbdpWdpFKuS4uMWxg2RaH9i1qx: 11,
  PsiThaCaT47Zboaw71QWScM8sXeMM7bbQFncK9FLqYc6EKdpjVP: 12,
  Psithaca2MLRFYargivpo7YvUr7wUDqyxrdhC5CQq78mRvimz6A: 12,
  PtJakartaiDz69SfDDLXJSiuZqTSeSKRDbKVZC8MNzJnvRjvnGw: 13,
  PtJakart2xVj7pYXJBXrqHgd82rdkLey5ZeeGwDgPp9rhQUbSqY: 13,
  PtKathmankSpLLDALzWw7CGD2j2MtyveTwboEYokqUCP4a1LxMg: 14,
  PtLimaPtLMwfNinJi9rCfDPWea8dFgTZ1MeJ9f1m2SRic6ayiwW: 15,
  PtMumbaiiFFEGbew1rRjzSPyzRbA51Tm3RVZL5suHPxSZYDhCEc: 16,
  PtMumbai2TmsJHNGRkD8v8YDbtao7BLUC3wjASn1inAKLFCjaH1: 16,
  PtNairobiyssHuh87hEhfVBGCVrK3WnS8Z2FT4ymB5tAa4r1nQf: 17,
  ProtoALphaALphaALphaALphaALphaALphaALphaALphaDdp3zK: 18
};
function ProtoInferiorTo(a2, b3) {
  return protoLevel[a2] < protoLevel[b3];
}
var MacroError = class extends TaquitoError {
  constructor(prim, message) {
    super();
    this.prim = prim;
    this.message = message;
    this.name = "MacroError";
  }
};
function assertArgs$1(ex, n2) {
  var _a3, _b;
  if (n2 === 0 && ex.args === void 0 || ((_a3 = ex.args) === null || _a3 === void 0 ? void 0 : _a3.length) === n2) {
    return true;
  }
  throw new MacroError(ex, `macro ${ex.prim} expects ${n2} arguments, was given ${(_b = ex.args) === null || _b === void 0 ? void 0 : _b.length}`);
}
function assertNoAnnots(ex) {
  if (ex.annots === void 0) {
    return true;
  }
  throw new MacroError(ex, `unexpected annotation on macro ${ex.prim}: ${ex.annots}`);
}
function assertIntArg(ex, arg) {
  if ("int" in arg) {
    return true;
  }
  throw new MacroError(ex, `macro ${ex.prim} expects int argument`);
}
function parsePairUnpairExpr(p3, expr, annotations, agg) {
  let i2 = 0;
  let ai = 0;
  const ann = [null, null];
  let lexpr;
  if (i2 === expr.length) {
    throw new MacroError(p3, `unexpected end: ${p3.prim}`);
  }
  let c2 = expr[i2++];
  switch (c2) {
    case "P": {
      const { r, n: n2, an: an2 } = parsePairUnpairExpr(p3, expr.slice(i2), annotations.slice(ai), agg);
      lexpr = r;
      i2 += n2;
      ai += an2;
      break;
    }
    case "A":
      if (ai !== annotations.length) {
        ann[0] = annotations[ai++];
      }
      break;
    default:
      throw new MacroError(p3, `${p3.prim}: unexpected character: ${c2}`);
  }
  let rexpr;
  if (i2 === expr.length) {
    throw new MacroError(p3, `unexpected end: ${p3.prim}`);
  }
  c2 = expr[i2++];
  switch (c2) {
    case "P": {
      const { r, n: n2, an: an2 } = parsePairUnpairExpr(p3, expr.slice(i2), annotations.slice(ai), agg);
      rexpr = r.map(([v, a2]) => [v + 1, a2]);
      i2 += n2;
      ai += an2;
      break;
    }
    case "I":
      if (ai !== annotations.length) {
        ann[1] = annotations[ai++];
      }
      break;
    default:
      throw new MacroError(p3, `${p3.prim}: unexpected character: ${c2}`);
  }
  return { r: agg(lexpr, rexpr, [0, ann]), n: i2, an: ai };
}
function parseSetMapCadr(p3, expr, vann, term) {
  const c2 = expr[0];
  switch (c2) {
    case "A":
      return expr.length > 1 ? [
        { prim: "DUP" },
        {
          prim: "DIP",
          args: [
            [{ prim: "CAR", annots: ["@%%"] }, parseSetMapCadr(p3, expr.slice(1), [], term)]
          ]
        },
        { prim: "CDR", annots: ["@%%"] },
        { prim: "SWAP" },
        { prim: "PAIR", annots: ["%@", "%@", ...vann] }
      ] : term.a;
    case "D":
      return expr.length > 1 ? [
        { prim: "DUP" },
        {
          prim: "DIP",
          args: [
            [{ prim: "CDR", annots: ["@%%"] }, parseSetMapCadr(p3, expr.slice(1), [], term)]
          ]
        },
        { prim: "CAR", annots: ["@%%"] },
        { prim: "PAIR", annots: ["%@", "%@", ...vann] }
      ] : term.d;
    default:
      throw new MacroError(p3, `${p3.prim}: unexpected character: ${c2}`);
  }
}
function trimLast(a2, v) {
  let l = a2.length;
  while (l > 0 && a2[l - 1] === v) {
    l--;
  }
  return a2.slice(0, l);
}
function filterAnnotations(a2) {
  const fields = [];
  const rest = [];
  if (a2 !== void 0) {
    for (const v of a2) {
      (v.length !== 0 && v[0] === "%" ? fields : rest).push(v);
    }
  }
  return { fields, rest };
}
function mkPrim({ prim, annots, args }) {
  return Object.assign(Object.assign({ prim }, annots && { annots }), args && { args });
}
var pairRe = /^P[PAI]{3,}R$/;
var unpairRe = /^UNP[PAI]{2,}R$/;
var cadrRe = /^C[AD]{2,}R$/;
var setCadrRe = /^SET_C[AD]+R$/;
var mapCadrRe = /^MAP_C[AD]+R$/;
var diipRe = /^DI{2,}P$/;
var duupRe = /^DU+P$/;
function expandMacros(ex, opt) {
  const proto = (opt === null || opt === void 0 ? void 0 : opt.protocol) || DefaultProtocol;
  function mayRename(annots) {
    return annots !== void 0 ? [{ prim: "RENAME", annots }] : [];
  }
  switch (ex.prim) {
    case "CMPEQ":
    case "CMPNEQ":
    case "CMPLT":
    case "CMPGT":
    case "CMPLE":
    case "CMPGE":
      if (assertArgs$1(ex, 0)) {
        return [{ prim: "COMPARE" }, mkPrim({ prim: ex.prim.slice(3), annots: ex.annots })];
      }
      break;
    case "IFEQ":
    case "IFNEQ":
    case "IFLT":
    case "IFGT":
    case "IFLE":
    case "IFGE":
      if (assertArgs$1(ex, 2)) {
        return [
          { prim: ex.prim.slice(2) },
          mkPrim({ prim: "IF", annots: ex.annots, args: ex.args })
        ];
      }
      break;
    case "IFCMPEQ":
    case "IFCMPNEQ":
    case "IFCMPLT":
    case "IFCMPGT":
    case "IFCMPLE":
    case "IFCMPGE":
      if (assertArgs$1(ex, 2)) {
        return [
          { prim: "COMPARE" },
          { prim: ex.prim.slice(5) },
          mkPrim({ prim: "IF", annots: ex.annots, args: ex.args })
        ];
      }
      break;
    case "FAIL":
      if (assertArgs$1(ex, 0) && assertNoAnnots(ex)) {
        return [{ prim: "UNIT" }, { prim: "FAILWITH" }];
      }
      break;
    case "ASSERT":
      if (assertArgs$1(ex, 0) && assertNoAnnots(ex)) {
        return [
          {
            prim: "IF",
            args: [[], [[{ prim: "UNIT" }, { prim: "FAILWITH" }]]]
          }
        ];
      }
      break;
    case "ASSERT_EQ":
    case "ASSERT_NEQ":
    case "ASSERT_LT":
    case "ASSERT_GT":
    case "ASSERT_LE":
    case "ASSERT_GE":
      if (assertArgs$1(ex, 0) && assertNoAnnots(ex)) {
        return [
          { prim: ex.prim.slice(7) },
          {
            prim: "IF",
            args: [[], [[{ prim: "UNIT" }, { prim: "FAILWITH" }]]]
          }
        ];
      }
      break;
    case "ASSERT_CMPEQ":
    case "ASSERT_CMPNEQ":
    case "ASSERT_CMPLT":
    case "ASSERT_CMPGT":
    case "ASSERT_CMPLE":
    case "ASSERT_CMPGE":
      if (assertArgs$1(ex, 0) && assertNoAnnots(ex)) {
        return [
          [{ prim: "COMPARE" }, { prim: ex.prim.slice(10) }],
          {
            prim: "IF",
            args: [[], [[{ prim: "UNIT" }, { prim: "FAILWITH" }]]]
          }
        ];
      }
      break;
    case "ASSERT_NONE":
      if (assertArgs$1(ex, 0) && assertNoAnnots(ex)) {
        return [
          {
            prim: "IF_NONE",
            args: [[], [[{ prim: "UNIT" }, { prim: "FAILWITH" }]]]
          }
        ];
      }
      break;
    case "ASSERT_SOME":
      if (assertArgs$1(ex, 0)) {
        return [
          {
            prim: "IF_NONE",
            args: [[[{ prim: "UNIT" }, { prim: "FAILWITH" }]], mayRename(ex.annots)]
          }
        ];
      }
      break;
    case "ASSERT_LEFT":
      if (assertArgs$1(ex, 0)) {
        return [
          {
            prim: "IF_LEFT",
            args: [mayRename(ex.annots), [[{ prim: "UNIT" }, { prim: "FAILWITH" }]]]
          }
        ];
      }
      break;
    case "ASSERT_RIGHT":
      if (assertArgs$1(ex, 0)) {
        return [
          {
            prim: "IF_LEFT",
            args: [[[{ prim: "UNIT" }, { prim: "FAILWITH" }]], mayRename(ex.annots)]
          }
        ];
      }
      break;
    case "IF_SOME":
      if (assertArgs$1(ex, 2)) {
        return [mkPrim({ prim: "IF_NONE", annots: ex.annots, args: [ex.args[1], ex.args[0]] })];
      }
      break;
    case "IF_RIGHT":
      if (assertArgs$1(ex, 2)) {
        return [mkPrim({ prim: "IF_LEFT", annots: ex.annots, args: [ex.args[1], ex.args[0]] })];
      }
      break;
    case "CAR":
    case "CDR":
      if (ex.args !== void 0) {
        if (assertArgs$1(ex, 1) && assertIntArg(ex, ex.args[0])) {
          const n2 = parseInt(ex.args[0].int, 10);
          return mkPrim({
            prim: "GET",
            args: [{ int: ex.prim === "CAR" ? String(n2 * 2 + 1) : String(n2 * 2) }],
            annots: ex.annots
          });
        }
      } else {
        return ex;
      }
  }
  if (pairRe.test(ex.prim)) {
    if (assertArgs$1(ex, 0)) {
      const { fields, rest } = filterAnnotations(ex.annots);
      const { r } = parsePairUnpairExpr(ex, ex.prim.slice(1), fields, (l, r2, top) => [
        ...l || [],
        ...r2 || [],
        top
      ]);
      return r.map(([v, a2], i2) => {
        const ann = [
          ...trimLast(a2, null).map((v2) => v2 === null ? "%" : v2),
          ...v === 0 && i2 === r.length - 1 ? rest : []
        ];
        const leaf = mkPrim({ prim: "PAIR", annots: ann.length !== 0 ? ann : void 0 });
        return v === 0 ? leaf : {
          prim: "DIP",
          args: v === 1 ? [[leaf]] : [{ int: String(v) }, [leaf]]
        };
      });
    }
  }
  if (unpairRe.test(ex.prim)) {
    if (ProtoInferiorTo(proto, Protocol.PtEdo2Zk) && assertArgs$1(ex, 0)) {
      const { r } = parsePairUnpairExpr(ex, ex.prim.slice(3), ex.annots || [], (l, r2, top) => [
        top,
        ...r2 || [],
        ...l || []
      ]);
      return r.map(([v, a2]) => {
        const leaf = [
          { prim: "DUP" },
          mkPrim({ prim: "CAR", annots: a2[0] !== null ? [a2[0]] : void 0 }),
          {
            prim: "DIP",
            args: [[mkPrim({ prim: "CDR", annots: a2[1] !== null ? [a2[1]] : void 0 })]]
          }
        ];
        return v === 0 ? leaf : {
          prim: "DIP",
          args: v === 1 ? [[leaf]] : [{ int: String(v) }, [leaf]]
        };
      });
    } else {
      if (ex.prim === "UNPAIR") {
        return ex;
      }
      if (assertArgs$1(ex, 0)) {
        const { r } = parsePairUnpairExpr(ex, ex.prim.slice(3), [], (l, r2, top) => [
          top,
          ...r2 || [],
          ...l || []
        ]);
        return r.map(([v]) => {
          const leaf = mkPrim({
            prim: "UNPAIR"
          });
          return v === 0 ? leaf : {
            prim: "DIP",
            args: v === 1 ? [[leaf]] : [{ int: String(v) }, [leaf]]
          };
        });
      }
    }
  }
  if (cadrRe.test(ex.prim)) {
    if (assertArgs$1(ex, 0)) {
      const ch = [...ex.prim.slice(1, ex.prim.length - 1)];
      return ch.map((c2, i2) => {
        const ann = i2 === ch.length - 1 ? ex.annots : void 0;
        switch (c2) {
          case "A":
            return mkPrim({ prim: "CAR", annots: ann });
          case "D":
            return mkPrim({ prim: "CDR", annots: ann });
          default:
            throw new MacroError(ex, `unexpected character: ${c2}`);
        }
      });
    }
  }
  if (setCadrRe.test(ex.prim)) {
    if (assertArgs$1(ex, 0)) {
      const { fields, rest } = filterAnnotations(ex.annots);
      if (fields.length > 1) {
        throw new MacroError(ex, `unexpected annotation on macro ${ex.prim}: ${fields}`);
      }
      const term = fields.length !== 0 ? {
        a: [
          { prim: "DUP" },
          { prim: "CAR", annots: fields },
          { prim: "DROP" },
          { prim: "CDR", annots: ["@%%"] },
          { prim: "SWAP" },
          { prim: "PAIR", annots: [fields[0], "%@"] }
        ],
        d: [
          { prim: "DUP" },
          { prim: "CDR", annots: fields },
          { prim: "DROP" },
          { prim: "CAR", annots: ["@%%"] },
          { prim: "PAIR", annots: ["%@", fields[0]] }
        ]
      } : {
        a: [
          { prim: "CDR", annots: ["@%%"] },
          { prim: "SWAP" },
          { prim: "PAIR", annots: ["%", "%@"] }
        ],
        d: [
          { prim: "CAR", annots: ["@%%"] },
          { prim: "PAIR", annots: ["%@", "%"] }
        ]
      };
      return parseSetMapCadr(ex, ex.prim.slice(5, ex.prim.length - 1), rest, term);
    }
  }
  if (mapCadrRe.test(ex.prim)) {
    if (assertArgs$1(ex, 1)) {
      const { fields } = filterAnnotations(ex.annots);
      if (fields.length > 1) {
        throw new MacroError(ex, `unexpected annotation on macro ${ex.prim}: ${fields}`);
      }
      const term = {
        a: [
          { prim: "DUP" },
          { prim: "CDR", annots: ["@%%"] },
          {
            prim: "DIP",
            args: [
              [
                mkPrim({
                  prim: "CAR",
                  annots: fields.length !== 0 ? ["@" + fields[0].slice(1)] : void 0
                }),
                ex.args[0]
              ]
            ]
          },
          { prim: "SWAP" },
          { prim: "PAIR", annots: [fields.length !== 0 ? fields[0] : "%", "%@"] }
        ],
        d: [
          { prim: "DUP" },
          mkPrim({
            prim: "CDR",
            annots: fields.length !== 0 ? ["@" + fields[0].slice(1)] : void 0
          }),
          ex.args[0],
          { prim: "SWAP" },
          { prim: "CAR", annots: ["@%%"] },
          { prim: "PAIR", annots: ["%@", fields.length !== 0 ? fields[0] : "%"] }
        ]
      };
      return parseSetMapCadr(ex, ex.prim.slice(5, ex.prim.length - 1), [], term);
    }
  }
  if (diipRe.test(ex.prim)) {
    if (assertArgs$1(ex, 1)) {
      let n2 = 0;
      while (ex.prim[1 + n2] === "I") {
        n2++;
      }
      return mkPrim({ prim: "DIP", args: [{ int: String(n2) }, ex.args[0]] });
    }
  }
  if (duupRe.test(ex.prim)) {
    let n2 = 0;
    while (ex.prim[1 + n2] === "U") {
      n2++;
    }
    if (ProtoInferiorTo(proto, Protocol.PtEdo2Zk)) {
      if (n2 === 1) {
        if (ex.args === void 0) {
          return ex;
        }
        if (assertArgs$1(ex, 1) && assertIntArg(ex, ex.args[0])) {
          n2 = parseInt(ex.args[0].int, 10);
        }
      } else {
        assertArgs$1(ex, 0);
      }
      if (n2 === 1) {
        return [mkPrim({ prim: "DUP", annots: ex.annots })];
      } else if (n2 === 2) {
        return [
          {
            prim: "DIP",
            args: [[mkPrim({ prim: "DUP", annots: ex.annots })]]
          },
          { prim: "SWAP" }
        ];
      } else {
        return [
          {
            prim: "DIP",
            args: [{ int: String(n2 - 1) }, [mkPrim({ prim: "DUP", annots: ex.annots })]]
          },
          {
            prim: "DIG",
            args: [{ int: String(n2) }]
          }
        ];
      }
    } else {
      if (n2 === 1) {
        return ex;
      }
      if (assertArgs$1(ex, 0)) {
        return mkPrim({ prim: "DUP", args: [{ int: String(n2) }], annots: ex.annots });
      }
    }
  }
  return ex;
}
function expandGlobalConstants(ex, hashAndValue) {
  if (ex.args !== void 0 && ex.args.length === 1 && "string" in ex.args[0] && ex.args[0].string in hashAndValue) {
    return hashAndValue[ex.args[0].string];
  }
  return ex;
}
var MichelineParseError = class extends TaquitoError {
  /**
   * @param token A token caused the error
   * @param message An error message
   */
  constructor(token, message) {
    super();
    this.token = token;
    this.message = message;
    this.name = "MichelineParseError";
  }
};
var JSONParseError = class extends TaquitoError {
  /**
   * @param node A node caused the error
   * @param message An error message
   */
  constructor(node, message) {
    super();
    this.node = node;
    this.message = message;
    this.name = "JSONParseError";
  }
};
var errEOF = new MichelineParseError(null, "Unexpected EOF");
function isAnnotation(tok) {
  return tok.t === Literal.Ident && (tok.v[0] === "@" || tok.v[0] === "%" || tok.v[0] === ":");
}
var intRe = new RegExp("^-?[0-9]+$");
var bytesRe = new RegExp("^([0-9a-fA-F]{2})*$");
var Parser = class {
  constructor(opt) {
    this.opt = opt;
  }
  expand(ex) {
    var _a3, _b, _c;
    if (((_a3 = this.opt) === null || _a3 === void 0 ? void 0 : _a3.expandGlobalConstant) !== void 0 && ex.prim === "constant") {
      const ret = expandGlobalConstants(ex, this.opt.expandGlobalConstant);
      if (ret !== ex) {
        ret[sourceReference] = Object.assign(Object.assign({}, ex[sourceReference] || { first: 0, last: 0 }), { globalConstant: ex });
      }
      return ret;
    }
    if (((_b = this.opt) === null || _b === void 0 ? void 0 : _b.expandMacros) !== void 0 ? (_c = this.opt) === null || _c === void 0 ? void 0 : _c.expandMacros : true) {
      const ret = expandMacros(ex, this.opt);
      if (ret !== ex) {
        ret[sourceReference] = Object.assign(Object.assign({}, ex[sourceReference] || { first: 0, last: 0 }), { macro: ex });
      }
      return ret;
    } else {
      return ex;
    }
  }
  parseListExpr(scanner, start) {
    var _a3;
    const ref = {
      first: start.first,
      last: start.last
    };
    const expectBracket = start.t === "(";
    let tok;
    if (expectBracket) {
      tok = scanner.next();
      if (tok.done) {
        throw errEOF;
      }
      ref.last = tok.value.last;
    } else {
      tok = { value: start };
    }
    if (tok.value.t !== Literal.Ident) {
      throw new MichelineParseError(tok.value, `not an identifier: ${tok.value.v}`);
    }
    const ret = {
      prim: tok.value.v,
      [sourceReference]: ref
    };
    for (; ; ) {
      const tok2 = scanner.next();
      if (tok2.done) {
        if (expectBracket) {
          throw errEOF;
        }
        break;
      } else if (tok2.value.t === ")") {
        if (!expectBracket) {
          throw new MichelineParseError(tok2.value, "unexpected closing bracket");
        }
        ref.last = tok2.value.last;
        break;
      } else if (isAnnotation(tok2.value)) {
        ret.annots = ret.annots || [];
        ret.annots.push(tok2.value.v);
        ref.last = tok2.value.last;
      } else {
        ret.args = ret.args || [];
        const arg = this.parseExpr(scanner, tok2.value);
        ref.last = ((_a3 = arg[sourceReference]) === null || _a3 === void 0 ? void 0 : _a3.last) || ref.last;
        ret.args.push(arg);
      }
    }
    return this.expand(ret);
  }
  parseArgs(scanner, start) {
    var _a3;
    const ref = {
      first: start.first,
      last: start.last
    };
    const p3 = {
      prim: start.v,
      [sourceReference]: ref
    };
    for (; ; ) {
      const t = scanner.next();
      if (t.done || t.value.t === "}" || t.value.t === ";") {
        return [p3, t];
      }
      if (isAnnotation(t.value)) {
        ref.last = t.value.last;
        p3.annots = p3.annots || [];
        p3.annots.push(t.value.v);
      } else {
        const arg = this.parseExpr(scanner, t.value);
        ref.last = ((_a3 = arg[sourceReference]) === null || _a3 === void 0 ? void 0 : _a3.last) || ref.last;
        p3.args = p3.args || [];
        p3.args.push(arg);
      }
    }
  }
  parseSequenceExpr(scanner, start) {
    var _a3, _b;
    const ref = {
      first: start.first,
      last: start.last
    };
    const seq = [];
    seq[sourceReference] = ref;
    const expectBracket = start.t === "{";
    let tok = start.t === "{" ? null : { value: start };
    for (; ; ) {
      if (tok === null) {
        tok = scanner.next();
        if (!tok.done) {
          ref.last = tok.value.last;
        }
      }
      if (tok.done) {
        if (expectBracket) {
          throw errEOF;
        } else {
          return seq;
        }
      }
      if (tok.value.t === "}") {
        if (!expectBracket) {
          throw new MichelineParseError(tok.value, "unexpected closing bracket");
        } else {
          return seq;
        }
      } else if (tok.value.t === Literal.Ident) {
        const [itm, n2] = this.parseArgs(scanner, tok.value);
        ref.last = ((_a3 = itm[sourceReference]) === null || _a3 === void 0 ? void 0 : _a3.last) || ref.last;
        seq.push(this.expand(itm));
        tok = n2;
      } else {
        const ex = this.parseExpr(scanner, tok.value);
        ref.last = ((_b = ex[sourceReference]) === null || _b === void 0 ? void 0 : _b.last) || ref.last;
        seq.push(ex);
        tok = null;
      }
      if (tok === null) {
        tok = scanner.next();
        if (!tok.done) {
          ref.last = tok.value.last;
        }
      }
      if (!tok.done && tok.value.t === ";") {
        tok = null;
      }
    }
  }
  parseExpr(scanner, tok) {
    switch (tok.t) {
      case Literal.Ident:
        return this.expand({
          prim: tok.v,
          [sourceReference]: { first: tok.first, last: tok.last }
        });
      case Literal.Number:
        return { int: tok.v, [sourceReference]: { first: tok.first, last: tok.last } };
      case Literal.String:
        return {
          string: JSON.parse(tok.v),
          [sourceReference]: { first: tok.first, last: tok.last }
        };
      case Literal.Bytes:
        return { bytes: tok.v.slice(2), [sourceReference]: { first: tok.first, last: tok.last } };
      case "{":
        return this.parseSequenceExpr(scanner, tok);
      default:
        return this.parseListExpr(scanner, tok);
    }
  }
  /**
   * Parses a Micheline sequence expression, such as smart contract source. Enclosing curly brackets may be omitted.
   * @param src A Micheline sequence `{parameter ...; storage int; code { DUP ; ...};}` or `parameter ...; storage int; code { DUP ; ...};`
   */
  parseSequence(src) {
    if (typeof src !== "string") {
      throw new TypeError(`string type was expected, got ${typeof src} instead`);
    }
    const scanner = scan2(src);
    const tok = scanner.next();
    if (tok.done) {
      return null;
    }
    return this.parseSequenceExpr(scanner, tok.value);
  }
  /**
   * Parse a Micheline sequence expression. Enclosing curly brackets may be omitted.
   * @param src A Michelson list expression such as `(Pair {Elt "0" 0} 0)` or `Pair {Elt "0" 0} 0`
   * @returns An AST node or null for empty document.
   */
  parseList(src) {
    if (typeof src !== "string") {
      throw new TypeError(`string type was expected, got ${typeof src} instead`);
    }
    const scanner = scan2(src);
    const tok = scanner.next();
    if (tok.done) {
      return null;
    }
    return this.parseListExpr(scanner, tok.value);
  }
  /**
   * Parse any Michelson expression
   * @param src A Michelson expression such as `(Pair {Elt "0" 0} 0)` or `{parameter ...; storage int; code { DUP ; ...};}`
   * @returns An AST node or null for empty document.
   */
  parseMichelineExpression(src) {
    if (typeof src !== "string") {
      throw new TypeError(`string type was expected, got ${typeof src} instead`);
    }
    const scanner = scan2(src);
    const tok = scanner.next();
    if (tok.done) {
      return null;
    }
    return this.parseExpr(scanner, tok.value);
  }
  /**
   * Parse a Micheline sequence expression, such as smart contract source. Enclosing curly brackets may be omitted.
   * An alias for `parseSequence`
   * @param src A Micheline sequence `{parameter ...; storage int; code { DUP ; ...};}` or `parameter ...; storage int; code { DUP ; ...};`
   */
  parseScript(src) {
    return this.parseSequence(src);
  }
  /**
   * Parse a Micheline sequence expression. Enclosing curly brackets may be omitted.
   * An alias for `parseList`
   * @param src A Michelson list expression such as `(Pair {Elt "0" 0} 0)` or `Pair {Elt "0" 0} 0`
   * @returns An AST node or null for empty document.
   */
  parseData(src) {
    return this.parseList(src);
  }
  /**
   * Takes a JSON-encoded Michelson, validates it, strips away unneeded properties and optionally expands macros (See {@link ParserOptions}).
   * @param src An object containing JSON-encoded Michelson, usually returned by `JSON.parse()`
   */
  parseJSON(src) {
    if (typeof src !== "object") {
      throw new TypeError(`object type was expected, got ${typeof src} instead`);
    }
    if (Array.isArray(src)) {
      const ret = [];
      for (const n2 of src) {
        if (n2 === null || typeof n2 !== "object") {
          throw new JSONParseError(n2, `unexpected sequence element: ${n2}`);
        }
        ret.push(this.parseJSON(n2));
      }
      return ret;
    } else if ("prim" in src) {
      const p3 = src;
      if (typeof p3.prim === "string" && (p3.annots === void 0 || Array.isArray(p3.annots)) && (p3.args === void 0 || Array.isArray(p3.args))) {
        const ret = {
          prim: p3.prim
        };
        if (p3.annots !== void 0) {
          for (const a2 of p3.annots) {
            if (typeof a2 !== "string") {
              throw new JSONParseError(a2, `string expected: ${a2}`);
            }
          }
          ret.annots = p3.annots;
        }
        if (p3.args !== void 0) {
          ret.args = [];
          for (const a2 of p3.args) {
            if (a2 === null || typeof a2 !== "object") {
              throw new JSONParseError(a2, `unexpected argument: ${a2}`);
            }
            ret.args.push(this.parseJSON(a2));
          }
        }
        return this.expand(ret);
      }
      throw new JSONParseError(src, `malformed prim expression: ${src}`);
    } else if ("string" in src) {
      if (typeof src.string === "string") {
        return { string: src.string };
      }
      throw new JSONParseError(src, `malformed string literal: ${src}`);
    } else if ("int" in src) {
      if (typeof src.int === "string" && intRe.test(src.int)) {
        return { int: src.int };
      }
      throw new JSONParseError(src, `malformed int literal: ${src}`);
    } else if ("bytes" in src) {
      if (typeof src.bytes === "string" && bytesRe.test(src.bytes)) {
        return { bytes: src.bytes };
      }
      throw new JSONParseError(src, `malformed bytes literal: ${src}`);
    } else {
      throw new JSONParseError(src, `unexpected object: ${src}`);
    }
  }
};
var H4 = [
  1779033703 | 0,
  3144134277 | 0,
  1013904242 | 0,
  2773480762 | 0,
  1359893119 | 0,
  2600822924 | 0,
  528734635 | 0,
  1541459225 | 0
];
var K2 = [
  1116352408 | 0,
  1899447441 | 0,
  3049323471 | 0,
  3921009573 | 0,
  961987163 | 0,
  1508970993 | 0,
  2453635748 | 0,
  2870763221 | 0,
  3624381080 | 0,
  310598401 | 0,
  607225278 | 0,
  1426881987 | 0,
  1925078388 | 0,
  2162078206 | 0,
  2614888103 | 0,
  3248222580 | 0,
  3835390401 | 0,
  4022224774 | 0,
  264347078 | 0,
  604807628 | 0,
  770255983 | 0,
  1249150122 | 0,
  1555081692 | 0,
  1996064986 | 0,
  2554220882 | 0,
  2821834349 | 0,
  2952996808 | 0,
  3210313671 | 0,
  3336571891 | 0,
  3584528711 | 0,
  113926993 | 0,
  338241895 | 0,
  666307205 | 0,
  773529912 | 0,
  1294757372 | 0,
  1396182291 | 0,
  1695183700 | 0,
  1986661051 | 0,
  2177026350 | 0,
  2456956037 | 0,
  2730485921 | 0,
  2820302411 | 0,
  3259730800 | 0,
  3345764771 | 0,
  3516065817 | 0,
  3600352804 | 0,
  4094571909 | 0,
  275423344 | 0,
  430227734 | 0,
  506948616 | 0,
  659060556 | 0,
  883997877 | 0,
  958139571 | 0,
  1322822218 | 0,
  1537002063 | 0,
  1747873779 | 0,
  1955562222 | 0,
  2024104815 | 0,
  2227730452 | 0,
  2361852424 | 0,
  2428436474 | 0,
  2756734187 | 0,
  3204031479 | 0,
  3329325298 | 0
];
var Base58DecodingError = class extends TaquitoError {
  constructor(message) {
    super();
    this.message = message;
    this.name = "Base58DecodingError";
  }
};
function sha256(msg) {
  const r = (msg.length + 9) % 64;
  const pad2 = r === 0 ? 0 : 64 - r;
  if (msg.length > 268435455) {
    throw new InvalidMessageError("", `: Invalid length ${msg.length} is too big -- SHA-256.`);
  }
  const l = msg.length << 3;
  const buffer2 = [
    ...msg,
    128,
    ...new Array(pad2).fill(0),
    0,
    0,
    0,
    0,
    l >> 24 & 255,
    l >> 16 & 255,
    l >> 8 & 255,
    l & 255
  ];
  function ror(x3, n2) {
    return x3 >>> n2 | x3 << 32 - n2;
  }
  const h3 = [...H4];
  const w3 = new Array(64);
  const v = new Array(8);
  for (let offset = 0; offset < buffer2.length; offset += 64) {
    let q3 = offset;
    let i2 = 0;
    while (i2 < 16) {
      w3[i2] = buffer2[q3] << 24 | buffer2[q3 + 1] << 16 | buffer2[q3 + 2] << 8 | buffer2[q3 + 3];
      q3 += 4;
      i2++;
    }
    while (i2 < 64) {
      const s0 = ror(w3[i2 - 15], 7) ^ ror(w3[i2 - 15], 18) ^ w3[i2 - 15] >>> 3;
      const s1 = ror(w3[i2 - 2], 17) ^ ror(w3[i2 - 2], 19) ^ w3[i2 - 2] >>> 10;
      w3[i2] = (s1 | 0) + w3[i2 - 7] + s0 + w3[i2 - 16] | 0;
      i2++;
    }
    for (let i3 = 0; i3 < 8; i3++) {
      v[i3] = h3[i3];
    }
    for (let i3 = 0; i3 < 64; i3++) {
      const b0 = ror(v[0], 2) ^ ror(v[0], 13) ^ ror(v[0], 22);
      const b1 = ror(v[4], 6) ^ ror(v[4], 11) ^ ror(v[4], 25);
      const t1 = v[7] + b1 + (v[4] & v[5] ^ ~v[4] & v[6]) + K2[i3] + w3[i3] | 0;
      const t2 = b0 + (v[0] & v[1] ^ v[0] & v[2] ^ v[1] & v[2]) | 0;
      v[7] = v[6];
      v[6] = v[5];
      v[5] = v[4];
      v[4] = v[3] + t1 | 0;
      v[3] = v[2];
      v[2] = v[1];
      v[1] = v[0];
      v[0] = t1 + t2 | 0;
    }
    for (let i3 = 0; i3 < 8; i3++) {
      h3[i3] = h3[i3] + v[i3] | 0;
    }
  }
  const digest = [];
  for (const v2 of h3) {
    digest.push(v2 >> 24 & 255);
    digest.push(v2 >> 16 & 255);
    digest.push(v2 >> 8 & 255);
    digest.push(v2 & 255);
  }
  return digest;
}
var base58alphabetFwd = [
  0,
  1,
  2,
  3,
  4,
  5,
  6,
  7,
  8,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  9,
  10,
  11,
  12,
  13,
  14,
  15,
  16,
  -1,
  17,
  18,
  19,
  20,
  21,
  -1,
  22,
  23,
  24,
  25,
  26,
  27,
  28,
  29,
  30,
  31,
  32,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  33,
  34,
  35,
  36,
  37,
  38,
  39,
  40,
  41,
  42,
  43,
  -1,
  44,
  45,
  46,
  47,
  48,
  49,
  50,
  51,
  52,
  53,
  54,
  55,
  56,
  57
];
function byteAt(src, i2) {
  const c2 = src.charCodeAt(i2) - 49;
  if (c2 >= base58alphabetFwd.length || base58alphabetFwd[c2] === -1) {
    throw new Base58DecodingError(`Unexpected character at position ${i2}: ${src[i2]}`);
  }
  return base58alphabetFwd[c2];
}
function decodeBase58(src) {
  const acc = [];
  let i2 = 0;
  while (i2 < src.length && byteAt(src, i2) === 0) {
    i2++;
  }
  let zeros = i2;
  while (i2 < src.length) {
    let carry = byteAt(src, i2++);
    let ii = 0;
    while (carry !== 0 || ii < acc.length) {
      const m2 = (acc[ii] || 0) * 58 + carry;
      acc[ii++] = m2 % 256;
      carry = Math.floor(m2 / 256);
    }
  }
  while (zeros-- > 0) {
    acc.push(0);
  }
  return acc.reverse();
}
function decodeBase58Check(src) {
  const buffer2 = decodeBase58(src);
  if (buffer2.length < 4) {
    throw new Base58DecodingError(`Data is too short ${buffer2.length}`);
  }
  const data = buffer2.slice(0, buffer2.length - 4);
  const sum = buffer2.slice(buffer2.length - 4);
  const computed = sha256(sha256(data));
  if (sum[0] !== computed[0] || sum[1] !== computed[1] || sum[2] !== computed[2] || sum[3] !== computed[3]) {
    throw new Base58DecodingError("Invalid checksum");
  }
  return data;
}
var InvalidMichelsonError = class extends ParameterValidationError {
  constructor(message) {
    super();
    this.message = message;
    this.name = "InvalidMichelsonError";
  }
};
var InvalidTypeExpressionError = class extends ParameterValidationError {
  constructor(message) {
    super();
    this.message = message;
    this.name = "InvalidTypeExpressionError";
  }
};
var InvalidDataExpressionError = class extends ParameterValidationError {
  constructor(message) {
    super();
    this.message = message;
    this.name = "InvalidDataExpressionError";
  }
};
var InvalidEntrypointError = class extends ParameterValidationError {
  constructor(entrypoint) {
    super();
    this.entrypoint = entrypoint;
    this.name = "InvalidEntrypointError";
    this.message = `Contract has no entrypoint named: "${entrypoint}"`;
  }
};
var LongIntegerError = class extends TaquitoError {
  constructor(message) {
    super();
    this.message = message;
    this.name = "LongIntegerError";
  }
};
var MichelsonError = class extends TaquitoError {
  /**
   * @param val Value of a AST node caused the error
   * @param path Path to a node caused the error
   * @param message An error message
   */
  constructor(val, message) {
    super();
    this.val = val;
    this.message = message;
    this.name = "MichelsonError";
  }
};
var MichelsonTypeError = class extends MichelsonError {
  /**
   * @param val Value of a type node caused the error
   * @param data Value of a data node caused the error
   * @param message An error message
   */
  constructor(val, message, data) {
    super(val, message);
    this.val = val;
    this.message = message;
    this.name = "MichelsonTypeError";
    if (data !== void 0) {
      this.data = data;
    }
  }
};
var LongInteger = class {
  constructor(arg) {
    this.neg = false;
    this.buf = [];
    if (arg === void 0) {
      return;
    }
    if (typeof arg === "string") {
      for (let i2 = 0; i2 < arg.length; i2++) {
        const c2 = arg.charCodeAt(i2);
        if (i2 === 0 && c2 === 45) {
          this.neg = true;
        } else {
          if (c2 < 48 || c2 > 57) {
            throw new LongIntegerError(`unexpected character in integer constant "${arg[i2]}"`);
          }
          this.append(c2 - 48);
        }
      }
    } else if (arg < 0) {
      this.neg = true;
      this.append(-arg);
    } else {
      this.append(arg);
    }
  }
  append(c2) {
    let i2 = 0;
    while (c2 !== 0 || i2 < this.buf.length) {
      const m2 = (this.buf[i2] || 0) * 10 + c2;
      this.buf[i2++] = m2 % 256;
      c2 = Math.floor(m2 / 256);
    }
  }
  cmp(arg) {
    if (this.neg !== arg.neg) {
      return (arg.neg ? 1 : 0) - (this.neg ? 1 : 0);
    } else {
      let ret = 0;
      if (this.buf.length !== arg.buf.length) {
        ret = this.buf.length < arg.buf.length ? -1 : 1;
      } else if (this.buf.length !== 0) {
        let i2 = arg.buf.length - 1;
        while (i2 >= 0 && this.buf[i2] === arg.buf[i2]) {
          i2--;
        }
        ret = i2 < 0 ? 0 : this.buf[i2] < arg.buf[i2] ? -1 : 1;
      }
      return !this.neg ? ret : ret === 0 ? 0 : -ret;
    }
  }
  get sign() {
    return this.buf.length === 0 ? 0 : this.neg ? -1 : 1;
  }
};
function parseBytes(s) {
  const ret = [];
  for (let i2 = 0; i2 < s.length; i2 += 2) {
    const x3 = parseInt(s.slice(i2, i2 + 2), 16);
    if (Number.isNaN(x3)) {
      return null;
    }
    ret.push(x3);
  }
  return ret;
}
function isDecimal(x3) {
  try {
    new LongInteger(x3);
    return true;
  } catch (_a3) {
    return false;
  }
}
function isNatural(x3) {
  try {
    return new LongInteger(x3).sign >= 0;
  } catch (_a3) {
    return false;
  }
}
var annRe = /^(@%|@%%|%@|[@:%]([_0-9a-zA-Z][_0-9a-zA-Z.%@]*)?)$/;
function unpackAnnotations(p3, opt) {
  if (Array.isArray(p3)) {
    return {};
  }
  let field;
  let type;
  let vars;
  if (p3.annots !== void 0) {
    for (const v of p3.annots) {
      if (v.length !== 0) {
        if (!annRe.test(v) || !(opt === null || opt === void 0 ? void 0 : opt.specialVar) && (v === "@%" || v === "@%%") || !(opt === null || opt === void 0 ? void 0 : opt.specialFields) && v === "%@") {
          throw new MichelsonError(p3, `${p3.prim}: unexpected annotation: ${v}`);
        }
        switch (v[0]) {
          case "%":
            if ((opt === null || opt === void 0 ? void 0 : opt.emptyFields) || v.length > 1) {
              field = field || [];
              field.push(v);
            }
            break;
          case ":":
            if (v.length > 1) {
              type = type || [];
              type.push(v);
            }
            break;
          case "@":
            if ((opt === null || opt === void 0 ? void 0 : opt.emptyVar) || v.length > 1) {
              vars = vars || [];
              vars.push(v);
            }
            break;
        }
      }
    }
  }
  return { f: field, t: type, v: vars };
}
var tezosPrefix = {
  BlockHash: [32, [1, 52]],
  OperationHash: [32, [5, 116]],
  OperationListHash: [32, [133, 233]],
  OperationListListHash: [32, [29, 159, 109]],
  ProtocolHash: [32, [2, 170]],
  ContextHash: [32, [79, 199]],
  ED25519PublicKeyHash: [20, [6, 161, 159]],
  SECP256K1PublicKeyHash: [20, [6, 161, 161]],
  P256PublicKeyHash: [20, [6, 161, 164]],
  ContractHash: [20, [2, 90, 121]],
  CryptoboxPublicKeyHash: [16, [153, 103]],
  ED25519Seed: [32, [13, 15, 58, 7]],
  ED25519PublicKey: [32, [13, 15, 37, 217]],
  SECP256K1SecretKey: [32, [17, 162, 224, 201]],
  P256SecretKey: [32, [16, 81, 238, 189]],
  ED25519EncryptedSeed: [56, [7, 90, 60, 179, 41]],
  SECP256K1EncryptedSecretKey: [56, [9, 237, 241, 174, 150]],
  P256EncryptedSecretKey: [56, [9, 48, 57, 115, 171]],
  SECP256K1PublicKey: [33, [3, 254, 226, 86]],
  P256PublicKey: [33, [3, 178, 139, 127]],
  SECP256K1Scalar: [33, [38, 248, 136]],
  SECP256K1Element: [33, [5, 92, 0]],
  ED25519SecretKey: [64, [43, 246, 78, 7]],
  ED25519Signature: [64, [9, 245, 205, 134, 18]],
  SECP256K1Signature: [64, [13, 115, 101, 19, 63]],
  P256Signature: [64, [54, 240, 44, 52]],
  GenericSignature: [64, [4, 130, 43]],
  ChainID: [4, [87, 82, 0]],
  RollupAddress: [20, [1, 128, 120, 31]],
  TxRollupL2Address: [20, [6, 161, 166]]
};
function checkDecodeTezosID(id, ...types) {
  const buf = decodeBase58Check(id);
  for (const t of types) {
    const [plen, p3] = tezosPrefix[t];
    if (buf.length === plen + p3.length) {
      let i2 = 0;
      while (i2 < p3.length && buf[i2] === p3[i2]) {
        i2++;
      }
      if (i2 === p3.length) {
        return [t, buf.slice(p3.length)];
      }
    }
  }
  return null;
}
function unpackComb(id, v) {
  const vv = v;
  const args = Array.isArray(vv) ? vv : vv.args;
  if (args.length === 2) {
    const ret = id === "pair" ? {
      prim: "pair",
      args
    } : {
      prim: "Pair",
      args
    };
    return ret;
  }
  return Object.assign(Object.assign({}, Array.isArray(vv) ? { prim: id } : vv), { args: [
    args[0],
    {
      prim: id,
      args: args.slice(1)
    }
  ] });
}
function isPairType(t) {
  return Array.isArray(t) || t.prim === "pair";
}
function isPairData(d2) {
  return Array.isArray(d2) || "prim" in d2 && d2.prim === "Pair";
}
var rfc3339Re = /^[0-9]{4}-(0[1-9]|1[0-2])-(0[1-9]|[12][0-9]|3[01])[T ]([01][0-9]|2[0-3]):([0-5][0-9]):([0-5][0-9]|60)(\.[0-9]+)?(Z|[+-]([01][0-9]|2[0-3]):([0-5][0-9]))$/;
function parseDate(a2) {
  if ("string" in a2) {
    if (isNatural(a2.string)) {
      return new Date(parseInt(a2.string, 10));
    } else if (rfc3339Re.test(a2.string)) {
      const x3 = new Date(a2.string);
      if (!Number.isNaN(x3.valueOf)) {
        return x3;
      }
    }
  } else if (isDecimal(a2.int)) {
    return new Date(parseInt(a2.int, 10));
  }
  return null;
}
var maxViewNameLength = 31;
var noArgInstructionIDs = {
  ABS: true,
  ADD: true,
  ADDRESS: true,
  AMOUNT: true,
  AND: true,
  APPLY: true,
  BALANCE: true,
  BLAKE2B: true,
  CAR: true,
  CDR: true,
  CHAIN_ID: true,
  CHECK_SIGNATURE: true,
  COMPARE: true,
  CONCAT: true,
  CONS: true,
  EDIV: true,
  EQ: true,
  EXEC: true,
  FAILWITH: true,
  GE: true,
  GET_AND_UPDATE: true,
  GT: true,
  HASH_KEY: true,
  IMPLICIT_ACCOUNT: true,
  INT: true,
  ISNAT: true,
  JOIN_TICKETS: true,
  KECCAK: true,
  LE: true,
  LEVEL: true,
  LSL: true,
  LSR: true,
  LT: true,
  MEM: true,
  MUL: true,
  NEG: true,
  NEQ: true,
  NEVER: true,
  NOT: true,
  NOW: true,
  OR: true,
  PACK: true,
  PAIRING_CHECK: true,
  READ_TICKET: true,
  SAPLING_VERIFY_UPDATE: true,
  SELF: true,
  SELF_ADDRESS: true,
  SENDER: true,
  SET_DELEGATE: true,
  SHA256: true,
  SHA3: true,
  SHA512: true,
  SIZE: true,
  SLICE: true,
  SOME: true,
  SOURCE: true,
  SPLIT_TICKET: true,
  SUB: true,
  SWAP: true,
  TICKET: true,
  TICKET_DEPRECATED: true,
  TOTAL_VOTING_POWER: true,
  TRANSFER_TOKENS: true,
  UNIT: true,
  VOTING_POWER: true,
  XOR: true,
  RENAME: true,
  OPEN_CHEST: true,
  SUB_MUTEZ: true,
  MIN_BLOCK_TIME: true,
  BYTES: true,
  NAT: true
};
var instructionIDs = Object.assign({}, noArgInstructionIDs, {
  CONTRACT: true,
  CREATE_CONTRACT: true,
  DIG: true,
  DIP: true,
  DROP: true,
  DUG: true,
  DUP: true,
  EMIT: true,
  EMPTY_BIG_MAP: true,
  EMPTY_MAP: true,
  EMPTY_SET: true,
  GET: true,
  IF: true,
  IF_CONS: true,
  IF_LEFT: true,
  IF_NONE: true,
  ITER: true,
  LAMBDA: true,
  LAMBDA_REC: true,
  LEFT: true,
  LOOP: true,
  LOOP_LEFT: true,
  MAP: true,
  NIL: true,
  NONE: true,
  PAIR: true,
  PUSH: true,
  RIGHT: true,
  SAPLING_EMPTY_STATE: true,
  UNPACK: true,
  UNPAIR: true,
  UPDATE: true,
  CAST: true,
  VIEW: true
});
var simpleComparableTypeIDs = {
  unit: true,
  never: true,
  bool: true,
  int: true,
  nat: true,
  string: true,
  chain_id: true,
  bytes: true,
  mutez: true,
  key_hash: true,
  key: true,
  signature: true,
  timestamp: true,
  address: true,
  tx_rollup_l2_address: true
};
var typeIDs = Object.assign({}, simpleComparableTypeIDs, {
  or: true,
  pair: true,
  set: true,
  big_map: true,
  contract: true,
  lambda: true,
  list: true,
  map: true,
  operation: true,
  option: true,
  bls12_381_g1: true,
  bls12_381_g2: true,
  bls12_381_fr: true,
  sapling_transaction: true,
  sapling_transaction_deprecated: true,
  sapling_state: true,
  ticket: true,
  chest_key: true,
  chest: true
});
var MichelsonValidationError = class extends MichelsonError {
  /**
   * @param val Value of a node caused the error
   * @param message An error message
   */
  constructor(val, message) {
    super(val, message);
    this.val = val;
    this.message = message;
    this.name = "MichelsonValidationError";
  }
};
function isPrim(ex) {
  return "prim" in ex;
}
function isPrimOrSeq(ex) {
  return Array.isArray(ex) || "prim" in ex;
}
function assertPrim(ex) {
  if (isPrim(ex)) {
    return true;
  }
  throw new MichelsonValidationError(ex, "prim expression expected");
}
function assertSeq(ex) {
  if (Array.isArray(ex)) {
    return true;
  }
  throw new MichelsonValidationError(ex, "sequence expression expected");
}
function assertPrimOrSeq(ex) {
  if (isPrimOrSeq(ex)) {
    return true;
  }
  throw new MichelsonValidationError(ex, "prim or sequence expression expected");
}
function assertNatural(i2) {
  if (i2.int[0] === "-") {
    throw new MichelsonValidationError(i2, "natural number expected");
  }
}
function assertIntLiteral(ex) {
  if ("int" in ex) {
    return true;
  }
  throw new MichelsonValidationError(ex, "int literal expected");
}
function assertStringLiteral(ex) {
  if ("string" in ex) {
    return true;
  }
  throw new MichelsonValidationError(ex, "string literal expected");
}
function assertArgs(ex, n2) {
  var _a3;
  if (n2 === 0 && ex.args === void 0 || ((_a3 = ex.args) === null || _a3 === void 0 ? void 0 : _a3.length) === n2) {
    return true;
  }
  throw new MichelsonValidationError(ex, `${n2} arguments expected`);
}
function assertMichelsonInstruction(ex) {
  var _a3, _b;
  if (Array.isArray(ex)) {
    for (const n2 of ex) {
      if (!Array.isArray(n2) && !isPrim(n2)) {
        throw new MichelsonValidationError(ex, "sequence or prim expected");
      }
      assertMichelsonInstruction(n2);
    }
    return true;
  }
  if (assertPrim(ex)) {
    if (Object.prototype.hasOwnProperty.call(noArgInstructionIDs, ex.prim)) {
      assertArgs(ex, 0);
      return true;
    }
    switch (ex.prim) {
      case "DROP":
      case "PAIR":
      case "UNPAIR":
      case "DUP":
      case "UPDATE":
      case "GET":
        if (ex.args !== void 0 && assertArgs(ex, 1)) {
          if (assertIntLiteral(ex.args[0])) {
            assertNatural(ex.args[0]);
          }
        }
        break;
      case "DIG":
      case "DUG":
      case "SAPLING_EMPTY_STATE":
        if (assertArgs(ex, 1)) {
          if (assertIntLiteral(ex.args[0])) {
            assertNatural(ex.args[0]);
          }
        }
        break;
      case "NONE":
      case "LEFT":
      case "RIGHT":
      case "NIL":
      case "CAST":
        if (assertArgs(ex, 1)) {
          assertMichelsonType(ex.args[0]);
        }
        break;
      case "UNPACK":
        if (assertArgs(ex, 1)) {
          assertMichelsonPackableType(ex.args[0]);
        }
        break;
      case "CONTRACT":
        if (assertArgs(ex, 1)) {
          assertMichelsonPassableType(ex.args[0]);
        }
        break;
      case "IF_NONE":
      case "IF_LEFT":
      case "IF_CONS":
      case "IF":
        if (assertArgs(ex, 2)) {
          if (assertSeq(ex.args[0])) {
            assertMichelsonInstruction(ex.args[0]);
          }
          if (assertSeq(ex.args[1])) {
            assertMichelsonInstruction(ex.args[1]);
          }
        }
        break;
      case "MAP":
      case "ITER":
      case "LOOP":
      case "LOOP_LEFT":
        if (assertArgs(ex, 1)) {
          assertMichelsonInstruction(ex.args[0]);
        }
        break;
      case "CREATE_CONTRACT":
        if (assertArgs(ex, 1)) {
          assertMichelsonContract(ex.args[0]);
        }
        break;
      case "DIP":
        if (((_a3 = ex.args) === null || _a3 === void 0 ? void 0 : _a3.length) === 2) {
          if (assertIntLiteral(ex.args[0])) {
            assertNatural(ex.args[0]);
          }
          if (assertSeq(ex.args[1])) {
            assertMichelsonInstruction(ex.args[1]);
          }
        } else if (((_b = ex.args) === null || _b === void 0 ? void 0 : _b.length) === 1) {
          if (assertSeq(ex.args[0])) {
            assertMichelsonInstruction(ex.args[0]);
          }
        } else {
          throw new MichelsonValidationError(ex, "1 or 2 arguments expected");
        }
        break;
      case "PUSH":
        if (assertArgs(ex, 2)) {
          assertMichelsonPushableType(ex.args[0]);
          assertMichelsonData(ex.args[1]);
        }
        break;
      case "EMPTY_SET":
        if (assertArgs(ex, 1)) {
          assertMichelsonComparableType(ex.args[0]);
        }
        break;
      case "EMPTY_MAP":
        if (assertArgs(ex, 2)) {
          assertMichelsonComparableType(ex.args[0]);
          assertMichelsonType(ex.args[1]);
        }
        break;
      case "EMPTY_BIG_MAP":
        if (assertArgs(ex, 2)) {
          assertMichelsonComparableType(ex.args[0]);
          assertMichelsonBigMapStorableType(ex.args[1]);
        }
        break;
      case "LAMBDA_REC":
      case "LAMBDA":
        if (assertArgs(ex, 3)) {
          assertMichelsonType(ex.args[0]);
          assertMichelsonType(ex.args[1]);
          if (assertSeq(ex.args[2])) {
            assertMichelsonInstruction(ex.args[2]);
          }
        }
        break;
      case "VIEW":
        if (assertArgs(ex, 2)) {
          if (assertStringLiteral(ex.args[0])) {
            assertViewNameValid(ex.args[0]);
          }
          if (assertMichelsonType(ex.args[1])) {
            assertMichelsonPushableType(ex.args[1]);
          }
        }
        break;
      case "EMIT":
        if (ex.args && ex.args.length > 0) {
          assertArgs(ex, 1);
        } else {
          assertArgs(ex, 0);
        }
        break;
      default:
        throw new MichelsonValidationError(ex, "instruction expected");
    }
  }
  return true;
}
function assertMichelsonComparableType(ex) {
  if (assertPrimOrSeq(ex)) {
    if (Array.isArray(ex) || ex.prim === "pair" || ex.prim === "or" || ex.prim === "option") {
      traverseType(ex, (ex2) => assertMichelsonComparableType(ex2));
    } else if (!Object.prototype.hasOwnProperty.call(simpleComparableTypeIDs, ex.prim)) {
      throw new MichelsonValidationError(ex, `${ex.prim}: type is not comparable`);
    }
  }
  return true;
}
function assertMichelsonPackableType(ex) {
  if (assertPrimOrSeq(ex)) {
    if (isPrim(ex)) {
      if (!Object.prototype.hasOwnProperty.call(typeIDs, ex.prim) || ex.prim === "big_map" || ex.prim === "operation" || ex.prim === "sapling_state" || ex.prim === "ticket") {
        throw new MichelsonValidationError(ex, `${ex.prim}: type can't be used inside PACK/UNPACK instructions`);
      }
      traverseType(ex, (ex2) => assertMichelsonPackableType(ex2));
    }
  }
  return true;
}
function assertMichelsonPushableType(ex) {
  if (assertPrimOrSeq(ex)) {
    if (isPrim(ex)) {
      if (!Object.prototype.hasOwnProperty.call(typeIDs, ex.prim) || ex.prim === "big_map" || ex.prim === "operation" || ex.prim === "sapling_state" || ex.prim === "ticket" || ex.prim === "contract") {
        throw new MichelsonValidationError(ex, `${ex.prim}: type can't be pushed`);
      }
      traverseType(ex, (ex2) => assertMichelsonPushableType(ex2));
    }
  }
  return true;
}
function assertMichelsonStorableType(ex) {
  if (assertPrimOrSeq(ex)) {
    if (isPrim(ex)) {
      if (!Object.prototype.hasOwnProperty.call(typeIDs, ex.prim) || ex.prim === "operation" || ex.prim === "contract") {
        throw new MichelsonValidationError(ex, `${ex.prim}: type can't be used as part of a storage`);
      }
      traverseType(ex, (ex2) => assertMichelsonStorableType(ex2));
    }
  }
  return true;
}
function assertMichelsonPassableType(ex) {
  if (assertPrimOrSeq(ex)) {
    if (isPrim(ex)) {
      if (!Object.prototype.hasOwnProperty.call(typeIDs, ex.prim) || ex.prim === "operation") {
        throw new MichelsonValidationError(ex, `${ex.prim}: type can't be used as part of a parameter`);
      }
      traverseType(ex, (ex2) => assertMichelsonPassableType(ex2));
    }
  }
  return true;
}
function assertMichelsonBigMapStorableType(ex) {
  if (assertPrimOrSeq(ex)) {
    if (isPrim(ex)) {
      if (!Object.prototype.hasOwnProperty.call(typeIDs, ex.prim) || ex.prim === "big_map" || ex.prim === "operation" || ex.prim === "sapling_state") {
        throw new MichelsonValidationError(ex, `${ex.prim}: type can't be used inside a big_map`);
      }
      traverseType(ex, (ex2) => assertMichelsonBigMapStorableType(ex2));
    }
  }
  return true;
}
var viewRe = new RegExp("^[a-zA-Z0-9_.%@]*$");
function assertViewNameValid(name) {
  if (name.string.length > maxViewNameLength) {
    throw new MichelsonValidationError(name, `view name too long: ${name.string}`);
  }
  if (!viewRe.test(name.string)) {
    throw new MichelsonValidationError(name, `invalid character(s) in view name: ${name.string}`);
  }
}
function assertMichelsonType(ex) {
  if (assertPrimOrSeq(ex)) {
    if (isPrim(ex)) {
      if (!Object.prototype.hasOwnProperty.call(typeIDs, ex.prim)) {
        throw new MichelsonValidationError(ex, "type expected");
      }
      traverseType(ex, (ex2) => assertMichelsonType(ex2));
    }
  }
  return true;
}
function traverseType(ex, cb) {
  if (Array.isArray(ex) || ex.prim === "pair") {
    const args = Array.isArray(ex) ? ex : ex.args;
    if (args === void 0 || args.length < 2) {
      throw new MichelsonValidationError(ex, "at least 2 arguments expected");
    }
    args.forEach((a2) => {
      if (assertPrimOrSeq(a2)) {
        cb(a2);
      }
    });
    return true;
  }
  switch (ex.prim) {
    case "option":
    case "list":
      if (assertArgs(ex, 1) && assertPrimOrSeq(ex.args[0])) {
        cb(ex.args[0]);
      }
      break;
    case "contract":
      if (assertArgs(ex, 1)) {
        assertMichelsonPassableType(ex.args[0]);
      }
      break;
    case "or":
      if (assertArgs(ex, 2) && assertPrimOrSeq(ex.args[0]) && assertPrimOrSeq(ex.args[1])) {
        cb(ex.args[0]);
        cb(ex.args[1]);
      }
      break;
    case "lambda":
      if (assertArgs(ex, 2)) {
        assertMichelsonType(ex.args[0]);
        assertMichelsonType(ex.args[1]);
      }
      break;
    case "set":
      if (assertArgs(ex, 1)) {
        assertMichelsonComparableType(ex.args[0]);
      }
      break;
    case "map":
      if (assertArgs(ex, 2) && assertPrimOrSeq(ex.args[0]) && assertPrimOrSeq(ex.args[1])) {
        assertMichelsonComparableType(ex.args[0]);
        cb(ex.args[1]);
      }
      break;
    case "big_map":
      if (assertArgs(ex, 2) && assertPrimOrSeq(ex.args[0]) && assertPrimOrSeq(ex.args[1])) {
        assertMichelsonComparableType(ex.args[0]);
        assertMichelsonBigMapStorableType(ex.args[1]);
        cb(ex.args[1]);
      }
      break;
    case "ticket":
      if (assertArgs(ex, 1) && assertPrimOrSeq(ex.args[0])) {
        assertMichelsonComparableType(ex.args[0]);
      }
      break;
    case "sapling_state":
    case "sapling_transaction":
      if (assertArgs(ex, 1)) {
        assertIntLiteral(ex.args[0]);
      }
      break;
    default:
      assertArgs(ex, 0);
  }
  return true;
}
function assertMichelsonData(ex) {
  if ("int" in ex || "string" in ex || "bytes" in ex) {
    return true;
  }
  if (Array.isArray(ex)) {
    let mapElts = 0;
    for (const n2 of ex) {
      if (isPrim(n2) && n2.prim === "Elt") {
        if (assertArgs(n2, 2)) {
          assertMichelsonData(n2.args[0]);
          assertMichelsonData(n2.args[1]);
        }
        mapElts++;
      } else {
        assertMichelsonData(n2);
      }
    }
    if (mapElts !== 0 && mapElts !== ex.length) {
      throw new MichelsonValidationError(ex, "data entries and map elements can't be intermixed");
    }
    return true;
  }
  if (isPrim(ex)) {
    switch (ex.prim) {
      case "Unit":
      case "True":
      case "False":
      case "None":
        assertArgs(ex, 0);
        break;
      case "Pair":
        if (ex.args === void 0 || ex.args.length < 2) {
          throw new MichelsonValidationError(ex, "at least 2 arguments expected");
        }
        for (const a2 of ex.args) {
          assertMichelsonData(a2);
        }
        break;
      case "Left":
      case "Right":
      case "Some":
        if (assertArgs(ex, 1)) {
          assertMichelsonData(ex.args[0]);
        }
        break;
      case "Lambda_rec":
        if (ex.args) {
          assertMichelsonInstruction(ex.args);
        }
        break;
      default:
        if (Object.prototype.hasOwnProperty.call(instructionIDs, ex.prim)) {
          assertMichelsonInstruction(ex);
        } else {
          throw new MichelsonValidationError(ex, "data entry or instruction expected");
        }
    }
  } else {
    throw new MichelsonValidationError(ex, "data entry expected");
  }
  return true;
}
function assertMichelsonContract(ex) {
  if (assertSeq(ex)) {
    const toplevelSec = {};
    const views = {};
    for (const sec of ex) {
      if (assertPrim(sec)) {
        if (sec.prim !== "view") {
          if (sec.prim in toplevelSec) {
            throw new MichelsonValidationError(ex, `duplicate contract section: ${sec.prim}`);
          }
          toplevelSec[sec.prim] = true;
        }
        switch (sec.prim) {
          case "code":
            if (assertArgs(sec, 1)) {
              if (assertSeq(sec.args[0])) {
                assertMichelsonInstruction(sec.args[0]);
              }
            }
            break;
          case "parameter":
            if (assertArgs(sec, 1)) {
              assertMichelsonPassableType(sec.args[0]);
            }
            if (sec.annots) {
              throw new MichelsonValidationError(sec, "Annotation must be part of the parameter type");
            }
            break;
          case "storage":
            if (assertArgs(sec, 1)) {
              assertMichelsonStorableType(sec.args[0]);
            }
            break;
          case "view":
            if (assertArgs(sec, 4)) {
              if (assertStringLiteral(sec.args[0])) {
                const name = sec.args[0];
                if (name.string in views) {
                  throw new MichelsonValidationError(ex, `duplicate view name: ${name.string}`);
                }
                views[name.string] = true;
                assertViewNameValid(name);
              }
              assertMichelsonPushableType(sec.args[1]);
              assertMichelsonPushableType(sec.args[2]);
              if (assertSeq(sec.args[3])) {
                assertMichelsonInstruction(sec.args[3]);
              }
            }
            break;
          default:
            throw new MichelsonValidationError(ex, `unexpected contract section: ${sec.prim}`);
        }
      }
    }
  }
  return true;
}
function isInstruction(p3) {
  return Object.prototype.hasOwnProperty.call(instructionIDs, p3.prim);
}
function assertDataListIfAny(d2) {
  if (!Array.isArray(d2)) {
    return false;
  }
  for (const v of d2) {
    if ("prim" in v) {
      if (isInstruction(v)) {
        throw new MichelsonError(d2, `Instruction outside of a lambda: ${JSON.stringify(d2)}`);
      } else if (v.prim === "Elt") {
        throw new MichelsonError(d2, `Elt item outside of a map literal: ${JSON.stringify(d2)}`);
      }
    }
  }
  return true;
}
function __rest(s, e) {
  var t = {};
  for (var p3 in s)
    if (Object.prototype.hasOwnProperty.call(s, p3) && e.indexOf(p3) < 0)
      t[p3] = s[p3];
  if (s != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i2 = 0, p3 = Object.getOwnPropertySymbols(s); i2 < p3.length; i2++) {
      if (e.indexOf(p3[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p3[i2]))
        t[p3[i2]] = s[p3[i2]];
    }
  return t;
}
var primitives = [
  "parameter",
  "storage",
  "code",
  "False",
  "Elt",
  "Left",
  "None",
  "Pair",
  "Right",
  "Some",
  "True",
  "Unit",
  "PACK",
  "UNPACK",
  "BLAKE2B",
  "SHA256",
  "SHA512",
  "ABS",
  "ADD",
  "AMOUNT",
  "AND",
  "BALANCE",
  "CAR",
  "CDR",
  "CHECK_SIGNATURE",
  "COMPARE",
  "CONCAT",
  "CONS",
  "CREATE_ACCOUNT",
  "CREATE_CONTRACT",
  "IMPLICIT_ACCOUNT",
  "DIP",
  "DROP",
  "DUP",
  "EDIV",
  "EMPTY_MAP",
  "EMPTY_SET",
  "EQ",
  "EXEC",
  "FAILWITH",
  "GE",
  "GET",
  "GT",
  "HASH_KEY",
  "IF",
  "IF_CONS",
  "IF_LEFT",
  "IF_NONE",
  "INT",
  "LAMBDA",
  "LE",
  "LEFT",
  "LOOP",
  "LSL",
  "LSR",
  "LT",
  "MAP",
  "MEM",
  "MUL",
  "NEG",
  "NEQ",
  "NIL",
  "NONE",
  "NOT",
  "NOW",
  "OR",
  "PAIR",
  "PUSH",
  "RIGHT",
  "SIZE",
  "SOME",
  "SOURCE",
  "SENDER",
  "SELF",
  "STEPS_TO_QUOTA",
  "SUB",
  "SWAP",
  "TRANSFER_TOKENS",
  "SET_DELEGATE",
  "UNIT",
  "UPDATE",
  "XOR",
  "ITER",
  "LOOP_LEFT",
  "ADDRESS",
  "CONTRACT",
  "ISNAT",
  "CAST",
  "RENAME",
  "bool",
  "contract",
  "int",
  "key",
  "key_hash",
  "lambda",
  "list",
  "map",
  "big_map",
  "nat",
  "option",
  "or",
  "pair",
  "set",
  "signature",
  "string",
  "bytes",
  "mutez",
  "timestamp",
  "unit",
  "operation",
  "address",
  "SLICE",
  "DIG",
  "DUG",
  "EMPTY_BIG_MAP",
  "APPLY",
  "chain_id",
  "CHAIN_ID",
  "LEVEL",
  "SELF_ADDRESS",
  "never",
  "NEVER",
  "UNPAIR",
  "VOTING_POWER",
  "TOTAL_VOTING_POWER",
  "KECCAK",
  "SHA3",
  "PAIRING_CHECK",
  "bls12_381_g1",
  "bls12_381_g2",
  "bls12_381_fr",
  "sapling_state",
  "sapling_transaction_deprecated",
  "SAPLING_EMPTY_STATE",
  "SAPLING_VERIFY_UPDATE",
  "ticket",
  "TICKET_DEPRECATED",
  "READ_TICKET",
  "SPLIT_TICKET",
  "JOIN_TICKETS",
  "GET_AND_UPDATE",
  "chest",
  "chest_key",
  "OPEN_CHEST",
  "VIEW",
  "view",
  "constant",
  "SUB_MUTEZ",
  "tx_rollup_l2_address",
  "MIN_BLOCK_TIME",
  "sapling_transaction",
  "EMIT",
  "Lambda_rec",
  "LAMBDA_REC",
  "TICKET",
  "BYTES",
  "NAT"
];
var primTags = Object.assign({}, ...primitives.map((v, i2) => ({ [v]: i2 })));
var Tag;
(function(Tag2) {
  Tag2[Tag2["Int"] = 0] = "Int";
  Tag2[Tag2["String"] = 1] = "String";
  Tag2[Tag2["Sequence"] = 2] = "Sequence";
  Tag2[Tag2["Prim0"] = 3] = "Prim0";
  Tag2[Tag2["Prim0Annot"] = 4] = "Prim0Annot";
  Tag2[Tag2["Prim1"] = 5] = "Prim1";
  Tag2[Tag2["Prim1Annot"] = 6] = "Prim1Annot";
  Tag2[Tag2["Prim2"] = 7] = "Prim2";
  Tag2[Tag2["Prim2Annot"] = 8] = "Prim2Annot";
  Tag2[Tag2["Prim"] = 9] = "Prim";
  Tag2[Tag2["Bytes"] = 10] = "Bytes";
})(Tag || (Tag = {}));
var boundsErr = new Error("bounds out of range");
var Reader = class _Reader {
  constructor(buffer2, idx = 0, cap = buffer2.length) {
    this.buffer = buffer2;
    this.idx = idx;
    this.cap = cap;
  }
  /** Remaining length */
  get length() {
    return this.cap - this.idx;
  }
  readBytes(len) {
    if (this.cap - this.idx < len) {
      throw boundsErr;
    }
    const ret = this.buffer.slice(this.idx, this.idx + len);
    this.idx += len;
    return ret;
  }
  reader(len) {
    if (this.cap - this.idx < len) {
      throw boundsErr;
    }
    const ret = new _Reader(this.buffer, this.idx, this.idx + len);
    this.idx += len;
    return ret;
  }
  copy() {
    return new _Reader(this.buffer, this.idx, this.cap);
  }
  readUint8() {
    if (this.cap - this.idx < 1) {
      throw boundsErr;
    }
    return this.buffer[this.idx++] >>> 0;
  }
  readUint16() {
    if (this.cap - this.idx < 2) {
      throw boundsErr;
    }
    const x0 = this.buffer[this.idx++];
    const x1 = this.buffer[this.idx++];
    return (x0 << 8 | x1) >>> 0;
  }
  readUint32() {
    if (this.cap - this.idx < 4) {
      throw boundsErr;
    }
    const x0 = this.buffer[this.idx++];
    const x1 = this.buffer[this.idx++];
    const x22 = this.buffer[this.idx++];
    const x3 = this.buffer[this.idx++];
    return (x0 << 24 | x1 << 16 | x22 << 8 | x3) >>> 0;
  }
  readInt8() {
    if (this.cap - this.idx < 1) {
      throw boundsErr;
    }
    const x3 = this.buffer[this.idx++];
    return x3 << 24 >> 24;
  }
  readInt16() {
    if (this.cap - this.idx < 2) {
      throw boundsErr;
    }
    const x0 = this.buffer[this.idx++];
    const x1 = this.buffer[this.idx++];
    return (x0 << 8 | x1) << 16 >> 16;
  }
  readInt32() {
    if (this.cap - this.idx < 4) {
      throw boundsErr;
    }
    const x0 = this.buffer[this.idx++];
    const x1 = this.buffer[this.idx++];
    const x22 = this.buffer[this.idx++];
    const x3 = this.buffer[this.idx++];
    return x0 << 24 | x1 << 16 | x22 << 8 | x3;
  }
};
var ContractID;
(function(ContractID2) {
  ContractID2[ContractID2["Implicit"] = 0] = "Implicit";
  ContractID2[ContractID2["Originated"] = 1] = "Originated";
})(ContractID || (ContractID = {}));
var PublicKeyHashID;
(function(PublicKeyHashID2) {
  PublicKeyHashID2[PublicKeyHashID2["ED25519"] = 0] = "ED25519";
  PublicKeyHashID2[PublicKeyHashID2["SECP256K1"] = 1] = "SECP256K1";
  PublicKeyHashID2[PublicKeyHashID2["P256"] = 2] = "P256";
})(PublicKeyHashID || (PublicKeyHashID = {}));
function readPublicKeyHash(rd) {
  let type;
  const tag = rd.readUint8();
  switch (tag) {
    case PublicKeyHashID.ED25519:
      type = "ED25519PublicKeyHash";
      break;
    case PublicKeyHashID.SECP256K1:
      type = "SECP256K1PublicKeyHash";
      break;
    case PublicKeyHashID.P256:
      type = "P256PublicKeyHash";
      break;
    default:
      throw new Error(`unknown public key hash tag: ${tag}`);
  }
  return { type, hash: rd.readBytes(20) };
}
function readAddress(rd) {
  let address;
  const tag = rd.readUint8();
  switch (tag) {
    case ContractID.Implicit:
      address = readPublicKeyHash(rd);
      break;
    case ContractID.Originated:
      address = {
        type: "ContractHash",
        hash: rd.readBytes(20)
      };
      rd.readBytes(1);
      break;
    default:
      throw new Error(`unknown address tag: ${tag}`);
  }
  if (rd.length !== 0) {
    const dec = new TextDecoder();
    address.entryPoint = dec.decode(new Uint8Array(rd.readBytes(rd.length)));
  }
  return address;
}
var PublicKeyID;
(function(PublicKeyID2) {
  PublicKeyID2[PublicKeyID2["ED25519"] = 0] = "ED25519";
  PublicKeyID2[PublicKeyID2["SECP256K1"] = 1] = "SECP256K1";
  PublicKeyID2[PublicKeyID2["P256"] = 2] = "P256";
})(PublicKeyID || (PublicKeyID = {}));
function readPublicKey(rd) {
  let ln2;
  let type;
  const tag = rd.readUint8();
  switch (tag) {
    case PublicKeyID.ED25519:
      type = "ED25519PublicKey";
      ln2 = 32;
      break;
    case PublicKeyID.SECP256K1:
      type = "SECP256K1PublicKey";
      ln2 = 33;
      break;
    case PublicKeyID.P256:
      type = "P256PublicKey";
      ln2 = 33;
      break;
    default:
      throw new Error(`unknown public key tag: ${tag}`);
  }
  return { type, publicKey: rd.readBytes(ln2) };
}
function decodeAddressBytes(b3) {
  const bytes = parseBytes(b3.bytes);
  if (bytes === null) {
    throw new Error(`can't parse bytes: "${b3.bytes}"`);
  }
  const rd = new Reader(new Uint8Array(bytes));
  return readAddress(rd);
}
function decodePublicKeyHashBytes(b3) {
  const bytes = parseBytes(b3.bytes);
  if (bytes === null) {
    throw new Error(`can't parse bytes: "${b3.bytes}"`);
  }
  const rd = new Reader(new Uint8Array(bytes));
  return readPublicKeyHash(rd);
}
function decodePublicKeyBytes(b3) {
  const bytes = parseBytes(b3.bytes);
  if (bytes === null) {
    throw new Error(`can't parse bytes: "${b3.bytes}"`);
  }
  const rd = new Reader(new Uint8Array(bytes));
  return readPublicKey(rd);
}
var MichelsonInstructionError = class extends MichelsonError {
  /**
   * @param val Value of a type node caused the error
   * @param stackState Current stack state
   * @param message An error message
   */
  constructor(val, stackState, message) {
    super(val, message);
    this.val = val;
    this.stackState = stackState;
    this.message = message;
    this.name = "MichelsonInstructionError";
  }
};
function typeID(t) {
  return Array.isArray(t) ? "pair" : t.prim;
}
function typeArgs(t) {
  return "prim" in t ? t.args : t;
}
function assertScalarTypesEqual(a2, b3, field = false) {
  if (typeID(a2) !== typeID(b3)) {
    throw new MichelsonTypeError(a2, `types mismatch: ${typeID(a2)} != ${typeID(b3)}`, void 0);
  }
  const ann = [unpackAnnotations(a2), unpackAnnotations(b3)];
  if (ann[0].t && ann[1].t && ann[0].t[0] !== ann[1].t[0]) {
    throw new MichelsonTypeError(a2, `${typeID(a2)}: type names mismatch: ${ann[0].t[0]} != ${ann[1].t[0]}`, void 0);
  }
  if (field && ann[0].f && ann[1].f && ann[0].f[0] !== ann[1].f[0]) {
    throw new MichelsonTypeError(a2, `${typeID(a2)}: field names mismatch: ${ann[0].f[0]} != ${ann[1].f}`, void 0);
  }
  if (isPairType(a2)) {
    const aArgs = unpackComb("pair", a2);
    const bArgs = unpackComb("pair", b3);
    assertScalarTypesEqual(aArgs.args[0], bArgs.args[0], true);
    assertScalarTypesEqual(aArgs.args[1], bArgs.args[1], true);
    return;
  }
  switch (a2.prim) {
    case "option":
    case "list":
    case "contract":
    case "set":
    case "ticket":
      assertScalarTypesEqual(a2.args[0], b3.args[0]);
      break;
    case "or":
      assertScalarTypesEqual(a2.args[0], b3.args[0], true);
      assertScalarTypesEqual(a2.args[1], b3.args[1], true);
      break;
    case "lambda":
    case "map":
    case "big_map":
      assertScalarTypesEqual(a2.args[0], b3.args[0]);
      assertScalarTypesEqual(a2.args[1], b3.args[1]);
      break;
    case "sapling_state":
    case "sapling_transaction":
      if (parseInt(a2.args[0].int, 10) !== parseInt(b3.args[0].int, 10)) {
        throw new MichelsonTypeError(a2, `${typeID(a2)}: type argument mismatch: ${a2.args[0].int} != ${b3.args[0].int}`, void 0);
      }
  }
}
function assertStacksEqual(a2, b3) {
  if (a2.length !== b3.length) {
    throw new MichelsonTypeError(a2, `stack length mismatch: ${a2.length} != ${b3.length}`, void 0);
  }
  for (let i2 = 0; i2 < a2.length; i2++) {
    assertScalarTypesEqual(a2[i2], b3[i2]);
  }
}
function assertTypeAnnotationsValid(t, field = false) {
  var _a3, _b, _c;
  if (!Array.isArray(t)) {
    const ann = unpackAnnotations(t);
    if ((((_a3 = ann.t) === null || _a3 === void 0 ? void 0 : _a3.length) || 0) > 1) {
      throw new MichelsonTypeError(t, `${t.prim}: at most one type annotation allowed: ${t.annots}`, void 0);
    }
    if (field) {
      if ((((_b = ann.f) === null || _b === void 0 ? void 0 : _b.length) || 0) > 1) {
        throw new MichelsonTypeError(t, `${t.prim}: at most one field annotation allowed: ${t.annots}`, void 0);
      }
    } else {
      if ((((_c = ann.f) === null || _c === void 0 ? void 0 : _c.length) || 0) > 0) {
        throw new MichelsonTypeError(t, `${t.prim}: field annotations aren't allowed: ${t.annots}`, void 0);
      }
    }
  }
  if (isPairType(t)) {
    const args = typeArgs(t);
    for (const a2 of args) {
      assertTypeAnnotationsValid(a2, true);
    }
    return;
  }
  switch (t.prim) {
    case "option":
    case "list":
    case "contract":
    case "set":
      assertTypeAnnotationsValid(t.args[0]);
      break;
    case "or":
      for (const a2 of t.args) {
        assertTypeAnnotationsValid(a2, true);
      }
      break;
    case "lambda":
    case "map":
    case "big_map":
      assertTypeAnnotationsValid(t.args[0]);
      assertTypeAnnotationsValid(t.args[1]);
  }
}
function isFunction2(d2) {
  if (!Array.isArray(d2)) {
    return false;
  }
  for (const v of d2) {
    if (!(Array.isArray(v) && isFunction2(v) || "prim" in v && isInstruction(v))) {
      return false;
    }
  }
  return true;
}
function assertDataValidInternal(d2, t, ctx) {
  if (isPairType(t)) {
    if (isPairData(d2)) {
      assertDataListIfAny(d2);
      const dc = unpackComb("Pair", d2);
      const tc = unpackComb("pair", t);
      assertDataValidInternal(dc.args[0], tc.args[0], ctx);
      assertDataValidInternal(dc.args[1], tc.args[1], ctx);
      return;
    }
    throw new MichelsonTypeError(t, `pair expected: ${JSON.stringify(d2)}`, d2);
  }
  switch (t.prim) {
    case "int":
      if ("int" in d2 && isDecimal(d2.int)) {
        return;
      }
      throw new MichelsonTypeError(t, `integer value expected: ${JSON.stringify(d2)}`, d2);
    case "nat":
    case "mutez":
      if ("int" in d2 && isNatural(d2.int)) {
        return;
      }
      throw new MichelsonTypeError(t, `natural value expected: ${JSON.stringify(d2)}`, d2);
    case "string":
      if ("string" in d2) {
        return;
      }
      throw new MichelsonTypeError(t, `string value expected: ${JSON.stringify(d2)}`, d2);
    case "bytes":
    case "bls12_381_g1":
    case "bls12_381_g2":
      if ("bytes" in d2 && parseBytes(d2.bytes) !== null) {
        return;
      }
      throw new MichelsonTypeError(t, `bytes value expected: ${JSON.stringify(d2)}`, d2);
    case "bool":
      if ("prim" in d2 && (d2.prim === "True" || d2.prim === "False")) {
        return;
      }
      throw new MichelsonTypeError(t, `boolean value expected: ${JSON.stringify(d2)}`, d2);
    case "key_hash":
      if ("string" in d2 && checkDecodeTezosID(d2.string, "ED25519PublicKeyHash", "SECP256K1PublicKeyHash", "P256PublicKeyHash") !== null) {
        return;
      } else if ("bytes" in d2) {
        try {
          decodePublicKeyHashBytes(d2);
          return;
        } catch (err) {
        }
      }
      throw new MichelsonTypeError(t, `key hash expected: ${JSON.stringify(d2)}`, d2);
    case "timestamp":
      if (("string" in d2 || "int" in d2) && parseDate(d2) !== null) {
        return;
      }
      throw new MichelsonTypeError(t, `timestamp expected: ${JSON.stringify(d2)}`, d2);
    case "address":
      if ("string" in d2) {
        let address = d2.string;
        const ep = d2.string.indexOf("%");
        if (ep >= 0) {
          address = d2.string.slice(0, ep);
        }
        if (checkDecodeTezosID(address, "ED25519PublicKeyHash", "SECP256K1PublicKeyHash", "P256PublicKeyHash", "ContractHash", "TxRollupL2Address", "RollupAddress") !== null) {
          return;
        }
      } else if ("bytes" in d2) {
        try {
          decodeAddressBytes(d2);
          return;
        } catch (err) {
        }
      }
      throw new MichelsonTypeError(t, `address expected: ${JSON.stringify(d2)}`, d2);
    case "key":
      if ("string" in d2 && checkDecodeTezosID(d2.string, "ED25519PublicKey", "SECP256K1PublicKey", "P256PublicKey") !== null) {
        return;
      } else if ("bytes" in d2) {
        try {
          decodePublicKeyBytes(d2);
          return;
        } catch (err) {
        }
      }
      throw new MichelsonTypeError(t, `public key expected: ${JSON.stringify(d2)}`, d2);
    case "unit":
      if ("prim" in d2 && d2.prim === "Unit") {
        return;
      }
      throw new MichelsonTypeError(t, `unit value expected: ${JSON.stringify(d2)}`, d2);
    case "signature":
      if ("bytes" in d2 || "string" in d2 && checkDecodeTezosID(d2.string, "ED25519Signature", "SECP256K1Signature", "P256Signature", "GenericSignature") !== null) {
        return;
      }
      throw new MichelsonTypeError(t, `signature expected: ${JSON.stringify(d2)}`, d2);
    case "chain_id":
      if ("bytes" in d2 || "string" in d2) {
        const x3 = "string" in d2 ? decodeBase58Check(d2.string) : parseBytes(d2.bytes);
        if (x3 !== null) {
          return;
        }
      }
      throw new MichelsonTypeError(t, `chain id expected: ${JSON.stringify(d2)}`, d2);
    case "option":
      if ("prim" in d2) {
        if (d2.prim === "None") {
          return;
        } else if (d2.prim === "Some") {
          assertDataValidInternal(d2.args[0], t.args[0], ctx);
          return;
        }
      }
      throw new MichelsonTypeError(t, `option expected: ${JSON.stringify(d2)}`, d2);
    case "list":
    case "set":
      if (assertDataListIfAny(d2)) {
        for (const v of d2) {
          assertDataValidInternal(v, t.args[0], ctx);
        }
        return;
      }
      throw new MichelsonTypeError(t, `${t.prim} expected: ${JSON.stringify(d2)}`, d2);
    case "or":
      if ("prim" in d2) {
        if (d2.prim === "Left") {
          assertDataValidInternal(d2.args[0], t.args[0], ctx);
          return;
        } else if (d2.prim === "Right") {
          assertDataValidInternal(d2.args[0], t.args[1], ctx);
          return;
        }
      }
      throw new MichelsonTypeError(t, `union (or) expected: ${JSON.stringify(d2)}`, d2);
    case "lambda":
      if (isFunction2(d2)) {
        const ret = functionTypeInternal(d2, [t.args[0]], ctx);
        if ("failed" in ret) {
          throw new MichelsonTypeError(t, `function is failed with error type: ${ret.failed}`, d2);
        }
        if (ret.length !== 1) {
          throw new MichelsonTypeError(t, "function must return a value", d2);
        }
        assertScalarTypesEqual(t.args[1], ret[0]);
        return;
      }
      throw new MichelsonTypeError(t, `function expected: ${JSON.stringify(d2)}`, d2);
    case "map":
    case "big_map":
      if (Array.isArray(d2)) {
        for (const v of d2) {
          if (!("prim" in v) || v.prim !== "Elt") {
            throw new MichelsonTypeError(t, `map elements expected: ${JSON.stringify(d2)}`, d2);
          }
          assertDataValidInternal(v.args[0], t.args[0], ctx);
          assertDataValidInternal(v.args[1], t.args[1], ctx);
        }
        return;
      }
      throw new MichelsonTypeError(t, `${t.prim} expected: ${JSON.stringify(d2)}`, d2);
    case "bls12_381_fr":
      if ("int" in d2 && isDecimal(d2.int) || "bytes" in d2 && parseBytes(d2.bytes) !== null) {
        return;
      }
      throw new MichelsonTypeError(t, `BLS12-381 element expected: ${JSON.stringify(d2)}`, d2);
    case "sapling_state":
      if (Array.isArray(d2)) {
        return;
      }
      throw new MichelsonTypeError(t, `sapling state expected: ${JSON.stringify(d2)}`, d2);
    case "ticket":
      assertDataValidInternal(d2, {
        prim: "pair",
        args: [{ prim: "address" }, t.args[0], { prim: "nat" }]
      }, ctx);
      return;
    default:
      throw new MichelsonTypeError(t, `type ${typeID(t)} don't have Michelson literal representation`, d2);
  }
}
function instructionListType(inst, stack, ctx) {
  let ret = stack;
  let s = stack;
  let i2 = 0;
  for (const op of inst) {
    const ft3 = functionTypeInternal(op, s, ctx);
    ret = ft3;
    if ("failed" in ft3) {
      break;
    }
    s = ft3;
    i2++;
  }
  if ("failed" in ret && ret.level == 0 && (!("prim" in ret.failed) || ret.failed.prim !== "never") && i2 !== inst.length - 1) {
    throw new MichelsonInstructionError(inst, ret, "FAIL must appear in a tail position");
  }
  if ((ctx === null || ctx === void 0 ? void 0 : ctx.traceCallback) !== void 0) {
    const trace = {
      op: inst,
      in: stack,
      out: ret
    };
    ctx.traceCallback(trace);
  }
  return "failed" in ret ? { failed: ret.failed, level: ret.level + 1 } : ret;
}
function functionTypeInternal(inst, stack, ctx) {
  const proto = (ctx === null || ctx === void 0 ? void 0 : ctx.protocol) || DefaultProtocol;
  if (Array.isArray(inst)) {
    return instructionListType(inst, stack, ctx);
  }
  const instruction = inst;
  function args(n2, ...typeIds) {
    if (stack.length < typeIds.length + n2) {
      throw new MichelsonInstructionError(instruction, stack, `${instruction.prim}: stack must have at least ${typeIds.length} element(s)`);
    }
    let i2 = n2;
    for (const ids of typeIds) {
      if (ids !== null && ids.length !== 0) {
        let ii = 0;
        while (ii < ids.length && ids[ii] !== typeID(stack[i2])) {
          ii++;
        }
        if (ii === ids.length) {
          throw new MichelsonInstructionError(instruction, stack, `${instruction.prim}: stack type mismatch: [${i2}] expected to be ${ids}, got ${typeID(stack[i2])} instead`);
        }
      }
      i2++;
    }
    return stack.slice(n2, typeIds.length + n2);
  }
  function rethrow(fn2) {
    return (...args2) => {
      try {
        return fn2(...args2);
      } catch (err) {
        if (err instanceof MichelsonError) {
          throw new MichelsonInstructionError(instruction, stack, err.message);
        } else {
          throw err;
        }
      }
    };
  }
  function rethrowTypeGuard(fn2) {
    return (arg) => {
      try {
        return fn2(arg);
      } catch (err) {
        if (err instanceof MichelsonError) {
          throw new MichelsonInstructionError(instruction, stack, err.message);
        } else {
          throw err;
        }
      }
    };
  }
  const argAnn = rethrow(unpackAnnotations);
  const ensureStacksEqual = rethrow(assertStacksEqual);
  const ensureTypesEqual = rethrow(assertScalarTypesEqual);
  const ensureComparableType = rethrowTypeGuard(assertMichelsonComparableType);
  const ensurePackableType = rethrowTypeGuard(assertMichelsonPackableType);
  const ensureStorableType = rethrowTypeGuard(assertMichelsonStorableType);
  const ensurePushableType = rethrowTypeGuard(assertMichelsonPushableType);
  const ensureBigMapStorableType = rethrowTypeGuard(assertMichelsonBigMapStorableType);
  function instructionAnn(num, opt) {
    const a2 = argAnn(instruction, Object.assign(Object.assign({}, opt), { emptyFields: num.f !== void 0 && num.f > 1, emptyVar: num.v !== void 0 && num.v > 1 }));
    const assertNum = (a3, n2, type) => {
      if (a3 && a3.length > (n2 || 0)) {
        throw new MichelsonInstructionError(instruction, stack, `${instruction.prim}: at most ${n2 || 0} ${type} annotations allowed`);
      }
    };
    assertNum(a2.f, num.f, "field");
    assertNum(a2.t, num.t, "type");
    assertNum(a2.v, num.v, "variable");
    return a2;
  }
  function annotate(tt2, a2) {
    const tx = tt2;
    const t = Array.isArray(tx) ? { prim: "pair", args: tx } : tx;
    const src = argAnn(t);
    const ann = a2.v !== void 0 || a2.t !== void 0 || a2.f !== void 0 ? [
      ...(a2.v === null ? src.v : a2.v) || [],
      ...(a2.t === null ? src.t : a2.t) || [],
      ...(a2.f === null ? src.f : a2.f) || []
    ] : void 0;
    const rest = __rest(t, ["annots"]);
    return Object.assign(Object.assign({}, rest), ann && ann.length !== 0 && { annots: ann });
  }
  function annotateVar(t, def) {
    const ia = instructionAnn({ v: 1 });
    return annotate(t, {
      v: ia.v !== void 0 ? ia.v : def !== void 0 ? [def] : null,
      t: null
    });
  }
  function annotateField(arg, field, insAnn, n2, defField) {
    var _a3, _b, _c, _d;
    const fieldAnn = (_a3 = argAnn(field).f) === null || _a3 === void 0 ? void 0 : _a3[0];
    const insFieldAnn = (_b = insAnn.f) === null || _b === void 0 ? void 0 : _b[n2];
    if (insFieldAnn !== void 0 && insFieldAnn !== "%" && fieldAnn !== void 0 && insFieldAnn !== fieldAnn) {
      throw new MichelsonInstructionError(instruction, stack, `${instruction.prim}: field names doesn't match: ${insFieldAnn} !== ${fieldAnn}`);
    }
    const insVarAnn = (_c = insAnn.v) === null || _c === void 0 ? void 0 : _c[n2];
    const varAnn = (_d = argAnn(arg).v) === null || _d === void 0 ? void 0 : _d[0];
    return annotate(field, {
      t: null,
      v: insVarAnn ? insVarAnn === "@%" ? fieldAnn ? ["@" + fieldAnn.slice(1)] : void 0 : insVarAnn === "@%%" ? varAnn ? ["@" + varAnn.slice(1) + "." + (fieldAnn ? fieldAnn.slice(1) : defField)] : fieldAnn ? ["@" + fieldAnn.slice(1)] : void 0 : [insVarAnn] : null
    });
  }
  function getN(src, n2, i2 = n2) {
    const p3 = unpackComb("pair", src);
    if (i2 === 1) {
      return [p3.args[0]];
    } else if (i2 === 2) {
      return p3.args;
    }
    const right = p3.args[1];
    if (isPairType(right)) {
      return [p3.args[0], ...getN(right, n2, i2 - 1)];
    } else {
      throw new MichelsonInstructionError(instruction, stack, `${instruction.prim}: at least ${n2} fields are expected`);
    }
  }
  function getNth(src, n2, i2 = n2) {
    if (i2 === 0) {
      return src;
    }
    const p3 = unpackComb("pair", src);
    if (i2 === 1) {
      return p3.args[0];
    }
    const right = p3.args[1];
    if (isPairType(right)) {
      return getNth(right, n2, i2 - 2);
    } else if (i2 === 2) {
      return right;
    }
    throw new MichelsonInstructionError(instruction, stack, `${instruction.prim}: at least ${n2 + 1} fields are expected`);
  }
  function updateNth(src, x3, n2, i2 = n2) {
    if (i2 === 0) {
      return x3;
    }
    const p3 = unpackComb("pair", src);
    if (i2 === 1) {
      return Object.assign(Object.assign({}, p3), { args: [x3, p3.args[1]] });
    }
    const right = p3.args[1];
    if (isPairType(right)) {
      return Object.assign(Object.assign({}, p3), { args: [p3.args[0], updateNth(right, x3, n2, i2 - 2)] });
    } else if (i2 === 2) {
      return Object.assign(Object.assign({}, p3), { args: [p3.args[0], x3] });
    }
    throw new MichelsonInstructionError(instruction, stack, `${instruction.prim}: at least ${n2 + 1} fields are expected`);
  }
  const varSuffix = (a2, suffix) => [
    "@" + (a2.v ? a2.v[0].slice(1) + "." : "") + suffix
  ];
  function branchType(br0, br1) {
    if ("failed" in br0 || "failed" in br1) {
      return "failed" in br0 ? br1 : br0;
    } else {
      ensureStacksEqual(br0, br1);
      return br0;
    }
  }
  const retStack = ((instruction2) => {
    var _a3, _b, _c, _d, _e3;
    switch (instruction2.prim) {
      case "DUP": {
        const n2 = instruction2.args ? parseInt(instruction2.args[0].int, 10) : 1;
        if (n2 === 0) {
          throw new MichelsonInstructionError(instruction2, stack, "DUP 0 is forbidden");
        }
        const s = args(n2 - 1, null)[0];
        if (typeID(s) === "ticket") {
          throw new MichelsonInstructionError(instruction2, stack, "ticket can't be DUPed");
        }
        return [s, ...stack];
      }
      case "SWAP": {
        const s = args(0, null, null);
        instructionAnn({});
        return [s[1], s[0], ...stack.slice(2)];
      }
      case "SOME":
        return [
          annotate({ prim: "option", args: [args(0, null)[0]] }, instructionAnn({ t: 1, v: 1 })),
          ...stack.slice(1)
        ];
      case "UNIT":
        return [annotate({ prim: "unit" }, instructionAnn({ v: 1, t: 1 })), ...stack];
      case "PAIR": {
        const n2 = instruction2.args ? parseInt(instruction2.args[0].int, 10) : 2;
        if (n2 < 2) {
          throw new MichelsonInstructionError(instruction2, stack, `PAIR ${n2} is forbidden`);
        }
        const s = args(0, ...new Array(n2).fill(null));
        const ia = instructionAnn({ f: n2, t: 1, v: 1 }, { specialFields: true });
        const trim = (s2) => {
          const i2 = s2.lastIndexOf(".");
          return s2.slice(i2 > 0 ? i2 + 1 : 1);
        };
        const retArgs = s.map((v, i2) => {
          var _a4;
          const va = argAnn(v);
          const f2 = ia.f && ia.f.length > i2 && ia.f[i2] !== "%" ? ia.f[i2] === "%@" ? va.v ? ["%" + trim(((_a4 = va.v) === null || _a4 === void 0 ? void 0 : _a4[0]) || "")] : void 0 : [ia.f[i2]] : void 0;
          return annotate(v, { v: null, t: null, f: f2 });
        });
        return [
          annotate({
            prim: "pair",
            args: retArgs
          }, { t: ia.t, v: ia.v }),
          ...stack.slice(n2)
        ];
      }
      case "UNPAIR": {
        const n2 = instruction2.args ? parseInt(instruction2.args[0].int, 10) : 2;
        if (n2 < 2) {
          throw new MichelsonInstructionError(instruction2, stack, `UNPAIR ${n2} is forbidden`);
        }
        const s = args(0, ["pair"])[0];
        const ia = instructionAnn({ f: 2, v: 2 }, { specialVar: true });
        const fields = getN(s, n2);
        return [
          ...fields.map((field, i2) => annotateField(s, field, ia, i2, i2 === 0 ? "car" : "cdr")),
          ...stack.slice(1)
        ];
      }
      case "CAR":
      case "CDR": {
        const s = unpackComb("pair", args(0, ["pair"])[0]);
        const field = s.args[instruction2.prim === "CAR" ? 0 : 1];
        const ia = instructionAnn({ f: 1, v: 1 }, { specialVar: true });
        return [
          annotateField(s, field, ia, 0, instruction2.prim.toLocaleLowerCase()),
          ...stack.slice(1)
        ];
      }
      case "CONS": {
        const s = args(0, null, ["list"]);
        ensureTypesEqual(s[0], s[1].args[0]);
        return [annotateVar({ prim: "list", args: [s[1].args[0]] }), ...stack.slice(2)];
      }
      case "SIZE":
        args(0, ["string", "list", "set", "map", "bytes"]);
        return [annotateVar({ prim: "nat" }), ...stack.slice(1)];
      case "MEM": {
        const s = args(0, null, ["set", "map", "big_map"]);
        ensureComparableType(s[0]);
        ensureTypesEqual(s[0], s[1].args[0]);
        return [annotateVar({ prim: "bool" }), ...stack.slice(2)];
      }
      case "GET":
        if (instruction2.args) {
          const n2 = parseInt(instruction2.args[0].int, 10);
          const s = args(0, ["pair"])[0];
          return [annotateVar(getNth(s, n2)), ...stack.slice(1)];
        } else {
          const s = args(0, null, ["map", "big_map"]);
          ensureComparableType(s[0]);
          ensureTypesEqual(s[0], s[1].args[0]);
          return [annotateVar({ prim: "option", args: [s[1].args[1]] }), ...stack.slice(2)];
        }
      case "UPDATE":
        if (instruction2.args) {
          const n2 = parseInt(instruction2.args[0].int, 10);
          const s = args(0, null, ["pair"]);
          return [annotateVar(updateNth(s[1], s[0], n2)), ...stack.slice(2)];
        } else {
          const s0 = args(0, null, ["bool", "option"]);
          ensureComparableType(s0[0]);
          if (s0[1].prim === "bool") {
            const s12 = args(2, ["set"]);
            ensureTypesEqual(s0[0], s12[0].args[0]);
            return [
              annotateVar({
                prim: "set",
                args: [annotate(s0[0], { t: null })]
              }),
              ...stack.slice(3)
            ];
          }
          const s1 = args(2, ["map", "big_map"]);
          ensureTypesEqual(s0[0], s1[0].args[0]);
          if (s1[0].prim === "map") {
            return [
              annotateVar({
                prim: "map",
                args: [annotate(s0[0], { t: null }), annotate(s0[1].args[0], { t: null })]
              }),
              ...stack.slice(3)
            ];
          }
          ensureBigMapStorableType(s0[1].args[0]);
          return [
            annotateVar({
              prim: "big_map",
              args: [annotate(s0[0], { t: null }), annotate(s0[1].args[0], { t: null })]
            }),
            ...stack.slice(3)
          ];
        }
      case "GET_AND_UPDATE": {
        const ia = instructionAnn({ v: 2 });
        const s = args(0, null, ["option"], ["map", "big_map"]);
        ensureComparableType(s[0]);
        ensureTypesEqual(s[0], s[2].args[0]);
        ensureTypesEqual(s[1].args[0], s[2].args[1]);
        const va = (_a3 = ia.v) === null || _a3 === void 0 ? void 0 : _a3.map((v) => v !== "@" ? [v] : void 0);
        if (s[2].prim === "map") {
          return [
            annotate({ prim: "option", args: [s[2].args[1]] }, { v: va === null || va === void 0 ? void 0 : va[0] }),
            annotate({
              prim: "map",
              args: [annotate(s[0], { t: null }), annotate(s[1].args[0], { t: null })]
            }, { v: va === null || va === void 0 ? void 0 : va[1] }),
            ...stack.slice(3)
          ];
        }
        ensureBigMapStorableType(s[1].args[0]);
        return [
          annotate({ prim: "option", args: [s[2].args[1]] }, { v: va === null || va === void 0 ? void 0 : va[0] }),
          annotate({
            prim: "big_map",
            args: [annotate(s[0], { t: null }), annotate(s[1].args[0], { t: null })]
          }, { v: va === null || va === void 0 ? void 0 : va[1] }),
          ...stack.slice(3)
        ];
      }
      case "EXEC": {
        const s = args(0, null, ["lambda"]);
        ensureTypesEqual(s[0], s[1].args[0]);
        return [annotateVar(s[1].args[1]), ...stack.slice(2)];
      }
      case "APPLY": {
        const s = args(0, null, ["lambda"]);
        ensureStorableType(s[0]);
        ensurePushableType(s[0]);
        if (!isPairType(s[1].args[0])) {
          throw new MichelsonInstructionError(instruction2, stack, `${instruction2.prim}: function's argument must be a pair: ${typeID(s[1].args[0])}`);
        }
        const pt3 = s[1].args[0];
        ensureTypesEqual(s[0], typeArgs(pt3)[0]);
        return [
          annotateVar({ prim: "lambda", args: [typeArgs(pt3)[1], s[1].args[1]] }),
          ...stack.slice(2)
        ];
      }
      case "FAILWITH": {
        const s = args(0, null)[0];
        if (!ProtoInferiorTo(proto, Protocol.PtEdo2Zk)) {
          ensurePackableType(s);
        }
        return { failed: s, level: 0 };
      }
      case "NEVER":
        args(0, ["never"]);
        return { failed: { prim: "never" }, level: 0 };
      case "RENAME":
        return [annotateVar(args(0, null)[0]), ...stack.slice(1)];
      case "CONCAT": {
        const s0 = args(0, ["string", "list", "bytes"]);
        if (s0[0].prim === "list") {
          if (typeID(s0[0].args[0]) !== "string" && typeID(s0[0].args[0]) !== "bytes") {
            throw new MichelsonInstructionError(instruction2, stack, `${instruction2.prim}: can't concatenate list of ${typeID(s0[0].args[0])}'s`);
          }
          return [annotateVar(s0[0].args[0]), ...stack.slice(1)];
        }
        const s1 = args(1, ["string", "bytes"]);
        if (s0[0].prim !== s1[0].prim) {
          throw new MichelsonInstructionError(instruction2, stack, `${instruction2.prim}: can't concatenate ${s0[0].prim} with ${s1[0].prim}`);
        }
        return [annotateVar(s1[0]), ...stack.slice(2)];
      }
      case "SLICE":
        return [
          annotateVar({ prim: "option", args: [args(0, ["nat"], ["nat"], ["string", "bytes"])[2]] }, "@slice"),
          ...stack.slice(3)
        ];
      case "PACK": {
        const s = args(0, null)[0];
        ensurePackableType(s);
        return [annotateVar({ prim: "bytes" }, "@packed"), ...stack.slice(1)];
      }
      case "ADD": {
        const s = args(0, ["nat", "int", "timestamp", "mutez", "bls12_381_g1", "bls12_381_g2", "bls12_381_fr"], ["nat", "int", "timestamp", "mutez", "bls12_381_g1", "bls12_381_g2", "bls12_381_fr"]);
        if (s[0].prim === "nat" && s[1].prim === "int" || s[0].prim === "int" && s[1].prim === "nat") {
          return [annotateVar({ prim: "int" }), ...stack.slice(2)];
        } else if (s[0].prim === "int" && s[1].prim === "timestamp" || s[0].prim === "timestamp" && s[1].prim === "int") {
          return [annotateVar({ prim: "timestamp" }), ...stack.slice(2)];
        } else if ((s[0].prim === "int" || s[0].prim === "nat" || s[0].prim === "mutez" || s[0].prim === "bls12_381_g1" || s[0].prim === "bls12_381_g2" || s[0].prim === "bls12_381_fr") && s[0].prim === s[1].prim) {
          return [annotateVar(s[0]), ...stack.slice(2)];
        }
        throw new MichelsonInstructionError(instruction2, stack, `${instruction2.prim}: can't add ${s[0].prim} to ${s[1].prim}`);
      }
      case "SUB": {
        const s = ProtoInferiorTo(proto, Protocol.PsiThaCa) ? args(0, ["nat", "int", "timestamp", "mutez"], ["nat", "int", "timestamp", "mutez"]) : args(0, ["nat", "int", "timestamp"], ["nat", "int", "timestamp"]);
        if ((s[0].prim === "nat" || s[0].prim === "int") && (s[1].prim === "nat" || s[1].prim === "int") || s[0].prim === "timestamp" && s[1].prim === "timestamp") {
          return [annotateVar({ prim: "int" }), ...stack.slice(2)];
        } else if (s[0].prim === "timestamp" && s[1].prim === "int") {
          return [annotateVar({ prim: "timestamp" }), ...stack.slice(2)];
        } else if (s[0].prim === "mutez" && s[1].prim === "mutez") {
          return [annotateVar({ prim: "mutez" }), ...stack.slice(2)];
        }
        throw new MichelsonInstructionError(instruction2, stack, `${instruction2.prim}: can't subtract ${s[0].prim} from ${s[1].prim}`);
      }
      case "SUB_MUTEZ": {
        args(0, ["mutez"], ["mutez"]);
        return [annotateVar({ prim: "option", args: [{ prim: "mutez" }] }), ...stack.slice(2)];
      }
      case "MUL": {
        const s = args(0, ["nat", "int", "mutez", "bls12_381_g1", "bls12_381_g2", "bls12_381_fr"], ["nat", "int", "mutez", "bls12_381_g1", "bls12_381_g2", "bls12_381_fr"]);
        if (s[0].prim === "nat" && s[1].prim === "int" || s[0].prim === "int" && s[1].prim === "nat") {
          return [annotateVar({ prim: "int" }), ...stack.slice(2)];
        } else if (s[0].prim === "nat" && s[1].prim === "mutez" || s[0].prim === "mutez" && s[1].prim === "nat") {
          return [annotateVar({ prim: "mutez" }), ...stack.slice(2)];
        } else if ((s[0].prim === "bls12_381_g1" || s[0].prim === "bls12_381_g2" || s[0].prim === "bls12_381_fr") && s[1].prim === "bls12_381_fr" || (s[0].prim === "nat" || s[0].prim === "int") && s[0].prim === s[1].prim) {
          return [annotateVar(s[0]), ...stack.slice(2)];
        } else if ((s[0].prim === "nat" || s[0].prim === "int") && s[1].prim === "bls12_381_fr" || (s[1].prim === "nat" || s[1].prim === "int") && s[0].prim === "bls12_381_fr") {
          return [annotateVar({ prim: "bls12_381_fr" }), ...stack.slice(2)];
        }
        throw new MichelsonInstructionError(instruction2, stack, `${instruction2.prim}: can't multiply ${s[0].prim} by ${s[1].prim}`);
      }
      case "EDIV": {
        const res = (a2, b3) => ({
          prim: "option",
          args: [{ prim: "pair", args: [{ prim: a2 }, { prim: b3 }] }]
        });
        const s = args(0, ["nat", "int", "mutez"], ["nat", "int", "mutez"]);
        if (s[0].prim === "nat" && s[1].prim === "nat") {
          return [annotateVar(res("nat", "nat")), ...stack.slice(2)];
        } else if ((s[0].prim === "nat" || s[0].prim === "int") && (s[1].prim === "nat" || s[1].prim === "int")) {
          return [annotateVar(res("int", "nat")), ...stack.slice(2)];
        } else if (s[0].prim === "mutez" && s[1].prim === "nat") {
          return [annotateVar(res("mutez", "mutez")), ...stack.slice(2)];
        } else if (s[0].prim === "mutez" && s[1].prim === "mutez") {
          return [annotateVar(res("nat", "mutez")), ...stack.slice(2)];
        }
        throw new MichelsonInstructionError(instruction2, stack, `${instruction2.prim}: can't euclideally divide ${s[0].prim} by ${s[1].prim}`);
      }
      case "ABS":
        args(0, ["int"]);
        return [annotateVar({ prim: "nat" }), ...stack.slice(1)];
      case "ISNAT":
        args(0, ["int"]);
        return [annotateVar({ prim: "option", args: [{ prim: "nat" }] }), ...stack.slice(1)];
      case "INT":
        args(0, ["nat", "bls12_381_fr", "bytes"]);
        return [annotateVar({ prim: "int" }), ...stack.slice(1)];
      case "BYTES":
        args(0, ["nat", "int"]);
        return [annotateVar({ prim: "bytes" }), ...stack.slice(1)];
      case "NAT":
        args(0, ["bytes"]);
        return [annotateVar({ prim: "nat" }), ...stack.slice(1)];
      case "NEG": {
        const s = args(0, ["nat", "int", "bls12_381_g1", "bls12_381_g2", "bls12_381_fr"])[0];
        if (s.prim === "nat" || s.prim === "int") {
          return [annotateVar({ prim: "int" }), ...stack.slice(1)];
        }
        return [annotateVar(s), ...stack.slice(1)];
      }
      case "LSL":
      case "LSR":
        args(0, ["nat", "bytes"], ["nat", "bytes"]);
        return [annotateVar({ prim: "nat" }), ...stack.slice(2)];
      case "OR":
      case "XOR": {
        const s = args(0, ["nat", "bytes", "bool"], ["nat", "bytes", "bool"]);
        if (s[0].prim !== s[1].prim) {
          throw new MichelsonInstructionError(instruction2, stack, `${instruction2.prim}: both arguments must be of the same type: ${s[0].prim}, ${s[1].prim}`);
        }
        return [annotateVar(s[1]), ...stack.slice(2)];
      }
      case "AND": {
        const s = args(0, ["nat", "bytes", "bool", "int"], ["nat", "bytes", "bool"]);
        if ((s[0].prim !== "int" || s[1].prim !== "nat") && s[0].prim !== s[1].prim) {
          throw new MichelsonInstructionError(instruction2, stack, `${instruction2.prim}: both arguments must be of the same type: ${s[0].prim}, ${s[1].prim}`);
        }
        return [annotateVar(s[1]), ...stack.slice(2)];
      }
      case "NOT": {
        const s = args(0, ["nat", "bytes", "bool", "int"])[0];
        if (s.prim === "bool") {
          return [annotateVar({ prim: "bool" }), ...stack.slice(1)];
        }
        return [annotateVar({ prim: "int" }), ...stack.slice(1)];
      }
      case "COMPARE": {
        const s = args(0, null, null);
        ensureComparableType(s[0]);
        ensureComparableType(s[1]);
        return [annotateVar({ prim: "int" }), ...stack.slice(2)];
      }
      case "EQ":
      case "NEQ":
      case "LT":
      case "GT":
      case "LE":
      case "GE":
        args(0, ["int"]);
        return [annotateVar({ prim: "bool" }), ...stack.slice(1)];
      case "SELF": {
        if ((ctx === null || ctx === void 0 ? void 0 : ctx.contract) === void 0) {
          throw new MichelsonInstructionError(instruction2, stack, `${instruction2.prim}: contract required`);
        }
        const ia = instructionAnn({ f: 1, v: 1 });
        const ep = contractEntryPoint(ctx.contract, (_b = ia.f) === null || _b === void 0 ? void 0 : _b[0]);
        if (ep === null) {
          throw new MichelsonInstructionError(instruction2, stack, `${instruction2.prim}: contract has no entrypoint ${ep}`);
        }
        return [
          annotate({ prim: "contract", args: [ep] }, { v: ia.v ? ia.v : ["@self"] }),
          ...stack
        ];
      }
      case "TRANSFER_TOKENS": {
        const s = args(0, null, ["mutez"], ["contract"]);
        ensureTypesEqual(s[0], s[2].args[0]);
        return [annotateVar({ prim: "operation" }), ...stack.slice(3)];
      }
      case "SET_DELEGATE": {
        const s = args(0, ["option"])[0];
        if (typeID(s.args[0]) !== "key_hash") {
          throw new MichelsonInstructionError(instruction2, stack, `${instruction2.prim}: key hash expected: ${typeID(s.args[0])}`);
        }
        return [annotateVar({ prim: "operation" }), ...stack.slice(1)];
      }
      case "IMPLICIT_ACCOUNT":
        args(0, ["key_hash"]);
        return [annotateVar({ prim: "contract", args: [{ prim: "unit" }] }), ...stack.slice(1)];
      case "NOW":
        return [annotateVar({ prim: "timestamp" }, "@now"), ...stack];
      case "AMOUNT":
        return [annotateVar({ prim: "mutez" }, "@amount"), ...stack];
      case "BALANCE":
        return [annotateVar({ prim: "mutez" }, "@balance"), ...stack];
      case "CHECK_SIGNATURE":
        args(0, ["key"], ["signature"], ["bytes"]);
        return [annotateVar({ prim: "bool" }), ...stack.slice(3)];
      case "BLAKE2B":
      case "SHA256":
      case "SHA512":
      case "KECCAK":
      case "SHA3":
        args(0, ["bytes"]);
        return [annotateVar({ prim: "bytes" }), ...stack.slice(1)];
      case "HASH_KEY":
        args(0, ["key"]);
        return [annotateVar({ prim: "key_hash" }), ...stack.slice(1)];
      case "SOURCE":
        return [annotateVar({ prim: "address" }, "@source"), ...stack];
      case "SENDER":
        return [annotateVar({ prim: "address" }, "@sender"), ...stack];
      case "ADDRESS": {
        const s = args(0, ["contract"])[0];
        const ia = instructionAnn({ v: 1 });
        return [
          annotate({ prim: "address", [refContract]: s }, { v: ia.v ? ia.v : varSuffix(argAnn(s), "address") }),
          ...stack.slice(1)
        ];
      }
      case "SELF_ADDRESS": {
        const addr = { prim: "address" };
        if ((ctx === null || ctx === void 0 ? void 0 : ctx.contract) !== void 0) {
          addr[refContract] = {
            prim: "contract",
            args: [contractSection(ctx.contract, "parameter").args[0]]
          };
        }
        return [annotateVar(addr, "@address"), ...stack];
      }
      case "CHAIN_ID":
        return [annotateVar({ prim: "chain_id" }), ...stack];
      case "DROP": {
        instructionAnn({});
        const n2 = instruction2.args !== void 0 ? parseInt(instruction2.args[0].int, 10) : 1;
        args(n2 - 1, null);
        return stack.slice(n2);
      }
      case "DIG": {
        instructionAnn({});
        const n2 = parseInt(instruction2.args[0].int, 10);
        return [args(n2, null)[0], ...stack.slice(0, n2), ...stack.slice(n2 + 1)];
      }
      case "DUG": {
        instructionAnn({});
        const n2 = parseInt(instruction2.args[0].int, 10);
        return [...stack.slice(1, n2 + 1), args(0, null)[0], ...stack.slice(n2 + 1)];
      }
      case "NONE":
        assertTypeAnnotationsValid(instruction2.args[0]);
        return [
          annotate({ prim: "option", args: [instruction2.args[0]] }, instructionAnn({ t: 1, v: 1 })),
          ...stack
        ];
      case "LEFT":
      case "RIGHT": {
        const s = args(0, null)[0];
        const ia = instructionAnn({ f: 2, t: 1, v: 1 }, { specialFields: true });
        const va = argAnn(s);
        const children = [
          annotate(s, {
            t: null,
            v: null,
            f: ia.f && ia.f.length > 0 && ia.f[0] !== "%" ? ia.f[0] === "%@" ? va.v ? ["%" + va.v[0].slice(1)] : void 0 : ia.f : void 0
          }),
          annotate(instruction2.args[0], {
            t: null,
            f: ia.f && ia.f.length > 1 && ia.f[1] !== "%" ? ia.f : void 0
          })
        ];
        return [
          annotate({
            prim: "or",
            args: instruction2.prim === "LEFT" ? children : [children[1], children[0]]
          }, { t: ia.t, v: ia.v }),
          ...stack.slice(1)
        ];
      }
      case "NIL":
        assertTypeAnnotationsValid(instruction2.args[0]);
        return [
          annotate({ prim: "list", args: [instruction2.args[0]] }, instructionAnn({ t: 1, v: 1 })),
          ...stack
        ];
      case "UNPACK":
        args(0, ["bytes"]);
        assertTypeAnnotationsValid(instruction2.args[0]);
        return [
          annotateVar({ prim: "option", args: [instruction2.args[0]] }, "@unpacked"),
          ...stack.slice(1)
        ];
      case "CONTRACT": {
        const s = args(0, ["address"])[0];
        assertTypeAnnotationsValid(instruction2.args[0]);
        const ia = instructionAnn({ v: 1, f: 1 });
        const contract = s[refContract];
        if (contract !== void 0) {
          const ep = contractEntryPoint(contract, (_c = ia.f) === null || _c === void 0 ? void 0 : _c[0]);
          if (ep === null) {
            throw new MichelsonInstructionError(instruction2, stack, `${instruction2.prim}: contract has no entrypoint ${ep}`);
          }
          ensureTypesEqual(ep, instruction2.args[0]);
        }
        return [
          annotate({ prim: "option", args: [{ prim: "contract", args: [instruction2.args[0]] }] }, { v: ia.v ? ia.v : varSuffix(argAnn(s), "contract") }),
          ...stack.slice(1)
        ];
      }
      case "CAST": {
        instructionAnn({});
        const s = args(0, null)[0];
        assertTypeAnnotationsValid(instruction2.args[0]);
        ensureTypesEqual(instruction2.args[0], s);
        return [instruction2.args[0], ...stack.slice(1)];
      }
      case "IF_NONE": {
        instructionAnn({});
        const s = args(0, ["option"])[0];
        const tail = stack.slice(1);
        const br0 = functionTypeInternal(instruction2.args[0], tail, ctx);
        const br1 = functionTypeInternal(instruction2.args[1], [annotate(s.args[0], { t: null, v: varSuffix(argAnn(s), "some") }), ...tail], ctx);
        return branchType(br0, br1);
      }
      case "IF_LEFT": {
        instructionAnn({});
        const s = args(0, ["or"])[0];
        const va = argAnn(s);
        const lefta = argAnn(s.args[0]);
        const righta = argAnn(s.args[1]);
        const tail = stack.slice(1);
        const br0 = functionTypeInternal(instruction2.args[0], [
          annotate(s.args[0], {
            t: null,
            v: varSuffix(va, lefta.f ? lefta.f[0].slice(1) : "left")
          }),
          ...tail
        ], ctx);
        const br1 = functionTypeInternal(instruction2.args[1], [
          annotate(s.args[1], {
            t: null,
            v: varSuffix(va, righta.f ? righta.f[0].slice(1) : "right")
          }),
          ...tail
        ], ctx);
        return branchType(br0, br1);
      }
      case "IF_CONS": {
        instructionAnn({});
        const s = args(0, ["list"])[0];
        const va = argAnn(s);
        const tail = stack.slice(1);
        const br0 = functionTypeInternal(instruction2.args[0], [
          annotate(s.args[0], { t: null, v: varSuffix(va, "hd") }),
          annotate(s, { t: null, v: varSuffix(va, "tl") }),
          ...tail
        ], ctx);
        const br1 = functionTypeInternal(instruction2.args[1], tail, ctx);
        return branchType(br0, br1);
      }
      case "IF": {
        instructionAnn({});
        args(0, ["bool"]);
        const tail = stack.slice(1);
        const br0 = functionTypeInternal(instruction2.args[0], tail, ctx);
        const br1 = functionTypeInternal(instruction2.args[1], tail, ctx);
        return branchType(br0, br1);
      }
      case "MAP": {
        const s = args(0, ["list", "map", "option"])[0];
        const tail = stack.slice(1);
        const elt = s.prim === "map" ? { prim: "pair", args: s.args } : s.args[0];
        const body = functionTypeInternal(instruction2.args[0], [annotate(elt, { t: null, v: varSuffix(argAnn(s), "elt") }), ...tail], ctx);
        if ("failed" in body) {
          if (!("prim" in body.failed) || body.failed.prim !== "never") {
            throw new MichelsonInstructionError(instruction2, stack, `${instruction2.prim}: FAIL is not allowed in MAP`);
          }
          return { failed: body.failed, level: body.level + 1 };
        }
        if (body.length < 1) {
          throw new MichelsonInstructionError(instruction2, stack, `${instruction2.prim}: function must return a value`);
        }
        ensureStacksEqual(body.slice(1), tail);
        return s.prim === "list" ? [annotateVar({ prim: "list", args: [body[0]] }), ...tail] : s.prim === "map" ? [annotateVar({ prim: "map", args: [s.args[0], body[0]] }), ...tail] : [annotateVar({ prim: "option", args: [body[0]] }), ...tail];
      }
      case "ITER": {
        instructionAnn({});
        const s = args(0, ["set", "list", "map"])[0];
        const tail = stack.slice(1);
        const elt = s.prim === "map" ? { prim: "pair", args: s.args } : s.args[0];
        const body = functionTypeInternal(instruction2.args[0], [annotate(elt, { t: null, v: varSuffix(argAnn(s), "elt") }), ...tail], ctx);
        if ("failed" in body) {
          return { failed: body.failed, level: body.level + 1 };
        }
        ensureStacksEqual(body, tail);
        return tail;
      }
      case "LOOP": {
        instructionAnn({});
        args(0, ["bool"]);
        const tail = stack.slice(1);
        const body = functionTypeInternal(instruction2.args[0], tail, ctx);
        if ("failed" in body) {
          return { failed: body.failed, level: body.level + 1 };
        }
        ensureStacksEqual(body, [{ prim: "bool" }, ...tail]);
        return tail;
      }
      case "LOOP_LEFT": {
        instructionAnn({});
        const s = args(0, ["or"])[0];
        const tail = stack.slice(1);
        const body = functionTypeInternal(instruction2.args[0], [annotate(s.args[0], { t: null, v: varSuffix(argAnn(s), "left") }), ...tail], ctx);
        if ("failed" in body) {
          return { failed: body.failed, level: body.level + 1 };
        }
        ensureStacksEqual(body, [s, ...tail]);
        return [annotate(s.args[1], { t: null, v: instructionAnn({ v: 1 }).v }), ...tail];
      }
      case "DIP": {
        instructionAnn({});
        const n2 = instruction2.args.length === 2 ? parseInt(instruction2.args[0].int, 10) : 1;
        args(n2 - 1, null);
        const head = stack.slice(0, n2);
        const tail = stack.slice(n2);
        const body = instruction2.args.length === 2 ? functionTypeInternal(instruction2.args[1], tail, ctx) : functionTypeInternal(instruction2.args[0], tail, ctx);
        if ("failed" in body) {
          return { failed: body.failed, level: body.level + 1 };
        }
        return [...head, ...body];
      }
      case "CREATE_CONTRACT": {
        const ia = instructionAnn({ v: 2 });
        const s = args(0, ["option"], ["mutez"], null);
        if (typeID(s[0].args[0]) !== "key_hash") {
          throw new MichelsonInstructionError(instruction2, stack, `${instruction2.prim}: key hash expected: ${typeID(s[0].args[0])}`);
        }
        if (ensureStorableType(s[2])) {
          assertContractValid(instruction2.args[0]);
          assertScalarTypesEqual(contractSection(instruction2.args[0], "storage").args[0], s[2]);
        }
        const va = (_d = ia.v) === null || _d === void 0 ? void 0 : _d.map((v) => v !== "@" ? [v] : void 0);
        return [
          annotate({ prim: "operation" }, { v: va === null || va === void 0 ? void 0 : va[0] }),
          annotate({
            prim: "address",
            [refContract]: {
              prim: "contract",
              args: [contractSection(instruction2.args[0], "parameter").args[0]]
            }
          }, { v: va === null || va === void 0 ? void 0 : va[1] }),
          ...stack.slice(3)
        ];
      }
      case "PUSH":
        assertTypeAnnotationsValid(instruction2.args[0]);
        assertDataValidInternal(instruction2.args[1], instruction2.args[0], Object.assign(Object.assign({}, ctx), { contract: void 0 }));
        return [annotateVar(instruction2.args[0]), ...stack];
      case "EMPTY_SET":
        assertTypeAnnotationsValid(instruction2.args[0]);
        ensureComparableType(instruction2.args[0]);
        return [
          annotate({ prim: "set", args: instruction2.args }, instructionAnn({ t: 1, v: 1 })),
          ...stack
        ];
      case "EMPTY_MAP":
        assertTypeAnnotationsValid(instruction2.args[0]);
        ensureComparableType(instruction2.args[0]);
        assertTypeAnnotationsValid(instruction2.args[1]);
        return [
          annotate({ prim: "map", args: instruction2.args }, instructionAnn({ t: 1, v: 1 })),
          ...stack
        ];
      case "EMPTY_BIG_MAP":
        assertTypeAnnotationsValid(instruction2.args[0]);
        ensureComparableType(instruction2.args[0]);
        assertTypeAnnotationsValid(instruction2.args[1]);
        ensureBigMapStorableType(instruction2.args[0]);
        return [
          annotate({ prim: "big_map", args: instruction2.args }, instructionAnn({ t: 1, v: 1 })),
          ...stack
        ];
      case "LAMBDA_REC":
      case "LAMBDA": {
        assertTypeAnnotationsValid(instruction2.args[0]);
        assertTypeAnnotationsValid(instruction2.args[1]);
        const s = [instruction2.args[0]];
        if (instruction2.prim === "LAMBDA_REC") {
          s.push({ prim: "lambda", args: [instruction2.args[0], instruction2.args[1]] });
        }
        const body = functionTypeInternal(instruction2.args[2], s, Object.assign(Object.assign({}, ctx), { contract: void 0 }));
        if ("failed" in body) {
          return { failed: body.failed, level: body.level + 1 };
        }
        if (body.length !== 1) {
          throw new MichelsonInstructionError(instruction2, stack, `${instruction2.prim}: function must return a value`);
        }
        ensureTypesEqual(instruction2.args[1], body[0]);
        return [
          annotateVar({ prim: "lambda", args: [instruction2.args[0], instruction2.args[1]] }),
          ...stack
        ];
      }
      case "LEVEL":
        return [annotateVar({ prim: "nat" }, "@level"), ...stack];
      case "TOTAL_VOTING_POWER":
        return [annotateVar({ prim: "nat" }), ...stack];
      case "VOTING_POWER":
        args(0, ["key_hash"]);
        return [annotateVar({ prim: "nat" }), ...stack.slice(1)];
      case "TICKET": {
        const s = args(0, null, ["nat"])[0];
        ensureComparableType(s);
        if (ProtoInferiorTo(proto, Protocol.PtLimaPtL)) {
          return [
            annotate({ prim: "ticket", args: [s] }, instructionAnn({ t: 1, v: 1 })),
            ...stack.slice(2)
          ];
        } else {
          return [
            annotateVar({
              prim: "option",
              args: [annotate({ prim: "ticket", args: [s] }, instructionAnn({ t: 1, v: 1 }))]
            }),
            ...stack.slice(2)
          ];
        }
      }
      case "JOIN_TICKETS": {
        const s = unpackComb("pair", args(0, ["pair"])[0]);
        if (typeID(s.args[0]) !== "ticket") {
          throw new MichelsonInstructionError(instruction2, stack, `${instruction2.prim}: ticket expected: ${typeID(s.args[0])}`);
        }
        ensureTypesEqual(s.args[0], s.args[1]);
        return [
          annotateVar({
            prim: "option",
            args: [annotate(s.args[0], { t: null })]
          }),
          ...stack.slice(1)
        ];
      }
      case "SPLIT_TICKET": {
        const s = args(0, ["ticket"], ["pair"]);
        const p3 = unpackComb("pair", s[1]);
        if (typeID(p3.args[0]) !== "nat") {
          throw new MichelsonInstructionError(instruction2, stack, `${instruction2.prim}: nat expected: ${typeID(p3.args[0])}`);
        }
        ensureTypesEqual(p3.args[0], p3.args[1]);
        return [
          annotateVar({
            prim: "option",
            args: [
              {
                prim: "pair",
                args: [annotate(s[0], { t: null }), annotate(s[0], { t: null })]
              }
            ]
          }),
          ...stack.slice(2)
        ];
      }
      case "READ_TICKET": {
        const ia = instructionAnn({ v: 2 });
        const s = args(0, ["ticket"])[0];
        const va = (_e3 = ia.v) === null || _e3 === void 0 ? void 0 : _e3.map((v) => v !== "@" ? [v] : void 0);
        return [
          annotate({
            prim: "pair",
            args: [{ prim: "address" }, annotate(s.args[0], { t: null }), { prim: "nat" }]
          }, { v: va === null || va === void 0 ? void 0 : va[0] }),
          annotate(s, { v: va === null || va === void 0 ? void 0 : va[1], t: null }),
          ...stack.slice(1)
        ];
      }
      case "PAIRING_CHECK": {
        const p3 = args(0, ["list"])[0].args[0];
        if (!isPairType(p3)) {
          throw new MichelsonInstructionError(instruction2, stack, `${instruction2.prim}: pair expected: ${typeID(p3)}`);
        }
        const c2 = unpackComb("pair", p3);
        if (typeID(c2.args[0]) !== "bls12_381_g1") {
          throw new MichelsonInstructionError(instruction2, stack, `${instruction2.prim}: bls12_381_g1 expected: ${typeID(c2.args[0])}`);
        }
        if (typeID(c2.args[1]) !== "bls12_381_g2") {
          throw new MichelsonInstructionError(instruction2, stack, `${instruction2.prim}: bls12_381_g2 expected: ${typeID(c2.args[1])}`);
        }
        return [annotateVar({ prim: "bool" }), ...stack.slice(1)];
      }
      case "SAPLING_EMPTY_STATE":
        return [
          annotate({ prim: "sapling_state", args: [instruction2.args[0]] }, instructionAnn({ v: 1, t: 1 })),
          ...stack
        ];
      case "SAPLING_VERIFY_UPDATE": {
        const s = args(0, ["sapling_transaction"], ["sapling_state"]);
        if (parseInt(s[0].args[0].int, 10) !== parseInt(s[1].args[0].int, 10)) {
          throw new MichelsonInstructionError(instruction2, stack, `${instruction2.prim}: sapling memo size mismatch: ${s[0].args[0].int} != ${s[1].args[0].int}`);
        }
        return ProtoInferiorTo(proto, Protocol.PtJakarta) ? [
          annotateVar({
            prim: "option",
            args: [
              {
                prim: "pair",
                args: [{ prim: "int" }, annotate(s[1], { t: null })]
              }
            ]
          }),
          ...stack.slice(2)
        ] : [
          annotateVar({
            prim: "option",
            args: [
              {
                prim: "pair",
                args: [
                  { prim: "bytes" },
                  {
                    prim: "pair",
                    args: [{ prim: "int" }, annotate(s[1], { t: null })]
                  }
                ]
              }
            ]
          }),
          ...stack.slice(2)
        ];
      }
      case "OPEN_CHEST":
        args(0, ["chest_key"], ["chest"], ["nat"]);
        return [
          annotateVar({ prim: "or", args: [{ prim: "bytes" }, { prim: "bool" }] }),
          ...stack.slice(3)
        ];
      case "VIEW": {
        const s = args(0, null, ["address"]);
        ensurePushableType(s[0]);
        return [annotateVar({ prim: "option", args: [instruction2.args[1]] }), ...stack.slice(2)];
      }
      case "MIN_BLOCK_TIME":
        return [annotateVar({ prim: "nat" }), ...stack];
      case "EMIT": {
        const ia = instructionAnn({ f: 1, t: 1 });
        if (instruction2.args) {
          const s = args(0, null);
          ensureTypesEqual(s[0], instruction2.args[0]);
          return [annotate({ prim: "operation" }, ia), ...stack.slice(1)];
        }
        return [annotate({ prim: "operation" }, ia), ...stack.slice(1)];
      }
      default:
        throw new MichelsonError(instruction2, `unexpected instruction: ${instruction2.prim}`);
    }
  })(instruction);
  if ((ctx === null || ctx === void 0 ? void 0 : ctx.traceCallback) !== void 0) {
    const trace = {
      op: instruction,
      in: stack,
      out: retStack
    };
    ctx.traceCallback(trace);
  }
  return retStack;
}
function contractSection(contract, section) {
  for (const s of contract) {
    if (s.prim === section) {
      return s;
    }
  }
  throw new MichelsonError(contract, `missing contract section: ${section}`);
}
function contractViews(contract) {
  const views = {};
  for (const s of contract) {
    if (s.prim === "view") {
      views[s.args[0].string] = s;
    }
  }
  return views;
}
function isContract(v) {
  if (Array.isArray(v)) {
    for (const s of v) {
      if ("prim" in s && (s.prim === "parameter" || s.prim === "storage" || s.prim === "code")) {
        return true;
      }
    }
  }
  return false;
}
function contractEntryPoint(src, ep) {
  ep = ep || "%default";
  const entryPoint = contractEntryPoints(src).find((x3) => x3[0] === ep);
  if (entryPoint !== void 0) {
    return entryPoint[1];
  } else if (ep === "%default") {
    return isContract(src) ? contractSection(src, "parameter").args[0] : src;
  }
  return null;
}
function isOrType(t) {
  return Array.isArray(t) || t.prim === "or";
}
function contractEntryPoints(src) {
  if (isContract(src)) {
    const param = contractSection(src, "parameter");
    const ch = contractEntryPoints(param.args[0]);
    const a2 = unpackAnnotations(param);
    return a2.f ? [[a2.f[0], param.args[0]], ...ch] : ch;
  }
  if (isOrType(src)) {
    const args = typeArgs(src);
    const getArg = (n2) => {
      const a2 = unpackAnnotations(args[n2]);
      if (typeID(args[n2]) === "or") {
        const ch = contractEntryPoints(args[n2]);
        return a2.f ? [[a2.f[0], args[n2]], ...ch] : ch;
      }
      return a2.f ? [[a2.f[0], args[n2]]] : [];
    };
    return [...getArg(0), ...getArg(1)];
  }
  return [];
}
function assertContractValid(contract, ctx) {
  const assertSection = (parameter2, storage2, ret2, code2) => {
    assertTypeAnnotationsValid(parameter2, true);
    assertTypeAnnotationsValid(storage2);
    const arg = {
      prim: "pair",
      args: [
        Object.assign(Object.assign({}, parameter2), { annots: ["@parameter"] }),
        Object.assign(Object.assign({}, storage2), { annots: ["@storage"] })
      ]
    };
    const out = functionTypeInternal(code2, [arg], Object.assign(Object.assign({}, ctx), { contract }));
    if ("failed" in out) {
      return out;
    }
    try {
      assertStacksEqual(out, [ret2]);
    } catch (err) {
      if (err instanceof MichelsonError) {
        throw new MichelsonInstructionError(code2, out, err.message);
      } else {
        throw err;
      }
    }
    return out;
  };
  const parameter = contractSection(contract, "parameter").args[0];
  const storage = contractSection(contract, "storage").args[0];
  const code = contractSection(contract, "code").args[0];
  const expected = {
    prim: "pair",
    args: [{ prim: "list", args: [{ prim: "operation" }] }, storage]
  };
  const ret = assertSection(parameter, storage, expected, code);
  for (const view of Object.values(contractViews(contract))) {
    assertSection(view.args[1], storage, view.args[2], view.args[3]);
  }
  return ret;
}
function assertDataValid(d2, t, ctx) {
  assertTypeAnnotationsValid(t);
  assertDataValidInternal(d2, t, ctx || null);
}
function functionType(inst, stack, ctx) {
  for (const t of stack) {
    assertTypeAnnotationsValid(t);
  }
  if ((ctx === null || ctx === void 0 ? void 0 : ctx.contract) !== void 0) {
    for (const typesec of ["parameter", "storage"]) {
      const sec = contractSection(ctx.contract, typesec).args[0];
      assertTypeAnnotationsValid(sec);
    }
  }
  return functionTypeInternal(inst, stack, ctx || null);
}
function isDataValid(d2, t, ctx) {
  try {
    assertDataValid(d2, t, ctx);
    return true;
  } catch (_a3) {
    return false;
  }
}
var Contract = class _Contract {
  constructor(contract, opt) {
    this.contract = contract;
    this.ctx = Object.assign({ contract }, opt);
    this.output = assertContractValid(contract, this.ctx);
  }
  static parse(src, opt) {
    const p3 = new Parser(opt);
    const expr = typeof src === "string" ? p3.parseScript(src) : p3.parseJSON(src);
    if (expr === null) {
      throw new InvalidMichelsonError("empty Michelson");
    }
    if (assertMichelsonContract(expr)) {
      return new _Contract(expr, opt);
    }
  }
  static parseTypeExpression(src, opt) {
    const p3 = new Parser(opt);
    const expr = typeof src === "string" ? p3.parseScript(src) : p3.parseJSON(src);
    if (expr === null) {
      throw new InvalidTypeExpressionError("empty type expression");
    }
    if (assertMichelsonType(expr)) {
      assertTypeAnnotationsValid(expr);
      return expr;
    }
  }
  static parseDataExpression(src, opt) {
    const p3 = new Parser(opt);
    const expr = typeof src === "string" ? p3.parseScript(src) : p3.parseJSON(src);
    if (expr === null) {
      throw new InvalidDataExpressionError("empty data expression");
    }
    if (assertMichelsonData(expr)) {
      return expr;
    }
    throw void 0;
  }
  section(section) {
    return contractSection(this.contract, section);
  }
  entryPoints() {
    return contractEntryPoints(this.contract);
  }
  entryPoint(ep) {
    return contractEntryPoint(this.contract, ep);
  }
  assertDataValid(d2, t) {
    assertDataValid(d2, t, this.ctx);
  }
  isDataValid(d2, t) {
    return isDataValid(d2, t, this.ctx);
  }
  assertParameterValid(ep, d2) {
    const t = this.entryPoint(ep || void 0);
    if (t === null) {
      throw new InvalidEntrypointError(ep === null || ep === void 0 ? void 0 : ep.toString());
    }
    this.assertDataValid(d2, t);
  }
  isParameterValid(ep, d2) {
    try {
      this.assertParameterValid(ep, d2);
      return true;
    } catch (_a3) {
      return false;
    }
  }
  functionType(inst, stack) {
    return functionType(inst, stack, this.ctx);
  }
};
var dummyContract = new Contract([
  { prim: "parameter", args: [{ prim: "unit" }] },
  { prim: "storage", args: [{ prim: "unit" }] },
  {
    prim: "code",
    args: [[{ prim: "CAR" }, { prim: "NIL", args: [{ prim: "operation" }] }, { prim: "PAIR" }]]
  }
]);

// node_modules/@taquito/local-forging/dist/taquito-local-forging.es6.js
var toHexString = (bytes) => bytes.reduce((str, byte) => str + byte.toString(16).padStart(2, "0"), "");
var pad = (num, paddingLen = 8) => {
  return num.toString(16).padStart(paddingLen, "0");
};
var ENTRYPOINT_MAX_LENGTH = 31;
var CODEC;
(function(CODEC2) {
  CODEC2["SECRET"] = "secret";
  CODEC2["RAW"] = "raw";
  CODEC2["TZ1"] = "tz1";
  CODEC2["BRANCH"] = "branch";
  CODEC2["ZARITH"] = "zarith";
  CODEC2["PUBLIC_KEY"] = "public_key";
  CODEC2["PKH"] = "pkh";
  CODEC2["DELEGATE"] = "delegate";
  CODEC2["SCRIPT"] = "script";
  CODEC2["BALLOT_STATEMENT"] = "ballotStmt";
  CODEC2["PROPOSAL"] = "proposal";
  CODEC2["PROPOSAL_ARR"] = "proposalArr";
  CODEC2["INT32"] = "int32";
  CODEC2["INT16"] = "int16";
  CODEC2["PARAMETERS"] = "parameters";
  CODEC2["ADDRESS"] = "address";
  CODEC2["SMART_CONTRACT_ADDRESS"] = "smart_contract_address";
  CODEC2["SMART_ROLLUP_ADDRESS"] = "smart_rollup_address";
  CODEC2["SMART_ROLLUP_COMMITMENT_HASH"] = "smart_rollup_commitment_hash";
  CODEC2["VALUE"] = "value";
  CODEC2["PADDED_BYTES"] = "padded_bytes";
  CODEC2["SMART_ROLLUP_MESSAGE"] = "smart_rollup_message";
  CODEC2["MANAGER"] = "manager";
  CODEC2["BLOCK_PAYLOAD_HASH"] = "blockPayloadHash";
  CODEC2["ENTRYPOINT"] = "entrypoint";
  CODEC2["OPERATION"] = "operation";
  CODEC2["OP_ACTIVATE_ACCOUNT"] = "activate_account";
  CODEC2["OP_DELEGATION"] = "delegation";
  CODEC2["OP_TRANSACTION"] = "transaction";
  CODEC2["OP_ORIGINATION"] = "origination";
  CODEC2["OP_BALLOT"] = "ballot";
  CODEC2["OP_FAILING_NOOP"] = "failing_noop";
  CODEC2["OP_ENDORSEMENT"] = "endorsement";
  CODEC2["OP_SEED_NONCE_REVELATION"] = "seed_nonce_revelation";
  CODEC2["OP_REVEAL"] = "reveal";
  CODEC2["OP_PROPOSALS"] = "proposals";
  CODEC2["OP_REGISTER_GLOBAL_CONSTANT"] = "register_global_constant";
  CODEC2["OP_TRANSFER_TICKET"] = "transfer_ticket";
  CODEC2["OP_TX_ROLLUP_ORIGINATION"] = "tx_rollup_origination";
  CODEC2["OP_TX_ROLLUP_SUBMIT_BATCH"] = "tx_rollup_submit_batch";
  CODEC2["BURN_LIMIT"] = "burn_limit";
  CODEC2["TX_ROLLUP_ORIGINATION_PARAM"] = "tx_rollup_origination_param";
  CODEC2["TX_ROLLUP_ID"] = "tx_rollup_id";
  CODEC2["TX_ROLLUP_BATCH_CONTENT"] = "tx_rollup_batch_content";
  CODEC2["OP_INCREASE_PAID_STORAGE"] = "increase_paid_storage";
  CODEC2["OP_UPDATE_CONSENSUS_KEY"] = "update_consensus_key";
  CODEC2["OP_DRAIN_DELEGATE"] = "drain_delegate";
  CODEC2["DEPOSITS_LIMIT"] = "deposits_limit";
  CODEC2["OP_SET_DEPOSITS_LIMIT"] = "set_deposits_limit";
  CODEC2["OP_SMART_ROLLUP_ORIGINATE"] = "smart_rollup_originate";
  CODEC2["PVM_KIND"] = "pvm_kind";
  CODEC2["OP_SMART_ROLLUP_ADD_MESSAGES"] = "smart_rollup_add_messages";
  CODEC2["OP_SMART_ROLLUP_EXECUTE_OUTBOX_MESSAGE"] = "smart_rollup_execute_outbox_message";
})(CODEC || (CODEC = {}));
var opMapping = {
  "00": "parameter",
  "01": "storage",
  "02": "code",
  "03": "False",
  "04": "Elt",
  "05": "Left",
  "06": "None",
  "07": "Pair",
  "08": "Right",
  "09": "Some",
  "0a": "True",
  "0b": "Unit",
  "0c": "PACK",
  "0d": "UNPACK",
  "0e": "BLAKE2B",
  "0f": "SHA256",
  "10": "SHA512",
  "11": "ABS",
  "12": "ADD",
  "13": "AMOUNT",
  "14": "AND",
  "15": "BALANCE",
  "16": "CAR",
  "17": "CDR",
  "18": "CHECK_SIGNATURE",
  "19": "COMPARE",
  "1a": "CONCAT",
  "1b": "CONS",
  "1c": "CREATE_ACCOUNT",
  "1d": "CREATE_CONTRACT",
  "1e": "IMPLICIT_ACCOUNT",
  "1f": "DIP",
  "20": "DROP",
  "21": "DUP",
  "22": "EDIV",
  "23": "EMPTY_MAP",
  "24": "EMPTY_SET",
  "25": "EQ",
  "26": "EXEC",
  "27": "FAILWITH",
  "28": "GE",
  "29": "GET",
  "2a": "GT",
  "2b": "HASH_KEY",
  "2c": "IF",
  "2d": "IF_CONS",
  "2e": "IF_LEFT",
  "2f": "IF_NONE",
  "30": "INT",
  "31": "LAMBDA",
  "32": "LE",
  "33": "LEFT",
  "34": "LOOP",
  "35": "LSL",
  "36": "LSR",
  "37": "LT",
  "38": "MAP",
  "39": "MEM",
  "3a": "MUL",
  "3b": "NEG",
  "3c": "NEQ",
  "3d": "NIL",
  "3e": "NONE",
  "3f": "NOT",
  "40": "NOW",
  "41": "OR",
  "42": "PAIR",
  "43": "PUSH",
  "44": "RIGHT",
  "45": "SIZE",
  "46": "SOME",
  "47": "SOURCE",
  "48": "SENDER",
  "49": "SELF",
  "4a": "STEPS_TO_QUOTA",
  "4b": "SUB",
  "4c": "SWAP",
  "4d": "TRANSFER_TOKENS",
  "4e": "SET_DELEGATE",
  "4f": "UNIT",
  "50": "UPDATE",
  "51": "XOR",
  "52": "ITER",
  "53": "LOOP_LEFT",
  "54": "ADDRESS",
  "55": "CONTRACT",
  "56": "ISNAT",
  "57": "CAST",
  "58": "RENAME",
  "59": "bool",
  "5a": "contract",
  "5b": "int",
  "5c": "key",
  "5d": "key_hash",
  "5e": "lambda",
  "5f": "list",
  "60": "map",
  "61": "big_map",
  "62": "nat",
  "63": "option",
  "64": "or",
  "65": "pair",
  "66": "set",
  "67": "signature",
  "68": "string",
  "69": "bytes",
  "6a": "mutez",
  "6b": "timestamp",
  "6c": "unit",
  "6d": "operation",
  "6e": "address",
  "6f": "SLICE",
  "70": "DIG",
  "71": "DUG",
  "72": "EMPTY_BIG_MAP",
  "73": "APPLY",
  "74": "chain_id",
  "75": "CHAIN_ID",
  "76": "LEVEL",
  "77": "SELF_ADDRESS",
  "78": "never",
  "79": "NEVER",
  "7a": "UNPAIR",
  "7b": "VOTING_POWER",
  "7c": "TOTAL_VOTING_POWER",
  "7d": "KECCAK",
  "7e": "SHA3",
  "7f": "PAIRING_CHECK",
  "80": "bls12_381_g1",
  "81": "bls12_381_g2",
  "82": "bls12_381_fr",
  "83": "sapling_state",
  "84": "sapling_transaction_deprecated",
  "85": "SAPLING_EMPTY_STATE",
  "86": "SAPLING_VERIFY_UPDATE",
  "87": "ticket",
  "88": "TICKET_DEPRECATED",
  "89": "READ_TICKET",
  "8a": "SPLIT_TICKET",
  "8b": "JOIN_TICKETS",
  "8c": "GET_AND_UPDATE",
  "8d": "chest",
  "8e": "chest_key",
  "8f": "OPEN_CHEST",
  "90": "VIEW",
  "91": "view",
  "92": "constant",
  "93": "SUB_MUTEZ",
  "94": "tx_rollup_l2_address",
  "95": "MIN_BLOCK_TIME",
  "96": "sapling_transaction",
  "97": "EMIT",
  "98": "Lambda_rec",
  "99": "LAMBDA_REC",
  "9a": "TICKET",
  "9b": "BYTES",
  "9c": "NAT"
};
var opMappingReverse = (() => {
  const result = {};
  Object.keys(opMapping).forEach((key) => {
    result[opMapping[key]] = key;
  });
  return result;
})();
var kindMapping = {
  4: "activate_account",
  107: "reveal",
  110: "delegation",
  108: "transaction",
  109: "origination",
  6: "ballot",
  21: "endorsement",
  1: "seed_nonce_revelation",
  5: "proposals",
  111: "register_global_constant",
  150: "tx_rollup_origination",
  151: "tx_rollup_submit_batch",
  158: "transfer_ticket",
  112: "set_deposits_limit",
  113: "increase_paid_storage",
  114: "update_consensus_key",
  9: "drain_delegate",
  200: "smart_rollup_originate",
  201: "smart_rollup_add_messages",
  206: "smart_rollup_execute_outbox_message",
  17: "failing_noop"
};
var kindMappingReverse = (() => {
  const result = {};
  Object.keys(kindMapping).forEach((key) => {
    const keyNum = typeof key === "string" ? parseInt(key, 10) : key;
    result[kindMapping[keyNum]] = pad(keyNum, 2);
  });
  return result;
})();
var entrypointMapping = {
  "00": "default",
  "01": "root",
  "02": "do",
  "03": "set_delegate",
  "04": "remove_delegate",
  "05": "deposit"
};
var entrypointMappingReverse = (() => {
  const result = {};
  Object.keys(entrypointMapping).forEach((key) => {
    result[entrypointMapping[key]] = key;
  });
  return result;
})();
var InvalidOperationSchemaError = class extends ParameterValidationError {
  constructor(operation, errorDetail) {
    super();
    this.operation = operation;
    this.errorDetail = errorDetail;
    this.name = "InvalidOperationSchemaError";
    this.message = `Invalid operation content recevied`;
    errorDetail ? this.message += ` ${errorDetail}.` : "";
  }
};
var OversizedEntryPointError = class extends ParameterValidationError {
  constructor(entrypoint) {
    super();
    this.entrypoint = entrypoint;
    this.name = "OversizedEntryPointError";
    this.message = `Invalid entrypoint length "${entrypoint.length}", maximum length is "${ENTRYPOINT_MAX_LENGTH}".`;
  }
};
var InvalidBallotValueError = class extends ParameterValidationError {
  constructor(ballotValue) {
    super();
    this.ballotValue = ballotValue;
    this.name = "InvalidBallotValueError";
    this.message = `Invalid ballot value "${ballotValue}" expecting one of the following: "yay", "nay", "pass".`;
  }
};
var DecodeBallotValueError = class extends ParameterValidationError {
  constructor(ballotValue) {
    super();
    this.ballotValue = ballotValue;
    this.name = "DecodeBallotValueError";
    this.message = `Invalid ballot value "${ballotValue}", cannot be decoded.`;
  }
};
var UnexpectedMichelsonValueError = class extends ParameterValidationError {
  constructor(value) {
    super();
    this.value = value;
    this.name = "UnexpectedMichelsonValueError";
    this.message = `Invalid Michelson value "${value}", unalbe to encode.`;
  }
};
var OperationDecodingError = class extends ParameterValidationError {
  constructor(message) {
    super();
    this.message = message;
    this.name = "OperationDecodingError";
  }
};
var OperationEncodingError = class extends ParameterValidationError {
  constructor(message) {
    super();
    this.message = message;
    this.name = "OperationEncodingError";
  }
};
var UnsupportedOperationError = class extends ParameterValidationError {
  constructor(op) {
    super();
    this.op = op;
    this.name = "UnsupportedOperationError";
    this.message = `Unsupported operation "${op}", can submit an issue on our github for feature request.`;
  }
};
var UnsupportedPvmKindError = class extends ParameterValidationError {
  constructor(pvm) {
    super();
    this.pvm = pvm;
    this.name = "UnsupportedPvmKindError";
    this.message = `Invalid Pvm kind "${pvm}" expecting either "arith" or "wasm_2_0_0".`;
  }
};
var DecodePvmKindError = class extends ParameterValidationError {
  constructor(pvm) {
    super();
    this.pvm = pvm;
    this.name = "DecodePvmKindError";
    this.message = `Invalid Pvm kind "${pvm}", cannot be decoded.`;
  }
};
var InvalidSmartRollupAddressError = class extends ParameterValidationError {
  constructor(address, errorDetail) {
    super();
    this.address = address;
    this.errorDetail = errorDetail;
    this.name = "InvalidSmartRollupAddress";
    this.message = `Invalid smart rollup address "${address}"`;
    errorDetail ? this.message += ` ${errorDetail}.` : "";
  }
};
var InvalidSmartRollupCommitmentHashError = class extends ParameterValidationError {
  constructor(hash6, errorDetail) {
    super();
    this.hash = hash6;
    this.errorDetail = errorDetail;
    this.name = "InvalidSmartRollupCommitmentHashError";
    this.message = `Invalid smart rollup commitment hash "${hash6}"`;
    errorDetail ? this.message += ` ${errorDetail}.` : "";
  }
};
var Uint8ArrayConsumer = class _Uint8ArrayConsumer {
  constructor(arr, offset = 0) {
    this.arr = arr;
    this.offset = offset;
  }
  static fromHexString(hex) {
    const lowHex = hex.toLowerCase();
    if (/^(([a-f]|\d){2})*$/.test(lowHex)) {
      const arr = new Uint8Array((lowHex.match(/([a-z]|\d){2}/g) || []).map((byte) => parseInt(byte, 16)));
      return new _Uint8ArrayConsumer(arr);
    } else {
      throw new InvalidHexStringError(lowHex);
    }
  }
  consume(count2) {
    const subArr = this.arr.subarray(this.offset, this.offset + count2);
    this.offset += count2;
    return subArr;
  }
  get(idx) {
    return this.arr[this.offset + idx];
  }
  length() {
    return this.arr.length - this.offset;
  }
  slice(start, end) {
    return new _Uint8ArrayConsumer(this.arr.slice(start, end));
  }
};
var isPrim2 = (value) => {
  return "prim" in value;
};
var isBytes = (value) => {
  return "bytes" in value && typeof value.bytes === "string";
};
var isString = (value) => {
  return "string" in value && typeof value.string === "string";
};
var isInt = (value) => {
  return "int" in value && typeof value.int === "string";
};
var scriptEncoder = (script) => {
  const code = valueEncoder(script.code);
  const storage = valueEncoder(script.storage);
  return `${pad(code.length / 2, 8)}${code}${pad(storage.length / 2, 8)}${storage}`;
};
var scriptDecoder = (value) => {
  const code = extractRequiredLen(value);
  const storage = extractRequiredLen(value);
  return {
    code: valueDecoder(new Uint8ArrayConsumer(code)),
    storage: valueDecoder(new Uint8ArrayConsumer(storage))
  };
};
var valueEncoder = (value) => {
  if (Array.isArray(value)) {
    const encoded = value.map((x3) => valueEncoder(x3)).join("");
    const len = encoded.length / 2;
    return `02${pad(len)}${encoded}`;
  } else if (isPrim2(value)) {
    return primEncoder(value);
  } else if (isBytes(value)) {
    return bytesEncoder(value);
  } else if (isString(value)) {
    return stringEncoder(value);
  } else if (isInt(value)) {
    return intEncoder(value);
  }
  throw new UnexpectedMichelsonValueError(JSON.stringify(value));
};
var valueDecoder = (value) => {
  const preamble = value.consume(1);
  switch (preamble[0]) {
    case 10:
      return bytesDecoder(value);
    case 1:
      return stringDecoder(value);
    case 0:
      return intDecoder(value);
    case 2: {
      const val = new Uint8ArrayConsumer(extractRequiredLen(value));
      const results = [];
      while (val.length() > 0) {
        results.push(valueDecoder(val));
      }
      return results;
    }
    default:
      return primDecoder(value, preamble);
  }
};
var extractRequiredLen = (value, bytesLength = 4) => {
  const len = value.consume(bytesLength);
  const valueLen = parseInt(Buffer.from(len).toString("hex"), 16);
  return value.consume(valueLen);
};
var stripLengthPrefixFromBytes = (value, bytesLength = 4) => {
  const ret = [];
  let values = value;
  while (values.length()) {
    const len = values.consume(bytesLength);
    const valueLen = parseInt(Buffer.from(len).toString("hex"), 16);
    ret.push(values.consume(valueLen));
    values = values.slice(valueLen + bytesLength);
  }
  return ret;
};
var bytesEncoder = (value) => {
  if (!/^([A-Fa-f0-9]{2})*$/.test(value.bytes)) {
    throw new InvalidHexStringError(value.bytes);
  }
  const len = value.bytes.length / 2;
  return `0a${pad(len)}${value.bytes}`;
};
var bytesDecoder = (value) => {
  const bytes = extractRequiredLen(value);
  return {
    bytes: Buffer.from(bytes).toString("hex")
  };
};
var stringEncoder = (value) => {
  const str = Buffer.from(value.string, "utf8").toString("hex");
  const hexLength = str.length / 2;
  return `01${pad(hexLength)}${str}`;
};
var stringDecoder = (value) => {
  const str = extractRequiredLen(value);
  return {
    string: Buffer.from(str).toString("utf8")
  };
};
var intEncoder = ({ int }) => {
  const num = new BigNumber(int, 10);
  const positiveMark = num.toString(2)[0] === "-" ? "1" : "0";
  const binary = num.toString(2).replace(/-/g, "");
  const pad2 = binary.length <= 6 ? 6 : (binary.length - 6) % 7 ? binary.length + 7 - (binary.length - 6) % 7 : binary.length;
  const splitted = binary.padStart(pad2, "0").match(/\d{6,7}/g);
  const reversed = splitted.reverse();
  reversed[0] = positiveMark + reversed[0];
  const numHex = reversed.map((x3, i2) => (
    // Add one to the last chunk
    parseInt((i2 === reversed.length - 1 ? "0" : "1") + x3, 2).toString(16).padStart(2, "0")
  ));
  return `00${numHex.join("")}`;
};
var intDecoder = (value) => {
  let c2 = value.consume(1)[0];
  const hexNumber = [];
  const isNotLastChunkMask = 1 << 7;
  while (c2 & isNotLastChunkMask) {
    hexNumber.push(c2);
    c2 = value.consume(1)[0];
  }
  hexNumber.push(c2);
  const isNegative = !!(1 << 6 & hexNumber[0]);
  hexNumber[0] = hexNumber[0] & 127;
  const numBin = hexNumber.map((x3, i2) => x3.toString(2).slice(i2 === 0 ? -6 : -7).padStart(i2 === 0 ? 6 : 7, "0")).reverse();
  let num = new BigNumber(numBin.join(""), 2);
  if (isNegative) {
    num = num.times(-1);
  }
  return {
    int: num.toFixed()
  };
};
var primEncoder = (value) => {
  const hasAnnot = +Array.isArray(value.annots);
  const argsCount = Array.isArray(value.args) ? value.args.length : 0;
  const preamble = pad(Math.min(2 * argsCount + hasAnnot + 3, 9), 2);
  const op = opMappingReverse[value.prim];
  let encodedArgs = (value.args || []).map((arg) => valueEncoder(arg)).join("");
  const encodedAnnots = Array.isArray(value.annots) ? encodeAnnots(value.annots) : "";
  if ((value.prim === "LAMBDA" || value.prim === "LAMBDA_REC") && argsCount) {
    encodedArgs = pad(encodedArgs.length / 2) + encodedArgs + pad(0);
  }
  if ((value.prim === "pair" || value.prim === "Pair") && argsCount > 2) {
    encodedArgs = encodedAnnots === "" ? pad(encodedArgs.length / 2) + encodedArgs + pad(0) : pad(encodedArgs.length / 2) + encodedArgs;
  }
  if (value.prim === "view" && value.args) {
    encodedArgs = pad(encodedArgs.length / 2) + encodedArgs + pad(0);
  }
  return `${preamble}${op}${encodedArgs}${encodedAnnots}`;
};
var primDecoder = (value, preamble) => {
  const hasAnnot = (preamble[0] - 3) % 2 === 1;
  let argsCount = Math.floor((preamble[0] - 3) / 2);
  const op = value.consume(1)[0].toString(16).padStart(2, "0");
  const result = {
    prim: opMapping[op]
  };
  if (opMapping[op] === "LAMBDA" || opMapping[op] === "LAMBDA_REC") {
    value.consume(4);
  }
  if (opMapping[op] === "view") {
    if (argsCount != 0) {
      return primViewDecoder(value, result);
    } else {
      return result;
    }
  }
  let combPairArgs;
  let combPairAnnots;
  if ((opMapping[op] === "pair" || opMapping[op] === "Pair") && argsCount > 2) {
    combPairArgs = decodeCombPair(value);
    argsCount = 0;
    combPairAnnots = decodeAnnots(value);
  }
  const args = new Array(argsCount).fill(0).map(() => valueDecoder(value));
  if (opMapping[op] === "LAMBDA" || opMapping[op] === "LAMBDA_REC") {
    value.consume(4);
  }
  if (combPairArgs) {
    result["args"] = combPairArgs;
  } else if (args.length) {
    result["args"] = args;
  }
  if (combPairAnnots && combPairAnnots[0] !== "") {
    result["annots"] = combPairAnnots;
  } else if (hasAnnot) {
    result["annots"] = decodeAnnots(value);
  }
  return result;
};
var primViewDecoder = (value, result) => {
  value.consume(4);
  result["args"] = new Array(4).fill(0).map(() => valueDecoder(value));
  value.consume(4);
  return result;
};
var decodeCombPair = (val) => {
  const array = new Uint8ArrayConsumer(extractRequiredLen(val));
  const args = [];
  while (array.length() > 0) {
    args.push(valueDecoder(array));
  }
  return args;
};
var encodeAnnots = (value) => {
  const mergedAnnot = value.map((x3) => {
    return Buffer.from(x3, "utf8").toString("hex");
  }).join("20");
  const len = mergedAnnot.length / 2;
  return `${pad(len)}${mergedAnnot}`;
};
var decodeAnnots = (val) => {
  const len = val.consume(4);
  const annotLen = parseInt(Buffer.from(len).toString("hex"), 16);
  const restOfAnnot = val.consume(annotLen);
  const restOfAnnotHex = Buffer.from(restOfAnnot).toString("hex");
  return restOfAnnotHex.split("20").map((x3) => Buffer.from(x3, "hex").toString("utf8"));
};
var prefixEncoder = (prefix$1) => (str) => {
  return buf2hex(Buffer.from(b58cdecode(str, prefix[prefix$1])));
};
var prefixDecoder = (pre) => (str) => {
  const val = str.consume(prefixLength[pre]);
  return b58cencode(val, prefix[pre]);
};
var tz1Decoder = prefixDecoder(Prefix.TZ1);
var branchDecoder = prefixDecoder(Prefix.B);
var pkhDecoder = (val) => {
  const prefix2 = val.consume(1);
  if (prefix2[0] === 0) {
    return prefixDecoder(Prefix.TZ1)(val);
  } else if (prefix2[0] === 1) {
    return prefixDecoder(Prefix.TZ2)(val);
  } else if (prefix2[0] === 2) {
    return prefixDecoder(Prefix.TZ3)(val);
  }
};
var branchEncoder = prefixEncoder(Prefix.B);
var tz1Encoder = prefixEncoder(Prefix.TZ1);
var boolEncoder = (bool) => bool ? "ff" : "00";
var proposalEncoder = (proposal) => {
  return prefixEncoder(Prefix.P)(proposal);
};
var proposalDecoder = (proposal) => {
  return prefixDecoder(Prefix.P)(proposal);
};
var proposalsDecoder = (proposal) => {
  const proposals = [];
  proposal.consume(4);
  while (proposal.length() > 0) {
    proposals.push(proposalDecoder(proposal));
  }
  return proposals;
};
var proposalsEncoder = (proposals) => {
  return pad(32 * proposals.length) + proposals.map((x3) => proposalEncoder(x3)).join("");
};
var ballotEncoder = (ballot) => {
  switch (ballot) {
    case "yay":
      return "00";
    case "nay":
      return "01";
    case "pass":
      return "02";
    default:
      throw new InvalidBallotValueError(ballot);
  }
};
var ballotDecoder = (ballot) => {
  const value = ballot.consume(1);
  switch (value[0]) {
    case 0:
      return "yay";
    case 1:
      return "nay";
    case 2:
      return "pass";
    default:
      throw new DecodeBallotValueError(value[0].toString());
  }
};
var pvmKindEncoder = (pvm) => {
  switch (pvm) {
    case "arith":
      return "00";
    case "wasm_2_0_0":
      return "01";
    default:
      throw new UnsupportedPvmKindError(pvm);
  }
};
var pvmKindDecoder = (pvm) => {
  const value = pvm.consume(1);
  switch (value[0]) {
    case 0:
      return "arith";
    case 1:
      return "wasm_2_0_0";
    default:
      throw new DecodePvmKindError(value[0].toString());
  }
};
var delegateEncoder = (val) => {
  if (val) {
    return boolEncoder(true) + pkhEncoder(val);
  } else {
    return boolEncoder(false);
  }
};
var int32Encoder = (val) => {
  const num = parseInt(String(val), 10);
  const byte = [];
  for (let i2 = 0; i2 < 4; i2++) {
    const shiftBy = (4 - (i2 + 1)) * 8;
    byte.push((num & 255 << shiftBy) >> shiftBy);
  }
  return Buffer.from(byte).toString("hex");
};
var int32Decoder = (val) => {
  const num = val.consume(4);
  let finalNum = 0;
  for (let i2 = 0; i2 < num.length; i2++) {
    finalNum = finalNum | num[i2] << (num.length - (i2 + 1)) * 8;
  }
  return finalNum;
};
var int16Encoder = (val) => {
  const num = parseInt(String(val), 10);
  const byte = [];
  for (let i2 = 0; i2 < 2; i2++) {
    const shiftBy = (2 - (i2 + 1)) * 8;
    byte.push((num & 255 << shiftBy) >> shiftBy);
  }
  return Buffer.from(byte).toString("hex");
};
var int16Decoder = (val) => {
  const num = val.consume(2);
  let finalNum = 0;
  for (let i2 = 0; i2 < num.length; i2++) {
    finalNum = finalNum | num[i2] << (num.length - (i2 + 1)) * 8;
  }
  return finalNum;
};
var boolDecoder = (val) => {
  const bool = val.consume(1);
  return bool[0] === 255;
};
var delegateDecoder = (val) => {
  const hasDelegate = boolDecoder(val);
  if (hasDelegate) {
    return pkhDecoder(val);
  }
};
var pkhEncoder = (val) => {
  const pubkeyPrefix = val.substring(0, 3);
  switch (pubkeyPrefix) {
    case Prefix.TZ1:
      return "00" + prefixEncoder(Prefix.TZ1)(val);
    case Prefix.TZ2:
      return "01" + prefixEncoder(Prefix.TZ2)(val);
    case Prefix.TZ3:
      return "02" + prefixEncoder(Prefix.TZ3)(val);
    case Prefix.TZ4:
      return "03" + prefixEncoder(Prefix.TZ4)(val);
    default:
      throw new InvalidKeyHashError(val, invalidDetail(ValidationResult.NO_PREFIX_MATCHED) + ` expecting one for the following "${Prefix.TZ1}", "${Prefix.TZ2}", "${Prefix.TZ3}" or "${Prefix.TZ4}".`);
  }
};
var publicKeyEncoder = (val) => {
  const pubkeyPrefix = val.substring(0, 4);
  switch (pubkeyPrefix) {
    case Prefix.EDPK:
      return "00" + prefixEncoder(Prefix.EDPK)(val);
    case Prefix.SPPK:
      return "01" + prefixEncoder(Prefix.SPPK)(val);
    case Prefix.P2PK:
      return "02" + prefixEncoder(Prefix.P2PK)(val);
    default:
      throw new InvalidPublicKeyError(val, invalidDetail(ValidationResult.NO_PREFIX_MATCHED) + ` expecting one of the following '${Prefix.EDPK}', '${Prefix.SPPK}', '${Prefix.P2PK}' or '${Prefix.BLPK}'.`);
  }
};
var addressEncoder = (val) => {
  const pubkeyPrefix = val.substring(0, 3);
  switch (pubkeyPrefix) {
    case Prefix.TZ1:
    case Prefix.TZ2:
    case Prefix.TZ3:
    case Prefix.TZ4:
      return "00" + pkhEncoder(val);
    case Prefix.KT1:
      return "01" + prefixEncoder(Prefix.KT1)(val) + "00";
    default:
      throw new InvalidAddressError(val, invalidDetail(ValidationResult.NO_PREFIX_MATCHED) + ` expecting one of the following prefix '${Prefix.TZ1}', ${Prefix.TZ2}', '${Prefix.TZ3}', '${Prefix.TZ4}' or '${Prefix.KT1}'.`);
  }
};
var smartRollupAddressEncoder = (val) => {
  if (val.substring(0, 3) !== Prefix.SR1) {
    throw new InvalidSmartRollupAddressError(val, invalidDetail(ValidationResult.NO_PREFIX_MATCHED) + ` expecting prefix '${Prefix.SR1}'.`);
  }
  return prefixEncoder(Prefix.SR1)(val);
};
var smartContractAddressEncoder = (val) => {
  const prefix2 = val.substring(0, 3);
  if (prefix2 === Prefix.KT1) {
    return "01" + prefixEncoder(Prefix.KT1)(val) + "00";
  }
  throw new InvalidContractAddressError(val, invalidDetail(ValidationResult.NO_PREFIX_MATCHED) + ` expecting prefix '${Prefix.KT1}'.`);
};
var publicKeyDecoder = (val) => {
  const preamble = val.consume(1);
  switch (preamble[0]) {
    case 0:
      return prefixDecoder(Prefix.EDPK)(val);
    case 1:
      return prefixDecoder(Prefix.SPPK)(val);
    case 2:
      return prefixDecoder(Prefix.P2PK)(val);
    default:
      throw new InvalidPublicKeyError(val.toString(), invalidDetail(ValidationResult.NO_PREFIX_MATCHED));
  }
};
var smartRollupCommitmentHashEncoder = (val) => {
  const prefix2 = val.substring(0, 4);
  if (prefix2 === Prefix.SRC1) {
    return prefixEncoder(Prefix.SRC1)(val);
  }
  throw new InvalidSmartRollupCommitmentHashError(val, invalidDetail(ValidationResult.NO_PREFIX_MATCHED) + ` expecting prefix '${Prefix.SRC1}'`);
};
var addressDecoder = (val) => {
  const preamble = val.consume(1);
  switch (preamble[0]) {
    case 0:
      return pkhDecoder(val);
    case 1: {
      const address = prefixDecoder(Prefix.KT1)(val);
      val.consume(1);
      return address;
    }
    default:
      throw new InvalidAddressError(val.toString(), ": Unable to decode.");
  }
};
var smartRollupAddressDecoder = (val) => {
  const address = prefixDecoder(Prefix.SR1)(val);
  if (address.substring(0, 3) !== Prefix.SR1) {
    throw new InvalidSmartRollupAddressError(address, invalidDetail(ValidationResult.NO_PREFIX_MATCHED) + ` expecting prefix '${Prefix.SR1}'.`);
  }
  return address;
};
var smartContractAddressDecoder = (val) => {
  const preamble = val.consume(1);
  if (preamble[0] === 1) {
    const scAddress = prefixDecoder(Prefix.KT1)(val);
    val.consume(1);
    return scAddress;
  }
  throw new InvalidContractAddressError(val.toString(), invalidDetail(ValidationResult.NO_PREFIX_MATCHED));
};
var smartRollupCommitmentHashDecoder = (val) => {
  const address = prefixDecoder(Prefix.SRC1)(val);
  if (address.substring(0, 4) !== Prefix.SRC1) {
    throw new InvalidSmartRollupCommitmentHashError(address, invalidDetail(ValidationResult.NO_PREFIX_MATCHED) + ` expecting prefix '${Prefix.SRC1}'`);
  }
  return address;
};
var zarithEncoder = (n2) => {
  const fn2 = [];
  let nn2 = new bignumber_default(n2, 10);
  if (nn2.isNaN()) {
    throw new TypeError(`Invalid zarith number ${n2}`);
  }
  while (true) {
    if (nn2.lt(128)) {
      if (nn2.lt(16))
        fn2.push("0");
      fn2.push(nn2.toString(16));
      break;
    } else {
      let b3 = nn2.mod(128);
      nn2 = nn2.minus(b3);
      nn2 = nn2.dividedBy(128);
      b3 = b3.plus(128);
      fn2.push(b3.toString(16));
    }
  }
  return fn2.join("");
};
var zarithDecoder = (n2) => {
  let mostSignificantByte = 0;
  while (mostSignificantByte < n2.length() && (n2.get(mostSignificantByte) & 128) !== 0) {
    mostSignificantByte += 1;
  }
  let num = new bignumber_default(0);
  for (let i2 = mostSignificantByte; i2 >= 0; i2 -= 1) {
    const tmp = n2.get(i2) & 127;
    num = num.multipliedBy(128);
    num = num.plus(tmp);
  }
  n2.consume(mostSignificantByte + 1);
  return new bignumber_default(num).toString();
};
var entrypointDecoder = (value) => {
  const preamble = pad(value.consume(1)[0], 2);
  if (preamble in entrypointMapping) {
    return entrypointMapping[preamble];
  } else {
    const entry = extractRequiredLen(value, 1);
    const entrypoint = Buffer.from(entry).toString("utf8");
    if (entrypoint.length > ENTRYPOINT_MAX_LENGTH) {
      throw new OversizedEntryPointError(entrypoint);
    }
    return entrypoint;
  }
};
var parametersDecoder = (val) => {
  const preamble = val.consume(1);
  if (preamble[0] === 0) {
    return;
  } else {
    const encodedEntrypoint = entrypointDecoder(val);
    const params = extractRequiredLen(val);
    const parameters = valueDecoder(new Uint8ArrayConsumer(params));
    return {
      entrypoint: encodedEntrypoint,
      value: parameters
    };
  }
};
var entrypointEncoder = (entrypoint) => {
  if (entrypoint in entrypointMappingReverse) {
    return `${entrypointMappingReverse[entrypoint]}`;
  } else {
    if (entrypoint.length > ENTRYPOINT_MAX_LENGTH) {
      throw new OversizedEntryPointError(entrypoint);
    }
    const value = { string: entrypoint };
    return `ff${valueEncoder(value).slice(8)}`;
  }
};
var parametersEncoder = (val) => {
  if (!val || val.entrypoint === "default" && "prim" in val.value && val.value.prim === "Unit") {
    return "00";
  }
  const encodedEntrypoint = entrypointEncoder(val.entrypoint);
  const parameters = valueEncoder(val.value);
  const length = (parameters.length / 2).toString(16).padStart(8, "0");
  return `ff${encodedEntrypoint}${length}${parameters}`;
};
var valueParameterEncoder = (value) => {
  const valueEncoded = valueEncoder(value);
  return `${pad(valueEncoded.length / 2)}${valueEncoded}`;
};
var valueParameterDecoder = (val) => {
  const value = extractRequiredLen(val);
  return valueDecoder(new Uint8ArrayConsumer(value));
};
var blockPayloadHashEncoder = prefixEncoder(Prefix.VH);
var blockPayloadHashDecoder = prefixDecoder(Prefix.VH);
var entrypointNameEncoder = (entrypoint) => {
  const value = { string: entrypoint };
  return `${valueEncoder(value).slice(2)}`;
};
var entrypointNameDecoder = (val) => {
  const entry = extractRequiredLen(val);
  return Buffer.from(entry).toString("utf8");
};
var txRollupOriginationParamEncoder = (_value) => {
  return "";
};
var txRollupOriginationParamDecoder = (_val) => {
  return {};
};
var txRollupIdEncoder = prefixEncoder(Prefix.TXR1);
var txRollupIdDecoder = prefixDecoder(Prefix.TXR1);
var txRollupBatchContentEncoder = (value) => {
  return `${pad(value.length / 2)}${value}`;
};
var txRollupBatchContentDecoder = (val) => {
  const value = extractRequiredLen(val);
  return Buffer.from(value).toString("hex");
};
var burnLimitEncoder = (val) => {
  return !val ? "00" : `ff${zarithEncoder(val)}`;
};
var burnLimitDecoder = (value) => {
  const prefix2 = value.consume(1);
  if (Buffer.from(prefix2).toString("hex") !== "00") {
    return zarithDecoder(value);
  }
};
var depositsLimitEncoder = (val) => {
  return !val ? "00" : `ff${zarithEncoder(val)}`;
};
var depositsLimitDecoder = (value) => {
  const prefix2 = value.consume(1);
  if (Buffer.from(prefix2).toString("hex") !== "00") {
    return zarithDecoder(value);
  }
};
var paddedBytesEncoder = (val, paddingLength = 8) => {
  return `${pad(val.length / 2, paddingLength)}${val}`;
};
var paddedBytesDecoder = (val) => {
  const value = extractRequiredLen(val);
  return Buffer.from(value).toString("hex");
};
var smartRollupMessageEncoder = (val) => {
  const message = val.reduce((prev, curr) => {
    return prev + `${pad(curr.length / 2)}${curr}`;
  }, "");
  return `${pad(message.length / 2)}${message}`;
};
var smartRollupMessageDecoder = (val) => {
  const valueArray = extractRequiredLen(val);
  const ret = stripLengthPrefixFromBytes(new Uint8ArrayConsumer(valueArray));
  return ret.map((value) => Buffer.from(value).toString("hex"));
};
var ManagerOperationSchema = {
  branch: CODEC.BRANCH,
  contents: [CODEC.OPERATION]
};
var ActivationSchema = {
  pkh: CODEC.TZ1,
  secret: CODEC.SECRET
};
var RevealSchema = {
  source: CODEC.PKH,
  fee: CODEC.ZARITH,
  counter: CODEC.ZARITH,
  gas_limit: CODEC.ZARITH,
  storage_limit: CODEC.ZARITH,
  public_key: CODEC.PUBLIC_KEY
};
var DelegationSchema = {
  source: CODEC.PKH,
  fee: CODEC.ZARITH,
  counter: CODEC.ZARITH,
  gas_limit: CODEC.ZARITH,
  storage_limit: CODEC.ZARITH,
  delegate: CODEC.DELEGATE
};
var TransactionSchema = {
  source: CODEC.PKH,
  fee: CODEC.ZARITH,
  counter: CODEC.ZARITH,
  gas_limit: CODEC.ZARITH,
  storage_limit: CODEC.ZARITH,
  amount: CODEC.ZARITH,
  destination: CODEC.ADDRESS,
  parameters: CODEC.PARAMETERS
};
var OriginationSchema = {
  source: CODEC.PKH,
  fee: CODEC.ZARITH,
  counter: CODEC.ZARITH,
  gas_limit: CODEC.ZARITH,
  storage_limit: CODEC.ZARITH,
  balance: CODEC.ZARITH,
  delegate: CODEC.DELEGATE,
  script: CODEC.SCRIPT
};
var BallotSchema = {
  source: CODEC.PKH,
  period: CODEC.INT32,
  proposal: CODEC.PROPOSAL,
  ballot: CODEC.BALLOT_STATEMENT
};
var EndorsementSchema = {
  slot: CODEC.INT16,
  level: CODEC.INT32,
  round: CODEC.INT32,
  block_payload_hash: CODEC.BLOCK_PAYLOAD_HASH
};
var SeedNonceRevelationSchema = {
  level: CODEC.INT32,
  nonce: CODEC.RAW
};
var ProposalsSchema = {
  source: CODEC.PKH,
  period: CODEC.INT32,
  proposals: CODEC.PROPOSAL_ARR
};
var RegisterGlobalConstantSchema = {
  source: CODEC.PKH,
  fee: CODEC.ZARITH,
  counter: CODEC.ZARITH,
  gas_limit: CODEC.ZARITH,
  storage_limit: CODEC.ZARITH,
  value: CODEC.VALUE
};
var TransferTicketSchema = {
  source: CODEC.PKH,
  fee: CODEC.ZARITH,
  counter: CODEC.ZARITH,
  gas_limit: CODEC.ZARITH,
  storage_limit: CODEC.ZARITH,
  ticket_contents: CODEC.VALUE,
  ticket_ty: CODEC.VALUE,
  ticket_ticketer: CODEC.ADDRESS,
  ticket_amount: CODEC.ZARITH,
  destination: CODEC.ADDRESS,
  entrypoint: CODEC.ENTRYPOINT
};
var TxRollupOriginationSchema = {
  source: CODEC.PKH,
  fee: CODEC.ZARITH,
  counter: CODEC.ZARITH,
  gas_limit: CODEC.ZARITH,
  storage_limit: CODEC.ZARITH,
  tx_rollup_origination: CODEC.TX_ROLLUP_ORIGINATION_PARAM
};
var TxRollupSubmitBatchSchema = {
  source: CODEC.PKH,
  fee: CODEC.ZARITH,
  counter: CODEC.ZARITH,
  gas_limit: CODEC.ZARITH,
  storage_limit: CODEC.ZARITH,
  rollup: CODEC.TX_ROLLUP_ID,
  content: CODEC.TX_ROLLUP_BATCH_CONTENT,
  burn_limit: CODEC.BURN_LIMIT
};
var IncreasePaidStorageSchema = {
  source: CODEC.PKH,
  fee: CODEC.ZARITH,
  counter: CODEC.ZARITH,
  gas_limit: CODEC.ZARITH,
  storage_limit: CODEC.ZARITH,
  amount: CODEC.ZARITH,
  destination: CODEC.SMART_CONTRACT_ADDRESS
};
var UpdateConsensusKeySchema = {
  source: CODEC.PKH,
  fee: CODEC.ZARITH,
  counter: CODEC.ZARITH,
  gas_limit: CODEC.ZARITH,
  storage_limit: CODEC.ZARITH,
  pk: CODEC.PUBLIC_KEY
};
var DrainDelegateSchema = {
  consensus_key: CODEC.PKH,
  delegate: CODEC.PKH,
  destination: CODEC.PKH
};
var SetDepositsLimitSchema = {
  source: CODEC.PKH,
  fee: CODEC.ZARITH,
  counter: CODEC.ZARITH,
  gas_limit: CODEC.ZARITH,
  storage_limit: CODEC.ZARITH,
  limit: CODEC.DEPOSITS_LIMIT
};
var SmartRollupOriginateSchema = {
  source: CODEC.PKH,
  fee: CODEC.ZARITH,
  counter: CODEC.ZARITH,
  gas_limit: CODEC.ZARITH,
  storage_limit: CODEC.ZARITH,
  pvm_kind: CODEC.PVM_KIND,
  kernel: CODEC.PADDED_BYTES,
  origination_proof: CODEC.PADDED_BYTES,
  parameters_ty: CODEC.VALUE
};
var SmartRollupAddMessagesSchema = {
  source: CODEC.PKH,
  fee: CODEC.ZARITH,
  counter: CODEC.ZARITH,
  gas_limit: CODEC.ZARITH,
  storage_limit: CODEC.ZARITH,
  message: CODEC.SMART_ROLLUP_MESSAGE
};
var SmartRollupExecuteOutboxMessageSchema = {
  source: CODEC.PKH,
  fee: CODEC.ZARITH,
  counter: CODEC.ZARITH,
  gas_limit: CODEC.ZARITH,
  storage_limit: CODEC.ZARITH,
  rollup: CODEC.SMART_ROLLUP_ADDRESS,
  cemented_commitment: CODEC.SMART_ROLLUP_COMMITMENT_HASH,
  output_proof: CODEC.PADDED_BYTES
};
var FailingNoopSchema = {
  arbitrary: CODEC.PADDED_BYTES
};
var operationEncoder = (encoders2) => (operation) => {
  if (!(operation.kind in encoders2) || !(operation.kind in kindMappingReverse)) {
    throw new InvalidOperationKindError(operation.kind);
  }
  return kindMappingReverse[operation.kind] + encoders2[operation.kind](operation);
};
var operationDecoder = (decoders2) => (value) => {
  const op = value.consume(1);
  const operationName = kindMapping[op[0]];
  if (operationName === void 0) {
    throw new UnsupportedOperationError(op[0].toString());
  }
  const decodedObj = decoders2[operationName](value);
  if (typeof decodedObj !== "object") {
    throw new OperationDecodingError("Invalid operation, cannot be decoded.");
  }
  return Object.assign({ kind: operationName }, decodedObj);
};
var schemaEncoder = (encoders2) => (schema) => (value) => {
  const keys2 = Object.keys(schema);
  return keys2.reduce((prev, key) => {
    const valueToEncode = schema[key];
    if (value && Array.isArray(valueToEncode)) {
      const encoder = encoders2[valueToEncode[0]];
      const values = value[key];
      if (!Array.isArray(values)) {
        throw new OperationEncodingError(`Invalid operation value "${JSON.stringify(values)}" of key "${key}, expected value to be Array.`);
      }
      return prev + values.reduce((prevBytes, current) => prevBytes + encoder(current), "");
    } else {
      const encoder = encoders2[valueToEncode];
      return prev + encoder(value[key]);
    }
  }, "");
};
var schemaDecoder = (decoders2) => (schema) => (value) => {
  const keys2 = Object.keys(schema);
  return keys2.reduce((prev, key) => {
    const valueToEncode = schema[key];
    if (Array.isArray(valueToEncode)) {
      const decoder = decoders2[valueToEncode[0]];
      const decoded = [];
      const lastLength = value.length();
      while (value.length() > 0) {
        decoded.push(decoder(value));
        if (lastLength === value.length()) {
          throw new OperationDecodingError("Unable to decode value");
        }
      }
      return Object.assign(Object.assign({}, prev), { [key]: decoded });
    } else {
      const decoder = decoders2[valueToEncode];
      const result = decoder(value);
      if (typeof result !== "undefined") {
        return Object.assign(Object.assign({}, prev), { [key]: result });
      } else {
        return Object.assign({}, prev);
      }
    }
  }, {});
};
var decoders = {
  [CODEC.SECRET]: (val) => toHexString(val.consume(20)),
  [CODEC.RAW]: (val) => toHexString(val.consume(32)),
  [CODEC.TZ1]: tz1Decoder,
  [CODEC.BRANCH]: branchDecoder,
  [CODEC.ZARITH]: zarithDecoder,
  [CODEC.PUBLIC_KEY]: publicKeyDecoder,
  [CODEC.PKH]: pkhDecoder,
  [CODEC.DELEGATE]: delegateDecoder,
  [CODEC.INT32]: int32Decoder,
  [CODEC.SCRIPT]: scriptDecoder,
  [CODEC.BALLOT_STATEMENT]: ballotDecoder,
  [CODEC.PROPOSAL]: proposalDecoder,
  [CODEC.PROPOSAL_ARR]: proposalsDecoder,
  [CODEC.PARAMETERS]: parametersDecoder,
  [CODEC.ADDRESS]: addressDecoder,
  [CODEC.SMART_ROLLUP_ADDRESS]: smartRollupAddressDecoder,
  [CODEC.SMART_CONTRACT_ADDRESS]: smartContractAddressDecoder,
  [CODEC.SMART_ROLLUP_COMMITMENT_HASH]: smartRollupCommitmentHashDecoder,
  [CODEC.VALUE]: valueParameterDecoder,
  [CODEC.INT16]: int16Decoder,
  [CODEC.BLOCK_PAYLOAD_HASH]: blockPayloadHashDecoder,
  [CODEC.ENTRYPOINT]: entrypointNameDecoder,
  [CODEC.TX_ROLLUP_ORIGINATION_PARAM]: txRollupOriginationParamDecoder,
  [CODEC.TX_ROLLUP_ID]: txRollupIdDecoder,
  [CODEC.TX_ROLLUP_BATCH_CONTENT]: txRollupBatchContentDecoder,
  [CODEC.BURN_LIMIT]: burnLimitDecoder,
  [CODEC.DEPOSITS_LIMIT]: depositsLimitDecoder,
  [CODEC.PVM_KIND]: pvmKindDecoder,
  [CODEC.PADDED_BYTES]: paddedBytesDecoder,
  [CODEC.SMART_ROLLUP_MESSAGE]: smartRollupMessageDecoder
};
decoders[CODEC.OPERATION] = operationDecoder(decoders);
decoders[CODEC.OP_ACTIVATE_ACCOUNT] = (val) => schemaDecoder(decoders)(ActivationSchema)(val);
decoders[CODEC.OP_FAILING_NOOP] = (val) => schemaDecoder(decoders)(FailingNoopSchema)(val);
decoders[CODEC.OP_DELEGATION] = (val) => schemaDecoder(decoders)(DelegationSchema)(val);
decoders[CODEC.OP_TRANSACTION] = (val) => schemaDecoder(decoders)(TransactionSchema)(val);
decoders[CODEC.OP_ORIGINATION] = (val) => schemaDecoder(decoders)(OriginationSchema)(val);
decoders[CODEC.OP_BALLOT] = (val) => schemaDecoder(decoders)(BallotSchema)(val);
decoders[CODEC.OP_ENDORSEMENT] = (val) => schemaDecoder(decoders)(EndorsementSchema)(val);
decoders[CODEC.OP_SEED_NONCE_REVELATION] = (val) => schemaDecoder(decoders)(SeedNonceRevelationSchema)(val);
decoders[CODEC.OP_PROPOSALS] = (val) => schemaDecoder(decoders)(ProposalsSchema)(val);
decoders[CODEC.OP_REVEAL] = (val) => schemaDecoder(decoders)(RevealSchema)(val);
decoders[CODEC.OP_REGISTER_GLOBAL_CONSTANT] = (val) => schemaDecoder(decoders)(RegisterGlobalConstantSchema)(val);
decoders[CODEC.OP_TRANSFER_TICKET] = (val) => schemaDecoder(decoders)(TransferTicketSchema)(val);
decoders[CODEC.OP_TX_ROLLUP_ORIGINATION] = (val) => schemaDecoder(decoders)(TxRollupOriginationSchema)(val);
decoders[CODEC.OP_TX_ROLLUP_SUBMIT_BATCH] = (val) => schemaDecoder(decoders)(TxRollupSubmitBatchSchema)(val);
decoders[CODEC.OP_INCREASE_PAID_STORAGE] = (val) => schemaDecoder(decoders)(IncreasePaidStorageSchema)(val);
decoders[CODEC.OP_UPDATE_CONSENSUS_KEY] = (val) => schemaDecoder(decoders)(UpdateConsensusKeySchema)(val);
decoders[CODEC.OP_DRAIN_DELEGATE] = (val) => schemaDecoder(decoders)(DrainDelegateSchema)(val);
decoders[CODEC.OP_SMART_ROLLUP_ORIGINATE] = (val) => schemaDecoder(decoders)(SmartRollupOriginateSchema)(val);
decoders[CODEC.OP_SMART_ROLLUP_ADD_MESSAGES] = (val) => schemaDecoder(decoders)(SmartRollupAddMessagesSchema)(val);
decoders[CODEC.OP_SMART_ROLLUP_EXECUTE_OUTBOX_MESSAGE] = (val) => schemaDecoder(decoders)(SmartRollupExecuteOutboxMessageSchema)(val);
decoders[CODEC.MANAGER] = schemaDecoder(decoders)(ManagerOperationSchema);
decoders[CODEC.OP_SET_DEPOSITS_LIMIT] = (val) => schemaDecoder(decoders)(SetDepositsLimitSchema)(val);
var encoders = {
  [CODEC.SECRET]: (val) => val,
  [CODEC.RAW]: (val) => val,
  [CODEC.TZ1]: tz1Encoder,
  [CODEC.BRANCH]: branchEncoder,
  [CODEC.ZARITH]: zarithEncoder,
  [CODEC.PUBLIC_KEY]: publicKeyEncoder,
  [CODEC.PKH]: pkhEncoder,
  [CODEC.DELEGATE]: delegateEncoder,
  [CODEC.SCRIPT]: scriptEncoder,
  [CODEC.BALLOT_STATEMENT]: ballotEncoder,
  [CODEC.PROPOSAL]: proposalEncoder,
  [CODEC.PROPOSAL_ARR]: proposalsEncoder,
  [CODEC.INT32]: int32Encoder,
  [CODEC.PARAMETERS]: parametersEncoder,
  [CODEC.ADDRESS]: addressEncoder,
  [CODEC.SMART_ROLLUP_ADDRESS]: smartRollupAddressEncoder,
  [CODEC.SMART_CONTRACT_ADDRESS]: smartContractAddressEncoder,
  [CODEC.SMART_ROLLUP_COMMITMENT_HASH]: smartRollupCommitmentHashEncoder,
  [CODEC.VALUE]: valueParameterEncoder,
  [CODEC.INT16]: int16Encoder,
  [CODEC.BLOCK_PAYLOAD_HASH]: blockPayloadHashEncoder,
  [CODEC.ENTRYPOINT]: entrypointNameEncoder,
  [CODEC.TX_ROLLUP_ORIGINATION_PARAM]: txRollupOriginationParamEncoder,
  [CODEC.TX_ROLLUP_ID]: txRollupIdEncoder,
  [CODEC.TX_ROLLUP_BATCH_CONTENT]: txRollupBatchContentEncoder,
  [CODEC.BURN_LIMIT]: burnLimitEncoder,
  [CODEC.DEPOSITS_LIMIT]: depositsLimitEncoder,
  [CODEC.PVM_KIND]: pvmKindEncoder,
  [CODEC.PADDED_BYTES]: paddedBytesEncoder,
  [CODEC.SMART_ROLLUP_MESSAGE]: smartRollupMessageEncoder
};
encoders[CODEC.OPERATION] = operationEncoder(encoders);
encoders[CODEC.OP_ACTIVATE_ACCOUNT] = (val) => schemaEncoder(encoders)(ActivationSchema)(val);
encoders[CODEC.OP_DELEGATION] = (val) => schemaEncoder(encoders)(DelegationSchema)(val);
encoders[CODEC.OP_TRANSACTION] = (val) => schemaEncoder(encoders)(TransactionSchema)(val);
encoders[CODEC.OP_ORIGINATION] = (val) => schemaEncoder(encoders)(OriginationSchema)(val);
encoders[CODEC.OP_BALLOT] = (val) => schemaEncoder(encoders)(BallotSchema)(val);
encoders[CODEC.OP_ENDORSEMENT] = (val) => schemaEncoder(encoders)(EndorsementSchema)(val);
encoders[CODEC.OP_SEED_NONCE_REVELATION] = (val) => schemaEncoder(encoders)(SeedNonceRevelationSchema)(val);
encoders[CODEC.OP_PROPOSALS] = (val) => schemaEncoder(encoders)(ProposalsSchema)(val);
encoders[CODEC.OP_REVEAL] = (val) => schemaEncoder(encoders)(RevealSchema)(val);
encoders[CODEC.OP_REGISTER_GLOBAL_CONSTANT] = (val) => schemaEncoder(encoders)(RegisterGlobalConstantSchema)(val);
encoders[CODEC.OP_TRANSFER_TICKET] = (val) => schemaEncoder(encoders)(TransferTicketSchema)(val);
encoders[CODEC.OP_TX_ROLLUP_ORIGINATION] = (val) => schemaEncoder(encoders)(TxRollupOriginationSchema)(val);
encoders[CODEC.OP_TX_ROLLUP_SUBMIT_BATCH] = (val) => schemaEncoder(encoders)(TxRollupSubmitBatchSchema)(val);
encoders[CODEC.OP_INCREASE_PAID_STORAGE] = (val) => schemaEncoder(encoders)(IncreasePaidStorageSchema)(val);
encoders[CODEC.OP_UPDATE_CONSENSUS_KEY] = (val) => schemaEncoder(encoders)(UpdateConsensusKeySchema)(val);
encoders[CODEC.OP_DRAIN_DELEGATE] = (val) => schemaEncoder(encoders)(DrainDelegateSchema)(val);
encoders[CODEC.OP_SMART_ROLLUP_ORIGINATE] = (val) => schemaEncoder(encoders)(SmartRollupOriginateSchema)(val);
encoders[CODEC.OP_SMART_ROLLUP_ADD_MESSAGES] = (val) => schemaEncoder(encoders)(SmartRollupAddMessagesSchema)(val);
encoders[CODEC.OP_SMART_ROLLUP_EXECUTE_OUTBOX_MESSAGE] = (val) => schemaEncoder(encoders)(SmartRollupExecuteOutboxMessageSchema)(val);
encoders[CODEC.MANAGER] = schemaEncoder(encoders)(ManagerOperationSchema);
encoders[CODEC.OP_SET_DEPOSITS_LIMIT] = (val) => schemaEncoder(encoders)(SetDepositsLimitSchema)(val);
encoders[CODEC.OP_FAILING_NOOP] = (val) => schemaEncoder(encoders)(FailingNoopSchema)(val);
var OperationKindMapping = {
  activate_account: ActivationSchema,
  reveal: RevealSchema,
  delegation: DelegationSchema,
  transaction: TransactionSchema,
  origination: OriginationSchema,
  ballot: BallotSchema,
  endorsement: EndorsementSchema,
  seed_nonce_revelation: SeedNonceRevelationSchema,
  proposals: ProposalsSchema,
  register_global_constant: RegisterGlobalConstantSchema,
  transfer_ticket: TransferTicketSchema,
  tx_rollup_origination: TxRollupOriginationSchema,
  tx_rollup_submit_batch: TxRollupSubmitBatchSchema,
  increase_paid_storage: IncreasePaidStorageSchema,
  update_consensus_key: UpdateConsensusKeySchema,
  drain_delegate: DrainDelegateSchema,
  set_deposits_limit: SetDepositsLimitSchema,
  smart_rollup_originate: SmartRollupOriginateSchema,
  smart_rollup_add_messages: SmartRollupAddMessagesSchema,
  smart_rollup_execute_outbox_message: SmartRollupExecuteOutboxMessageSchema,
  failing_noop: FailingNoopSchema
};
var getArrayDifference = (arr1, arr2) => {
  return arr2.filter((x3) => !arr1.includes(x3));
};
var deleteArrayElementByValue = (array, item) => {
  return array.filter((e) => e !== item);
};
var validateOperationKind = (opKind) => {
  const opKindList = Object.keys(OperationKindMapping);
  return opKindList.includes(opKind);
};
var validateMissingProperty = (operationContent) => {
  const kind = operationContent.kind;
  const keys2 = Object.keys(operationContent);
  const cleanKeys = deleteArrayElementByValue(keys2, "kind");
  const schemaKeys = Object.keys(OperationKindMapping[kind]);
  return getArrayDifference(cleanKeys, schemaKeys);
};
var ProtocolsHash;
(function(ProtocolsHash2) {
  ProtocolsHash2["Pt24m4xi"] = "Pt24m4xiPbLDhVgVfABUjirbmda3yohdN82Sp9FeuAXJ4eV9otd";
  ProtocolsHash2["PsBABY5H"] = "PsBABY5HQTSkA4297zNHfsZNKtxULfL18y95qb3m53QJiXGmrbU";
  ProtocolsHash2["PsBabyM1"] = "PsBabyM1eUXZseaJdmXFApDSBqj8YBfwELoxZHHW77EMcAbbwAS";
  ProtocolsHash2["PsCARTHA"] = "PsCARTHAGazKbHtnKfLzQg3kms52kSRpgnDY982a9oYsSXRLQEb";
  ProtocolsHash2["PsDELPH1"] = "PsDELPH1Kxsxt8f9eWbxQeRxkjfbxoqM52jvs5Y5fBxWWh4ifpo";
  ProtocolsHash2["PtEdo2Zk"] = "PtEdo2ZkT9oKpimTah6x2embF25oss54njMuPzkJTEi5RqfdZFA";
  ProtocolsHash2["PsFLorena"] = "PsFLorenaUUuikDWvMDr6fGBRG8kt3e3D3fHoXK1j1BFRxeSH4i";
  ProtocolsHash2["PtGRANADs"] = "PtGRANADsDU8R9daYKAgWnQYAJ64omN1o3KMGVCykShA97vQbvV";
  ProtocolsHash2["PtHangz2"] = "PtHangz2aRngywmSRGGvrcTyMbbdpWdpFKuS4uMWxg2RaH9i1qx";
  ProtocolsHash2["Psithaca2"] = "Psithaca2MLRFYargivpo7YvUr7wUDqyxrdhC5CQq78mRvimz6A";
  ProtocolsHash2["PtJakart2"] = "PtJakart2xVj7pYXJBXrqHgd82rdkLey5ZeeGwDgPp9rhQUbSqY";
  ProtocolsHash2["PtKathman"] = "PtKathmankSpLLDALzWw7CGD2j2MtyveTwboEYokqUCP4a1LxMg";
  ProtocolsHash2["PtLimaPtL"] = "PtLimaPtLMwfNinJi9rCfDPWea8dFgTZ1MeJ9f1m2SRic6ayiwW";
  ProtocolsHash2["PtMumbaii"] = "PtMumbaiiFFEGbew1rRjzSPyzRbA51Tm3RVZL5suHPxSZYDhCEc";
  ProtocolsHash2["PtMumbai2"] = "PtMumbai2TmsJHNGRkD8v8YDbtao7BLUC3wjASn1inAKLFCjaH1";
  ProtocolsHash2["PtNairobi"] = "PtNairobiyssHuh87hEhfVBGCVrK3WnS8Z2FT4ymB5tAa4r1nQf";
  ProtocolsHash2["ProtoALpha"] = "ProtoALphaALphaALphaALphaALphaALphaALphaALphaDdp3zK";
})(ProtocolsHash || (ProtocolsHash = {}));
var PROTOCOL_CURRENT = ProtocolsHash.PtMumbai2;
function getCodec(codec, _proto) {
  return {
    encoder: encoders[codec],
    decoder: (hex) => {
      const consumer = Uint8ArrayConsumer.fromHexString(hex);
      return decoders[codec](consumer);
    }
  };
}
var LocalForger = class {
  constructor(protocolHash = PROTOCOL_CURRENT) {
    this.protocolHash = protocolHash;
    this.codec = getCodec(CODEC.MANAGER, this.protocolHash);
  }
  forge(params) {
    const branchValidation = validateBlock(params.branch);
    if (branchValidation !== ValidationResult.VALID) {
      throw new InvalidBlockHashError(params.branch, invalidDetail(branchValidation));
    }
    for (const content of params.contents) {
      if (!validateOperationKind(content.kind)) {
        throw new InvalidOperationKindError(content.kind);
      }
      const diff = validateMissingProperty(content);
      if (diff.length === 1) {
        if (content.kind === "delegation" && diff[0] === "delegate") {
          continue;
        } else if (content.kind === "origination" && diff[0] === "delegate") {
          continue;
        } else if (content.kind === "transaction" && diff[0] === "parameters") {
          continue;
        } else if (content.kind === "set_deposits_limit" && diff[0] === "limit") {
          continue;
        } else if (content.kind === "tx_rollup_submit_batch" && diff[0] === "burn_limit") {
          continue;
        } else {
          throw new InvalidOperationSchemaError(content, `missing properties "${diff.join(", ")}"`);
        }
      } else if (diff.length > 1) {
        throw new InvalidOperationSchemaError(content, `missing properties "${diff.join(", ")}"`);
      }
    }
    const forged = this.codec.encoder(params).toLowerCase();
    return Promise.resolve(forged);
  }
  parse(hex) {
    return Promise.resolve(this.codec.decoder(hex));
  }
};
var localForger = new LocalForger();

// node_modules/@taquito/taquito/dist/taquito.es6.js
function __awaiter38(thisArg, _arguments, P2, generator) {
  function adopt(value) {
    return value instanceof P2 ? value : new P2(function(resolve) {
      resolve(value);
    });
  }
  return new (P2 || (P2 = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
}
var DEFAULT_GAS_LIMIT;
(function(DEFAULT_GAS_LIMIT2) {
  DEFAULT_GAS_LIMIT2[DEFAULT_GAS_LIMIT2["DELEGATION"] = 10600] = "DELEGATION";
  DEFAULT_GAS_LIMIT2[DEFAULT_GAS_LIMIT2["ORIGINATION"] = 10600] = "ORIGINATION";
  DEFAULT_GAS_LIMIT2[DEFAULT_GAS_LIMIT2["TRANSFER"] = 10600] = "TRANSFER";
  DEFAULT_GAS_LIMIT2[DEFAULT_GAS_LIMIT2["REVEAL_TZ1"] = 1e3] = "REVEAL_TZ1";
  DEFAULT_GAS_LIMIT2[DEFAULT_GAS_LIMIT2["REVEAL_TZ2"] = 1e3] = "REVEAL_TZ2";
  DEFAULT_GAS_LIMIT2[DEFAULT_GAS_LIMIT2["REVEAL_TZ3"] = 2e3] = "REVEAL_TZ3";
  DEFAULT_GAS_LIMIT2[DEFAULT_GAS_LIMIT2["REVEAL_TZ4"] = 2e3] = "REVEAL_TZ4";
})(DEFAULT_GAS_LIMIT || (DEFAULT_GAS_LIMIT = {}));
var DEFAULT_FEE;
(function(DEFAULT_FEE2) {
  DEFAULT_FEE2[DEFAULT_FEE2["DELEGATION"] = 1257] = "DELEGATION";
  DEFAULT_FEE2[DEFAULT_FEE2["ORIGINATION"] = 1e4] = "ORIGINATION";
  DEFAULT_FEE2[DEFAULT_FEE2["TRANSFER"] = 1e4] = "TRANSFER";
  DEFAULT_FEE2[DEFAULT_FEE2["REVEAL"] = 374] = "REVEAL";
})(DEFAULT_FEE || (DEFAULT_FEE = {}));
var DEFAULT_STORAGE_LIMIT;
(function(DEFAULT_STORAGE_LIMIT2) {
  DEFAULT_STORAGE_LIMIT2[DEFAULT_STORAGE_LIMIT2["DELEGATION"] = 0] = "DELEGATION";
  DEFAULT_STORAGE_LIMIT2[DEFAULT_STORAGE_LIMIT2["ORIGINATION"] = 257] = "ORIGINATION";
  DEFAULT_STORAGE_LIMIT2[DEFAULT_STORAGE_LIMIT2["TRANSFER"] = 257] = "TRANSFER";
  DEFAULT_STORAGE_LIMIT2[DEFAULT_STORAGE_LIMIT2["REVEAL"] = 0] = "REVEAL";
})(DEFAULT_STORAGE_LIMIT || (DEFAULT_STORAGE_LIMIT = {}));
var Protocols;
(function(Protocols2) {
  Protocols2["Pt24m4xi"] = "Pt24m4xiPbLDhVgVfABUjirbmda3yohdN82Sp9FeuAXJ4eV9otd";
  Protocols2["PsBABY5H"] = "PsBABY5HQTSkA4297zNHfsZNKtxULfL18y95qb3m53QJiXGmrbU";
  Protocols2["PsBabyM1"] = "PsBabyM1eUXZseaJdmXFApDSBqj8YBfwELoxZHHW77EMcAbbwAS";
  Protocols2["PsCARTHA"] = "PsCARTHAGazKbHtnKfLzQg3kms52kSRpgnDY982a9oYsSXRLQEb";
  Protocols2["PsDELPH1"] = "PsDELPH1Kxsxt8f9eWbxQeRxkjfbxoqM52jvs5Y5fBxWWh4ifpo";
  Protocols2["PtEdo2Zk"] = "PtEdo2ZkT9oKpimTah6x2embF25oss54njMuPzkJTEi5RqfdZFA";
  Protocols2["PsFLorena"] = "PsFLorenaUUuikDWvMDr6fGBRG8kt3e3D3fHoXK1j1BFRxeSH4i";
  Protocols2["PtGRANADs"] = "PtGRANADsDU8R9daYKAgWnQYAJ64omN1o3KMGVCykShA97vQbvV";
  Protocols2["PtHangz2"] = "PtHangz2aRngywmSRGGvrcTyMbbdpWdpFKuS4uMWxg2RaH9i1qx";
  Protocols2["PsiThaCa"] = "PsiThaCaT47Zboaw71QWScM8sXeMM7bbQFncK9FLqYc6EKdpjVP";
  Protocols2["Psithaca2"] = "Psithaca2MLRFYargivpo7YvUr7wUDqyxrdhC5CQq78mRvimz6A";
  Protocols2["PtJakart2"] = "PtJakart2xVj7pYXJBXrqHgd82rdkLey5ZeeGwDgPp9rhQUbSqY";
  Protocols2["PtKathman"] = "PtKathmankSpLLDALzWw7CGD2j2MtyveTwboEYokqUCP4a1LxMg";
  Protocols2["PtLimaPtL"] = "PtLimaPtLMwfNinJi9rCfDPWea8dFgTZ1MeJ9f1m2SRic6ayiwW";
  Protocols2["PtMumbaii"] = "PtMumbaiiFFEGbew1rRjzSPyzRbA51Tm3RVZL5suHPxSZYDhCEc";
  Protocols2["PtMumbai2"] = "PtMumbai2TmsJHNGRkD8v8YDbtao7BLUC3wjASn1inAKLFCjaH1";
  Protocols2["PtNairobi"] = "PtNairobiyssHuh87hEhfVBGCVrK3WnS8Z2FT4ymB5tAa4r1nQf";
  Protocols2["ProtoALpha"] = "ProtoALphaALphaALphaALphaALphaALphaALphaALphaDdp3zK";
})(Protocols || (Protocols = {}));
var protocols = {
  "004": [Protocols.Pt24m4xi],
  "005": [Protocols.PsBABY5H, Protocols.PsBabyM1],
  "006": [Protocols.PsCARTHA],
  "007": [Protocols.PsDELPH1],
  "008": [Protocols.PtEdo2Zk],
  "009": [Protocols.PsFLorena],
  "010": [Protocols.PtGRANADs],
  "011": [Protocols.PtHangz2],
  "012": [Protocols.PsiThaCa, Protocols.Psithaca2],
  "013": [Protocols.PtJakart2],
  "014": [Protocols.PtKathman],
  "015": [Protocols.PtLimaPtL],
  "016": [Protocols.PtMumbai2],
  "017": [Protocols.PtNairobi],
  "018": [Protocols.ProtoALpha]
};
var ChainIds;
(function(ChainIds2) {
  ChainIds2["MAINNET"] = "NetXdQprcVkpaWU";
  ChainIds2["CARTHAGENET"] = "NetXjD3HPJJjmcd";
  ChainIds2["DELPHINET"] = "NetXm8tYqnMWky1";
  ChainIds2["EDONET"] = "NetXSgo1ZT2DRUG";
  ChainIds2["FLORENCENET"] = "NetXxkAx4woPLyu";
  ChainIds2["GRANADANET"] = "NetXz969SFaFn8k";
  ChainIds2["HANGZHOUNET"] = "NetXZSsxBpMQeAT";
  ChainIds2["ITHACANET"] = "NetXbhmtAbMukLc";
  ChainIds2["ITHACANET2"] = "NetXnHfVqm9iesp";
  ChainIds2["JAKARTANET2"] = "NetXLH1uAxK7CCh";
  ChainIds2["KATHMANDUNET"] = "NetXazhm4yetmff";
  ChainIds2["LIMANET"] = "NetXizpkH94bocH";
  ChainIds2["MUMBAINET"] = "NetXQw6nWSnrJ5t";
  ChainIds2["MUMBAINET2"] = "NetXgbcrNtXD2yA";
  ChainIds2["NAIROBINET"] = "NetXyuzvDo2Ugzb";
})(ChainIds || (ChainIds = {}));
var InvalidCodeParameter = class extends ParameterValidationError {
  constructor(message, data) {
    super();
    this.message = message;
    this.data = data;
    this.name = "InvalidCodeParameter";
  }
};
var InvalidInitParameter = class extends ParameterValidationError {
  constructor(message, data) {
    super();
    this.message = message;
    this.data = data;
    this.name = "InvalidInitParameter";
  }
};
var OriginationParameterError = class extends ParameterValidationError {
  constructor(message) {
    super();
    this.message = message;
    this.name;
  }
};
var InvalidBalanceError = class extends ParameterValidationError {
  constructor(message) {
    super();
    this.message = message;
    this.name = "InvalidBalanceError";
  }
};
var createOriginationOperation = ({ code, init, balance = "0", delegate, storage, fee = DEFAULT_FEE.ORIGINATION, gasLimit = DEFAULT_GAS_LIMIT.ORIGINATION, storageLimit = DEFAULT_STORAGE_LIMIT.ORIGINATION, mutez = false }) => __awaiter38(void 0, void 0, void 0, function* () {
  if (storage !== void 0 && init !== void 0) {
    throw new OriginationParameterError("Storage and Init cannot be set a the same time. Please either use storage or init but not both.");
  }
  if (!Array.isArray(code)) {
    throw new InvalidCodeParameter("Wrong code parameter type, expected an array", code);
  }
  let contractStorage;
  if (storage !== void 0) {
    const storageType = code.find((p3) => "prim" in p3 && p3.prim === "storage");
    if ((storageType === null || storageType === void 0 ? void 0 : storageType.args) === void 0) {
      throw new InvalidCodeParameter("The storage section is missing from the script", code);
    }
    const schema = new Schema(storageType.args[0]);
    contractStorage = schema.Encode(storage);
  } else if (init !== void 0 && typeof init === "object") {
    contractStorage = init;
  } else {
    throw new InvalidInitParameter("Wrong init parameter type, expected JSON Michelson", init);
  }
  const script = {
    code,
    storage: contractStorage
  };
  if (isNaN(Number(balance))) {
    throw new InvalidBalanceError(`Invalid Balance "${balance}", cannot be converted to a number`);
  }
  const operation = {
    kind: OpKind.ORIGINATION,
    fee,
    gas_limit: gasLimit,
    storage_limit: storageLimit,
    balance: mutez ? balance.toString() : format("tz", "mutez", balance).toString(),
    script
  };
  if (delegate) {
    operation.delegate = delegate;
  }
  return operation;
});
var createTransferOperation = ({ to, amount, parameter, fee = DEFAULT_FEE.TRANSFER, gasLimit = DEFAULT_GAS_LIMIT.TRANSFER, storageLimit = DEFAULT_STORAGE_LIMIT.TRANSFER, mutez = false }) => __awaiter38(void 0, void 0, void 0, function* () {
  const operation = {
    kind: OpKind.TRANSACTION,
    fee,
    gas_limit: gasLimit,
    storage_limit: storageLimit,
    amount: mutez ? amount.toString() : format("tz", "mutez", amount).toString(),
    destination: to,
    parameters: parameter
  };
  return operation;
});
var createSetDelegateOperation = ({ delegate, source, fee = DEFAULT_FEE.DELEGATION, gasLimit = DEFAULT_GAS_LIMIT.DELEGATION, storageLimit = DEFAULT_STORAGE_LIMIT.DELEGATION }) => __awaiter38(void 0, void 0, void 0, function* () {
  const operation = {
    kind: OpKind.DELEGATION,
    source,
    fee,
    gas_limit: gasLimit,
    storage_limit: storageLimit,
    delegate
  };
  return operation;
});
var createIncreasePaidStorageOperation = ({ source, fee, gasLimit, storageLimit, amount, destination }) => __awaiter38(void 0, void 0, void 0, function* () {
  return {
    kind: OpKind.INCREASE_PAID_STORAGE,
    source,
    fee,
    gas_limit: gasLimit,
    storage_limit: storageLimit,
    amount,
    destination
  };
});
var _counters;
_counters = /* @__PURE__ */ new WeakMap();
var BATCH_KINDS = [
  OpKind.ACTIVATION,
  OpKind.ORIGINATION,
  OpKind.TRANSACTION,
  OpKind.DELEGATION
];
var defaultConfigStreamer = {
  shouldObservableSubscriptionRetry: false,
  observableSubscriptionRetryFunction: retry()
};

// node_modules/@taquito/beacon-wallet/dist/taquito-beacon-wallet.es6.js
function __awaiter39(thisArg, _arguments, P2, generator) {
  function adopt(value) {
    return value instanceof P2 ? value : new P2(function(resolve) {
      resolve(value);
    });
  }
  return new (P2 || (P2 = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
}
var BeaconWalletNotInitialized = class extends PermissionDeniedError {
  constructor() {
    super();
    this.name = "BeaconWalletNotInitialized";
    this.message = 'BeaconWallet needs to be initialized by calling `await BeaconWallet.requestPermissions({network: {type: "chosen_network"}})` first.';
  }
};
var MissingRequiredScopes = class extends PermissionDeniedError {
  constructor(requiredScopes) {
    super();
    this.requiredScopes = requiredScopes;
    this.name = "MissingRequiredScopes";
    this.message = `Required permissions scopes: ${requiredScopes.join(",")} were not granted.`;
  }
};
var VERSION = {
  "commitHash": "a5b3c864e1537d0fe0a7f8f0b55989ef89311fa2",
  "version": "17.3.0"
};
var BeaconWallet = class {
  constructor(options) {
    this.client = getDAppClientInstance(options);
  }
  validateRequiredScopesOrFail(permissionScopes, requiredScopes) {
    const mandatoryScope = new Set(requiredScopes);
    for (const scope of permissionScopes) {
      if (mandatoryScope.has(scope)) {
        mandatoryScope.delete(scope);
      }
    }
    if (mandatoryScope.size > 0) {
      throw new MissingRequiredScopes(Array.from(mandatoryScope));
    }
  }
  requestPermissions(request) {
    return __awaiter39(this, void 0, void 0, function* () {
      yield this.client.requestPermissions(request);
    });
  }
  getPKH() {
    return __awaiter39(this, void 0, void 0, function* () {
      const account = yield this.client.getActiveAccount();
      if (!account) {
        throw new BeaconWalletNotInitialized();
      }
      return account.address;
    });
  }
  mapTransferParamsToWalletParams(params) {
    return __awaiter39(this, void 0, void 0, function* () {
      let walletParams;
      yield this.client.showPrepare();
      try {
        walletParams = yield params();
      } catch (err) {
        yield this.client.hideUI();
        throw err;
      }
      return this.removeDefaultParams(walletParams, yield createTransferOperation(this.formatParameters(walletParams)));
    });
  }
  mapIncreasePaidStorageWalletParams(params) {
    return __awaiter39(this, void 0, void 0, function* () {
      let walletParams;
      yield this.client.showPrepare();
      try {
        walletParams = yield params();
      } catch (err) {
        yield this.client.hideUI();
        throw err;
      }
      return this.removeDefaultParams(walletParams, yield createIncreasePaidStorageOperation(this.formatParameters(walletParams)));
    });
  }
  mapOriginateParamsToWalletParams(params) {
    return __awaiter39(this, void 0, void 0, function* () {
      let walletParams;
      yield this.client.showPrepare();
      try {
        walletParams = yield params();
      } catch (err) {
        yield this.client.hideUI();
        throw err;
      }
      return this.removeDefaultParams(walletParams, yield createOriginationOperation(this.formatParameters(walletParams)));
    });
  }
  mapDelegateParamsToWalletParams(params) {
    return __awaiter39(this, void 0, void 0, function* () {
      let walletParams;
      yield this.client.showPrepare();
      try {
        walletParams = yield params();
      } catch (err) {
        yield this.client.hideUI();
        throw err;
      }
      return this.removeDefaultParams(walletParams, yield createSetDelegateOperation(this.formatParameters(walletParams)));
    });
  }
  formatParameters(params) {
    if (params.fee) {
      params.fee = params.fee.toString();
    }
    if (params.storageLimit) {
      params.storageLimit = params.storageLimit.toString();
    }
    if (params.gasLimit) {
      params.gasLimit = params.gasLimit.toString();
    }
    return params;
  }
  removeDefaultParams(params, operatedParams) {
    if (!params.fee) {
      delete operatedParams.fee;
    }
    if (!params.storageLimit) {
      delete operatedParams.storage_limit;
    }
    if (!params.gasLimit) {
      delete operatedParams.gas_limit;
    }
    return operatedParams;
  }
  sendOperations(params) {
    return __awaiter39(this, void 0, void 0, function* () {
      const account = yield this.client.getActiveAccount();
      if (!account) {
        throw new BeaconWalletNotInitialized();
      }
      const permissions = account.scopes;
      this.validateRequiredScopesOrFail(permissions, [PermissionScope.OPERATION_REQUEST]);
      const { transactionHash } = yield this.client.requestOperation({ operationDetails: params });
      return transactionHash;
    });
  }
  /**
   *
   * @description Removes all beacon values from the storage. After using this method, this instance is no longer usable.
   * You will have to instantiate a new BeaconWallet.
   */
  disconnect() {
    return __awaiter39(this, void 0, void 0, function* () {
      yield this.client.destroy();
    });
  }
  /**
   *
   * @description This method removes the active account from local storage by setting it to undefined.
   */
  clearActiveAccount() {
    return __awaiter39(this, void 0, void 0, function* () {
      yield this.client.setActiveAccount();
    });
  }
  sign(bytes, watermark) {
    return __awaiter39(this, void 0, void 0, function* () {
      let bb = hex2buf(bytes);
      if (typeof watermark !== "undefined") {
        bb = mergebuf(watermark, bb);
      }
      const watermarkedBytes = buf2hex((0, import_typedarray_to_buffer2.default)(bb));
      const signingType = this.getSigningType(watermark);
      if (signingType !== SigningType.OPERATION) {
        throw new UnsupportedActionError(`Taquito Beacon Wallet currently only supports signing operations, not ${signingType}`);
      }
      const { signature } = yield this.client.requestSignPayload({
        payload: watermarkedBytes,
        signingType
      });
      return signature;
    });
  }
  getSigningType(watermark) {
    if (!watermark || watermark.length === 0) {
      return SigningType.RAW;
    }
    if (watermark.length === 1) {
      if (watermark[0] === 5) {
        return SigningType.MICHELINE;
      }
      if (watermark[0] === 3) {
        return SigningType.OPERATION;
      }
    }
    throw new Error(`Invalid watermark ${JSON.stringify(watermark)}`);
  }
  getPK() {
    return __awaiter39(this, void 0, void 0, function* () {
      const account = yield this.client.getActiveAccount();
      if (!account) {
        throw new BeaconWalletNotInitialized();
      }
      return account === null || account === void 0 ? void 0 : account.publicKey;
    });
  }
};
export {
  BeaconWallet,
  BeaconWalletNotInitialized,
  MissingRequiredScopes,
  VERSION
};
/*! Bundled license information:

typedarray-to-buffer/index.js:
  (*! typedarray-to-buffer. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> *)
*/
//# sourceMappingURL=@taquito_beacon-wallet.js.map
